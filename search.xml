<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[怀念 Ubuntu：查看 CPU 信息]]></title>
    <url>%2F2021%2F12%2F19%2F%E6%80%80%E5%BF%B5-Ubuntu%EF%BC%9A%E6%9F%A5%E7%9C%8B-CPU-%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[初中时期结识了一位挚友，在初中生涯我俩算是焦不离孟的友情，有一次我们聊天。 我说：“看到自己之前写的字，实在太丑了。。。” 他说：“说明你进步了。每当你审视之前做的东西不够完美，说明你是有追求的人。” 现在想想，这位朋友当时的解释算是哲学界的泰斗解说了。 今天在翻阅之前写的技术文章，发现了 linux 常用命令: 查看 CPU 信息 这篇文章，那是我在 2012 年写的。当时自己使用 Linux 已经有两年多的时间了，很多命令还是记不住，我就在 CSDN 上面写下来当作备忘了。几年过去了，今天翻翻自己之前写的东西突然看到了它，文笔确实很糟糕，阅读量只有 1.3万+但最近7天查看较多就想着发出来给大家共享一下，希望能帮到正在努力的你。 记得在大四的时候，我就开始折腾 Ubuntu，觉得这个东西挺好玩的，它最吸引我的地方就是可以在上面为所欲为的敲打命令，整个系统能被自己敲打出来的命令所操控，那种感觉不仅爽而且还很酷。毕业之后购买的第一台笔记本是联想的，我还特意要求老板给装上了 Ubuntu 的系统。工作了这么多年用过 macOS、Windows，但 Linux 给我的那种纯粹的感觉至今让人难以忘却，我的台式机里面一直给 Ubuntu 留着位置，时不时的要拿出来爽一把。 在 Windows 下面可以很方便快捷的看出当前 CPU 的信息，那么在 Linux 下面如何很快的知道呢？ 也很简单，不信你可以试一试下面这个命令： lscpu 可以看出，CPU 的信息出来了，红色部分是 CPU 的位数和 CPU 的核数。 也可以用 cat -n /proc/cpuinfo 命令查看更加详细的信息，但查出来的内容太多，看起来挺费劲。 下面给出几个常用的命令。wc 主要用于统计，uniq 主要用于出去重复行，只显示其中相同的某条数据。大家可以自行去搜索和学习这两个命令。 1、查看物理 CPU 的个数 1cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l 注意：物理 CPU 就是实实在在的硬件。 2、查看逻辑 CPU 的个数 1cat /proc/cpuinfo | grep "processor" | wc -l 3、查看 CPU 是几核 1cat /proc/cpuinfo | grep "cores" | uniq 4、查看 CPU 的主频 1cat /proc/cpuinfo | grep MHz | uniq 查询结果如下图，所示： 当然不同的 CPU 显示结果会不一样，上图是 2012 年购买的机器安装的 Ubuntu，下图是现在虚拟机安装的 Ubuntu 系统。 做自己喜欢做的事情，这个很重要！]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux Ubuntu CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行动起来才能解决焦虑]]></title>
    <url>%2F2021%2F11%2F28%2F%E8%A1%8C%E5%8A%A8%E8%B5%B7%E6%9D%A5%E6%89%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E7%84%A6%E8%99%91%2F</url>
    <content type="text"><![CDATA[最近遇到很多朋友或者同事，多多少少都有在说自己比较焦虑，恰好自己正在看《底层逻辑》和《结构思考力》，今天我也来凑个热闹，聊聊焦虑。 焦虑是对亲人或自己生命安全、前途命运等的过度担心而产生的一种烦躁情绪。其中含有着急、挂念、忧愁、紧张、恐慌、不安等成分。 我有过一次记忆犹新的焦虑，来自于童年。 那时我已经7岁了，岁末年初。春节对于孩子们来说是让人期待和兴奋的，大雪在空中高兴的飞舞着，胖胖的雪人给院子增添了一份温馨，用树枝做的鼻子让它显得格外卓别林。父母在厨房里准备着年夜饭，我独自在房间里黯然神伤。我突然觉得哪一天父母要是离开了我们，眼前这一切都会随之消失，那种可怕的想法让我潸然泪下。说起来也奇怪，那个时候的我为什么会有这样的焦虑，现在想想还挺傻的。 人有悲欢离合。珍惜当下，珍惜和亲人或者同事在一起的日子，记住和他们在一起努力奋斗和生活的岁月，比什么都重要。 有个做互联网开发的朋友，工作了大概两年的时间，他说自己当初为了找工作就学习了比较热门的技术，但最近他觉得这门技术会凉凉，开始担心自己将来会被淘汰。 我问他，“你用现在的技术做的项目前景如何？” “项目还可以并且很有前景，也有很多技术大牛一起工作，能学到不少知识”。 “那你应该提升自己的能力让项目变得更好，在项目中夯实基础，我相信你再学习其他的专业编程知识会更加与鱼得水”。 “那我应该在项目中不断磨练自己的基本功，用最好的状态为项目贡献力量”。 “是的，调整好心态，行动起来”。 我相信每个人都有自己的焦虑。 孩子成绩总是差强人意； 总觉得老公的工资杯水车薪； 等着买房而房价总是居高不下； 项目交付质量层次不齐； 工作中大小事务层出不穷； 身体情不自禁地发了福，减肥屡屡失败； 等等。。。 心理学研究表明，焦虑都是源自于对事件的“不确定性”。对于不太确定的事情，我们会在脑海不停地猜想可能发生的后果，从而感到焦虑、不安，难以专心做好眼前的事。 心理学家河森堡说，如果你觉得某件事让你特别焦虑，压得你喘不过气来，那么最好的排解方法就是直接去做这件事，什么都别管，就是使劲做，努力去推动进度。你每往前推进一点这件棘手的事情，你的焦虑就会减少一分。同时，你的焦虑越少，推进工作的速度也就越快。只要咬紧牙关，不停地推进，总会有解脱的那一天。而且你每完成一个棘手的任务，或多或少都会比之前强大一点，这件苦差事总会改变你一点。 如果你不采取任何行动，焦虑慢慢的会将你吞噬，让你变得消极甚至抑郁。 从某种角度来看，焦虑并不是绝对的坏事，人无远虑必有近忧。当焦虑来临后，你更应该具有忧患意识，客观的评价当前情况，让焦虑变成自己前进的动力。付出更多的努力改变现状，争取取得更好的成绩。 面对焦虑，我们应该持有更开放的心态，学会释放压力。无论如何，你要行动起来不能只是焦虑！生而为人，要能欢喜。 努力向前一步，离梦想就更进一步]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>焦虑 工作 生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术人，也应具备项目管理能力]]></title>
    <url>%2F2021%2F11%2F07%2F%E6%8A%80%E6%9C%AF%E4%BA%BA%EF%BC%8C%E4%B9%9F%E5%BA%94%E5%85%B7%E5%A4%87%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[你即将要看到的内容在我脑海里翻滚了很久~ 自己写过不少技术博客，写的虽然不好但是总能拼凑出来。一旦开始写管理类的文章，就显得有些局促，但内心还是告诉我要坚持写下去。 自从写完 走上项管之路，迟迟没有动手去写关于项目管理的文章。倒不是因为自己想偷赖，而是确实不知道如何下手。这种感觉，就好比你在岸上看到一条肥嘟嘟的大鱼想据为己有而又无计可施一般让人难受。 与其临渊羡鱼，不如退而结网。 我想把自己在做项目经理这个职业中遇到的一些关于项目管理的问题、感悟和经验分享给大家，尽量通俗易懂的和盘托出。 关于项目管理方面的文章都会归纳在 项目管理 合集中，今天只分享的主题是在项目管理中常见问题的解答和分析。作为一名技术人，除了掌握专业的技能和解决问题的能力，还应该具备一定的项目管理能力，争取将来能做一名带兵打仗的将军实现自我更大的价值。 爬过一座高山之后，除了累，还有山顶的风光却和沿途的景色。做项目管理的经理人也是如此。 证书在手，天下我有 问：”考 PMP 证书到底有没有用“？ 再问：”考过 PMP，月薪是不是可以翻一番“？ 又问：”拿到 PMP 证书，是不是就可以当项目经理了“？ 之前有不少人问过我相同的问题，包括我自己在刚做项目经理的初期也有过类似的疑问。 这些问题都是好问题，但每个问题又不可以随便说 可以 或者 不可以。 PMP，全称是 Project Management Professional，指的是项目管理专业人士资格认证。它是由美国项目管理协会 PMI（Project Management Institute）发起的，严格评估项目管理人员知识技能是否具有高品质的资格认证考试。通过该考试可以拿到 PMP 证书。 从我个人经历和感悟来逐一回答上面三个问题。 1、考 PMP 证书到底有没有用？ 如果你有时间或者精力，考 PMP 证书对绝大多数人来说肯定是有用的，这个毋庸置疑。 考 PMP 证书花费大概在 5000 - 6000 左右，准备大概 2-3个月就可以了，也算是对自己的一种投资，说不定哪天能够派上用场，无心插柳柳成荫。 PMP 考试过程中你需要看相关的专业书籍，至少要看 2 遍，在书中学到的一些理论知识不仅可以运用到工作当中，还可以运用到生活、家庭和教育以及人际关系当中去。 一切皆项目，利用考证的机会可以学到一些项目管理知识，既拿到了 PMP 证书又学到了新知识，一举两得。 2、考过 PMP，月薪是不是可以翻一番？ 很多企业招聘项目经理会写：有 PMP 证书的优先。但是没有写：有 PMP 证书的薪资比没有 PMP 证书的薪资高 N 倍。 如果你之前有项目管理的工作经验，并且担任过几年的项目经理，做过的项目业绩也不错，但因为各种原因没有考 PMP 证书，突然有一天你心血来潮一脚油门考过了 PMP 考试。此时，你已不再是那个懵懂的少年，俨然是个项目管理老司机了，便可以理直气壮地跟公司领导谈谈升职加薪的事了。如果你对谈判结果不满意，大不了跳个槽，说不定薪资真能翻一番。此处不留爷，自有留爷处嘛。 考过了 PMP，拿到了证书，只能说明你对项目管理的专业知识技能掌握的还不错。至于能不能升职加薪，还是要看你的个人工作能力以及你所带的项目对公司的贡献度。 在我的职业生涯中，有很多项目经理并没有考 PMP但一样做的风生水起，他们确实比较优秀，能够用自己的方式和方法帮团队和组织实现目标。 3、拿到 PMP 证书，是不是就可以当项目经理了？ 可以这么说，没有 PMP 证书，也一样可以做项目经理。 “如果你恨一个人，就让他去当项目经理，因为十有八九他会被失败的项目毁了。“ 这是网上比较流行的一个段子，只有做过项目经理的人才能领悟这句话的含义。 大多数的公司或者企业，一般会从内部提拔人员担任项目经理的岗位，而不会从外部招聘（但有可能会从外部招聘一名项目管理专家）。 能从其他岗位做到项目经理这个位置的人，一般都是业绩比较突出，在团队里有较高的威望，一言九鼎，做人做事都能拿捏的恰到好处。 给想从事项目经理的同学们一句劝，最好先做好自己的业务再来做项目经理，在自己的业务中不断的实践项目管理知识，待时机成熟后再来考虑是否要坐上项目经理的宝座吧，且不要操之过急。 专业我有，恪尽职守 项目管理是一门学问和艺术，任何人都可以具备项目管理的能力，项目管理强调的是技能和专业；项目经理是一个岗位名称，项目经理要能够使用项目管理的方法、技巧和手段完成组织目标，强调的是职位和职能。 你可以不是项目经理，但你可能需要项目管理的能力。 一般有项目经理的团队，组织结构大致如下图所示。 还有一种情况是团队中没有专职的项目经理，需要有人能够履行项目经理的职能，一般都是由组长担任项目管理的职责。 常见的软件开发项目中，测试组长会带领测试成员负责项目的测试工作，前后端开发组长会安排开发成员的工作，负责项目开发周期以及开发质量。这样各个组的组长都是各组的”项目经理“。当项目发展到一定阶段（如团队人数增加了、产品线变多了等），产品经理会承担项目经理的角色组织和管理各个组长，向项目负责人（一般是部门负责人）汇报，产品经理要对用户和相关方负责，需要不断的提高产品用户体验，能够站在更高的层次管理项目。 从上面的介绍中，可以看出无论你是产品经理，还是开发或者测试组长，都需要一定的项目管理知识作为储备。 在很多互联网公司的职级晋升要求中，明文规定：”晋升到某个职级必须要具备项目管理的专业知识，否则不予通过“。就拿开发组长来说，可能 TA 编写代码的速度和代码质量在团队中出类拔萃，解决问题的思维和手段出其不意，大家都称 TA 为大神。只要跟 TA 讨论编程，TA 能够滔滔不绝的给你来上几段，但一到事情规划和人员管理上就显得手忙脚乱，措手不及。这种人需要公司或者企业给与一定的指导和培训，适当的让 TA 带领人员从小事做起，慢慢的培养项目管理的能力和自信，换句话说就是要能给予这样的人才赋能。 你要知道很多成功的企业家，他们都是从组长做起来的，他们通过不断的学习和实践具备了较强的项目管理能力，为后面自己的创业生涯添上了浓墨重彩的一笔。不积跬步无以至千里，点点滴滴才是基石。在做好本专业领域的同时，不妨”越俎代庖“地做一些管理项的工作，能让你事半功倍的完成目标。 你的使命是带领一批合适的人完成组织的特定目标]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>项目管理 常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: __attribute__((visibility()))]]></title>
    <url>%2F2021%2F08%2F08%2FGCC-attribute-visibility%2F</url>
    <content type="text"><![CDATA[在 objc-api.h 里面有很多关于 __attribute__ 的定义。 例如下面的代码片段： 1234567891011#if !defined(OBJC_VISIBLE)# if TARGET_OS_WIN32# if defined(BUILDING_OBJC)# define OBJC_VISIBLE __declspec(dllexport)# else# define OBJC_VISIBLE __declspec(dllimport)# endif# else# define OBJC_VISIBLE __attribute__((visibility("default")))# endif#endif 可以看到：OBJC_VISIBLE 的定义方式是 __attribute__((visibility(&quot;default&quot;)))。 那么究竟有什么作用呢？下面举例说明。 GCC 有个 visibility 属性，启用这个属性情况如下说明。 1、当编译时增加 -fvisibility=hidden 动态库中的函数默认是被隐藏的即 hidden，除非显示声明为 __attribute__((visibility(&quot;default&quot;))) 2、当编译时增加 -fvisibility=default 动态库中的函数默认是可见的。除非显示声明为 __attribute__((visibility(&quot;hidden&quot;))) 特别说明:：这个特性是 GCC4.0 以后才有的。 基于 GCC系列: 加载静态链接库 的例子。谈谈 visibility。 Car.c 1234567891011121314#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; __attribute ((visibility("default"))) int drive()&#123; printf("Car driving...\n"); return 0;&#125;void stop()&#123; printf("Car stop.\n");&#125; 注意：attribute 的定义和使用方法。 使用 visibility 属性来编译动态链接库，如下： 1g++-4.9 -shared -o libCar.so -fvisibility=hidden Car.c 这样一来，drive 方法是可见的，但是 stop 是不可见的。 main.c 123456789101112131415161718#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //// 在 gcc 编译器下, 必须声明方法// 在 clang 编译下, 只是给了警告//int drive();void stop();int main()&#123; drive(); stop(); return 0;&#125; 编译 1g++-4.9 -o app main.c -L ./ -lCar 提示信息 12345Undefined symbols for architecture x86_64: "stop()", referenced from: _main in ccZnwENu.old: symbol(s) not found for architecture x86_64collect2: error: ld returned 1 exit status 这说明了上面提到的第一种情况。 重新编译 Car.c，换个方式： 1g++-4.9 -shared -o libCar.so -fvisibility=default Car.c 注意: 这次使用了 default 属性。 编译 main.c 1g++-4.9 -o app main.c -L ./ -lCar 编译成功，运行程序 123./app Car driving...Car stop. 那么修改一下 Car.c 的代码 1234567891011121314#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; __attribute ((visibility("default"))) int drive()&#123; printf("Car driving...\n"); return 0;&#125;__attribute ((visibility("hidden"))) void stop()&#123; printf("Car stop.\n");&#125; 使用 visibility=default 和 visibility=hidden 分别编译 Car.c. 可以知道，stop 函数都是隐藏的，这个也很好的说明了上面两个问题。 另外，除了 default 和 hidden，还有 internal、 protected 等，大家可以根据自己的使用场景选择使用即可。 选择比努力更重要，将就可以一时但不能一世~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>gcc clang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows+Nginx 部署 Flutter Web]]></title>
    <url>%2F2021%2F07%2F09%2FWindows-Nginx-%E9%83%A8%E7%BD%B2-Flutter-Web%2F</url>
    <content type="text"><![CDATA[今天的内容比较简单，我们直接进入主题。 创建工程目前笔者用的 Flutter SDK 是 Stable 2.x，其已经支持 Web了。 使用 Android Studio 创建 Flutter 工程，需要勾选上对 Web 的支持，如下图所示： 如果你之前创建的工程没有勾选该选项，可以在工程目录下执行如下命令： 123# flutter create &lt;output directory&gt;# Create a new Flutter project in the specified directory.flutter create . 12345678910Recreating project .... web\favicon.png (created) web\icons\Icon-192.png (created) web\icons\Icon-512.png (created) web\index.html (created) web\manifest.json (created)Wrote 8 files.All done! 完成之后，在工程目录下就会生成 web 目录。 编译 Web 版本编译 Web 版本只需要一行命令 1flutter build web 编译成功后，在工程的 build 目录下面有个 web 目录。 Nginx 配置在 Nginx 的配置文件中，增加一个 server 配置即可。 12345678910server &#123; listen 8083; server_name localhost; location / &#123; # web目录的路径 root \project-path\build\web; # 默认页面 index index.html index.htm; &#125; &#125; 启动 Nginx（关于 Windows 上面操作 Nginx 的命令，可以参考笔者的 减少跨域中的OPTIONS请求) ，然后在浏览器中访问 http://localhost:8083/index.html 即可。 学习犹如爬山，适当的咬紧牙关冲刺一把，就能一览众山小]]></content>
      <categories>
        <category>Tools</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter Nginx Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主键值被我用完了]]></title>
    <url>%2F2021%2F06%2F12%2FMySQL%E4%B8%BB%E9%94%AE%E5%80%BC%E8%A2%AB%E6%88%91%E7%94%A8%E5%AE%8C%E4%BA%86%2F</url>
    <content type="text"><![CDATA[简介对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复是指能够通过某个字段唯一区分出不同的记录，这个字段被称为 主键。 对表的主键要求比较关键的一点是：记录一旦插入到表中，主键最好不要再修改。 选取表的主键一个基本原则是：没有特殊情况，不使用任何业务相关的字段（如证件号码、手机号码等）作为主键。 本篇主要说明下面两个问题： 主键值范围越界了会发生什么？ 不设置主键行吗？ 看完正文之后，可以在本篇的【小结】部分找到答案。 推荐下面几篇关于 MySQL 的文章： MySQL8-0-15在Win10上的折腾记 微服务-MySQL基本操作 导入MySQL数据库文件 数值类型的边界值C 标准库 limits.h 中定义了一些数据类型的值的范围、限制值，也就是说该类型的值不可以大于该上界或者小于该类型值的下界。 咱们先看下下面这个 C 语言例子。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int main() &#123; // 65535 printf("unsigned short max value: %u\n", USHRT_MAX); unsigned short yy = USHRT_MAX; printf("xx = %hu\n", yy); //65535 printf("xx + 1 = %hu\n", yy+1); //0 printf("xx + 2 = %hu\n", yy+2); //1 printf("unsigned short sizeof: %u\n", sizeof(unsigned short)); return 0;&#125; 编译运行，可以得到如下结果： 12345unsigned short max value: 65535xx = 65535xx + 1 = 0xx + 2 = 1unsigned short sizeof: 2 从结果来看，无符号的 short 数据类型的最大值是 65535，当然最小值就是 0，即范围是 0 ~ 65535。 在这里，还是要再提一下关于格式化打印里面的一些说明： i% 和 d%，都可以用来表示有符号的十进制整数，一般 ld% 用来表示 long 类型的； o% 用来表示八进制整数，x%（X%）用来表示十六进制整数； 对 short 类型使用 h 前缀，因此 %hd 表示以十进制显示 short 整数，%ho 表示以八进制显示 short 整数； %u 用来表示无符号整数，即 unsigned int 类型数据； h% 和 l% 前缀都可以同 u% 结合使用表示无符号整数。如 %lu 表示打印 unsigned long 类型、%hu 表示打印 unsigned short 类型； 打印 long 数值，%ld 打印 long 数值，%lx 表示以十六进制格式打印长整数，%lo 表示以八进制格式打印长整数； 实践经过上面的说明之后，接下来我们就可以进入今天的正题了。 创建数据库 play_db 123CREATE DATABASE play_db;USE play_db; 设置主键并自增创建表 table0 1CREATE TABLE table0(id SMALLINT unsigned AUTO_INCREMENT PRIMARY KEY, name char(10)) AUTO_INCREMENT=65535; SMALLINT 是 MySQL 支持的一种数据类型，占用 2 个字节，有符号的取值范围是 (-32 768，32 767)，无符号的取值范围是 (0，65 535)。 看下创建的表情况 1DESC table0; 插入数据 1INSERT INTO table0 (name) VALUES ('veryitman'); 可见，此时 id 默认值已经是 65535了，试图再插入一条数据。 1INSERT INTO table0 (name) VALUES ('.com'); 那么另外一个问题来了，如果我们不设置主键呢？ 不设置主键无自增创建表 table1 TINYINT unsigned，表示范围 0 ~ 255 12345CREATE TABLE table1(id TINYINT unsigned, name char(10));INSERT INTO table1 (id, name) VALUES (255, 'veryitman');INSERT INTO table1 (id, name) VALUES (256, 'haha'); 此时会报错：ERROR 1264 (22003): Out of range value for column &#39;id&#39; at row 1 如果不设置主键， InnoDB 会自动帮你创建一个不可见的、长度为 6 字节的 row_id，而且这个 row_id 是由 InnoDB 维护全局的 dictsys.row_id，每次插入一条数据时都会让全局 row_id 加一（未定义主键的表会使用全局 row_id 作为主键 id）。 如果全局 row_id 一直涨，直到涨到2的48次方-1时，这时候再加一就会让低 48 位的 row_id 都为 0，此时如果再插入一条数据，它拿到的 row_id 就是 0，这样的话就有可能存在主键冲突的。 所以创建表的时候，最好设置主键。 设置自增但无主键创建表 table2 1CREATE TABLE table2(id TINYINT unsigned AUTO_INCREMENT, name char(10)) AUTO_INCREMENT=255; 报错信息如下： 1ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key 错误信息的意思是，只能有一个自增列，它必须被定义为键。 小结1、在设计数据表时，尽量根据业务需求来选择合适的字段类型。数据库表的自增 ID 达到上限之后，再申请时它的值就不会在改变了，继续插入数据时会导致报主键冲突错误。 一个库或者表数据尽量不要太多，根据自己的业务合适设置即可。如果数据较多要进行分库分表，分布式环境下要注意主键生成问题，做到主键唯一； 2、为了避免一些不必要的麻烦和隐性错误，设计表都应该设置主键。 附录MySQL支持的数值类型 不积跬步，无以至千里；不积小流，无以成江海。]]></content>
      <categories>
        <category>Server</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>MySQL windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走上项管之路]]></title>
    <url>%2F2021%2F05%2F23%2F%E8%B5%B0%E4%B8%8A%E9%A1%B9%E7%AE%A1%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[简介在几年前，我还不知道项目管理究竟为何物，而如今自己却与它紧紧相连。 跟大家分享一下自己是如何走上项目管理之路的，希望能对你将来的职业规划有点帮助。 开发之路本人大学的专业是搞电子信息的。大学的生涯让我学到了很多高深莫测的知识，也让我结识了一帮志同道合的朋友，有幸能和他们一起在实验室里面搞研究。当然大学最重要的是让我获得了文凭，为将来找工作埋下了重要的基础。 我是从 2009 年真正开始接触移动端编程的，那个时候 Android 编程慢慢的在一线城市火了起来，朋友建议我趁现在有时间赶紧学一学：“这可能是将来让你辉煌腾达的首选之路”。听着他中肯的建议，仿佛自己已经走上了人生之颠，比当年哥伦布发现新大陆还 TM 还喜出望外。然鹅我不禁乐极生悲，Android 是啥？ 经过一番了解和学习，终于认识了 Android。从 Java 编程到 Android 编程，我开始了自我修炼之路。那个时候我就在想，这个玩意挺好玩的，这辈子我都要学习它，玩转它！现在想想那个时候的自己还是挺理想的一个人，呵呵！ 毕业后不久，就有模有样的干起了 Android 开发的勾当，这一干就是 5 年。 从一个意气风发的骚年变成了真正的码农，飘逸的头发也渐渐的稀疏了起来。 直到有一天，遇到一个项目，大佬（项目技术总监）告诉我说：“团队目前没有 iOS 开发的人员，你是否愿意为自己多增加一种技能？”。 看着大佬诚挚的眼神，年少轻狂的我想都没想就答应了。现在回想起自己那种很自信的样子，挺傻的。 从那以后，我便开始了没日没夜的走上了熟悉和学习 iOS 编程之路，苦并快乐着，可能是因为自己的勤奋感动了上苍，很快就上手了 iOS 开发，并做得如火如荼，一发不可收拾。 在 iOS 开发的同时，我并没有放弃对 Android 开发的学习和进步，两手都要抓尽量都要硬。在后续的编程道路里，我越来越发现编程是相通的，只要你肯努力，就没有克服不了的困难。唯一要克服的就是你的懒惰和借口。 慢慢地我又开始接触了 Java 后端编程，移动端游戏开发等工作。唯一遗憾的是没有接触过前端编程，当全栈工程师的梦想也就破灭了。 任何人都有选择的权力，在某个风和日丽的早上我毅然选择要放弃编程之路，准备踏上项目管理之路。 有很多人会说，你是因为年龄的问题才想着转管理路线的吧！ 我只能说，年龄只是很小的一部分因素。毕竟这个世界上还有很多事情，我还没有经历过，也想在有生之年换一种求生之路。 项目管理之路能从编程之路转到项管之路，跟当时的项目有关，对我来说也是一个机会。 走上项管的历程，让我想起了电影《功夫》里面的一个片段： “唉，小弟，小弟，别走啊” “哇，不得了，不得了啊！ 你有道灵光从天灵盖喷出来，你知道吗？ 年纪轻轻的就有一身横练的筋骨，简直百年一见的练武奇才啊！ 如果有一天，让你打通任督二脉，那还不风龙上天哪？！ 正所谓：我不入地狱，谁入地狱。警恶惩奸，维护世界和平这个任务，就交给你了，好吗？” “唔” 。。。 当然了，电影中的片段存在一定忽悠的成分。这里想表达的是：当机会来临的时候，做一下对比和衡量，适合就上吧！ 我很感谢当初让我转行的大佬，给了我很多专业的建议，让我在这条路上能够有个很好的开始。 在转行后，自己也是积极的学习项目管理知识，虽没有悬梁刺股倒也会闻鸡起舞。 在项目管理的职业生涯中，并非是一帆风顺的，跟编程一样需要不断的学习。让项目成功，是项目管理中的重要使命。 这里要给在座的各位提个醒，项目管理不是让你来颐指气使管人的，而是让你能够把握大局，营造氛围让大家创造一个又一个成功的项目。 在团队中，你应该坚持公平公正的原则，维持项目的可持续健康发展，做好服务大众的角色和义务！ ~ 今天就到这吧，后续我会分享更多关于自己在项目管理中的实际案例给大家~ 任何事都没有表面看起来的那么简单，既然选择了你认为适合自己的就坚持下去！终可见！]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>项目管理 职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS、VSCode中实时显示每行代码的修改记录]]></title>
    <url>%2F2021%2F04%2F12%2FAS%E3%80%81VSCode%E4%B8%AD%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E6%AF%8F%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[简介阅读下面内容开始之前，假设你已经在使用 git 管理自己的代码了。 阅读本篇，可以看到如下内容： 1、如何在 Android Studio 中实时显示每行代码的提交历史记录； 2、如何在 Android Studio 中查看单个文件的修改历史记录； 3、如何在 Visual Studio Code 中实时显示每行代码的提交历史记录； plugin 之功工欲善其事必先利其器，在使用 IDE 工具的时候找到适合自己的插件可以让你的工作事半功倍。 大家可以在 在 AS 中安装如下两个插件： Git GitToolBox 安装方式很简单，File/Setttings/Plugins，搜索插件名称直接安装完成重启 AS 即可。 在 VSCode 中安装如下插件： GitLens 使用快捷键 Ctrl + Shift + P，输入 Install Extensions，再搜索 GitLens 安装即可。 安装完成之后，就可以如下分别在 VSCode 和 AS 中的效果了，如下图所示： VSCode 显示效果： AS 显示效果： AS 设置 GitToolBox可以在 File/Setting 中对 GitToolBox 进行相关的设置，如下图： AS 查看单文件修改记录按照下面截图的步骤操作即可查看，例如查看 main.dart 的修改记录。 Show History 后，在打开的页面中即可查看该文件的修改记录。 如果你习惯使用 git 命令行操作，也可以结合 git log --pretty=oneline 文件名 和 git show COMMITID 的方式来查看。 一味的妥协和让步只会让事情愈发以控制，直至灾难来临~]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git AS VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Token 相关的重构]]></title>
    <url>%2F2021%2F01%2F17%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Token-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[简介在上一篇 微服务-Token的处理 中，写了一个 MSAuthTokenUtil 类，用来生成、刷新、校验 token，该类的方法都是 static 的。后续想了一下，还是将其改为普通的组件较好，在最新代码中对其做了两个较大的重构。 重构为组件将其改名为 MSAuthTokenHelper，并将其中的所有 static 方法改为实例方法，用注解 @Component 修饰。 12345@Slf4j@Componentpublic class MSAuthTokenHelper &#123; ///....&#125; 在所有使用到 MSAuthTokenHelper 的地方，增加对应的自动注入后调用即可。如下： 12345678910111213141516171819private MSAuthTokenHelper tokenHelper;@Autowiredpublic void setTokenHelper(MSAuthTokenHelper tokenHelper) &#123; this.tokenHelper = tokenHelper;&#125;@Overridepublic MSResponse refreshUserToken(String token) &#123; // ... String refreshToken = tokenHelper.refreshToken(token); if (null != refreshToken) &#123; String userID = tokenHelper.userIDfromToken(token); &#125; // ...&#125; 这里顺便提一下，@Controller，@Service，@Repository 以及 @Component 的区别以及联系，如下表所示： 注解 含义 @Component 最普通的组件，可以被注入到spring容器进行管理 @Repository 作用于持久层 @Service 作用于业务逻辑层 @Controller 作用于表现层（spring-mvc的注解） @Controller，@Service，@Repository 都继承了 @Component 的功能，可以看这几个注解的源码得知。 1234567891011121314151617181920212223242526272829303132333435/// Repository 注解@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Repository &#123; @AliasFor( annotation = Component.class ) String value() default "";&#125;/// Controller 注解@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller &#123; @AliasFor( annotation = Component.class ) String value() default "";&#125;/// Service 注解@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Service &#123; @AliasFor( annotation = Component.class ) String value() default "";&#125; 当一个类被 @Component 所注解，那么就意味着同样可以用 @Repository, @Service, @Controller 来替代它，同时这三个注解会具备有更多的功能，而且功能各异，可以根据自己的需要使用不同的注解来表示不同的业务和逻辑。具体可以参考 Spring/Spring-Boot 学习 @Controller,@Component,@Service,@Repository的异同 这篇文章，写的很清楚了。 从配置文件读取 token 的配置在之前的文章中，分享过如何通过 SpringBoot 的 @ConfigurationProperties 注解来读取配置文件，可以参考 微服务-ConfigurationProperties配置 这篇文章。 在 properties 文件中，新增如下的配置信息: 123456789# Auth token config# --------------------------------------------msconfig.authtoken.claims_jwtsid=restful_apimsconfig.authtoken.claims_subject=adminmsconfig.authtoken.claims_audience=client#token 过期时间24小时(24 * 60 * 60 * 1000)msconfig.authtoken.token_expire_time=86400000#密钥盐msconfig.authtoken.token_secret=token123 这些配置信息对应的 model 是 MSAuthTokenPropertyConfig，如下： 123456789101112@Setter@Getter@Component@ConfigurationProperties(prefix = "msconfig.authtoken")public class MSAuthTokenPropertyConfig &#123; private String claims_jwtsid; private String claims_subject; private String claims_audience; private long token_expire_time;//token 过期时间24小时 private String token_secret;//密钥盐&#125; 在 MSAuthTokenHelper直接使用即可，关键代码如下所示： 12345678910111213141516171819202122232425@Slf4j@Componentpublic class MSAuthTokenHelper &#123; private MSAuthTokenPropertyConfig authTokenPropertyConfig; @Autowired public void setAuthTokenPropertyConfig(MSAuthTokenPropertyConfig authTokenPropertyConfig) &#123; this.authTokenPropertyConfig = authTokenPropertyConfig; &#125; public String generateToken(String userID) &#123; String token = ""; long tokenExpireTime = authTokenPropertyConfig.getToken_expire_time(); String jwtsid = authTokenPropertyConfig.getClaims_jwtsid(); String subject = authTokenPropertyConfig.getClaims_subject(); String audience = authTokenPropertyConfig.getClaims_audience(); String tokenSecret = authTokenPropertyConfig.getToken_secret(); //... return token; &#125;&#125;]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>JWT Token Refractor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Token的处理]]></title>
    <url>%2F2021%2F01%2F03%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Token%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介在 Win10-安装-Redis 和 微服务-SpringBoot-集成-Redis 分别介绍了如何安装和使用 Redis，今天继续结合 Redis，聊聊 token 授权登录的事情。 今天聊的主角是 JWT，聊完 JWT 之后再结合实例实现用户 token 登录。 JWT 介绍JWT，JSON Web Token 的缩写，基于 RFC 7519 标准。 下面内容来自 jwd.io，如下： 1JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties. JWT 定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任（因为它是数字签名的）。 JWT 可应用于但不仅限于下面的几种场景： 1、跨域认证 JWT 是一种比较流行的跨域认证解决方案，JWT 的诞生并不是解决 CSRF 跨域攻击，而是解决跨域认证的难题。 A 网站和 B 网站是同一家公司的关联服务，现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，这应该如何实现呢？客户端保存 Token，每次请求都发回给服务器即可。 2、授权（Authorization） 用户一旦登录成功后，后续用户的每个请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的 JWT 的一个特性，因为它的开销很小，并且可以轻松地跨域使用。授权，是使用 JWT 的最常见的场景之一。 3、信息交换（Information Exchange） 对于安全的在各方之间传输信息而言，JWT 是一种很好的方式。JWT 可以被签名，例如，用公钥/私钥对，可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，还可以验证内容没有被篡改。 可以参考阮一峰老师的 JSON Web Token 入门教程，更多详细的介绍可以参考 jwd.io 的相关资料。 使用 JWTSpring Boot 集成 jjwt本文以集成 https://github.com/jwtk/jjwt 为例。如果你有兴趣也可以试着去使用 https://github.com/auth0/java-jwt，它是 JWT 的另一个 Java 实现。 截止到该文发布，在 maven repository 仓库中 jjwt 最新版本是 0.9.1 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 修改了哪些文件本次涉及修改和新增的文件如下： 【修改】MSUserSigninService.java：登录服务的接口； 【修改】MSUserSigninServiceImpl.java：登录服务的接口实现； 【修改】MSSigninController.java：登录的Controller； 【新增】MSAuthTokenUtil.java：token工具类； 【新增】MSAuthConfigurer.java：token配置管理； 【新增】MSAuthInterceptor.java：自定义拦截器； 具体的实现步骤为： 写 token 工具类，实现 token 的生成，校验等工作即 MSAuthTokenUtil.java; 写自定义拦截器，即 MSAuthInterceptor.java，该类实现了 HandlerInterceptor 接口； 拦截客户端相关的 API 请求，对相关的接口进行token的校验； 有了统一的拦截器不需要在每个 Controller 或者对应的 Service 中去做 token 的判断； 写自定义拦截器的配置管理类即 MSAuthConfigurer.java，该类实现了 WebMvcConfigurer 接口； 增加 token 登录的 API，并实现 Redis 缓存 token 的逻辑； 实例演练用户登录完成后，根据 userID 生成 token，将 token 保存到 Redis 中按照 userID 为 key 来进行存储的。 MSAuthInterceptor.java 是自定义的拦截器，在该拦截器中获取请求的 token 并进行相关的校验。核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Componentpublic class MSAuthInterceptor implements HandlerInterceptor &#123; private static final String REQUEST_TOKEN_KEY = "token"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestMethod = request.getMethod(); if ("OPTIONS".equalsIgnoreCase(requestMethod)) &#123; response.setStatus(HttpServletResponse.SC_OK); return true; &#125; // 请求的Header中拿 String token = request.getHeader(REQUEST_TOKEN_KEY); // Header中拿不到token if (null == token) &#123; String[] tokens = request.getParameterValues("token"); if (null != tokens &amp;&amp; tokens.length &gt; 0) &#123; token = tokens[0]; &#125; &#125; if (MSAuthTokenUtil.verifyToken(token)) &#123; return true; &#125; PrintWriter writer = null; response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); try &#123; writer = response.getWriter(); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(2); result.put("code", 400); result.put("msg", "用户令牌token无效"); result.put("data", null); writer.print(result); &#125; catch (IOException e) &#123; &#125; finally &#123; if (null != writer) &#123; writer.close(); &#125; &#125; return false; &#125;&#125; 拦截器的配置在 MSAuthConfigurer.java 中进行管理，关键代码如下： 12345678910111213141516171819202122232425262728@Configurationpublic class MSAuthConfigurer implements WebMvcConfigurer &#123; private MSAuthInterceptor authInterceptor; public MSAuthConfigurer(MSAuthInterceptor authInterceptor) &#123; this.authInterceptor = authInterceptor; &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 如下路径不做拦截 List&lt;String&gt; excludePaths = new ArrayList&lt;&gt;(); excludePaths.add("/signup/**"); //注册 excludePaths.add("/signin/name/**"); //用户名登录 excludePaths.add("/signin/get/token/**"); //获取token excludePaths.add("/signout/**"); //登出 excludePaths.add("/static/**"); //静态资源 excludePaths.add("/assets/**"); //静态资源 // 除了 excludePaths 外的请求地址都做拦截 registry.addInterceptor(authInterceptor) .addPathPatterns("/**") .excludePathPatterns(excludePaths); WebMvcConfigurer.super.addInterceptors(registry); &#125;&#125; 接下来重点说一下 MSAuthTokenUtil.java 里面如何生成 token 的，MSAuthTokenUtil.java 主要是完成生成、检验、刷新 token 等工作。 1234567891011121314151617181920public static String generateToken(String userID) &#123; String token = ""; Date date = new Date(); // 过期时间 Date expireDate = new Date(System.currentTimeMillis() + TOKEN_EXPIRE_TIME); token = Jwts.builder().setId(JWTSID) .setSubject(SUBJECT) .setAudience(AUDIENCE) .setIssuedAt(date) .setExpiration(expireDate) .claim(CLAIMS_USERID, userID) .signWith(SignatureAlgorithm.HS256, TOKEN_SECRET) .compact(); log.info("generateToken token: " + token); return token;&#125; 根据用户ID 生成 token，其中 claim(CLAIMS_USERID, userID) 是用于自定义字段的，便于解析 token 时获取相关的信息。 当我们调用用户名+密码登录的时候，会生成对应的 token，然后将该 token 保存到 Redis 中。下次调用 token 登录的接口时，会从 Redis 中取出对应的 token 信息进行校对，校对通过就返回成功，否则返回失败无法登录。 在 MSSigninController.java 分别实现了获取 token、刷新 token，token 登录三个接口，如下： 123456789101112131415161718192021222324252627282930313233@RequestMapping(value = "/get/token", method = RequestMethod.GET)@ApiOperation(value = "获取token", httpMethod = "GET", notes = "获取登录")@ApiImplicitParams(&#123; @ApiImplicitParam(name = "userID", value = "userID", required = true)&#125;)public MSResponse getToken(@RequestParam(value = "userid") String userID) &#123; MSResponse response = userSigninService.fetchUserToken(userID); return response;&#125;@RequestMapping(value = "/token", method = RequestMethod.GET)@ApiOperation(value = "Token登录", httpMethod = "GET", notes = "Token登录")@ApiImplicitParams(&#123; @ApiImplicitParam(name = "userID", value = "userID", required = true), @ApiImplicitParam(name = "token", value = "token", required = true)&#125;)public MSResponse siginWithToken(@RequestParam(value = "userid") String userID, @RequestParam(value = "token") String token) &#123; MSResponse response = userSigninService.signinUsingToken(userID, token); return response;&#125;@RequestMapping(value = "/refresh/token", method = RequestMethod.GET)@ApiOperation(value = "刷新Token", httpMethod = "GET", notes = "Token刷新")@ApiImplicitParams(&#123; @ApiImplicitParam(name = "token", value = "token", required = true)&#125;)public MSResponse refreshToken(@RequestParam(value = "token") String token) &#123; MSResponse response = userSigninService.refreshUserToken(token); return response;&#125; 为了方便使用了 GET 方式进行网络请求。后续可以改为 POST 请求。 登录逻辑都在 MSUserSigninServiceImpl.java 中，大家可以自行去看源码，这里不再赘述。 API 调用效果启动 MySQL，启动 Redis，再启动项目即可。 用户登录成功后，调用 /get/token API，如下： 调用 /token 进行登录的 API，如下： 调用 refresh/token API 如下： 待办事项 token 配置信息放置到配置文件中；2021.01.17 Done 微服务-Token-相关的重构; Redis 中设置 token 的过期时间； 调用刷新 token 的 API 后更新 Redis 中 token 的有效时间； 刷新 token、使用 token 登录的 API 修改为 POST 方式； Token 的加密，减少 Token 登录的数据库查询次数； 只有弱者才去争取公平，这句话虽然残忍但很现实~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Redis JWT Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决bash profile不生效的方法]]></title>
    <url>%2F2020%2F12%2F13%2F%E8%A7%A3%E5%86%B3bash-profile%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我喜欢把 macOS 上面的一些环境变量（主要是一些开发套件如 Java、Android、Flutter 等）放到 ~/.bash_profile 这个文件中，But… 自从在 macOS 上面安装了 ohmyz.sh 之后，每次重启电脑或者新开终端的时候，我在 ~/.bash_profile 这个文件中的所有命令都无法使用了。除非再次执行下面的命令： 1source ~/.bash_profile 通过网友们的群力群策，还是很快找到了解决方案。 在 ~/.zshrc 文件最后增加一行：source ~/.bash_profile 即可完美解决。 如果你发现本机 ~/ 目录下面没有 .zshrc 这个文件，可以新建一个，命令如下： 123cd ~/touch .zshrc 如果你是用的是 macOS Catalina(10.15) 版本的系统，其实系统已经用 Zsh 取代了 Bash，成为操作系统的默认 Shell。相比 Bash 来说，Zsh 也拥有许多更强大的功能： 更智能的自动补全； 命令选项提示； 更丰富的主题，等等。 可以使用下面的命令查询一下当前你的系统默认 Shell 是哪个，如下： 1ps -p $$ 我在 macOS 终端上执行，结果如下： 12PID TTY TIME CMD692 ttys000 0:00.91 -zsh 网上还有些朋友说在 ~/.profile 中增加 source ~/.bash_profile 也可以解决问题，但我亲测后发现对于自己当前的 macOS 并没有生效。 目标一旦确立，遇到任何困难请不要轻易放弃~]]></content>
      <categories>
        <category>MacOS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>macOS ohmyz bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入MySQL数据库文件]]></title>
    <url>%2F2020%2F12%2F13%2F%E5%AF%BC%E5%85%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[简介 user.sql 是我在 Windows 10 系统中写的数据库文件，下面的举例都是基于这个系统和文件进行操作的。 其他系统如 macOS，操作命令也基本一样，只是文件路径不一样罢了。 ~接下来给大家介绍两种导入数据库文件的方法。 1、先进后导式 这种方式是先进入 MySQL，然后再导入数据库文件 进入 MySQL 1mysql -u username -p password 其中 username、password 分别是你连接 MySQL 的用户名和密码； 进入之后，开始导入数据库文件 1source sql-file-path 其中 sql-file-path 是你数据库文件的路径，例如 1source E:/work/db/user.sql 2、同进同导式 这种方式是进入 MySQL 的同时也导入数据库文件 1mysql -u username -p password -D data &lt; sql-file-path 同理，username、password 分别是你连接 MySQL 的用户名和密码，后面的参数 -D 一定要大写， sql-file-path 是你数据库文件的路径，例如： 1mysql -u username -p password -D data &lt; E:/work/db/user.sql 当然我们也可以先不输入 password，等命令行提示输入密码的时候再输入也可以，如下： 1mysql -u username -p -D data &lt; E:/work/db/user.sql 还有其他姿势，大家自行探索吧~ 需求只是客户需要的一小部分而已，而不是需求等于需要~]]></content>
      <categories>
        <category>Server</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>MySQL windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: SpringBoot 集成 Redis]]></title>
    <url>%2F2020%2F12%2F05%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-SpringBoot-%E9%9B%86%E6%88%90-Redis%2F</url>
    <content type="text"><![CDATA[简介忙碌了一周，感觉只有此刻写文字的时间才是最惬意的。最近工作比较忙，文章更新的较慢还望大家多多见谅🙇‍！ 在阅读下面的内容之前，希望你已经安装并且做好了学习 Spring Boot 集成 Redis 的准备了。 如果你还没有搭建 Redis 环境，Win10-安装-Redis 这篇文章或许可以帮到您。 在 Spring Boot 1.x 版本中默认的 Redis 客户端是 Jedis 实现的，Spring Boot 2.x 版本中默认客户端是用 Lettuce 实现的。可以从加入的依赖包中看出，Spring Boot 2.2.x 中的 spring-data-redis 仍旧包括了 Jedis 和 Lettuce，但是默认使用了 Lettuce（换句话说，如果你不想使用默认的 Lettuce 实现可以换成 Jedis 的实现），如下图： Lettuce 和 Jedis 的都是连接 Redis Server 的客户端，简单异同点如下： Jedis 在实现上是直连 Redis Server，多线程环境下非线程安全，除非使用连接池，为每个 Redis 实例增加物理连接； Lettuce 是 一种可伸缩，线程安全，完全非阻塞的 Redis 客户端，多个线程可以共享一个 RedisConnection，它利用 Netty NIO 框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序； 本篇只分享在 Spring Boot 项目中如何集成 Jedis 实现的 Redis 客户端和简单使用，关于 Redis 的使用有很多应用场景，后续再做探讨和分享（Redis 确实很强大，值得我们深入学习和研究）。 加入依赖包在 pom.xml 文件中添加 redis 的依赖，如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 运行项目后，会报如下错误： 123456org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisConnectionFactory' defined in class path resource [org/springframework/boot/autoconfigure/data/redis/LettuceConnectionConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory]: Factory method 'redisConnectionFactory' threw exception; nested exception is java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig 此时，需要在你的 pom 文件中添加连接池 commons-pool2 的依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; Lettuce 需要依赖 Apache的 common-pool2（至少是2.2版本）提供连接池，本篇使用的版本是 2.6.0，具体可以参考 Connection-Pooling 的介绍。 配置 properties配置 application.properties 文件，如下： 123456789101112131415# ------------------------------------------# 配置 redis for lettuce# ------------------------------------------spring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.database=0spring.redis.password=#连接池最大连接数（使用负值表示没有限制）spring.redis.lettuce.pool.max-active=8# 连接池中的最大空闲连接 默认 8spring.redis.lettuce.pool.max-idle=8# 连接池中的最小空闲连接 默认 0spring.redis.lettuce.pool.min-idle=0# 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.lettuce.pool.max-wait=-1 注意：因为我的工程中使用了多个 properties 文件用于区分不同的环境，所以你根据自己的配置文件来配置 Redis 即可。 真的是 Lettuce 嘛？为了证明我们现在使用的是 Lettuce 实现的 Redis 客户端，我写了一段测试代码，放到登录的 MSSigninController 进行了测试（具体代码可以参考 GitHub），如下： 123456789101112131415161718private RedisTemplate&lt;String, Object&gt; redisTemplate; @Autowired public void setRedisTemplate(RedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; @GetMapping(value = "/redisconn") public String redis() &#123; log.info(redisTemplate.getValueSerializer().toString() + ", " + redisTemplate.getHashValueSerializer().toString()); RedisConnectionFactory connectionFactory = redisTemplate.getConnectionFactory(); log.info(connectionFactory.toString()); if (connectionFactory instanceof LettuceConnectionFactory) &#123; LettuceConnectionFactory lettuceConnectionFactory = (LettuceConnectionFactory) connectionFactory; log.info(lettuceConnectionFactory.getHostName() + ", " + lettuceConnectionFactory.getPort()); &#125; return connectionFactory.toString(); &#125; 运行项目，打开 http://localhost:8080/signin/redisconn 即可看到浏览器上面显示类似如下的输出信息。 1org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory@5e91612a 同时，控制台输出如下内容： 1234org.springframework.data.redis.serializer.JdkSerializationRedisSerializer@7fd8e94e, org.springframework.data.redis.serializer.JdkSerializationRedisSerializer@7fd8e94eorg.springframework.data.redis.connection.lettuce.LettuceConnectionFactory@34212775127.0.0.1, 6379 从上面的信息可以看出： Redis 的客户端实现默认使用的是 Lettuce； 默认的序列化类是 JdkSerializationRedisSerializer，下面我们可以配置 RedisTemplate 来改变默认的序列化类； 配置 RedisTemplate关于 RedisTemplate 的配置，配置的实例代码都在 MSRedisConfig 这个类中，这里不再粘贴代码，有需要的可以直接点击 GitHub 查看。 配置完成后重新运行工程，再次访问 http://localhost:8080/signin/redisconn，控制台输出如下内容： 1234org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer@3151bece, org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer@7248212aorg.springframework.data.redis.connection.lettuce.LettuceConnectionFactory@6bcda66f127.0.0.1, 6379 可见，我们已经成功改变了默认的序列化类。 实例这次的例子，仍是在原来的工程 微服务-结合MySQL实现登录注册 的基础上面改造的，后续分享的内容基本都是在这个工程上面拓展。 用户使用用户名和密码登录，首先去 Redis 里面查找，查找到了直接返回不用去 MySQL 数据库中查找了，如果没有找到再去 MySQL 数据库中查找，查找成功后存储到 Redis 中，本次分享只是为了说明如何集成 Redis以及其简单使用，流程比较简单没有考虑其他因素和优化，仅供学习使用。 修改的逻辑部分，代码贴在下面，可以结合注释看一下很简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@CrossOrigin(origins = &#123;"*", "http://localhost:63344"&#125;)@RequestMapping(value = "/name", method = RequestMethod.GET)@ApiOperation(value = "用户名登录", httpMethod = "GET", notes = "用户名登录")@ApiImplicitParams(&#123; @ApiImplicitParam(name = "username", value = "用户名", required = true), @ApiImplicitParam(name = "userpwd", value = "密码", required = true)&#125;)public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; MSResponse response = new MSResponse(); MSUser user = null; if (null == userName || null == userPwd || userName.length() &lt;= 0 || userPwd.length() &lt;= 0) &#123; MSUserResponseEnum responseEnum = MSUserResponseEnum.Login4SiginInvalidInfo; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123; /** 从Redis里面查找该用户 */ MSUser redisUser = (MSUser) redisTemplate.opsForValue().get(userName); String query_user_pwd = ""; if (null != redisUser &amp;&amp; userPwd.equals(redisUser.getAccountName())) &#123; // Redis 里面有该用户信息 log.info("Redis 中找到了 " + userName); MSUserResponseEnum rspEnum = MSUserResponseEnum.SUCCESS; user = redisUser; response.setCode(rspEnum.getCode()); response.setMsg(rspEnum.getMsg()); &#125; else &#123; // Redis 里面没有该用户信息 log.info("Redis 中没有找到 " + userName); /** 查数据库的‘user’表中是否有该用户？*/ List&lt;Map&gt; query_users = userService.queryUserByUserName(userName); if (query_users.isEmpty()) &#123;// 没有该用户 MSUserResponseEnum responseEnum = MSUserResponseEnum.LoginNoSuchUser; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123;// 有这个用户 Map user_map = query_users.get(0); query_user_pwd = (String) user_map.get("accountPwd"); if (!query_user_pwd.equals(userPwd)) &#123; MSUserResponseEnum responseEnum = MSUserResponseEnum.LoginUserPwdError; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123; // 将查询出来的map对象使用FastJson转换为MSUser对象 user = JSON.parseObject(JSON.toJSONString(user_map), MSUser.class); // 缓存到 Redis，使用userName作为key String userNameKey = String.valueOf(user.getAccountName()); redisTemplate.opsForValue().set(userNameKey, user); log.info("MySQL 中找到了 " + userName + ", 并存到 Redis 中"); MSUserResponseEnum rspEnum = MSUserResponseEnum.SUCCESS; response.setCode(rspEnum.getCode()); response.setMsg(rspEnum.getMsg()); &#125; &#125; &#125; &#125; response.setResults(user); return response;&#125; 连续两次登录请求 http://localhost:8080/signin/name?username=foobar&amp;userpwd=foobar ，可以看到如下输出： 123456Redis 中没有找到 foobarMySQL 中找到了 foobar, 并存到 Redis 中... 省略其他日志Redis 中找到了 foobar 打开 Redis 的 CLI，可以查询一下是否存储成功， 1127.0.0.1:6379&gt; get foobar 得到结果如下： 1"&#123;\"@class\":\"com.veryitman.user.model.MSUser\",\"userID\":1723068547,\"accountName\":\"foobar\",\"accountPwd\":\"foobar\",\"nickName\":\"foobar\",\"age\":20,\"gender\":1,\"motto\":\"\",\"phone\":\"\"&#125;" 参考资料 Lettuce Lettuce-Core Lettuce-Connection-Pooling Jedis 适当的赞美可以让对方做出好的改变~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Redis SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 安装 Redis]]></title>
    <url>%2F2020%2F11%2F15%2FWin10-%E5%AE%89%E8%A3%85-Redis%2F</url>
    <content type="text"><![CDATA[简介关于微服务相关的分享，我都是在 Windows 10 系统下实践的，所以跟 Spring Boot 配套的软件也是在此系统上面安装的。 今天跟大家介绍一下如何在 Win10 下安装 Redis，该篇是 Spring Boot 使用 Redis 的处女篇，下篇结合之前登录场景举例如何在 Spring Boot 中使用 Redis。 往期 Win10 下面安装 MySQL 的文章：MySQL8-0-15在Win10上的折腾记 推荐给有需要的伙伴。 安装 RedisStep1：下载 下载 Windows 版本的 Redis，点击这里 下载 Redis。 我下载的是 3.0.504 版本。 Step2：解压 解压下载的 zip 包到任意目录，如我的目录： Step3：启动 命令行进入刚才解压文件的根目录下，然后执行如下命令即可，如下： 1./redis-server.exe redis.windows.conf 看到如下界面表示成功。 这种方式一旦关闭命令行，Redis 服务就关闭了，所以需要将 Redis 安装成系统（Windows）服务。 Step4：日志文件 在 Redis 解压后的根目录，新建 Logs 目录，然后在该目录下新建 redis_log.txt 文件。 否则，在进行下面操作的时候会报 Redis service failed to start. 错误。 如果你按照该要求新建了还是报错，需要经过下面的操作解决。 在命令行中（如果使用的是 git bash 终端，需要在下面的命令前加上 winpty）下开启 CLI 模式，运行 1./redis-cli.exe 然后再运行 123shutdownexit 重新启动服务即可。 Step5：设置 Redis 成 Windows 服务 另外打开一个命令行窗口，执行如下命令： 1./redis-server.exe --service-install redis.windows-service.conf --loglevel verbose --service-name Redis 执行成功后，你可以在 Windows 的系统服务（CMD+R/services.msc）中找到该服务（服务名称为 Redis），如下图： 另外从下图可以看到其属性，对应的配置文件是 redis.windows-service.conf，对应上面注册服务时使用的配置文件，所以后续的自定义配置就需要修改这个文件，不要搞错了。 如果你使用 redis.windows.conf 那么这里就应该是这个文件。 Step6：启动服务 执行如下启动命令即可，如下： 1./redis-server.exe --service-start 在服务列表中刷新一下，可以看到 Redis 正在运行。 注册服务成功后，就不需要像 Step3 那样开启服务了，在 Step3 中开启的服务窗口也可以关闭了。后续使用 Step6 方式启动即可，或者将该服务设置为开机自启动也可以。 如果在启动 redis 服务的时候报如下的错误： 1[18236] 29 Nov 10:52:01.070 # HandleServiceCommands: system error caught. error code=1056, message = StartService failed: unknown error 说明你的 redis 服务已经启动了，可以查看 Windows 的服务（CMD+R/services.msc）中是否已经启动成功。 使用 RedisRedis 相关命令 再次强调一下，如果使用了 git bash 终端执行下面的命令没有反应或者卡住很久的话，需要在下面命令前加上 winpty 即可。 1234567891011121314// 安装服务./redis-server.exe --service-install// 卸载服务./redis-server.exe --service-uninstall// 开启服务./redis-server.exe --service-start// 停止服务./redis-server.exe --service-stop// 开启 CLI 模式./redis-cli.exe -h 127.0.0.1 -p 6379 测试 Redis在命令行开启 CLI （命令行界面 command-line interface）模式，任意设置一个变量，如下： 只有弱者才去争取公平，这句话虽然残忍但很现实~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Redis windows10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生而为人，我很欢喜]]></title>
    <url>%2F2020%2F09%2F26%2F%E7%94%9F%E8%80%8C%E4%B8%BA%E4%BA%BA%EF%BC%8C%E6%88%91%E5%BE%88%E6%AC%A2%E5%96%9C%2F</url>
    <content type="text"><![CDATA[记得第一次读挪威的森林，还是上高一的时候。 这本书是一个同班同学借给我看的，这位同学是被大家公认的博览群书的翩翩才子。现在看来，他和《挪威的森林》这本书中的永泽还真是有得一拼。他告诉我说书里面写的很刺激，值得一看。我当时以为这是一本植物学家写的关于人与自然、探索世界的书籍，但从他猥琐的笑容里我逐渐感觉到我可能猜错了。 当时粗略的读完了这本书，内心满是草泥马，觉得渡边就一混蛋、渣男。在那个时候，渣男这个词并不奉行但世界上早已经有了这样的一群人🤢。 前段时间在偶然的机会下，我在书店又看到了这本书，难掩心中的迷惑又从容的读了一遍，发现根本不是自己原来看到和想到的那样。结合当时的日本社会背景和文化，这本书更多的是在写人精神层面的东西，生活给我们的是九十九件不如意和一件无奈，所有的不开心 、抑郁、困惑都在于本心，只要心态好，雨后便是晴天。人需要学会自我救赎。 日本很多作家的书籍，读来都比较压抑，像太宰治的《人间失格》，这本书我很早之前就买了但迟迟没有想好什么时候去看，直到我读完东野圭吾的大部分小说后才鼓起勇气读完了《人间失格》，读完我才知道，像我这种心态像花一样的人根本不畏惧什么。在出社会之前，我自己也是个经常愁眉苦脸的家伙，很多朋友都告诉我包括我的大学老师（良师益友），说我眉头就好像是被一把无孔的锁死死的锁住一样，笑容在我的脸上显得很吝啬。在那个时候，我对大学毕业其实是很恐惧的，家庭没有任何背景，自己对未来也很迷茫，大脑里乱糟糟的。不过我内心很知道这一切需要靠自己去改变，只有努力奋斗才能摆脱内心的束缚。慢慢的，我自己把很多事情想明白了，做事情也很有主见了，心态调整的相当好。 当生活以痛吻我，我要报之以歌！ 前段时间，听到一位老师讲解书籍，里面提到【生而为人，我很抱歉】这句话，他说这是太宰治写的。文章下面的评论很多人都在喷他，说他没有文化，这句话根本不是太宰治写的。人就是这样，挑毛病最拿手。我默默的去查了一下，这句话最早是出自诗人 寺内寿太郎 之手但确实是因为太宰治让这句话发扬光大的。 诗人寺内寿太郎原创于《遗书》的一组诗歌，大致意思是：生而为人，深感歉意； 然后，在日本作家太宰治所写的短小说《二十世纪旗手》中，作者把这句话作为了一个副标题，1937年首次在《改造》杂志上发表，收录在《人间失格》作者集中。 寺内寿太郎和太宰治是认识的。 据说是一个名不见经传的文学青年寺内寿太郎，他的表兄弟是太宰的朋友。这个青年相当命途多舛，年轻时失去了双亲，靠亲戚抚养，上了庆应大学。曾经多次感到人生的无奈，离家出走。一颗追求文学的诗心，让他写下了题为《遗书》的一组诗歌。其中有一首就是“一句诗”：生而为人深感歉意。然后这个倒霉蛋儿式文学青年的大嘴表哥就在一次跟太宰溜达聊天的时候谈到了这个表弟的诗句。当时太宰他们认为有了好点子，谁先用，算谁的。于是太宰就出其不意地在《二十世纪旗手》的开头，用了这么一句话。这个可怜的文学青年，怀着一颗赤诚的文学之心阅读他崇拜的作家太宰大作的时候，第一句话就被噎成重伤，据说脸气得发青去找他表哥算账，他表哥找到太宰算账，太宰装傻，哎呀，我以为是你的主意呢，真是深感歉意啊。于是这个可怜的青年大哭着，一切都完啦，患上严重的忧郁症。多次离家出走，最后一次被人目击是战后在一个车站。之后就不知所终了。 然鹅在2006年的电影《被嫌弃的松子的一生》中，这句话也被说了一次。川尻松子在自杀前，抄写日本小说家太宰治短篇小说《二十一世纪旗手》的开篇语「生まれて、すみません。」(中文意思：生而为人，我很抱歉）作为遗言。 然后我在那篇文章的下面写了自己的评论： 所有批评老师讲解错误的人，你们真的知道这句话的来源吗？有这个撕逼的时间，不如去读读我的文章😄 生活中，美好的事物往往都是短暂的甚至是临时的，不如意的事情十之八九，只有调整好自己的心态才能迎接更美好的明天。情绪是可以感染的，热爱生活是我们不被坏情绪侵没和迷失的太阳。生活中需要正能量，很多事情只要你换个思路来想可能它的发生并不是一件坏事。不要把自己锁在那口暗无天日的井中，奋力前行才有美好的明天。 生而为人，我很欢喜！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>情绪管理 心态 阳光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中用char数组构造string]]></title>
    <url>%2F2020%2F09%2F05%2FC-%E4%B8%AD%E7%94%A8char%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0string%2F</url>
    <content type="text"><![CDATA[在 C++ 中如何使用用 char 数组 构造 string，确实是一个老掉牙的话题，但是稍加不注意你就会出错。 最近在写一个可以跨平台打印的日志程序，遇到了这个问题，故记之，共勉! 用 char 数组初始化 string 示例 12345678910111213#include &lt;string&gt;using std::string;using std::cout;int main(int argc, const char * argv[])&#123; char chArray[] = &#123;'h', 'e', 'l', 'l'&#125;; cout &lt;&lt; "array size = " &lt;&lt; sizeof(chArray)/sizeof(char) &lt;&lt; endl; cout &lt;&lt; chArray &lt;&lt; endl; string str(chArray); cout &lt;&lt; "str = " &lt;&lt; str &lt;&lt; " and str's size = " &lt;&lt; str.length() &lt;&lt; endl;&#125; 针对上面的代码，不同的编译器输出结果不一致，具有一定的随机性。 在 macos 系统下，输出结果 123array size = 4hell\310\367\277_\377str = hell\310\367\277_\377 and str's size = 10 得到这种结果，简直要法克… 但是有时候输出结果又是下面那样的 123array size = 4hellstr = hell and str's size = 5 很明显，string 的 size 不对. 思考一下，原来是少了 ‘\0’，修改上面代码，如下： 12345678910111213#include &lt;string&gt;using std::string;using std::cout;int main(int argc, const char * argv[])&#123; char chArray[] = &#123;'h', 'e', 'l', 'l', '\0'&#125;; cout &lt;&lt; "array size = " &lt;&lt; sizeof(chArray)/sizeof(char) &lt;&lt; endl; cout &lt;&lt; chArray &lt;&lt; endl; string str(chArray); cout &lt;&lt; "str = " &lt;&lt; str &lt;&lt; " and str's size = " &lt;&lt; str.length() &lt;&lt; endl;&#125; 修改之后，代码的结果输出正常了。 123array size = 5hellstr = hell and str's size = 4 也就是说，char 数组初始化 string 对象，数组的结束符 ‘\0’ 不要忘记了。 另外，要注意 string 的 size 要比 char 数组 的 size 小。 不知道上面的东西，你有没有看明白? 那么下面的代码输出，你觉得会达到自己的预期吗? 12345678910const char * cp = str.c_str();unsigned long size = str.length();char chArray2[size];for (int i=0; i&lt;size; i++) &#123; chArray2[i] = cp[i]; cout &lt;&lt; chArray2[i] &lt;&lt; endl;&#125;string str2(chArray2);cout &lt;&lt; "str2 = " &lt;&lt; str2 &lt;&lt; " and str2's size = " &lt;&lt; str2.length() &lt;&lt; endl; 这里很显然是错误的，至少两处是不对的。 1、chArray2 的大小； 2、chArray2 的结束符没有添加 ‘\0’； 修改一下，给出完整示例 123456789101112131415161718192021222324252627#include &lt;string&gt;using std::string;using std::cout;int main(int argc, const char * argv[])&#123; // char[] ---&gt; string char chArray[] = &#123;'h', 'e', 'l', 'l', '\0'&#125;; cout &lt;&lt; "array size = " &lt;&lt; sizeof(chArray)/sizeof(char) &lt;&lt; endl; cout &lt;&lt; chArray &lt;&lt; endl; string str(chArray); cout &lt;&lt; "str = " &lt;&lt; str &lt;&lt; " and str's size = " &lt;&lt; str.length() &lt;&lt; endl; // string --&gt; char[] const char * cp = str.c_str(); unsigned long size = str.length(); char chArray2[size + 1]; for (int i=0; i&lt;size; i++) &#123; chArray2[i] = cp[i]; cout &lt;&lt; chArray2[i] &lt;&lt; endl; &#125; chArray2[size] = '\0'; string str2(chArray2); cout &lt;&lt; "str2 = " &lt;&lt; str2 &lt;&lt; " and str2's size = " &lt;&lt; str2.length() &lt;&lt; endl;&#125; 也许有人会说，为什么要用 char 数组 去构造 string 对象，用 char *(指针)不是更好吗? 的确是这样，但是有时候需要 char 数组来操作，我也是把自己遇到的问题,加以总结跟大家分享一下。 把示例代码中的 1char chArray[] = &#123;'h', 'e', 'l', 'l', '\0'&#125;; 修改为 1char chArray[] = "hell"; 或者 1const char *chArray = "hell"; 代码也可以正常正确的输出。 如果你有兴趣，可以看我之前总结的一篇文章 不见得你会计算C字符串长度, 🙇‍！ 心若相知，无言也默契。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>macOS C++ string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 多 Module 管理工程]]></title>
    <url>%2F2020%2F08%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%A4%9A-Module-%E7%AE%A1%E7%90%86%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介在 微服务-想办法让项目运行起来 这篇文章中，介绍了如何使用 IDEA 开发工具搭建本地的微服务开发环境，通常我们会把一个微服务项目分解成多个服务，那么为了更好的管理该项目，大家一般都会在 IDE 里面通过多 Module 来进行管理。这里的多 Module 可以理解为多个 SpringBoot 项目。 近期收到一些小伙伴的反馈，在使用 IDEA 搭建多 Module 的时候总会遇到一些莫名其妙的问题，甚是让人烦恼。趁此机会给大家介绍一下。 下面的实践，使用的是 IntelliJ IDEA 2020.2 版本，2019.x 版本也是同样的创建方法。 说干就干一些在你看来并不起眼的工作，对于别人来说可能是难以逾越的鸿沟。 不废话，直接实践开干！ 1、打开 IDEA，File/New Project 选择 Spring Initializr，工程类型选择 Maven。 在接下来的步骤中，不需要选择任何依赖。填写完成后，点击 Finish 即可。 删除工程的 src、.mvn、mvnw 、mvnw.cmd 这几个目录。 删除后，工程目录如下 修改 pom.xml 文件，增加如下内容： 1&lt;packaging&gt;pom&lt;/packaging&gt; 在 Maven 项目中，packaging 给出了项目的打包类型，即作为项目的发布形式，其可能的类型。 123456789101112131415&lt;!-- 继承说明：这里继承SpringBoot提供的父工程 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.8.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;!-- 项目说明：这里作为聚合工程的父工程，修改打包为pom聚合工程 --&gt;&lt;groupId&gt;com.veryitman.main&lt;/groupId&gt;&lt;artifactId&gt;blog-main-server&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;name&gt;blog-main-server&lt;/name&gt;&lt;description&gt;Blog of main project for Spring Boot&lt;/description&gt; 在 Maven 3 中，其可用的打包类型如下： jar，默认类型 war ejb ear rar par pom maven-plugin 如下图所示： 2、创建 Module 在工程名称上面右键新建 module，如下图 这里以创建 SpringBoot Module 为例，使用 Spring Initializr 创建 Module 按照你自己的需求填写对应的信息即可进入到下一步直至 Finish. 此时，修改该 module 的 pom 文件，如下（将从工程继承而不是从spring boot继承）所示： 123456&lt;parent&gt; &lt;groupId&gt;com.veryitman.main&lt;/groupId&gt; &lt;artifactId&gt;project-xxx-server&lt;/artifactId&gt; &lt;!-- 工程名称 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 同理，再新建一个 mz-payment-inone 的 Module，最后工程目录如下： 同理， mz-payment-inone 建立好之后也修改一下它的 pom 文件中的 &lt;parent&gt; 标签内容。 所有的 module 建立完成之后，在 工程的 pom 中增加 module 的说明即增加 &lt;module&gt; 标签 ，如下： 12345&lt;!-- 模块说明：这里声明多个子模块 --&gt;&lt;modules&gt; &lt;module&gt;ms-login-inone&lt;/module&gt; &lt;module&gt;mz-payment-inone&lt;/module&gt;&lt;/modules&gt; 至此，工程中多 Module 已经创建完成👏，接下来再给大家介绍一下 Module 之间如何相互调用。 Module 之间的调用按照上面的方法，我再次创建了一个 mz-core 的 Module，该 Module 为 上面两个 SpringBoot Module 提供基础的方法。 在 mz-core 中增加了一个 MZDateUtil 类和对应的方法 在 mz-login-inone 中使用该类的方法。 为 mz-login-inone 添加依赖 ms-core，如图 在 mz-login-inone 的 pom.xml 文件中添加如下代码 编写 API 进行测试，在 mz-login-inone 的 MZLoginInoneController 中增加如下代码 12345678910@RestController@RequestMapping("login")public class MZLoginInoneController &#123; @GetMapping(value = "inone") public String loginInone() &#123; return "Current date: " + MZDateUtil.currentDate(); &#125;&#125; 运行 mz-login-inone，在浏览器访问该接口，显示如下： 如果你在使用过程中还有遇到奇葩的问题，欢迎留言评论，感谢阅读！ 詹姆斯·高斯林 （James Gosling）是一名软件专家，1955年5月19日出生于加拿大，Java 编程语言的共同创始人之一，一般公认他为“Java之父”。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>微服务 多Module SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瘦身秘笈: 饮食运动相得益彰]]></title>
    <url>%2F2020%2F08%2F15%2F%E7%98%A6%E8%BA%AB%E7%A7%98%E7%AC%88-%E9%A5%AE%E9%A3%9F%E8%BF%90%E5%8A%A8%E7%9B%B8%E5%BE%97%E7%9B%8A%E5%BD%B0%2F</url>
    <content type="text"><![CDATA[简介在 瘦身秘笈: 养成好习惯 这篇文章中给大家介绍了一些保护自己健康的好习惯，希望您在看下面内容之前，可以先看看之前的文章。 今天跟大家分享关于饮食和运动结合如何让自己更加健康起来，我不是专业的瘦身专家😅，只能根据自己的亲身经历抛砖引玉，希望每个为家庭付出的IT工作者都能健康。 你可能经常会听到有人说“我喝口凉水都能胖”，也看到很多吃得再多也长不胖的人，轮到自己想瘦一点的时候感觉怎么那么难，经常陷入下面的死循环中。 个人觉得只要自己不是胖的太过离谱（BMI大于30了）即使胖一点也没有关系，身体健康就好。你非要极致的身材，只能进行自我毁灭式的减肥了。 上次去爬山，听到有一哥们喘着气说长肥肉容易，掉肥肉难。感同身受，必须将 饮食+运动 结合好，你才能在与肥肉搏斗中立于不败之地。 我相信只要你能坚持下来，奇迹一定会在你身上发生。 了解概念热量单位 我们经常看到诸如 卡、千卡、焦、千焦、大卡 之类的热量单位，让人傻傻分不清。 一般描述食物的热量单位是卡路里（Calorie）, 1卡路里简称1卡，但是由于用 卡 来表示热量又太小了，所以人们总是用 千卡 （KCal）来表示食物的热量。1千卡热量有多少？就是把1升水升高1摄氏度需要的热量。例如每100g米饭大概是116千卡的热量，我们平时用小碗盛一碗米饭目测有200多克。 那么既然 千卡 已经能很好的表示食物热量了，为何还需要 大卡 呢？ 其实呢 大卡 就是 千卡 😄，只不过有些人对其的叫法不同而已，这就好比有些人把西红柿叫做番柿是一样的道理。 热量的单位还可以用 千焦（KJ）和 焦 （J，也称之为焦耳）作单位，但这个单位一般用作学术上面，没有 千卡 那么接地气。 焦耳（简称焦，符号为J），是国际单位能量和做功的单位。1焦耳能量相等于1牛顿力的作用点在力的方向上移动1米距离所做的功 。 符号J为纪念英国物理学家焦耳而命名。1焦=1牛·米，也等于1瓦的功率在1秒内所做的功，1焦=1瓦·秒。 千焦和千卡换算如下： 11千卡 = 4.184千焦 = 1大卡 = 1000卡 = 4184焦 以后你只需要记住，千卡和大卡都是一样的就可以了，在评估食物的热量上面暂时忘记焦耳这个单位吧，算起来脑壳会bulinbulin的痛。 脂肪和热量 1 克脂肪含有 9 大卡热量，1 斤脂肪为 500 克，那么 1 斤脂肪含有的热量为： 1500×9 ＝ 4500千卡 根据这样来计算，1 千克（KG，即1公斤）脂肪含有 9000 千卡热量。人体内每克纯脂肪的热量是 9 千卡，但人体脂肪内还有一些非脂肪物质，比如约 10% 的水分，所以 1 公斤的脂肪储存着大概 7000～7700 千卡 的热量。 换句话来说，你消耗掉大概 7000～7700 千卡 的热量才能瘦 1 公斤左右。饮食相当于摄入热量，运动可以消耗热量，这个道理很好懂吧？所以，控制饮食和适当的运动才能更好的控制热量的摄入和消耗。 饮食早睡早起很多小伙伴睡得晚早晨起来的也晚，尤其是周末这种现象更加严重。 如果你像上图中那样日复一日，迟早会不健康起来的🙁，也非常容易让你胖起来。正确的循环应该是下面那样： 正常饮食从早睡早起开始。 尽量每天早上8点左右吃完早餐，早餐不要过于油腻。 鸡蛋🥚+红薯（普通）+高钙牛奶； 鸡蛋🥚+高钙牛奶+玉米； 鸡蛋🥚+全麦面包+坚果； 鸡蛋🥚+蒸饺（瘦肉/蔬菜馅儿）； 鸡蛋🥚+红薯（紫薯）+青瓜； 蛋白粉（冲水）+全麦面包+坚果； 西红柿鸡蛋面🥚+柠檬水+蔬菜； 上面是我每周的早餐搭配，没有固定哪天早上吃什么，都是轮着来。你会发现我基本会保证每早都有个水煮鸡蛋，并且没有任何一种油炸的食物。 早上起来后，记得先喝一杯热开水，睡了一夜后身体水分会流失很多，所以需要早上起床后补充一定的水分（300ml~500ml左右即可）。每次早上喝热开水的时候，仿佛能听到细胞在身体里的欢呼声😄，你对身体的任何好，它都能感觉得到，不信的话你可以坚持几天试试。 少吃多餐我之前总喜欢把吃不完的饭菜全部包揽，直接倒进碗里拌饭吃那种，嗝！总觉得扔掉挺可惜的。殊不知，盘子里面剩下的菜下面全部是厚厚的油，伴着米饭吃起来是很爽但是也会让热量乘虚而入。 后面发现自己逐渐壮大的肚子，就开始慢慢戒掉 吃锅底 的习惯了。 午餐可以适当的油腻一点，但是不要太过分哟。可以给减肥的自己加个卤鸡腿，记得扔掉鸡皮（热量有点高），午餐后可以吃点青瓜。 每天中午午餐，尽量多吃蔬菜，蔬菜里面的膳食纤维可以适当的阻止脂肪的成长，帮你阻挡一部分热量肆虐滋长。 晚餐尽量在 18 点之前吃，不要吃太多，同样不要吃的过于油腻。如果晚上尤其是下班比较晚的小伙伴，可以给自己补充一片全麦面包或者一杯高钙脱脂牛奶。 晚餐可以相对清淡一点，如果你不小心吃多了，那你晚上尽量多运动一会，哪怕散步也好。 晚上临睡前2小时内就不要吃东西了，对！不吃 anything。 午餐和晚餐，我现在都是吃个7成饱，如果你是刚开始减肥，建议从9成饱开始逐步递减到半饱。下午如果饿了就给自己补充点水果或者面包，切记在这两餐当中吃的太多，这样不仅会加大热量的摄入，还会让你的胃不堪重负。 至于什么是几成饱，我也没有实际测量过。不过，有个简单的办法，把你平时吃的米饭或者其他主食适当的减少一些分量。 有很多人说不吃晚餐，可以很快的瘦下来，这个我承认。2018年我坚持了一个半月没有吃晚餐，确实瘦了不少，但是每天晚上肚子凄惨的叫声着实让人难受。一个半月后，我实在是坚持不下来了，自己的内心就感觉住着另外一个自己总是说：”算了吧，太辛苦了，放弃吧！“，这种声音会持续到你毫无反抗之力为止。然后我就开始回归到正常的晚餐生活，胃口就像决堤的大坝，体重又如日中天的上来了😳。抛开经常不吃晚餐对身体有无坏处来说，你要是能坚持下来我觉得你不去创业当 CEO 就对不起你这颗坚强的心。 运动上面简单说了一下瘦身期间如何调节自己的饮食，下面我们说说结合运动，让你的瘦身计划如虎添翼。 根据美国的运动协会所做的研讨表明，在人初步运动 10 分钟之后，脂肪组织中的血流量会增加，表明脂肪的进行初步的燃烧，在运动 30 分钟后，脂肪组织内的血流量达到最高，如果间断运动，其脂肪组织血流量最高浓度仍可持续6小时。 如果你能坚持，最好趁热打铁，连续运动 30 分钟，这样可以烧脂肪长达 6 小时。但是运动时长也并不需要太长，研究表明，运动时长即使超过 30 分钟，脂肪也只能燃烧 6 小时。 另外运动最好是每天都能坚持做，不要三天打鱼两天晒网。 我推荐给大家两种运动，成本比较低的那种。即步行、跑步。 步行我之前一直怀疑步行到底能否让人瘦身，后面坚持了三个月，发现步行只要坚持下来对瘦身是大有脾益的。 下面是我对步行的心路历程。 每天坚持最少 30 分钟的步行，利用午餐或者晚餐后散步，下班回家走一段等时间段来步行。每走1公里，大概消耗掉50千卡的热量。 我着重说一下调整部分。 刚开始，走路没有注意自己的走姿，后面通过朋友和书籍的指导，我做出了几个改变。 1、尽量大步走，但是注意量力而行； 2、后脚跟先着地，不要让脚掌先着地； 3、收腹，正常呼吸不要憋气； 4、尽量摆动自己的双臂，主要不要打着路人； 5、腰直起来，提臀，目视前方； 6、每次至少要走 30 分钟或者以上才有效，这个时候脂肪才会慢慢开始燃烧； 对了，抬头看红绿灯🚦，不要只忙着走路，安全第一！ 跑步如果你现在比较胖，还是建议不要跑步，对膝盖的伤害有点大。 我这里说的瘦身跑步指的是慢跑，比如你步行一公里需要12分钟，那么跑步一公里用7~8分钟就可以了。 慢跑更有助于瘦身减脂，快跑可以让你增肌。 我现在一周一般跑2~3次步，每次2公里左右，等体重再下来一点后再增大跑步的强度。每慢跑1公里的步，大概消耗掉80千卡的热量。 可以找个公园跑步，空气和氛围会好点更能让你坚持下来，如果有条件可以带上入耳式的蓝牙耳机，听着音乐放飞自我。 运动时体内水丢失加快，如果不及时补充会引起水不足。在运动强度较大时，要注意运动中水和矿物质的同时补充，运动后，应根据需要及时补充足量的饮水。 登山也是一项很不错的运动，根据自己的情况可以每个月可以进行一次登山运动，走进大自然呼吸新鲜空气，还能锻炼自己的意志。 切记每次运动前后，一定要进行适量的拉伸运动，防止肌肉过后酸痛影响接下来的运动。 减肥不仅仅是控制卡路里，更重要的是从根本上解决肥胖问题，改变易胖体质，别让脂肪缠上你。减肥的真理就是管住嘴迈开腿，通过减少摄入、增加能耗两方面实现，也就是说开源节流才能实现足够多的热量亏空。 肥肉不是一天突然长起来的，切记不要妄想一天就把肥肉给减下去，循序渐进的减肥才是王道，找到适合自己的减肥方法才能事半功倍！ 真正自律的人，是不会把自律挂嘴边的~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>运动 饮食 健康</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: ConfigurationProperties配置]]></title>
    <url>%2F2020%2F08%2F02%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-ConfigurationProperties%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介我们在开发的时候，可能会遇到这样的场景： 变量希望能够被在配置文件中动态配置，只要修改这些配置，对应的 Java 类对象的变量值就可以改变，从而改变代码的行为。这样我们通过修改配置就可以满足业务诉求，而不需要修改一行代码。 在 SpringBoot 中，可以通过 @ConfigurationProperties 和 @Values 两个注解配合 properties 文件达到上述目的。 比如我的 application.properties 文件配置如下： 123456789101112131415161718# ------------------------# Swagger config# ------------------------msconfig.swagger.enableSwagger=true# ------------------------# Security config# ------------------------msconfig.security.enableCSRF=falsemsconfig.security.defToken=&quot;token-xx-yy-kk-token-end&quot;msconfig.security.testList[0]=&quot;list0&quot;msconfig.security.testList[1]=&quot;list1&quot;msconfig.security.testList[2]=&quot;list2&quot;msconfig.security.testMap.KeyTest=&quot;map-key&quot;msconfig.security.testMap.ValueTest=&quot;map-value&quot; 接下来，通过 @ConfigurationProperties 和 @Values 来分别读取对应的配置。 本文涉及的代码都已经更新到 Github 工程 中了，大家可以下载查看。 关于微服务的相关文章目录，可以☞ 点我) 查看更多内容。 ConfigurationProperties对应的，新建两个实体类，如下图所示： 实体类 MSSecurityPropertyConfigModel 的代码如下： 1234567891011121314151617181920212223import lombok.Getter;import lombok.Setter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;@Component@Setter@Getter@ConfigurationProperties(prefix = "msconfig.security")public class MSSecurityPropertyConfigModel &#123; private boolean enableCSRF; private String defToken; // List的配置 private List testList; // Map的配置 private Map testMap;&#125; 这里需要注意以下几个问题： 1、必须提供 setter 方法，这里我使用了 lombok； 2、必须使用 @Component 注解，标注在实体类上面； 3、在 @ConfigurationProperties 的 prefix 中必须和配置文件命名保持一致； 4、需要在类上加上 @Component 注解； 关于 MSSwaggerPropertyConfigModel 大家可以自行查看代码，这里不再赘述。 写个测试类，验证一下配置。 1234567891011121314151617181920212223242526272829303132@RunWith(SpringRunner.class)@SpringBootTestpublic class MSPropertyConfigTests &#123; @Autowired MSSwaggerPropertyConfigModel swaggerPropertyConfigModel; @Autowired MSSecurityPropertyConfigModel securityPropertyConfigModel; private Logger logger = LoggerFactory.getLogger(MSPropertyConfigTests.class); @Test public void primitiveDataConfig() &#123; boolean enableSwagger = swaggerPropertyConfigModel.isEnableSwagger(); boolean enableCSRF = securityPropertyConfigModel.isEnableCSRF(); logger.info("primitiveDataConfig-enableSwagger: " + enableSwagger + ", enableCSRF: " + enableCSRF); String defToken = securityPropertyConfigModel.getDefToken(); logger.info("securityPropertyConfigModel deftoken: " + defToken); List list = securityPropertyConfigModel.getTestList(); for (Object v : list) &#123; logger.info("securityPropertyConfigModel value: " + v); &#125; Map map = securityPropertyConfigModel.getTestMap(); logger.info("securityPropertyConfigModel map: " + map); &#125;&#125; 执行该测试方法，得到如下的输出内容： 123456primitiveDataConfig-enableSwagger: true, enableCSRF: falsesecurityPropertyConfigModel deftoken: "token-xx-yy-kk-token-end"securityPropertyConfigModel value: "list0"securityPropertyConfigModel value: "list1"securityPropertyConfigModel value: "list2"securityPropertyConfigModel map: &#123;KeyTest="map-key", ValueTest="map-value"&#125; 如果您在使用 @ConfigurationProperties 注解过程中，提示如下错误： 1“Spring Boot Configuration Annotation Processor not found in classpath ” 此时需要在你的 pom.xml 文件中引进 configuration-processor 依赖即可解决。 123456&lt;!--ConfigurationProperties--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; Value使用 @Values 注解可以直接作用到某个类的某个字段上面，使用上面比较方便。 对于读取集合的方法跟 @ConfigurationProperties 注解有点不同。 在 application.properties 文件中增加 testList1 和 testMap1 配置如下: 123456789# ------------------------# Security config# ------------------------msconfig.security.enableCSRF=falsemsconfig.security.defToken=&quot;token-xx-yy-kk-token-end&quot;msconfig.security.testList1=list0,list1,list2msconfig.security.testMap1=&#123;name:&quot;map-key&quot;, age:20&#125; 注意：在配置文件中的 testList1 和 testMap1 配置格式和之前的不一样，否则解析会报错。 测试类中验证，示例代码如下，注意 @Values 注解对集合的书写格式。 1234567891011121314151617181920212223@Value("$&#123;msconfig.security.enableCSRF&#125;")private boolean geEnableCSRF;@Value("$&#123;msconfig.security.defToken&#125;")private String defUserToken;@Value("#&#123;'$&#123;msconfig.security.testList1&#125;'.split(',')&#125;")private List list1;@Value("#&#123;$&#123;msconfig.security.testMap1&#125;&#125;")private Map map1;@Testpublic void primitiveDataConfig() &#123; logger.info("annotation value. geEnableCSRF: " + geEnableCSRF); logger.info("annotation value. defUserToken: " + defUserToken); for (Object v : list1) &#123; logger.info("annotation value. list: " + v); &#125; logger.info("annotation value. map: " + map1);&#125; 读取结果如下： 123456annotation value. geEnableCSRF: falseannotation value. defUserToken: "token-xx-yy-kk-token-end"annotation value. list: list0annotation value. list: list1annotation value. list: list2annotation value. map: &#123;name=map-key, age=20&#125; 我们也可以将 @ConfigurationProperties 和 @Values 这两个注解配合使用。 1msconfig.security.alias=&quot;play-game&quot; 在代码中重新定义变量名称为 aliasPlayGame，可以使用 @Values 定位实际配置的变量名称。 1234567891011121314151617@Component@Setter@Getter@ConfigurationProperties(prefix = "msconfig.security")public class MSSecurityPropertyConfigModel &#123; private boolean enableCSRF; private String defToken; private List testList; private Map testMap; // 和 ConfigurationProperties 一起使用 @Value("msconfig.security.alias") private String aliasPlayGame;&#125; 你以为的不一定是你以为的]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>微服务 ConfigurationProperties SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok让服务近在咫尺]]></title>
    <url>%2F2020%2F07%2F16%2Fngrok%E8%AE%A9%E6%9C%8D%E5%8A%A1%E8%BF%91%E5%9C%A8%E5%92%AB%E5%B0%BA%2F</url>
    <content type="text"><![CDATA[简介最近在和一个第三方服务做联调，即我方服务调用第三方的服务 API-A，然后第三方把结果回调给我方服务 API-B，因为我是在本地搭建的 SpringBoot 服务，又涉及到频繁的改动，所以就没有部署到远程服务器上面。 API-A 回调到 API-B 需要我方服务能被外网访问，如是我就使用了 ngrok 这个工具进行了内网穿透，让第三方服务很容易的就访问到我的本地服务。 所谓的内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。 下面具体讲一讲该工具的安装、配置和使用。 配置Step1：下载工具 点击 这里 可以进入下载页面根据自己所在的平台选择下载 ngrok。 目前 ngrok 支持 Mac OS X、Linux Mac (32-bit) 、Windows (32-bit)、Windows (64-bit)、 Linux (ARM)、 Linux (ARM64) 、Linux (32-bit) 、FreeBSD (64-Bit) 、FreeBSD (32-bit) 等操作系统。 我使用的是 Windows 系统，下面我以此系统安装配置做一个说明。 下载完成后，解压到你的磁盘任意目录，如我的放到了下面目录中： Step2：配置 ngrok 配置 ngrok 需要在其官网注册一个账号，点击 Sign UP 完成注册即可。 注册完成之后进入 控制台，获取你的 Your Authtoken，复制一下即可后面有用。 打开 Windows 自带的命令行工具（CMD，曹孟德），执行下面 1./ngrok.exe authtoken 'your-authtoken' 完成后，会在 C:\Users\your-name\.ngrok2\ngrok.yml 文件中注册成功。 Step3：启动 ngrok 我的服务端口号是 8080， 执行下面命令： 1./ngrok.exe http 8080 可以在命令行看到如下输出： 1234567Session Status onlineAccount name (Plan: Free)Version 2.3.35Region United States (us)Web Interface http://127.0.0.1:4040Forwarding http://1a9d2e7e1e2d.ngrok.io -&gt; http://localhost:8080Forwarding https://1a9d2e7e1e2d.ngrok.io -&gt; http://localhost:8080 接下来，我们访问 SpringBoot 的服务 API，如下： 1http://1a9d2e7e1e2d.ngrok.io/pay/callback 或者访问 HTTPS 也可以的。 1https://1a9d2e7e1e2d.ngrok.io/pay/callback 在外网访问这个接口也是没有问题的。 场景内网穿透工具 ngrok 还有其他使用场景。 外网连接自己的内网服务器，在外网演示内网 WEB 站点； 无需部署开发的服务到外网服务器，快速调试本地程序，比如微信公众号的开发等； ngrok 支持 HTTP、HTTPS 协议站点，HTTP 协议站点直接升级为 HTTPS 站点； ngrok 支持 TCP，UDP 协议端口转发。 ngrok 支持数据库、SSH、远程桌面、网络摄像头等等开放到外网可以访问； 还有其他的内网穿透工具，大家可以自行搜索。 你以为的不一定是你以为的]]></content>
      <categories>
        <category>Server</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>ngrok 内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务-Android客户端: 实现注册和登录]]></title>
    <url>%2F2020%2F06%2F20%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Android%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[简介在 微服务项目系列文章 中跟大家一起学习了如何搭建、部署（本机和远程部署、热部署、Nginx等）、运行一个 SpringBoot 服务以及 MySQL 数据库的操作、文档（Swagger）的生成等操作，客户端采用浏览器的方式实现了用户注册、登录的流程。根据 微服务-立志做个伟大的项目 立下的【誓言】可以循序渐进的实现我们伟大的理想了，今天我们正式进入 Android 客户端的学习，希望对微服务、Android 开发感兴趣的同学有点帮助。 如果你对 Android 不了解，建议先学习 Google 官网关于 Android 开发的入门知识，最起码你能用 Android Studio 跑起一个工程。如果你对 Java 也不了解或者压根都没有学习过 Java，那么你可能要加油了争取用一周的时间搞懂 Java 语法了，然后在 Android 学习的过程中再去深入 Java 语言的学习。当然了你会 Kotlin 编程语言也可以。这里想告诉大家，任何一门编程语言想精通需要比较长的时间，但是初级入门能写简单的代码只要用心不应该超过一周。你只需要克服内心的恐惧笃定自己一定行，那么很快你就入门了。 阅读下面的内容需要你： 看过 微服务项目系列文章 中的文章，不要求都看过至少关于如何使用 SpringBoot 的部分看过； 会 Java 编程或者 Kotlin 编程，入门的知识即可； 了解 Android 开发，知道如何使用 Android Studio 这个 IDE； 本篇主要内容： 搭建 Android 工程的基本框架； 实现 Android 端的用户注册和登录功能； 工程源码在 Github 上面，大家可以去下载一起学习，工程相关目标如下： 项目目前只实现了注册、登录的功能，后续会丰富其内容。 搭建 Android 工程该工程名称为 MSBlog，我的本机环境安装了： JDK 1.8； Android Studio 4.0； Android SDK ； 首先，打开 Android Studio，选择 File/New/New Project...，打开下面视图 紧接着，点击 Next，填写相关的项目名称和包名等信息即可。 工程大致结构如下： 在 com.veryitman.msblog.http、com.veryitman.msblog.model 这两个包中是网络请求、数据模型等的 Java 实现，MZOkHTTPWrapper 是对 okhttp 的封装。 该工程中，使用了两个第三方库分别是 gson（json解析等）、okhttp（HTTP请求），详细配置在 app/build.gradle 文件中。 12implementation("com.squareup.okhttp3:okhttp:4.7.2")implementation 'com.google.code.gson:gson:2.8.6' 实现 Android 注册用户注册效果图 启动 SpringBoot 服务，注意在 MZHttpUrlModel 中修改一下连接该服务的 IP 地址（用你自己本机的IP）。 点击 Signup，根据用户输入的信息请求服务端的API去注册，点击 Had Account 去登录页面，点击 Guest 直接进入应用。 具体的代码是在 MZSigninActivity 中实现的，有兴趣的朋友可以看看源码，这里不再赘述。 在进行网络请求之前，注意需要在 AndroidManifest.xml 文件中添加访问网络的权限。 1&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; 实现 Android 登录用户登录效果图 具体的代码是在 MZSignupActivity 中实现的，有兴趣的朋友可以看看源码，这里不再赘述。 点击 Signup，根据用户输入的信息请求服务端的API去登录。 进入主界面后，就可以看到四个Tab页面，分别是主页、分类、好友、个人中心。 目前这几个页面尚未实现，后续会陆续完成。 总结新建一个 Android 工程还算是蛮简单的一个过程，希望大家能把工程跑起来，如果有任何问题可以留言给我。 今天的分享就这么多，简单的做个小结： 从搭建完成 SpringBoot 再到使用 Android 实现一个简单的客户端，需要初学者付出较多的努力，最关键的是我们一起迈出了第一步； 在代码中尽量不要使用魔术数字，把通用的常量放到对应的类中进行管理，减少后续的维护成本； 尽量多的输出 Log，并且使用 Tag 对 Log 进行分类，方便后续排查问题，提高解决问题的效率； 不要抱怨自己没有天赋，如果你能坚持做好一件事情，本身就是天赋。]]></content>
      <categories>
        <category>Server</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SpringBoot Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈亲子教育]]></title>
    <url>%2F2020%2F06%2F06%2F%E7%AE%80%E8%B0%88%E4%BA%B2%E5%AD%90%E6%95%99%E8%82%B2%2F</url>
    <content type="text"><![CDATA[简介网上流传着这样一句话：“没有一个教孩子学习的家长不是心梗的”。 当然了，这句玩笑话显然是夸张了一些，但它足以表明家长和孩子之间在学习这个话题上存在着不可调和的矛盾。 今天想跟大家分享一下在学习这件事情上，怎么做到更好的与自己的孩子相处才能不伤害彼此。 看到本篇文章的时候，或许你还是未婚者，或者是准父母者，抑或是已为人父母了，但我建议你看下去，说不定有些收获呢。 不可逆的伤害今年是个特别年，冠状病毒让全国家长增加了陪伴孩子的时间。别人都说：”陪伴是最好的教育“，而我却发现自己在陪伴的日子里并没有那么理性，动辄为了教孩子写作业变得勃然大怒，俨然就是一头失去理性的野兽，后想起来挺好笑的。 我小的时候经常挨父亲的揍，经常因为没有做好一些小事情，就会被突如其来的鞭子收拾的服服帖帖。直到自己上了初中，挨揍的迹象才逐渐消失，取而代之的是我对父亲的冷漠和敷衍以及对家的失望。你对孩子无缘无故的大骂，换来的并不是望子成龙而是不可逆的伤害，会让孩子对你失去信任，它会让你们彼此的交流变得屈指可数，到那个时候就后悔莫及了。 孩子来到这个世界上，不会的东西实在太多了，我们活了这麽多年不还仍旧在学习嘛？上学只是孩子在未来的道路上的一个阶段而已，而我们应该尽自己最大的努力让他在这个道路上走得更稳更安全才是正确的做法。只凭拳脚或者大吼大叫是无法让孩子信服的，三字经说”子不教父之过“，但是”教“得太”过“了就不好了。推荐大家读读 看《银河补习班》有感 这篇文章，鼓励和相信自己的孩子，才是给他前进的道路上最大的动力。每个孩子都是聪明的，他们会用自己的心灵感受你对他的点点滴滴。 知识的诅咒 大家应该考过驾照被教练带着练过车吧，我相信有很多学员都被教练骂哭过甚至还不止一次。若不是自己交了钱付出了那么多，应该早就拔方向盘走人了吧。我也听过身边很多同事抱怨过对教练的各种不满，年轻气盛点的学员也有当面怼教练的。 我自己亲身经历的一件事情，说起来也挺逗。那天去考科目三（路考），凌晨天不亮就出发到考试地了，如果当天科目三能考试通过就可以接着考科目四了，拿驾照就指日可待。在练车的过程中，教练对着我们几个学员分别痛斥了一顿，这个都说了几百遍了那个已经讲了上千遍了怎么还是不注意，我看你们考试挂了也是活该。这种感觉就像你清晨刚一起床就被人用冰水浇灌了一番。我确实是没有忍住就怼了教练一番，我用相对文明的成语胡乱说了他一通，还好大家都没有动起手来😄，那天考试还算顺利大家都考试通过了。 在回来的路上，我问一个学员你现在最想做的一件事是什么？他说删了教练的微信老死不相往来，我举起了左手，他举起了右手，我们不约而同的击了一掌，那响声响彻云霄，感觉那是练车以来最爽的一次就好比报了一个大仇一样。 教练开车多年俨然是一个老司机，而作为从来没有接触过汽车的学员，练车和考试对于他们来说除了不熟悉更可怕的是内心的那份对车的恐惧。再加上教练的咆哮就会更加乱了方寸。这就是知识的诅咒。 那什么是知识的诅咒呢？英文称之为The Curse of Knowledge`，我们一旦知道了某事，就无法想象这件事在未知者眼中的样子。当我们把自己知道的知识解释给别人的时候，因为信息的不对等，我们很难把自己知道的完完全全给对方解释清楚。总是，我们的知识“诅咒”了我们。 简单的用一句话来说，知识的诅咒 就是你自己知道的东西很难通过简单的交流或者教育让对方全部get到。 生活中有很多这样的例子，对于孩子的学习，同样存在知识的诅咒。我们总是认为这些作业太简单，应该讲一两遍孩子都会了，他们为何总是反复的在错呢？为了防止知识的诅咒对我们的影响，我们更应该多一些耐心，或者换个思路想一想是不是自己的教育和表达方式有问题？换个思路和做法，孩子是不是就能学的更轻松呢？ 瓦拉赫效应在了解了 知识的诅咒 这个知识点后，我们再来聊聊什么是 瓦拉赫效应。 在说 瓦拉赫效应 之前，我们还是先看看身边的真实事件。 我有个同学，初中成绩很一般，父母花钱求领导让他上了一个县高中。在高中的文理科分班之前，他整体成绩也很一般，没有人会相信他最后居然可以考上985的大学。后来同学聚会，他跟我们讲其实自己很喜欢理科尤其是数学和物理，对文科没有任何兴趣考试也是瞎蒙的。他非常感谢文理分科让自己有了更好的选择，否则自己的一生可能是另外一番景象。 学生的智能发展都是不均衡的，都有智能的强点和弱点，他们一旦找到自己最佳点，使潜力得到充分的发挥，便可取得惊人的成绩。这一现象人们称之为“瓦拉赫效应”。 奥托·瓦拉赫是诺贝尔化学奖获得者，他的成才过程极富传奇色彩。瓦拉赫在开始读中学时，父母为他选择的是一条文学之路，不料一个学期下来，教师为他写下了这样的评语：“瓦拉赫很用功，但过分拘泥。这样的人即使有着完美的品德，也决不可能在文字上发挥出来。”此后，他改学油画。可瓦拉赫既不善于构图，又不会调色，对艺术的理解力也不强，成绩在班上是倒数第一，学校的评语更是难以令人接受：“你是绘画艺术方面的不可造就之才。”面对如此“笨拙”的学生，绝大多数老师认为他已成才无望，只有化学老师认为他做事一丝不苟，具备做好化学实验应有的品格，建议他试学化学，父母接受了化学老师的建议。这下，瓦拉赫智慧的火花一下被点着了，文学艺术的“不可造之才”一下子变成公认的化学方面的“前程远大 的高才生”。 如果你还在强迫自己的孩子去上所谓的兴趣班的父母，是时候考虑一下继续这样下去会不会对孩子造成更大的伤害？ 在这个年代，每个人都有很大的压力包括孩子自己，即使你在班级里考了80分也可能是倒数第一，培养孩子的兴趣是很重要但前提是你让他把最基本的学习搞好。强迫他去上兴趣班是没有任何意义的。 自己乱七八糟的说了许多，总结一下吧！ 孩子在学习方面不懂的有很多，家长要更加有耐心的教导他们，别被知识诅咒了； 每个孩子的智能发展是不均衡的，当他们遇到问题后，试着换个方式去引导和教育他们，帮助他们找到那个平衡点； 拳打脚踢、声嘶力竭只能让家长和孩子之间的关系变得更加矛盾，造成的伤害不可逆； 不要私自给孩子下决定，尽量彼此进行商量，适当的时候可以进行适度的“骗”； 对孩子的歇斯底里，换来的只不过是两败俱伤。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>亲子 教育 知识的诅咒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 配置Nginx反向代理]]></title>
    <url>%2F2020%2F05%2F23%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E9%85%8D%E7%BD%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介本来是一件很小的事情，但我觉得还是很有必要跟大家分享一下，勿以善小而不为。 事情是这样的… 有个小伙伴告诉我说自己想学习一下 SpringBoot 结合 Nginx，毕竟用了 Tomcat 那么久（启动 SpringBoot 项目会自动启动 Tomcat）也是时候玩玩 Nginx 了。这个想法很赞，去探索和了解自己没有学过的东西本来就是一种进步。 他说按照网上教程配置了一下 Nginx，但是通过配置的方式访问 Nginx 死活都不能访问到 SpringBoot Web 项目提供的接口中去。 今天我们一起来看看这个问题，我也把实践的内容分享给大家，希望能帮助到有需要的人。 关于微服务相关的文章，有兴趣的可以参阅 微服务项目系列 这篇文章。 大写的 404经过一番的沟通，他给我大致描述了一下经过，我就开始了复现之路。 这个小伙伴是想通过 Nginx 的反向代理能力访问所有 SpringBoot Web 项目的接口，关于什么是反向代理、正向代理，可以参考我之前名为 反向代理 的一篇文章。 我所用依旧是 SpringBoot 项目源代码 中的代码，代码托管在 Github 上面了，有需要的朋友可以 clone 下来。 报错如下图所示： 我在本机（Windows 10系统）安装的 Nginx 版本是 1.15.12，上图可以看出访问对应的 url 出现了 404 错误，关于 404 这个错误码，百度百科是这样解释的： 404，是一种HTTP状态码，指网页或文件未找到。 HTTP 404或Not Found错误信息是HTTP的其中一种“标准回应信息”（HTTP状态码），此信息代表客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应且不知原因。 直白来讲，就是找不到资源。首先我们来看一下我是如何配置 Nginx 反向代理的。 配置文件 nginx.conf （在Nginx安装目录conf目录下），内容如下： 12345678910111213141516171819202122232425262728293031323334worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 自定义虚拟主机1 server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; &#125; # 自定义虚拟主机2：配置转发给ms-user服务（springboot） server &#123; listen 80; server_name user.com; location / &#123; proxy_pass http://localhost:8080; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; &#125; &#125;&#125; 从配置可以看到，配置了两个虚拟主机，问题就出现在这里。 让 404 消失我们再来看一下刚才报 404 的访问地址 http://localhost/signin/name?username=fooboy&amp;userpwd=123，其中 http://localhost 本质是 http://localhost:80，再结合看一下 Nginx 的配置文件，其实是访问到了 自定义虚拟主机1 上面了。 有两个比较简单的解决方案，下面的两种方案无需修改 SpringBoot 项目的任何配置，你只需要启动你的 SpringBoot 项目即可。 方案一：配置主机 host 修改系统主机 C:\Windows\System32\drivers\etc 目录下面的 HOSTS 文件，记得要用管理员身份打开才有权限去写。 在 HOSTS 文件中，增加如下配置： 1127.0.0.1 user.com 在浏览器访问 http://user.com/signin/name?username=fooboy&amp;userpwd=123 就可以成功了（注意访问的域名是 user.com），如下图所示（该API需要输入登录账号和密码）： 方案二：修改虚拟主机的端口 这个需要修改 Nginx 的配置文件，将 自定义虚拟主机2 中的端口改为非 80 端口号，修改如下： 1234567891011# 自定义虚拟主机2：配置转发给ms-user服务（springboot）server &#123; listen 8085; server_name user.com; location / &#123; proxy_pass http://localhost:8080; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; &#125;&#125; 修改完成后，保存文件。 需要重新加载 Nginx 的配置，可以在终端输入如下命令： 1nginx.exe -s reload 重新加载成功后，在浏览器访问 http://localhost:8085/signin/name?username=fooboy&amp;userpwd=123 就可以成功了（注意访问的端口改为了 8085），如下图所示： 至此问题解决。 只要你愿意，一切都来得及~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot Nginx 反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瘦身秘笈: 养成好习惯]]></title>
    <url>%2F2020%2F05%2F10%2F%E7%98%A6%E8%BA%AB%E7%A7%98%E7%AC%88-%E5%85%BB%E6%88%90%E5%A5%BD%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[习惯的力量得此秘笈者终生受益，练此秘笈无须自宫。 过年因疫情肆虐，大家基本都是待在家中。老婆跟我说，你能不能写点非技术的东西呀，技术文章我们都看不懂，你可以写点程序员平常是怎么生活的文章呀？面对她恨铁不成钢的“愤怒”，我也hinhin的反思了一把，除了代码之外，确实有很多东西值得说值得写。毕竟人不能总是陷入能力的陷阱中，要不断的打破知识的诅咒，不断的去探索和表达自己。 于是，今天分享的话题与技术基本没有关系，我们聊聊关于健康管理的话题。 不知道大家有没有这样一种感觉，每当别人给你分享关于他自己一些经验的时候，尤其这些经验我们还没有体验过，就觉得对方说的东西距离自己很遥远，哪怕对方是苦口婆心的谆谆教导，自己可能也只是心不在焉的听听而已。 今天要分享的是关于如何调整自己的生活习惯的话题，为了能让大家“欣然接受”（奢求🙁），我用实际行动确实让自己有所改变，才敢发文。希望对大家有益。 对于 程序员保养秘笈 这个话题，我准备分为几篇文章跟大家分享，本篇算是一个导读。无论你现在是处于程序开发的初级阶段（小白🤝），还是高级（脱发😜）阶段，都希望你能坚持看完。减肥的前提是你能养成好习惯并且坚持下来，千万不要轻易相信网上所谓的减肥机构以及一些虚假宣传。 我始终认为只要自己的身体各项指标正常（比如没有脂肪肝，没有高血压等），生活习惯良好，即使胖一点也无所谓。一旦你能养成良好的习惯，想不瘦都难并且可以受益终生。 下面正式进入吹🐂🍺的时间。 BMI 靠谱不？在2019年10月份，我体重达到了 86.5kg，我的身高175cm，这个体重对我来说已经超标了。当时的BMI（身体质量指数，简称体质指数）指数值为 28.2，下图是BMI相关的标准。 从上面的图中就可以看出，我已经属于过度肥胖了。 自从我改变了的生活方式后，现在的BMI指数值为23.4，虽然达标了但还有很大的缩减空间，还需要继续努力。 这里我要普及一下关于BMI的相关知识，请各位搬好小板凳认真听。 BMI就是所谓的“体质指数”，计算公式如下：$$BMI = 体重kg / （身高m）^2$$即体重除以身高的平方得到的值就是 BMI 值。看到这个公式，调皮的小伙伴可能会说你是不是长高了所以BMI值才变低的🤭，我都几十岁的人了，长高已经是可望不可及了。 下面是引用自作者 仰望尾迹云 的 《我的最后一本减肥书》里面的内容。 从公式上看，BMI就相当于把人均匀地剁成几段，称一称单位身高里人的体重。所以，体重越重，身高越低，BMI也就越高。BMI反映了人“横向发展”的程度，越胖的 人，BMI自然越高。BMI自20世纪五六十年代就开始用。但BMI多少算肥胖，多少算正常，不同国家和组织，规定都不一样。西方的标准一般略低。我国的标准，BMI值18.5～24算体重正常，24～28算超重，但还不算肥胖，超过28算肥胖。 但BMI也不是绝对标准。对大多数普通人来说，BMI有相对较好的指导意义，但BMI也有两个重要缺陷。 首先，BMI不区分脂肪和肌肉，有些人超重，是脂肪太多；但也有些人超重，是肌肉比例大，比如力量型运动员。他们体重大是因为肌肉发达，所以不能叫“胖”。用BMI衡量这些人的健康或者胖瘦，他们就很冤枉。有数据称，美国2004—2005赛季的1124名橄榄球运动员中，BMI超过30的有43%，超过35的有14%。看起来很可怕，但其实这些运动员身体健康得不得了，一个个也都不胖。 其次，BMI不区分脂肪的分布位置，这也是个大问题。从健康的角度讲，内脏脂肪和皮下脂肪，前者要比后者危险得多，但BMI可分不出脂肪长在哪儿。两个身高体重一样的人，一个胖得很均匀，一个脂肪都集中在内脏处，从健康和审美的角度讲，这两个人完全不同，但BMI却是一样的。所以，BMI高，不一定就是胖，也不一定就不健康；BMI低，不一定就不胖，也不一定绝对健康。BMI太粗略，所以有些问题还要具体来看。那为什么BMI在全世界被广泛使用了半个世纪？实际上这也是没办法的办法。准确地测量人的脂肪含量，并且明确脂肪的分布位置，难度很大，只有在实验室或者医院才能测出来。绝大多数人，不可能有条件经常去做体成分测试。 BMI最大的好处就是简单，知道身高体重就能算出来。虽然有误判，但相对来说，效用价格比还是很高的，适合大范围人群使用。不用BMI的话，也确实没有更好的办法来衡量人的身高体重和健康的关系了。 总之，如果你没有经常运动或者去健身（低头看看自己肚子上面的肉吧）用BMI来看自己是否偏胖，算是比较靠谱的衡量标准了。如果你偏瘦的话，就需要稍微补充一下营养了，毕竟太瘦了对身体也不好还影响加班的效率！ 算是好习惯吧说实话，我也不知道怎么来定义什么是好习惯，凡是让你受益的习惯我觉得都算是好习惯。我把自己受益的那些习惯分享给正在看此文的你。 下面这些习惯暂时不展开说，后续的文章会详细的介绍。 1、早睡早起 对于绝大部分生活在大城市的年轻人，尤其这些年轻人是程序员的话，早睡简直是让人望尘莫及了，996甚至997的日子习以为常，每晚回到家基本都是22点后了，洗个澡刷个d音聊个w信再给自己远方的女朋友打个电话，估计都凌晨了，猛一点的可能要到凌晨2、3点才开始睡觉，早起就变得更难了。 晚睡的坏处自然不用我多说，大家心里都跟明镜似的。我个人觉得在大城市奋斗的年轻人，能在24点前一点点睡觉，放下手机也算是‘立地成佛’了。不过慢慢养成习惯吧，坚持一段时间后再把早睡时间往前调整一点，循序渐进的去调整自己。早上尽量在8前起床，有条件的朋友可以自制早餐，一杯热牛奶，一个新鲜鸡蛋，一个苹果或者香蕉就搞定了。 2、规律饮食 早餐尽量在9点前搞定，根据自己的喜好，早上可以多吃一点，尤其是疫情期间蛋白质的补充千万不能少。 午餐以蔬菜为主，加点玉米或者红薯之类的粗粮，也可以适当的吃点肉但千万不要太油腻，像猪肘子呀别人吃一个，你最好吃一半甚至更少一点。有人说了万一要是没忍住吃多了呢，那怎么办？酒肉穿肠过，佛祖心中留😄。嗯，偶尔几下也没有关系了，你只要在接下来的一两天内通过运动把他消耗掉就可以了。 晚餐最好在19点前就吃完，主食适当的少一点，主食还是以大米为主吧，同等质量的面食要比大米的热量高，多吃点菜。如果晚上你能忍住不吃肉那就更好了，晚餐尽量保证低盐低油饮食，遇到晚上加班或者开会肚子饿了可以适当补充一点高纤维面包和牛奶，睡觉前2个小时内就不要吃东西了。 总之，一日三餐按时吃饭，蔬菜为主，主食为辅，8分饱就可以了，适当的给胃和肠道留点运动的空间，只有它们舒服了你才能高枕无忧。 PS：我之前使用过不吃晚餐的方法来减肥，苦苦的坚持了40多天，结果一个朋友的晚宴让我彻底突破了自己的防线，我承认那一晚我撑到了。最后可想而知，体重还是反弹回来了并且比之前更能吃了。所以，不吃饭减肥对于绝大多数的人来说是行不通的，只有吃饱了才能有力气减肥嘛！ 3、经常喝水 这里的水指的不是可乐，雪碧之类的饮料，而是白开水（适当的加点料也可以，比如柠檬片，枸杞，茶叶）。 经常喝水有助于身体的新陈代谢，特别是像瘦下来的朋友们，多喝水可以促进脂肪的燃烧。还有如果你有肾结石之类的疾病更应该多喝水，水喝的量够了上厕所也会频繁，还可以促进运动，一举两得。 喝水可以保持每15分钟喝2~3口的样子，不要豪饮，慢慢养成习惯就好了，最好不要等着自己渴了再来喝水，让喝水变成肌肉记忆。早起一杯温开水可以清肠道，用餐前一杯水有利于增强饱腹感减少用餐量，间接地可以减少热量的摄入。 4、适当运动 你是否经常坐在位置上点外卖吃？如果是我建议你改变一下自己这个习惯，可以选择去楼下跟同事一起用餐，既可以增加运动又可以促进与同事之间的交流，饭前饭后走一走，有助于消化和吸收，减少脂肪的堆积。 一提到运动，大家心里面想到的一般都是那种大汗淋漓的场面才算是运动。其实运动有很多种，如果你不能跑步就选择快走，如果你觉得快走还是很累那就慢走，反正动起来比坐下来要好一些。特别是比较胖的人，跑步要特别注意自己的膝盖，体重偏胖对膝盖的伤害是很大的。 可以使用 NEAT（Non-Exercise Activity Thermogenesis，即非运动性热消耗）法来增加自己的热量消耗，我总结了一下自己使用的 NEAT 小习惯，如下图： 这里我着重提一下收腹这个小动作，经常保持收腹的动作可以增强腹部的练习，有利于瘦肚子。当然了这个过程很慢，一旦你习惯了这个动作，我敢保证要不了多久肯定有同事说你瘦了许多。 5、戒烟限酒 之前有很多朋友都戒烟了，有的戒了半年，有的戒了几年，最后还是抽上了，戒烟是一个值得研究和探讨的课题。所以，我并没有期望你读到这里就立即戒烟了。 戒烟最难的是如何消除内心的那种失落的恐惧感，一烟在手，天下我有的感觉让人难以割舍。 我自己本身也是一个烟民，正在戒烟的苦难中苦苦挣扎着，等我哪一天真正戒掉了再来分享这个心路历程。 戒酒，对于有酒瘾的朋友也是很难的一件事情，但是限酒我觉得还是要去尝试一下的，少喝点不至于那么伤肝吧。本人对酒不感兴趣，也基本不喝，因为一喝就醉，实在没有这个天赋。 还有很多好的习惯没有一一列举出来，比如早晚刷牙（如果你喜欢甚至可以早中晚刷牙😜）、还有降低吃饭速度、午休等等，总之你有多自律就有多自由！ 勿以恶小而为之，勿以善小而不为~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>习惯 自律 健康</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Admin与服务监测和管理]]></title>
    <url>%2F2020%2F05%2F03%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Admin%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%B5%8B%E5%92%8C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介Spring Boot Admin 并不是 Spring Boot 官方出品的，开源地址 SpringBoot Admin，伴随着 SpringBoot 的更新，Spring Boot Admin 也做了相对应的更新。Spring Boot 推出 2.X 版本时，Spring Boot Admin 也及时进行了更新。本篇使用的就是 Spring Boot Admin 2.2.1版本，最新版本是 2.2.2。 Spring Boot Admin 分为 client 和 server 端，server 端一般独立为一个服务，client 可以是你已经开发完成的服务，也可以是你即将要开发的服务。 对 Spring Boot Admin 2.x 版本的具体的更新内容和变化感兴趣的朋友，可以参考 changes-2.x.adoc 文档，这里不再赘述。 继上一篇 微服务-Actuator实现服务监测，我们说到使用 Actuator 组件可以实现对服务的监测，但是这种方式没有管理界面体验很不友好。本篇继续学习关于 Admin 的知识，该组件不仅囊括了 Actuator 的功能，还提供了管理界面，使用起来比较方便。 本篇主要内容，如下： 通过 HTTP 方式集成和使用 spring-boot-admin-server； 如何安全的使用 spring-boot-admin，这里又包含两个内容: 如何将 spring-boot-admin-server 结合 spring-boot-security，实现安全管控以及如何配置； 如何将 spring-boot-admin-client 结合 spring-boot-security，实现安全管控以及如何配置； 完整工程代码，请移步 Github 下载。后续会结合 spring-cloud 中的 Eureka 组件再次学习和分享使用 spring-boot-admin。 配置 Admin Server为了学习和验证 Spring Boot Admin 的使用，我创建了一个 Admin-Server工程即 ms-admin，创建了两个 Admin-Client 工程即 ms-user 和 ms-admin-client，工程结构如下图: ms-user 和 ms-admin-client 不同点在于：ms-user 使用了 spring-boot-security 模块，而 ms-admin-client 没有使用 spring-boot-security 模块，是一个相对比较简单的 SpringBoot 服务。 1、配置 ms-admin在该 module 的 properties 文件中，配置如下： 12345spring.application.name=Admin-Server# ---------------------------------# 配置该服务的独立端口# ---------------------------------server.port=8087 注意：该服务的端口为 8087。 该 module 的 pom 文件，使用了 spring-boot 版本为 2.2.6.RELEASE，spring-boot-admin 版本为 2.2.1，这里一定要注意版本的匹配，否则工程运行会存在各种奇葩问题。这里教大家一个方法，如果你不知道如何匹配版本，直接使用 spring initializr 创建工程，然后下载创建的工程，看一下里面的 pom文件中各个模块的版本号就可以了。 修改一下启动类，增加 @EnableAdminServer 注解，如下： 123456789101112import de.codecentric.boot.admin.server.config.EnableAdminServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableAdminServer@SpringBootApplicationpublic class MZAdminApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MZAdminApplication.class, args); &#125;&#125; 2、配置 ms-admin-client在该 module 的 properties 文件中，配置如下： 1234567891011121314spring.application.name=Admin-Clientserver.port=8083# ------------------------# Actuator config# ------------------------# 可以访问任意控制点management.endpoints.web.exposure.include=*# ------------------------------------------# 配置 spring boot admin# ------------------------------------------spring.boot.admin.client.url=http://localhost:8087management.endpoint.health.show-details=always 注意：该服务的端口为 8083。如果 admin-client 和 admin-server 没有部署在同一台服务器，这里的spring.boot.admin.client.url 一定要写上 admin-server 所在服务器的ip地址。 在该 module 的 pom 文件中，引入如下依赖即可，如下： 1234567891011&lt;!-- springboot admin client --&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-client&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 其余的不需要修改任何东西。 3、启动验证分别启动 ms-admin、ms-admin-client，启动成功后，在浏览器中打开 http://localhost:8087 就可以看到如下效果，可以看到 ms-admin-client 被发现了。 点进去，可以看到 ms-admin-client 的运行状况。大家可以自己试试，我就不截图了。 配置带 security 的 Admin-Client上面我们说了，ms-user 也是一个 Admin-Client，我也希望他能被监控和管理，但是 ms-user 有点特殊它使用了 security 模块，那么如何让他被 Admin-Server 发现呢，我们接着往下看。 PS：ms-user 模块其实是我之前一直在 微服务相关文章 中使用的工程模块，这里只是重构了一下工程结构并且修改了一下名称而已。 因为 ms-user 包含了比较多的内容，其 pom 文件也相对复杂一些，这里粘贴一部分（MySQL和Swagger相关配置就不写了）。 12345678910111213141516171819202122232425262728spring.application.name=User-Server# ------------------------# Actuator config# ------------------------# 可以访问任意控制点management.endpoints.web.exposure.include=*# 配置独立的端口management.server.port=1012# 自定义访问控制点的路径management.endpoints.web.base-path=/monitormanagement.endpoint.shutdown.enabled=true# -----------------------------------------------# Spring Security Default user name and password# -----------------------------------------------spring.security.user.name=adminspring.security.user.password=adminspring.security.user.roles=ACTUATOR_ADMIN# ------------------------------------------# 配置 spring boot admin# ------------------------------------------spring.boot.admin.client.url=http://localhost:8087management.endpoint.health.show-details=always# 告诉admin-server用户名和密码，否则监控不到spring.boot.admin.client.instance.metadata.user.name=$&#123;spring.security.user.name&#125;spring.boot.admin.client.instance.metadata.user.password=$&#123;spring.security.user.password&#125; 这里要特别注意， ms-user 使用了security并且设置了用户名和密码，一定要告诉 Admin-Server，否则无法被监控到。也就是说如下的配置必须写： 123# 告诉admin-server用户名和密码，否则监控不到spring.boot.admin.client.instance.metadata.user.name=$&#123;spring.security.user.name&#125;spring.boot.admin.client.instance.metadata.user.password=$&#123;spring.security.user.password&#125; 紧接着我们启动 ms-user 这个服务，刷新一下浏览器，效果如下图： 可以看到 ms-user 这个服务被如愿以偿的发现了。 Admin-Server 使用 security在 ms-admin 的 pom 文件中引入 security 模块，如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 修改 properties 文件，增加用户名和密码的配置，完整配置如下： 1234567891011spring.application.name=Admin-Server# ---------------------------------# 配置该服务的独立端口# ---------------------------------server.port=8087# ---------------------------------# security 配置# ---------------------------------spring.security.user.name=adminspring.security.user.password=admin 配置完成后，我们分别重新启动一下 ms-admin、ms-admin-client 这两个服务。 再次打开 localhost:8087，会出现如下界面： 输入在 properties 文件中配置的用户名和密码，这里我配置的用户名和密码都是 admin，你也可以配置其他的。 输入之后可以看到如下界面，再次输入上面的用户名和密码即可。 初次进入显示效果如下截图，居然没有发现 ms-admin-client 这个服务。 这是因为没有在客户端配置进入 Admin-Server 的密码，安排上。 在 ms-admin-client 的 properties 中配置，如下： 12345678# ------------------------------------------# 配置 spring boot admin# ------------------------------------------spring.boot.admin.client.url=http://localhost:8087management.endpoint.health.show-details=always# 配置 admin server 的用户名和密码，否则注册不上spring.boot.admin.discovery.instances-metadata.user.name=$&#123;spring.security.user.name&#125;spring.boot.admin.discovery.instances-metadata.user.password=$&#123;spring.security.user.password&#125; 同理，在 ms-user 的配置文件 properties 中也增加相关的配置即可。 记得继承自 WebSecurityConfigurerAdapter 写一个配置类，可以参考 SpringBootAdminServerApplication 示例代码，不然客户端有可能无法注册成功。 重新启动 ms-admin 服务然后登录进去再启动客户端，就可以看到如下界面： 另外，Admin-Server 还可以集成 spring-boot-starter-mail 模块再简单的配置一下，就可以实现发送邮件的功能，这样服务的运行状态可以及时通知到对应的收件人了。 面朝大海，春暖花开。尚拙能成才，你没有比别人聪明，你只是更加努力罢了~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot Actuator Admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Actuator实现服务监测]]></title>
    <url>%2F2020%2F05%2F01%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Actuator%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[简介SpringBoot Actuator 可以帮助我们监控 SpringBoot 应用的运行情况，服务上线后如何监控和管理自己的服务是我们要考虑的一个重要问题。 Actuator 是 SpringBoot 的一个附加组件（需要自己手动集成），Actuator 能帮助应用程序实现在各个环境运行时的监控。可以使用 HTTP 的各个请求路径来进行健康检查、审计、收集引用的运行情况，对于应用状态、内存、线程、堆栈等等都可以进行监控，比较全面的监控了 SpringBoot 应用的整个生命周期。对于微服务的管理十分有意义，在企业级应用中，对系统进行运行状态监控是不可或缺的。 Actuator 不仅支持 HTTP 方式访问，还支持 JMX（Java Management Extensions，即Java管理扩展）、SSH、Telnet 方式访问。Actuator 还支持端点扩展，扩展 Actuator 的端点（Endpoint） 可以自定义监控指标，实现更多的运维能力。 访问 spring-boot-actuator 给我们展现的是纯 JSON 格式的数据，对于非开发人员来说不够直观和不够人性化。Spring Boot Admin 就是用来解决这个问题的，使用 Spring Boot Admin 可以实现这些 JSON 接口数据的界面展现，方便运营人员查看和管理。本篇我们只学习 spring-boot-actuator 的使用，关于 Spring Boot Admin 下一篇再一起学习。 本篇主要内容： 如何使用 spring-boot-actuator（算是简单入门）； 结合 spring-boot-security 增加对 spring-boot-actuator 的访问限制； 更多关于微服务相关文章，可以通过 微服务项目系列文章 学习。 实战在你的工程的 pom.xml 文件中，加入如下依赖就可以引入 spring-boot-actuator 组件，如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 等待加载完成（就是对应的jar包文件下载完成且ide加载jar正常），可以看到多了如下两个jar包。 actuator 是其功能实现，actuator-autoconfigure 是其自动配置的实现。 启动工程，然后在浏览器打开 http://localhost:8080/actuator，可以看到如下 json 数据。 1234567891011121314151617181920&#123; "_links": &#123; "self": &#123; "href": "http://localhost:8080/actuator", "templated": false &#125;, "health": &#123; "href": "http://localhost:8080/actuator/health", "templated": false &#125;, "health-path": &#123; "href": "http://localhost:8080/actuator/health/&#123;*path&#125;", "templated": true &#125;, "info": &#123; "href": "http://localhost:8080/actuator/info", "templated": false &#125; &#125;&#125; 你可以访问如下的 URL，如下： 12http://localhost:8080/actuator/healthhttp://localhost:8080/actuator/info 在 Actuator 的 2.x 版本中，大多数端点默认被禁掉了，且默认端点增加了 /actuator 前缀。默认暴露的两个端点为 /actuator/health 和 /actuator/info，正是如上可以访问的两个 URL. 如果想开启所有的断点可以被访问，需要在工程的 properties 文件中，增加如下配置： 1management.endpoints.web.exposure.include=* 再次访问 http://localhost:8080/actuator，就会有更多的URL可以被访问了。如 http://localhost:8080/actuator/env、http://localhost:8080/actuator/beans 等。 官方文档 Spring Boot Actuator: Production-ready Features 完整的介绍了相关的内容，大家可以自行查阅。 从上面的访问路径可以看出，默认访问 Actuator 所有的监控点路径都在/actuator/*，是否可以自定义呢？是的，可以自定义这个前缀，只需要在 properties 中配置如下内容即可： 1management.endpoints.web.base-path=/monitor 再次访问上面的 URL，就需要将 actuator/ 换成 monitor/ 了。 安全虽然 Actuator 提供了很方便的监控和管理服务的能力，但是试想一下让任何其他的服务都可以访问，会存在一些安全隐患，SpringBoot 提供了 security 模块，可以帮助我们更加安全的使用 Actuator。集成 security 也很简单，下面我们具体说说如何使用吧。 首先，需要在 pom 文件中，添加如下依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 其次，配置工程的 properties 文件，加入如下内容： 123spring.security.user.name=actuator-selfspring.security.user.password=actuator-adminspring.security.user.roles=ACTUATOR_ADMIN 用户名（name）和密码（password），可以根据自己的实际情况自定义。 最后，添加一个配置类 MSActuatorSecurityConfig，该类继承 WebSecurityConfigurerAdapter. 12345678910111213141516171819202122232425import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;import org.springframework.boot.autoconfigure.security.servlet.PathRequest;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configurationpublic class MSActuatorSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .requestMatchers(EndpointRequest.toAnyEndpoint()) .hasRole("ACTUATOR_ADMIN") .requestMatchers(PathRequest.toStaticResources().atCommonLocations()) .permitAll() .antMatchers("/") .permitAll() .antMatchers("/**") .authenticated() .and() .httpBasic(); &#125;&#125; 下次再次访问 http://localhost:8080/monitor，就会提示你输入用户名和密码了。 下图是使用 Chrome 浏览器显示的效果。 输入配置的用户名和密码登录就可以访问到数据了。 另外为了安全，可以单独设置 Actuator 的管理端口并配置不对外网开放，如下配置独立的端口 1102，然后可以在防火墙上做下限制即 1102 端口仅用于内网访问即可。 在 properties 中增加如下配置，如下： 12# 配置独立的端口management.server.port=1012 使用效果： 人无千日好，花无百日红，早时不算计，过后一场空。~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot Actuator 微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 结合MySQL实现登录注册]]></title>
    <url>%2F2020%2F04%2F11%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BB%93%E5%90%88MySQL%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[简介继 MySQL8.0.15在Win10上的折腾记 和 微服务: MySQL基本操作 后，由于个人原因没能继续创作，从今天开始补上，继续前进💪。 本篇是 微服务系列 的第 N 篇，本篇结合 MySQL 和 SpringBoot 实现用户登录注册，算是一个小实战也是对之前知识点的一个小结。 在阅读本篇内容之前，需要大家做好如下几件事情： 在本机安装了 MySQL，并且可以正常使用；如果你用的是 Windows10，可以参考 MySQL8.0.15在Win10上的折腾记 这篇文章； 已经搭建好了 SpringBoot 的开发环境；可以参考 微服务: 想办法让项目运行起来 来搭建环境； 能使用 SpringBoot 正确连接 MySQL，实现简单的增删改查（CRUD）；可以参考 微服务: MySQL基本操作 这篇文章； 理解跨域问题，请务必先阅读 跨域和OPTIONS这对欢喜冤家； 树立信心，坚持不懈，不怕困难； 本篇文章主要内容： 网页端，提供注册、登录的入口，请求服务端提供的 API，请求采用 Ajax； 服务端，提供注册、登录的 API，处理用户注册和登录的请求，并能正确读写 MySQL 数据库； 代码全部放在 Github，有需要的朋友们可以自行获取。 登录注册流程图本篇分享的用户注册和登录流程比较简单，看图说话。 前端效果本篇中的前端页面很简单，我本人对前端的认知是个二半吊子，现学现卖，主要是配合接口做一些实例，没啥技术含量。使用前端开发，给我最大的感觉就是方便，简洁。 1、注册页面 注册成功会自动跳转到登录页面。 2、登录页面 登录失败会自动跳转到注册页面。 页面和逻辑的源代码对应分别如下 1 -&gt; ms_login.html 是登录页面的 HTML 文件； 2 -&gt; ms_signup.html 是注册页面的 HTML 文件； 3 -&gt; ms_user.js 是 Ajax 的请求逻辑的 JavaScript 代码。 配置 MySQL 的连接既然要使用 MySQL，首先要在工程中配置跟 MySQL 相关的连接参数。 在工程的 application.properties 文件中，配置下面参数即可。 1234567# jdbcspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# charset=utf8mb4spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mzc_user?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=root# 设置为你自己 MySQL 的密码spring.datasource.password=root 具体的这些参数含义在 微服务: MySQL基本操作 这篇文章中有详细的讲解。 编写 API源文件 MSSigninController 实现了登录的 API，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940@RestController@RequestMapping(value = "signup") // 注意这里不要在signup前后加"/"public class MSSignupController &#123; @Autowired private MSUserService userService; @CrossOrigin(origins = &#123;"*"&#125;) @PostMapping(value = "/name") public MSResponse signup(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; MSResponse response = new MSResponse(); MSUser user = null; if (null == userName || null == userPwd || userName.length() &lt;= 0 || userPwd.length() &lt;= 0) &#123; MSResponseEnum signupError = MSResponseEnum.SignupInvalidInfo; response.setMsg(signupError.getMsg()); response.setCode(signupError.getCode()); &#125; else &#123; // 创建user表 userService.createUserTable(); // 检查用户数据库的‘user’表中是否有该用户？ List&lt;Map&gt; query_users = userService.queryUserByUserName(userName); if (null == query_users || query_users.isEmpty()) &#123;// 没有该用户的数据 user = MSUserUtil.createUser(userName, userPwd); // 插入一条用户数据到数据表中 userService.addUser(user); response.setCode(MSResponseEnum.SUCCESS.getCode()); response.setMsg(MSResponseEnum.SUCCESS.getMsg()); &#125; else &#123;// 用户数据库的‘user’表中有该用户信息 // 返回错误信息：该用户已经注册过了 MSResponseEnum signupError = MSResponseEnum.SignupHasExistUser; response.setMsg(signupError.getMsg()); response.setCode(signupError.getCode()); &#125; &#125; response.setResults(user); return response; &#125;&#125; 源文件 MSSignupController 实现了注册的 API，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RestController@RequestMapping(value = "signin") // 注意这里不要在signin前后加"/"public class MSSigninController &#123; @Autowired private MSUserService userService; @CrossOrigin(origins = &#123;"*", "http://localhost:8082"&#125;) @RequestMapping(value = "/name", method = RequestMethod.GET) public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; MSResponse response = new MSResponse(); MSUser user = null; if (null == userName || null == userPwd || userName.length() &lt;= 0 || userPwd.length() &lt;= 0) &#123; MSResponseEnum responseEnum = MSResponseEnum.Login4SiginInvalidInfo; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123; // 检查用户数据库的‘user’表中是否有该用户？ List&lt;Map&gt; query_users = userService.queryUserByUserName(userName); if (query_users.isEmpty()) &#123;// 没有该用户 MSResponseEnum responseEnum = MSResponseEnum.LoginNoSuchUser; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123;// 有这个用户 Map user_map = query_users.get(0); String query_user_name = (String) user_map.get("accountName"); // 没有对应的用户名 if (!query_user_name.equals(userName)) &#123; MSResponseEnum responseEnum = MSResponseEnum.LoginNoSuchUser; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123;// 查询到了该用户 // 将查询出来的map对象使用FastJson转换为MSUser对象 user = JSON.parseObject(JSON.toJSONString(user_map), MSUser.class); MSResponseEnum rspEnum = MSResponseEnum.SUCCESS; response.setCode(rspEnum.getCode()); response.setMsg(rspEnum.getMsg()); &#125; &#125; &#125; response.setResults(user); return response; &#125;&#125; 相比于之前的代码逻辑，现在的代码无非就是加入了操作数据库的逻辑。代码比较简单，看注释就可以看明白。 操作数据库的代码，都在 MSUserServiceImpl 这个实现类中。我就不一一的粘贴代码了。有兴趣的朋友可以自行到 Github 下载。 验证首先，启动工程，让工程在本地正常运行起来。如果你还没有搭建 SpringBoot 的开发环境，建议参考 微服务-想办法让项目运行起来 这篇文章。 然后在浏览器打开注册页面，建议使用 Chrome 浏览器操作。如下图，我使用 foobar 用户名和 foobar 密码进行注册。 点击注册按钮，成功后用终端登录 MySQL 数据库，看看是否有数据。如下图，可以看到数据库和对应的表。 可以从下图看出，数据已经成功的写入数据库中了。 最后，打开登录界面，输入用户名称和密码都是 foobar 的就可以登录成功，说明从数据库读取数据也是正常的。 今天就说这么多吧，下次再见！ 从现在做起，一切都还来得及。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>MySQL Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC坑集之block作为函数参数]]></title>
    <url>%2F2020%2F02%2F27%2FOC%E5%9D%91%E9%9B%86%E4%B9%8Bblock%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[对于 OC（Objective-C，苹果推出的自家编程语言） 的争论一直不休，对于一门语言，我觉得只要能解决你的问题就够了。 评论一门编程语言的好坏之前，需要我们真正的去用它，OC 孰好孰坏，需要你自己去尝试。 OC 坑集，主要记载使用 OC 开发项目遇到的问题，尽量简洁明了，希望大家喜欢。 block 语句块可以作为函数的参数, 在项目中都经常被作为回调来使用。 如果你还不熟悉 block 语法，请自行 google，这里不讲 block 语法。我们下面直接进入主题。 创建一个 OC 类 1234567#import &lt;Foundation/Foundation.h&gt;@interface FoolBar : NSObject- (void)makeFool:(void(^)(NSString *))callback;@end 1234567891011#import "FoolBar.h"@implementation FoolBar- (void)makeFool:(void (^)(NSString *))callback&#123; NSLog(@"makeFool | callback."); callback(@"This is a block parameter.");&#125;@end main.m 123456789101112#import &lt;Foundation/Foundation.h&gt;#import "FoolBar.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; FoolBar *fb = [[FoolBar alloc] init]; [fb makeFool:^(NSString *) &#123; &#125;]; &#125; return 0;&#125; 大家看到这里，应该觉得没什么问题。 我刚开始也是行事冲冲的，但编译器给了个大大的 Error, 大致意思是参数丢失。 经过一番思想上面的斗争，终于解决了问题。 在声明带有 block 语句的方法时，需要带上参数名称或者调用者自己写上参数名称。 1- (void)makeFool:(void(^)(NSString *param))callback; 重新给它整上，如下： 123456789101112#import &lt;Foundation/Foundation.h&gt;#import "FoolBar.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; FoolBar *fb = [[FoolBar alloc] init]; [fb makeFool:^(NSString *param) &#123; NSLog(@"param = %@", param); &#125;]; &#125; return 0;&#125; 使用 block 作为函数参数的时候，建议使用 typedef 定义 block. 1typedef void (^OnFoolCallback)(NSString *name); 定义和实现 1- (void)productFool:(OnFoolCallback)callback; 12345- (void)productFool:(OnFoolCallback)callback&#123; NSLog(@"productFool | callback."); callback(@"This is a block parameter: mark.");&#125; 测试和使用，如下： 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import "FoolBar.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; FoolBar *fb = [[FoolBar alloc] init]; [fb makeFool:^(NSString *param) &#123; NSLog(@"param = %@", param); &#125;]; [fb productFool:^(NSString *name) &#123; NSLog(@"name = %@", name); &#125;]; &#125; return 0;&#125; 盼望疫情早日结束，每个人都能回归到正常的生活当中去！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL: 实战-RSA分段解密]]></title>
    <url>%2F2020%2F01%2F05%2FOpenSSL-%E5%AE%9E%E6%88%98-RSA%E5%88%86%E6%AE%B5%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[简介本篇是继 OpenSSL: 简单易上手的RSA加解密 后的补充篇，实战篇。 在实际项目中，并没有像上篇文章写的那么简单，实际情况要复杂的多。万变不离其宗，抽丝剥茧，复杂事务的背后一定是有其本质原因和原理的存在，而我们就是挖掘原理，探索本质的福尔摩斯。 今天这篇文章，带领大家参与到实际项目中运用RSA加解密，在阅读下面内容之前，期望大家可以下载 openssl 的源码，或者下载我 上篇文中 的代码示例。 我下载的是 openssl-source-1.1.0f 这个版本的源码，正好对应我从 precompiled-openssl 下载的编译版本。 项目概述该项目的开发语言仍然采用C语言来实现，我们借助 openssl 来模拟实际项目中的案例。 服务端使用 RSA 加密原始数据，然后采用 Base64 编码该加密数据经过 HTTP 传输给到客户端； 客户端接收到该数据，先使用 Base64 解码数据，然后再使用 RSA 解密数据，最终得到原始数据。 这里特别注意，客户端收到的数据大小可能会大于 128 字节，我们知道 RSA 加密明文最大长度 117 字节，而解密的最大值是 128 字节，所以超过该大小需要分段解密数据。 大概流程图如下： 很简单的一个项目，对吧，接着往下看吧 :)- 解个小惑也许有些朋友会问，为毛 RSA 加密的明文大小是 117 字节，而解密的最大字节数是 128 字节，两者一样不是更好吗，至少好理解呀？ 得出上面结论的前提是我们RSA密钥长度是 1024 位即 128 字节（1024/8=128），同理如果是 512 位的密钥，那么最大的 RSA 解密字节长度应该是（512/8）64 字节，最大加密的明文长度是（64-11）53 字节。 在 openssl 源码中，我们可以看到如下代码： 1# define RSA_PKCS1_PADDING_SIZE 11 在 rsa_sign.c 文件中可以看到 RSA_sign 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int RSA_sign(int type, const unsigned char *m, unsigned int m_len, unsigned char *sigret, unsigned int *siglen, RSA *rsa)&#123; int encrypt_len, encoded_len = 0, ret = 0; unsigned char *tmps = NULL; const unsigned char *encoded = NULL; if (rsa-&gt;meth-&gt;rsa_sign) &#123; return rsa-&gt;meth-&gt;rsa_sign(type, m, m_len, sigret, siglen, rsa); &#125; /* Compute the encoded digest. */ if (type == NID_md5_sha1) &#123; /* * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and * earlier. It has no DigestInfo wrapper but otherwise is * RSASSA-PKCS1-v1_5. */ if (m_len != SSL_SIG_LENGTH) &#123; RSAerr(RSA_F_RSA_SIGN, RSA_R_INVALID_MESSAGE_LENGTH); return 0; &#125; encoded_len = SSL_SIG_LENGTH; encoded = m; &#125; else &#123; if (!encode_pkcs1(&amp;tmps, &amp;encoded_len, type, m, m_len)) goto err; encoded = tmps; &#125; if (encoded_len &gt; RSA_size(rsa) - RSA_PKCS1_PADDING_SIZE) &#123; RSAerr(RSA_F_RSA_SIGN, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY); goto err; &#125; encrypt_len = RSA_private_encrypt(encoded_len, encoded, sigret, rsa, RSA_PKCS1_PADDING); if (encrypt_len &lt;= 0) goto err; *siglen = encrypt_len; ret = 1;err: OPENSSL_clear_free(tmps, (size_t)encoded_len); return ret;&#125; 可以看出，RSA_PKCS1_PADDING 这种填充模式是占用了 11 个字节的，那么 127+11 正好也是 128 字节。 每次RSA加密的明文的长度是受RSA填充模式限制的，如下表： 填充方式 输入 输出 备注 RSA_PKCS1_PADDING 必须比RSA钥模长(modulus) 短至少11个字节, 也就是RSA_size(rsa) – 11，对于1024bit的密钥，RSA_size(rsa)=128字节，即明文为128-11=117字节；如果输入的明文过长，必须切割，然后填充。 和modulus一样长 最常用的填充方式 RSA_PKCS1_OAEP_PADDING RSA_size(rsa) – 41 和modulus一样长 最优非对称填充OAEP，安全性是最高的 RSA_NO_PADDING 可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充。 和modulus一样长 - 这里注意下面结论： 在不同的padding模式下，使用相同长度的密钥可以加密的数据最大长度不同； 在不同密钥长度下，使用相同的padding模式可以加密的数据最大长度也不同； 可以阅读 rfc2313 中关于 PKCS #1: RSA Encryption Version 1.5 的部分。 开战 实战代码主要在 main.c 文件中的 example_rsa3() 函数中。 原始数据是字符串 www.veryitman.com，如下还包括了公私钥。 1234567891011121314151617181920212223242526// 原始数据为字符串：www.veryitman.com unsigned char plainText[] = "www.veryitman.com"; unsigned char publicKey[] = "-----BEGIN PUBLIC KEY-----\n" "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrPgCMJW17JN2DW7tZFk/FB6pU\n" "pLvLOo6G/EuND8XZptffXbyiY2VscMRhP+kKVeaLO9HuEYR3Zl78x8oR6prytstc\n" "/MueersWDxh4iGSHsZXGxA41hXrXLRElrSTRc43ea18o0zMxZoVZiR2JFt7QcgM+\n" "T6eOrvj59MhXv9O46QIDAQAB\n" "-----END PUBLIC KEY-----\n"; unsigned char privateKey[] = "-----BEGIN RSA PRIVATE KEY-----\n" "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKs+AIwlbXsk3YNb\n" "u1kWT8UHqlSku8s6job8S40Pxdmm199dvKJjZWxwxGE/6QpV5os70e4RhHdmXvzH\n" "yhHqmvK2y1z8y556uxYPGHiIZIexlcbEDjWFetctESWtJNFzjd5rXyjTMzFmhVmJ\n" "HYkW3tByAz5Pp46u+Pn0yFe/07jpAgMBAAECgYBj1YH8MtXhNVzveEuBZMCc3hsv\n" "vdq+YSU3DV/+nXN7sQmp77xJ8CjxT80t5VS38dy2z+lUImJYOhamyNPGHkC2y84V\n" "7i5+e6ScQve1gnwHqRKGBjtSCaYOqm9rTDECCTT1oMU26sfYznWlJqMrkJp1jWn7\n" "aAwr+3FcX2XhD74ZAQJBAN34Y6fmHLRPv21MsdgGqUjKgyFvJfLUmtFFgb6sLEWc\n" "k22J3BAFAcNCTLYHFZwMhL/nwaw9/7rIUJD+lcl6n3cCQQDFfrN14qKC3GJfoBZ8\n" "k9S6F7Ss514DDPzIuenbafhoUjZDVcjLw9EmYZQjpfsQ3WdNICUKRrDHZay1Pz+s\n" "YkKfAkB+OKfaquS5t/t/2LPsxuTuipIEqiKnMjSTOfYsidVnBEFlcZZc2awF76aV\n" "f/PO1+OJCO2910ebXBtMSCi++GbDAkEAmc7zNPwsVH4OnyquWJdJNSUBMSd/sCCN\n" "PkaMOrVtINHmMMq+dvMqEBoupRS/U4Ma0JYYQsiLJL+qof2AOWDNQQJAcquLGHLT\n" "eGDDLluHo+kkIGwZi4aK/fDoylZ0NCEtYyMtShQ3JmllST9kmb9NJX2gMsejsirc\n" "H6ObxqZPbka6UA==\n" "-----END RSA PRIVATE KEY-----\n"; 对数据进行私钥加密，示例如下： 1234567// 私钥加密int encrypted_length = private_key_encrypt(plainText, len, privateKey, encrypted_str);if (-1 == encrypted_length)&#123; printf("Private Encrypt failed\n"); exit(0);&#125; 私钥加密之后，进行 Base64 编码： 12345678910char *base64_content;size_t encrypted_str_length = strlen(encrypted_str);int encode_res = mzc_base64_encode(encrypted_str, encrypted_str_length, &amp;base64_content);if (0 != encode_res)&#123; printf("Base64 encode failed\n"); exit(0);&#125;printf("Base64 encode content: %s\n\n", base64_content);printf("Base64 encode content's length: %i\n\n", strlen(base64_content)); 至此，上面两个步骤就模拟完成了服务端加密的过程。下面我们来继续模拟客户端解密的过程。 首先，对 Base64 编码之后的数据进行 Base64 解码。 12345678910char *base64DecodeOutput;size_t decode_output_length;int decode_res = mzc_base64_decode(base64_content, &amp;base64DecodeOutput, &amp;decode_output_length);printf("base64 decode content: %s\n\n", base64DecodeOutput);printf("base64 decode content's length: %i\n\n", decode_output_length);if (0 != decode_res)&#123; printf("Base64 decode failed\n"); exit(0);&#125; 看一下打印结果： 1base64 decode content's length: 160 很明显，长度要大于 128，需要进行分段处理。 123456789101112131415161718192021222324// 最大解密长度#define RSA_MAX_DECRYPT_SIZE 128// 每段解密的长度int chunk = 0;unsigned char tmp_dstr[RSA_MAX_DECRYPT_SIZE];memset(tmp_dstr, '\0', sizeof(tmp_dstr));// （数据被）分段解密（公钥解密）while (chunk &lt;= decode_output_length)&#123; int decrypted_length = public_key_decrypt(base64DecodeOutput, RSA_MAX_DECRYPT_SIZE, publicKey, tmp_dstr); memcpy(decrypted_str, tmp_dstr, decrypted_length); printf("Current decrypted content length =%d\n", decrypted_length); if (-1 == decrypted_length) &#123; printf("Public Decrypt failed\n"); exit(0); &#125; chunk += decrypted_length;&#125;printf("......\n\n");printf("Final decrypted string =%s\n", decrypted_str); 输出结果： 123......Final decrypted string =www.veryitman.com 至此整个过程简单模拟结束。 大家如果感兴趣的话，可以实现分段加密的过程。我就不再演示这个过程了，后续加入到源代码中去。 问君能有几多愁，恰似一江春水向东流。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>OpenSSL VS2017 RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL: 简单易上手的RSA加解密]]></title>
    <url>%2F2019%2F12%2F29%2FOpenSSL-%E7%AE%80%E5%8D%95%E6%98%93%E4%B8%8A%E6%89%8B%E7%9A%84RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[简介这篇文章是继 OpenSSL: 用VS2017创建C工程、OpenSSL: 完成VS2017的配置 两篇文章的第3篇，前两篇分别跟大家分享了如何在 visual studio2017 中创建C工程，配置OpenSSL的开发环境以及使用 openssl 开源库实现base64的编解码。 本篇跟大家分享如何使用 openssl 开源库实现 RSA 的加密和解密，不过这一篇是对简单的数据进行加解密，下一篇继续跟大家分享复杂一点的 RSA 加解密过程以及实例代码。 2019 即将被画上句号，自己还有很多愿望没有实现。一拿起书就感觉困，一拿起手机觉得黑夜里阳光明媚，无药可救了呀！ 获取公、私钥在 precompiled-openssl 获取的压缩包中，解压可以在 bin64或者bin（32位操作系统使用） 目录下面找到 openssl.exe 文件，双击打开即可。 生成私钥执行下面代码，如下： 1genrsa -out rsa_private_key.pem 1024 此时在 bin64 目录下会生成 rsa_private_key.pem 文件，即私钥文件； 将 RSA 私钥转换成 PKCS8 格式，执行如下代码： 1pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt 生成公钥执行下面代码，如下： 1rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 此时在 bin64 目录下会生成 rsa_public_key.pem 文件，即公钥文件； 用VS Code打开这两个文件，可以看到具体内容，在我的机器上生成的公钥： 123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrPgCMJW17JN2DW7tZFk/FB6pUpLvLOo6G/EuND8XZptffXbyiY2VscMRhP+kKVeaLO9HuEYR3Zl78x8oR6prytstc/MueersWDxh4iGSHsZXGxA41hXrXLRElrSTRc43ea18o0zMxZoVZiR2JFt7QcgM+T6eOrvj59MhXv9O46QIDAQAB-----END PUBLIC KEY----- 私钥，如下： 12345678910111213141516-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKs+AIwlbXsk3YNbu1kWT8UHqlSku8s6job8S40Pxdmm199dvKJjZWxwxGE/6QpV5os70e4RhHdmXvzHyhHqmvK2y1z8y556uxYPGHiIZIexlcbEDjWFetctESWtJNFzjd5rXyjTMzFmhVmJHYkW3tByAz5Pp46u+Pn0yFe/07jpAgMBAAECgYBj1YH8MtXhNVzveEuBZMCc3hsvvdq+YSU3DV/+nXN7sQmp77xJ8CjxT80t5VS38dy2z+lUImJYOhamyNPGHkC2y84V7i5+e6ScQve1gnwHqRKGBjtSCaYOqm9rTDECCTT1oMU26sfYznWlJqMrkJp1jWn7aAwr+3FcX2XhD74ZAQJBAN34Y6fmHLRPv21MsdgGqUjKgyFvJfLUmtFFgb6sLEWck22J3BAFAcNCTLYHFZwMhL/nwaw9/7rIUJD+lcl6n3cCQQDFfrN14qKC3GJfoBZ8k9S6F7Ss514DDPzIuenbafhoUjZDVcjLw9EmYZQjpfsQ3WdNICUKRrDHZay1Pz+sYkKfAkB+OKfaquS5t/t/2LPsxuTuipIEqiKnMjSTOfYsidVnBEFlcZZc2awF76aVf/PO1+OJCO2910ebXBtMSCi++GbDAkEAmc7zNPwsVH4OnyquWJdJNSUBMSd/sCCNPkaMOrVtINHmMMq+dvMqEBoupRS/U4Ma0JYYQsiLJL+qof2AOWDNQQJAcquLGHLTeGDDLluHo+kkIGwZi4aK/fDoylZ0NCEtYyMtShQ3JmllST9kmb9NJX2gMsejsircH6ObxqZPbka6UA==-----END PRIVATE KEY----- 紧接着我会使用这对公私钥进行编码。 RSA 实战 RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个相同的算法，但他的发现被列入机密，一直到1997年才被发表。 对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。 1983年麻省理工学院在美国为RSA算法申请了专利。这个专利2000年9月21日失效。由于该算法在申请专利前就已经被发表了，在世界上大多数其它地区这个专利权不被承认。 新建头文件 mzc_rsa.h，声明几个函数，如下： 12345678910111213#pragma once/* 公钥解密 */int public_key_decrypt(unsigned char *enc_data, int data_len, unsigned char *key, unsigned char *decrypted);/* 私钥加密 */int private_key_encrypt(unsigned char *data, int data_len, unsigned char *key, unsigned char *encrypted);/* 公钥加密 */int public_key_encrypt(unsigned char *data, int data_len, unsigned char *key, unsigned char *encrypted);/* 私钥解密 */int private_key_decrypt(unsigned char *enc_data, int data_len, unsigned char *key, unsigned char *decrypted); 对应的实现文件 mzc_rsa.c，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include "mzc_rsa.h"#include &lt;openssl/pem.h&gt;#include &lt;openssl/ssl.h&gt;#include &lt;openssl/rsa.h&gt;#include &lt;openssl/evp.h&gt;#include &lt;openssl/bio.h&gt;#include &lt;openssl/err.h&gt;#include &lt;openssl/buffer.h&gt;#include &lt;stdio.h&gt;const int PADDING = RSA_PKCS1_PADDING;RSA *createRSA(unsigned char *key, int public_token)&#123; RSA *rsa = NULL; BIO *keybio; keybio = BIO_new_mem_buf(key, -1); if (keybio == NULL) &#123; printf("Failed to create key BIO"); return 0; &#125; if (public_token) &#123; rsa = PEM_read_bio_RSA_PUBKEY(keybio, &amp;rsa, NULL, NULL); &#125; else &#123; rsa = PEM_read_bio_RSAPrivateKey(keybio, &amp;rsa, NULL, NULL); &#125; if (rsa == NULL) &#123; printf("Failed to create RSA"); &#125; return rsa;&#125;int public_key_decrypt(unsigned char *enc_data, int data_len, unsigned char *key, unsigned char *decrypted)&#123; RSA *rsa = createRSA(key, 1); int result = RSA_public_decrypt(data_len, enc_data, decrypted, rsa, PADDING); return result;&#125;int private_key_encrypt(unsigned char *data, int data_len, unsigned char *key, unsigned char *encrypted)&#123; RSA *rsa = createRSA(key, 0); int result = RSA_private_encrypt(data_len, data, encrypted, rsa, PADDING); return result;&#125;int public_key_encrypt(unsigned char *data, int data_len, unsigned char *key, unsigned char *encrypted)&#123; RSA *rsa = createRSA(key, 1); int result = RSA_public_encrypt(data_len, data, encrypted, rsa, PADDING); return result;&#125;int private_key_decrypt(unsigned char *enc_data, int data_len, unsigned char *key, unsigned char *decrypted)&#123; RSA *rsa = createRSA(key, 0); int result = RSA_private_decrypt(data_len, enc_data, decrypted, rsa, PADDING); return result;&#125; 注意这里使用的 RSA 对齐模式是 RSA_PKCS1_PADDING。 在测试的主函数（main）中，使用明文 www.veryitman.com 作为示例进行加密和解密操作，我在下面只列出关键实现。具体代码可以去 Github 下载，注意 clone rsa-feature 这个分支。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 公钥加密， 私钥解密 */int main()&#123; //原始数据为字符串：www.veryitman.com unsigned char plainText[] = "www.veryitman.com"; unsigned char publicKey[] = "-----BEGIN PUBLIC KEY-----\n" "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrPgCMJW17JN2DW7tZFk/FB6pU\n" "pLvLOo6G/EuND8XZptffXbyiY2VscMRhP+kKVeaLO9HuEYR3Zl78x8oR6prytstc\n" "/MueersWDxh4iGSHsZXGxA41hXrXLRElrSTRc43ea18o0zMxZoVZiR2JFt7QcgM+\n" "T6eOrvj59MhXv9O46QIDAQAB\n" "-----END PUBLIC KEY-----\n"; unsigned char privateKey[] = "-----BEGIN RSA PRIVATE KEY-----\n" "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKs+AIwlbXsk3YNb\n" "u1kWT8UHqlSku8s6job8S40Pxdmm199dvKJjZWxwxGE/6QpV5os70e4RhHdmXvzH\n" "yhHqmvK2y1z8y556uxYPGHiIZIexlcbEDjWFetctESWtJNFzjd5rXyjTMzFmhVmJ\n" "HYkW3tByAz5Pp46u+Pn0yFe/07jpAgMBAAECgYBj1YH8MtXhNVzveEuBZMCc3hsv\n" "vdq+YSU3DV/+nXN7sQmp77xJ8CjxT80t5VS38dy2z+lUImJYOhamyNPGHkC2y84V\n" "7i5+e6ScQve1gnwHqRKGBjtSCaYOqm9rTDECCTT1oMU26sfYznWlJqMrkJp1jWn7\n" "aAwr+3FcX2XhD74ZAQJBAN34Y6fmHLRPv21MsdgGqUjKgyFvJfLUmtFFgb6sLEWc\n" "k22J3BAFAcNCTLYHFZwMhL/nwaw9/7rIUJD+lcl6n3cCQQDFfrN14qKC3GJfoBZ8\n" "k9S6F7Ss514DDPzIuenbafhoUjZDVcjLw9EmYZQjpfsQ3WdNICUKRrDHZay1Pz+s\n" "YkKfAkB+OKfaquS5t/t/2LPsxuTuipIEqiKnMjSTOfYsidVnBEFlcZZc2awF76aV\n" "f/PO1+OJCO2910ebXBtMSCi++GbDAkEAmc7zNPwsVH4OnyquWJdJNSUBMSd/sCCN\n" "PkaMOrVtINHmMMq+dvMqEBoupRS/U4Ma0JYYQsiLJL+qof2AOWDNQQJAcquLGHLT\n" "eGDDLluHo+kkIGwZi4aK/fDoylZ0NCEtYyMtShQ3JmllST9kmb9NJX2gMsejsirc\n" "H6ObxqZPbka6UA==\n" "-----END RSA PRIVATE KEY-----\n"; unsigned char encrypted_str[128]; unsigned char decrypted_str[128]; // 需要初始化，否则解密出来的字符串会有多余的乱码 memset(encrypted_str, '\0', sizeof(encrypted_str)); memset(decrypted_str, '\0', sizeof(decrypted_str)); size_t len = strlen((const char *)plainText); printf("Encrypted length =%d\n", len); // 公钥加密 int encrypted_length = public_key_encrypt(plainText, len, publicKey, encrypted_str); if (encrypted_length == -1) &#123; printf("Private Encrypt failed\n"); exit(0); &#125; // 私钥解密 int decrypted_length = private_key_decrypt(encrypted_str, encrypted_length, privateKey, decrypted_str); if (decrypted_length == -1) &#123; printf("Public Decrypt failed\n"); exit(0); &#125; printf("Decrypted Text =%s\n", decrypted_str); printf("Decrypted Length =%d\n", decrypted_length); return 0;&#125; 今天到此为止，累了，睡觉了😜。 活着不是靠泪水搏取同情，而是靠汗水获得掌声~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>OpenSSL VS2017 RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中值得说的Handler之更新UI]]></title>
    <url>%2F2019%2F12%2F21%2FAndroid%E4%B8%AD%E5%80%BC%E5%BE%97%E8%AF%B4%E7%9A%84Handler%E4%B9%8B%E6%9B%B4%E6%96%B0UI%2F</url>
    <content type="text"><![CDATA[最近在看电视剧《庆余年》，被调皮的编剧逗得爱不释手，范闲同志从“潜龙勿用”直到大殿醉酒背诵唐诗300首，让众官瞠目结舌，也算是“飞龙在天”了，这一集(第27集)看的那叫一个过瘾。尤其范闲那句“我醉欲眠君且去，去你妈的…”，差点让我喷饭。 推荐大家周末可以看看，算是休闲一下吧！ 简介个人总是感觉 Android中更新 UI 很让人纠结！特此小结一下，算是抛砖引玉。 读这篇文章之前，假设你已经明白多线程、Handler 如何使用。 在文章的最后，附录一张草图，主要用于说明 Handler、Message、MessageQueue、Looper 之间的关系。 更新UI的骚操作1、在 onCreate() 方法中开启线程更新 UI直接上例子，如下： 12345678910111213141516171819public class MasterActivity extends Activity &#123; TextView tv = null; Button btn = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); System.out.println(Thread.currentThread().getName() + ": " + Thread.currentThread().getId()); tv = (TextView)findViewById(R.id.text); /*onCreate中开启新线程，更新UI。没有报错或者异常信息！*/ btn = (Button)findViewById(R.id.btn); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + ": " + Thread.currentThread().getId()); tv.setText("update UI is success!"); btn.setText("update UI is success!"); &#125; &#125;); thread.start(); &#125; 随便折腾，不会报错也不会报任何异常！ 以为开启的线程和 UI 线程（主线程）是同一个线程，但是很不幸，他们的线程id风牛马不相及！ 大家可以查一下 Android 源码，这个主要是因为在加载 Activity 的时候，还没有触发检查单线程的模型（即子线程不可以更新UI）。 如果你不相信的话，可以在上面的线程里面 while true，那么一定会报错的。 2、在 Activity 生命周期方法中更新 UI如 Activity 的 onResume、onStart、反正是以 on 开头的回调方法中在非主线程中更新 UI，实例如下： 12345678910111213@Overrideprotected void onRestart() &#123; super.onRestart(); /*onRestart中开启新线程，更新UI*/ Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + ": " + Thread.currentThread().getId()); tv.setText("update UI is success!"); btn.setText("update UI is success!"); &#125; &#125;); thread.start();&#125; 不好意思，按下返回按钮在启动程序，或者按 Home 键再启动程序，就这么折腾几下，就会包异常！ 异常信息如下： 12UI.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 大概意思是：只有在主线程中才可以进行更新 UI 的操作。 这个时候，大家都应该想到 postInvalidate() 这个方法了。修改实例如下： 123456789101112@Override protected void onRestart() &#123; super.onRestart(); /*onRestart中开启新线程，更新UI*/ Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + ": " + Thread.currentThread().getId()); tv.postInvalidate(); btn.postInvalidate(); tv.setText("update UI is success!"); btn.setText("update UI is success!"); &#125; &#125;); thread.start(); &#125; postInvalidate() 方法，源码： 1234567891011121314public void postInvalidate() &#123; postInvalidateDelayed(0); &#125; public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window if (mAttachInfo != null) &#123; Message msg = Message.obtain(); msg.what = AttachInfo.INVALIDATE_MSG; msg.obj = this; mAttachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds); &#125;&#125; 可以看出，postInvalidate() 本质是使用了 Handler 处理消息的机制！该方法可以在子线程中直接用来更新UI。对应的还有一个方法 invalidate()，稍候再说！ 3、在 Button 的事件中开启线程，更新 UI1234567891011121314151617181920212223public class MasterActivity extends Activity &#123; TextView tv = null; Button btn = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); System.out.println(Thread.currentThread().getName() + ": " + Thread.currentThread().getId()); tv = (TextView)findViewById(R.id.text); btn = (Button)findViewById(R.id.btn); btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + ": " + Thread.currentThread().getId()); tv.setText("update UI is success!"); btn.setText("update UI is success!"); &#125; &#125;); thread.start(); &#125; &#125;); &#125; Sorry，报错！即使你加上 postInvalidate() 方法，也会报这个错误。 1UI.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 4、使用 Handler 结合多线程更新 UIa. 开启一个线程，在 run 方法中通知 Handler b. Handler 中使用 handleMessage 方法更新 UI 5、Handler 和 invalidate 方法结合多线程更新 UI方法 invalidate 主要用在主线程中（即UI 线程中），不可以用于子线程。如果在子线程中需要使用 postInvalidate 方法。 Android 的 API 有说明： public void invalidate () Since: API Level 1 Invalidate the whole view. If the view is visible, onDraw(Canvas) will be called at some point in the future. This must be called from a UI thread. To call from a non-UI thread, call postInvalidate(). 看看该方法源码： 1234567891011121314public void invalidate() &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE); &#125; if ((mPrivateFlags &amp; (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS)) &#123; mPrivateFlags &amp;= ~DRAWN &amp; ~DRAWING_CACHE_VALID; final ViewParent p = mParent; final AttachInfo ai = mAttachInfo; if (p != null &amp;&amp; ai != null) &#123; final Rect r = ai.mTmpInvalRect; r.set(0, 0, mRight - mLeft, mBottom - mTop); // Don't call invalidate -- we don't want to internally scroll // our own bounds p.invalidateChild(this, r); &#125; &#125; &#125; &#125; &#125; &#125; invalidate 方法如果你直接在主线程中调用，是看不到任何更新的。需要与 Handler 结合！ Android 在 onDraw 事件处理绘图，而 invalidate() 函数可以再一次触发 onDraw 事件，然后再一次进行绘图动作。实例代码如下： 12345678910111213141516171819202122232425262728293031323334353637public class MasterActivity extends Activity &#123; static int times = 1; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView( new View(null) &#123; Paint vPaint = new Paint(); //绘制样式物件 private int i = 0; //弧形角度 @Override protected void onDraw (Canvas canvas) &#123; super.onDraw(canvas); System.out.println("this run " + (times++) +" times!"); // 设定绘图样式 vPaint.setColor( 0xff00ffff ); //画笔颜色 vPaint.setAntiAlias( true ); //反锯齿 vPaint.setStyle( Paint.Style.STROKE ); // 绘制一个弧形 canvas.drawArc(new RectF(60, 120, 260, 320), 0, i, true, vPaint ); // 弧形角度 if( (i+=10) &gt; 360 ) &#123; i = 0; &#125; // 重绘, 再一次执行onDraw 程序 invalidate(); &#125; &#125;); &#125;&#125; 经过测试，发现 times 一直在被 ++，说明 onDraw 被多次调用，并且一直在画图！ Android 的 API 有时候让人看的很郁闷很无语…..关于 invalidate 的使用，还待探索。革命尚未成功，同志仍需努力！ 小结附录： Handler、Message、MessageQueue、Looper 之间的关系 这里说明 Looper 使用无限循环取出消息，是有 UI OS 控制的； UI 线程是非安全的，即不要在子线程中更新 UI； Looper 取出来的消息，Handler 可以通过 what、obj 等量来区别分别获取属于自己的消息，所以推荐使用这些内置变量。 天生我材必有用，千金散尽还复来。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: MySQL基本操作]]></title>
    <url>%2F2019%2F12%2F07%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介本篇是 微服务系列 的第 N 篇，从本篇开始我们就要接触和学习数据库相关的知识了。 数据库我们选择 MySQL 数据库，免费且资料多，大部分公司都会使用该数据库。我是在 Windows 10 上面搭建的微服务开发环境，同理，MySQL 数据库也是在这个系统上面安装的并且使用的是 MySQL8.0 版本，如果你还没有安装或者在安装 MySQL8.0 遇到问题可以参考 MySQL8.0.15在Win10上的折腾记 这篇文章。 今天主要跟大家分享如何使用 SpringBoot 结合 JDBC 连接和操作 MySQL 数据库，主要还是以实例为主。 JDBC、ODBC、MySQL Connectors在说实例之前，带大家先了解一下标题中几个名词的概念。 JDBC（Java database connectivity，数据连接），是 Sun 公司编的一堆类和方法，都封装在 java.sql 包中，可以利用这些类和方法来把你的 Java 程序和任意的数据库连通。即通过使用 JDBC，Java 开发人员可以将 SQL 语句传送给几乎任何一种数据库。 对应的还有 ODBC（ Open Database Connectivity， 开放数据库互连），ODBC 是 Microsoft 提出的数据库访问接口标准。开放数据库互连定义了访问数据库 API 的一个规范，Microsoft 的 ODBC 文档是用 C 语言描述的，许多实际的 ODBC 驱动程序也是用 C 语言写的。ODBC 提供了对 SQL 语言的支持，用户可以直接将 SQL 语句送给 ODBC。 JDBC 和 ODBC 都是用来连接数据库的启动程序，两者具有数据库独立性甚至平台无关性。 MySQL Connectors 是 MySQL 数据库的驱动（程序），有对各种语言的支持。mysql-connector-java（也称之为 Connector/J 或者 mysql-connector-jdbc） 是 MySQL-Connectors 的 Java 版本的一个实现 ，用它可以连接 MySQL 系统。 同理，还有 mysql-connector-python、mysql-connector-c、 mysql-connector-ODBC、mysql-connector-jdbc 等，如下图（来自 MySQL Connectors 官网）： 可以使用下面的图简单描述一下JDBC和数据连接的示意图，如下图： 一图胜千言，Java 应用程序可以通过 JDBC 和数据库驱动程序连接、访问、操作数据库（MySQL、Oracle等）。 配置 pom 文件我还是用 Github 代码仓库的例子，大家可以自行 Clone 代码。 打开工程的 pom.xml 文件，增加 mysql-connector-java 和 spring-boot-starter-jdbc 依赖，从上面内容大家应该可以理解为什么要加入这两项了吧！ 12345678910&lt;!--mysql-connector-java--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 等待 Maven 下载完成这两项依赖。 配置 properties打开 application-dev.properties 文件，增加如下内容： 1234567891011# jdbc# spring.datasource.driver-class-name=com.mysql.jdbc.Driver# JDBC spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 连接的数据库# spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mzc_userspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mzc_user?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名spring.datasource.username=root# 数据库密码spring.datasource.password=pwd123 其中 mzc_user 是我创建的数据库文件名称，大家要根据自己的实际情况做相关的修改。配置 properties 注意以下几个问题。 1、spring.datasource.driver-class-name 的配置如果配置值为 com.mysql.jdbc.Driver，会报下面的警告： 123Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 意思是这个类已经过时了，请使用最新的 jdbc.driver 修改数据源配置，如下： 1spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 2、spring.datasource.url 的配置关于这个url 的配置，官方有更加详细的配置说明，可以参考 Connection URL Syntax 和 Configuration Properties 两篇文档。 如果配置为 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mzc_user，会一直报如下错误： 12The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决这个问题，有如下3种解决方案。 1、指定时区 12// 北京时间东八区serverTimezone=GMT%2B8 注意，%2B 是 + 的编码格式。如果你设置 serverTimezone=UTC，连接不报错， 但在用java代码插入到数据库时间的时候却出现了问题。 比如在 Java 代码里面插入的时间为 2018-06-24 17:29:56，但是在数据库里面显示的时间却为 2018-06-24 09:29:56，这样就有了8个小时的时差。UTC 代表的是全球标准时间 ，而我们使用的时间是北京时区也就是东八区，领先 UTC 八个小时。 12345// 京时间东八区serverTimezone=GMT%2B8// 或者使用上海时间serverTimezone=Asia/Shanghai 2、修改 MySQL 配置文件 我在 Windows 10 找到 MySQL 配置文件 my.ini ，如果你没有找到可以参考 MySQL8.0.15在Win10上的折腾记 这篇文章，非 Windows 系统可能配置文件时 my.cnf。 在配置文件中，增加默认时区配置： 1default-time-zone=&apos;+08:00&apos; 在 my.ini 或者 my.cnf 文件的 [mysqld] 下面增加上面配置，示例如下： 123456789[mysqld]# Set default time-zonedefault-time-zone=&apos;+08:00&apos;# The TCP/IP Port the MySQL Server will listen onport=3306# ... 修改配置文件之后，重启MySQL服务就可以了。 3、修改数据库， 配置全局时区 切换到名称为 mysql 的数据库，然后执行下面的语句： 1234show variables like '%time_zone%';# 设置全局时区，即时生效，作用于所有sessionset global time_zone='+8:00'; 设置完成后，可以使用 show variables like &#39;%time_zone%&#39;; 看看是否修改成功。 你也可以执行，但是只能对当前的 session 生效，示例如下： 12# 设置当前session时区，即时生效，但仅作用于当前sessionset time_zone='+8:00'; 我个人使用的是上述中的第1种方法，我也推荐大家使用这种方法，简单且无副作用。 这里有一篇坑记 jdbc mysql connector 6 时区问题，关于设置 time_zone 的坑，大家可以看看。 万事俱备，只欠代码配置完成之后，我们可以写点测试代码了。 本节的代码主要集中在 MSUserService、MSUserServiceImpl、MSDBTests 中，其中 MSUserService 是接口，定义了一些数据库操作的方法，如下： 123456789101112131415import java.util.List;import java.util.Map;public interface MSUserService &#123; int createUser(MSUser user); int deleteByUid(Integer uid); List&lt;Map&gt; queryUserByUid(Integer uid); List&lt;Map&gt; queryUserByUserName(String userName); int deleteUserTable();&#125; 而 MSUserServiceImpl 则是 MSUserService 的实现类， MSDBTests 主要是测试类，用来测试操作 MySQL 数据表的如创建表、查询、删除等操作。大家自行 Clone 代码去看实现即可，我就不在这里占用篇幅贴代码了。 在本节代码中，新增加了两个注解的使用即 @Service 和 @Slf4j，@Slf4j 这个注解主要用来简化使用日志。而 @Service 注解承担了两个职责一是 Bean 的创建，二是将一个类标识为一个服务。后续我会再深入跟大家分享 @Service 这个注解，目前你只需要用上它就可以了。 在本节的例子中，用到的数据表（user）的数据结构大概如下： 启动 MySQL 服务，然后启动 MSDBTests 中的测试代码，就可以看到实际效果了。 1234567891011121314151617181920212223242526@Testpublic void createUserSQLTest() &#123; MSUser user = new MSUser(); user.setUserID(1); user.setAccountName("mzc"); user.setAccountPwd("123"); user.setNickName("veryitman"); user.setMotto("foo"); user.setAge(25); user.setGender(MSUser.GENDER_MALE); user.setPhone("17122036530"); // 增加user数据 msUserService.createUser(user);&#125;@Testpublic void queryUserBySQLTest() &#123; // 根据user_id查询 List&lt;Map&gt; userJson = msUserService.queryUserByUid(1); logger.info("MSBlog Test, userJson by query user's id: " + userJson.get(0)); // 根据user_name查询 userJson = msUserService.queryUserByUserName("mzc"); logger.info("MSBlog Test, userJson by query user's name: " + userJson.get(0));&#125; 今天就分享到这里，下次结合登录注册例子操作 MySQL 数据库。 做事情，不问能不能做成，要问应不应该做。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>MySQL JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短地址原理]]></title>
    <url>%2F2019%2F11%2F24%2F%E7%9F%AD%E5%9C%B0%E5%9D%80%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介一个同事遇到一个问题，他说受限于第三方的服务，自己请求所带过去的字符串因为太长，无法从第三方服务获取信息，很是苦恼😴。后来我们商量了一下，最终借鉴短地址的思想解决了问题。道理很简单，因为我们请求中的附加字符串信息第三方服务只是透传回来给我们，我们只需要把这些附加信息进行字符压缩就可以了，这样请求带过去的字符串长度就满足了要求😊。 无论是写文章还是制作一些表格的时候，我会时常用到短地址。短地址的优势在于其短（字符少）、简洁，方便书写又不占位置。方便在社交网络和第三方平台上分享链接，投放广告。比如有人会在发朋友圈的时候带上短地址，还有一些营销短信里面也会带一些短地址链接。 有现成的短地址生成器，常用的短地址转换有 百度短网址转换、Google短网址转换 和 新浪短地址转换，可惜的是谷歌关闭了该服务，官方发言如下： 12345On March 30, 2018, we turned down support for goo.gl URL shortener. From April 13, 2018, only existing users were able to create short links on the goo.gl console.Analytics data was available for up to one year, until March 30, 2019, when goo.gl was discontinued. Previously created links will continue to redirect to their intended destination. Please see this blog post for more details. 我经常使用百度的短地址服务，在国内访问它是最快的也能满足我的工作和学习需求，它也提供 API 服务可以参考 短网址生成接口文档 学习和了解。 我们先来了解一下 HTTP 协议中那些重定向的事。 HTTP 请求重定向HTTP 中的 301、302、303、307、308 响应状态码，都表示重定向的响应。 其中，301、308 响应状态码表示永久重定向，302、303、307 表示临时重定向。 那我们来说一下什么是重定向？ 重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。 举个例子，你要去 A 机构办理一个证件，等你去了之后A机构的某人告诉你他们不再受理此事了，需要你去 B 机构办理，然后你就自己去了 B 机构。这个过程就类似于重定向。 那么，HTTP 协议中定义的这些30X响应状态码就好比 A机构的某人 它们告诉客户端，你需要访问另外一个地址了。 重定向做了两次 HTTP 请求， 第一次，客户端请求 A 服务器，A 响应告诉浏览器，你应该去 B 服务器访问。此时就去访问服务器 B，这个时候你可以看到浏览器中的网址变了，这就是第二次 HTTP 请求。 重定向过程： Step-1、浏览器（客户端）发送 HTTP 请求； Step-2、Web服务器A接收后发送 302 状态码响应，并在响应头中把对应的 Location 给浏览器； Step-3、浏览器收到服务器返回的 302 响应码，就自动再发送一个新的 HTTP 请求（请求URL是新的 Location 中的地址）； Step-4、Web服务器（可能是 A 也可能是其他服务器）根据此请求寻找资源并发送给浏览器，最终展示给用户。 关于 Location 可以看下面的截图（这是一个重定向的 HTTP 请求示例），它是被放在响应头中的，其值是需要重定向的网址 http://www.veryitman.com，从这个过程来看可以看出重定向是客户端（浏览器）行为。 还有个叫转发的技术，这个和重定向是不一样的，转发是服务器行为，还拿上面的 A 机构例子来说，你要去 A 机构办理一个证件，等你去了之后 A 机构的某人告诉你他们不再受理此事了，但是 A 机构可以自己协调资源帮你完成而不需要你去其他机构办理了。这个过程就类似于转发。 模拟重定向现在使用 SpringBoot 模拟一下重定向，我用的 SpringBoot 是 2.2.0.RELEASE 版本。 ①、新建 SpringBoot Web 工程，可以参考 微服务-想办法让项目运行起来 这篇文章。 ②、修改 pom 文件，增加 fastjson，示例如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; ③、新建 MSTestRedirectController 文件，源码如下： 1234567891011121314151617181920212223import com.alibaba.fastjson.JSON;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;@Controller@RequestMapping(value = "testredirect")public class MSTestRedirectController &#123; @GetMapping(value = "/access/web") public String redirect() &#123; return "redirect:/testredirect/index/realweb?parameter=coming"; &#125; @ResponseBody @GetMapping(value = "/index/realweb") public String real(HttpServletRequest request) &#123; return "redirect happened：" + JSON.toJSONString(request.getParameterMap()); &#125;&#125; 这里要注意几个问题： 既然是重定向，该 Controller 不能使用 @RestController 注解而要使用 @Controller 注解； 这里使用了关键字 redirect 实现重定向； ④、启动工程，并在浏览器访问下面的网址 1http://localhost:8080/testredirect/access/web 可以看到浏览器发生了重定向，截图如下： 除了上面的方法可以实现重定向外还可使用 HttpServletResponse 的 sendRedirect 方法，示例如下： 12345678910111213141516@GetMapping(value = "/access/web2")public String redirect2(HttpServletResponse response) &#123; try &#123; // 方法1：自定义状态码方式 // String url = "http://localhost:8080/testredirect/index/realweb?parameter=coming"; //response.setHeader("Location", url); //response.sendError(301); // 方法2：sendRedirect，默认返回的状态码是 302 response.sendRedirect("/testredirect/index/realweb?parameter=coming"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; return ""; &#125;&#125; 请求短地址过程我拿网址 http://www.veryitman.com/ 来举实例，使用百度短地址服务。 在 百度短地址页面 去生成 http://www.veryitman.com/ 对应的短地址，如下图所示： 得到短地址是 https://dwz.cn/hnmau4Zs 复制该地址拷贝到浏览器（我用的是 Chrome 浏览器）的地址栏中，并打开 Chrome 的审查视图。切换到 Network 选项，此时回车打开短网址。 HTTP 发送了 GET 请求（红色1），请求地址是 https://dwz.cn/hnmau4Zs ，服务器（百度的短地址服务）返回给 Chrome 浏览器 302 状态码，浏览器发现是该重定向码就再次用 Location 里面包含的地址发送了第二次请求即重定向请求。 你也可以使用微博的短地址服务，提醒一点，微博的短地址请求返回码是 301 而百度返回的是 302 响应码。302 状态码允许各种各样的重定向，一般情况下都会实现为到 GET 的重定向，但是不能确保 POST 会重定向为 POST，302 表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B；而 301 状态码表明目标资源被永久的移动到了一个新的 URI，任何未来对这个资源的引用都应该使用新的 URI。 短地址原理刚开始我很好奇，为什么我把长地址 A 转换为短地址 B，然后用 B 去访问居然还是 A 地址的内容，浏览器是怎么做到的？ 通过上面的请求过程示例，相信大家应该大概理解了请求短地址的原理了。 在百度短地址服务中，我们将 http://www.veryitman.com/ 转换为 https://dwz.cn/hnmau4Zs ，此时百度短地址服务维持了 短-长 地址的映射关系了而且是唯一的，当我们去访问 https://dwz.cn/hnmau4Zs ，其实请求的是百度短地址服务，该服务将短地址对应的长地址（放在响应头的 Location 中）返回给我们的浏览器，并返回 302 状态码，此时浏览器就重定向到了 http://www.veryitman.com/ 这个网址上了。 简单总结一下其步骤如下： Step-1、用户在浏览器里输入 https://dwz.cn/hnmau4Zs 这个网址去访问; Step-2、浏览器解析 DNS，获取该域名对应的 IP 地址; Step-3、获取到 IP 后，浏览器发送 HTTP GET 请求查询 hnmau4Zs 并获取到 https://dwz.cn/hnmau4Zs 对应的长地址; Step-4、HTTP 通过 302 状态码转到去请求对应的长地址 http://www.veryitman.com/ 上面了。 我把 http://www.veryitman.com/ 放到百度和微博的短地址生成分别是： 12// 百度短地址https://dwz.cn/hnmau4Zs 12// 微博段地址http://1t.click/aMtD 可以看出百度生成较复杂，首先协议变成了 HTTPS，其次生成代码是 8 位（hnmau4Zs），而微博生成的是 4 位（aMtD）代码。 短地址码一般都是由26个大写字母 A-Z 、26个小写字母 a-z 和10个数字 0-9 共62个字符随机组合而成，那么可以这样来生成短地址码，我们定义一个62进制，把这62个字符按照10进制数转成62进制数，那么就可以得到每个字符对应的62进制数了。同理，将短地址还原的时候把62进制转换为对应的10进制就可以了。 根据上面算法，可以看出百度可以支持 62^8 个短地址，微博可以支持 62^4 个短地址。 关于短地址生成的算法，大家可以用SpringBoot自己撸一个或者去网上找找别人已经实现的。 活着不是靠泪水搏取同情，而是靠汗水获得掌声~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Short-URL SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL: 完成VS2017的配置]]></title>
    <url>%2F2019%2F11%2F23%2FOpenSSL-%E5%AE%8C%E6%88%90VS2017%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介在 OpenSSL: 用VS2017创建C工程 中跟大家分享了如何在 Visual Studio 2017 中创建 C 工程和注意事项以及遇到问题的解决方案，今天我们开始在 Visual Studio 2017 中搭建 OpenSSL 的开发环境。 很多人在配置 OpenSSL 环境中遇到了不少问题，甚至还有放弃的。说实话，我也差点奔溃了:(，配置这些鬼东西确实有点复杂，说一句沃茨奥一点也不过分。 希望这篇文章能和你不期而遇，能够帮到你！写文不易，如果文中有任何错误之处还望大家不吝赐教。 下载OpenSSL使用 OpenSSL 有两种方式，一是自己下载其源码按照配置去编译，然后使用编译后的库；另一种是使用别人已经编译好的库文件。 我使用的是第二种方法，在 precompiled-openssl 下载的 OpenSSL Library，下载完成后，解压。 设置VS2017 下面分几个步骤完成设置。 1、拷贝文件到工程中在工程目录下面新建 vendor-openssl 目录，用来存放 OpenSSL 的头文件和库文件，便于管理，你也可以取个其他的名称。 进入解压后的 openssl-1.1.0f-vs2017 目录，复制 lib64 和 include64 到 vendor-openssl 目录下，如下图所示： 2、添加OpenSSL头文件打开工程的属性设置，打开方法如下： 按照上述截图的1、2、3、4点击 Edit，出现下面的编辑框，如下图： 选择 include64目录，如下截图所示： 点击OK即可完成头文件的添加。 3、添加OpenSSL库路径同理，打开属性设置，然后选择 Linker/General，如下图所示： 点击Edit，选择 OpenSSL 的库路径，如图： 4、添加库名称同理，打开属性设置，在 Linker/Input 中设置，如图： 点击Edit，输入下面库的名称（编译后的OpenSSL库文件）： 书写完每一个都要换行继续写下一个库名称，直到写完为止，如图： 点击弹框的OK按钮，关闭所有弹框。 base64编解码在资源管理器视图中，新建源文件，分别添加 mzc_base64.h、mzc_base64.c 和 main.c 三个文件，如下图： 这里我只给出测试的代码(main.c源码)，具体的编解码代码，大家可以去 GitHub 查看。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include "mzc_base64.h"int main()&#123; //Encode To Base64 char *base64EncodeOutput; //Take the web's url of my blog as example:http://veryitman.com char *text = "http:\/\/veryitman.com"; mzc_base64_encode(text, strlen(text), &amp;base64EncodeOutput); printf("Base64 encode output: %s\n", base64EncodeOutput); //Decode From Base64 char* base64DecodeOutput; size_t test; const char *base64Encode_str = "aHR0cDovL3ZlcnlpdG1hbi5jb20="; mzc_base64_decode(base64Encode_str, &amp;base64DecodeOutput, &amp;test); printf("Base64 decode output: %s %d\n", base64DecodeOutput, test); return 0;&#125; 在 Visual Studio 2017 中使用快捷键 Ctrl+F5 运行工程报错，报错如图： 需要拷贝 openssl-1.1.0f-vs2017 目录中的bin64里面的内容： 把这些文件放到可执行文件的目录中，如图： 再次 Ctrl+F5 就可以正常执行了。 注意：点击 源码文件 可以获取本文的代码。 活着不是靠泪水搏取同情，而是靠汗水获得掌声~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>OpenSSL VS2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL: 用VS2017创建C工程]]></title>
    <url>%2F2019%2F11%2F23%2FOpenSSL-%E7%94%A8VS2017%E5%88%9B%E5%BB%BAC%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介该系列文章给大家（主要是刚接触Visual Studio工具的C开发者）带来使用开发工具Visual Studio 2017进行OpenSSL编程，包括base64，AES、DES和RSA加解密等内容。 对于C/C++的编程，我工作之后基本都是在Linux上面写，很少在Windows上面耕耘。最近收到几个小伙伴的邮件，有请教如何在Windows上面进行C编程的，也有问关于OpenSSL的基础知识的。说实话我也不是很熟悉Windows上面的C编程，但凭借着一股自信还是硬着头皮实践了一把，算是给大家一个交待。 在这里非常感谢网名为“为C奋斗”的建议，也感谢网上开源代码的作者们，如果没有他们的贡献，我可能根本坚持不下来把这些知识做以总结和分享。 写文不易，挑灯夜战，如果文中有任何错误之处还望大家不吝赐教。 该系列文章中相关代码我都托管在Github上面了，点击 c-openssl 可以获取。 创建C工程 这部分介绍如何在Visual Studio 2017中创建C工程。 打开Visual Studio 2017，选择File/New/Project...，紧接着完成下面截图中的步骤即可完成工程创建。 点击OK稍等几秒就可以完成工程的创建，创建成功之后，该工程是一个空工程没有任何源文件，如图： 创建C文件 该部分介绍如何在工程中手动创建C文件。 需要手动创建C源码文件，右键点击 Source Files 注意：源码后缀是.c，不是.cpp. 创建完成后，打开 mzc_base64.c 写上一段简单的代码，测试一下是否正常。 12345678#include &lt;stdio.h&gt;int main()&#123; printf("Hello OpenSSL, I'm coming.\n"); return 0;&#125; 直接使用快捷键 Ctrl+F5 运行程序，可以看到弹出了系统的命令行并显示运行结果，截图如下： 至此在Visual Studio 2017中成功创建了C工程 =:） 遇到的问题有不少小伙伴跟我说，他们在创建的过程中遇到了这样或者那样的问题，我总结了一下分享给有需要的人。 1、没有找到Windows Desktop选项这种情况应该是没有在 Visual Studio 2017 中安装桌面开发组件，如图操作： 打开 Visual Studio Inistaller 安装通用Windows平台开发组件，如图： 安装完成后，再重新创建工程就有了该选项。 2、编译错误，找不到printf函数出现这种错误，大部分原因是没有安装 Windows10 SDK。打开 C:\Program Files (x86)\ 目录，看看是否有 Windows Kits 目录。 如果没有，就点击 Windows10 SDK 下载，安装完成后，重新创建工程就可以了。 如果有该目录，在工程属性中设置一下，如图： 打开属性视图，如下： 配置你正确的 Windows10 SDK 目录即可，我安装的是下面的版本： 3、无法访问头文件点击系统库的头文件，显示如下提示： 在头文件上面右键，可以看到跳转的几个选项都是不可用的状态，如下图： 出现这样的情况不要怕，这是VS的病，只能等Microsoft去根治了。我们使用 Open Document 代替，快捷键是Ctrl+Shift+G，一样可以打开对应的头文件。 生命不是要超越别人，而是要超越自己~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>OpenSSL VS2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL8.0.15在Win10上的折腾记]]></title>
    <url>%2F2019%2F11%2F10%2FMySQL8-0-15%E5%9C%A8Win10%E4%B8%8A%E7%9A%84%E6%8A%98%E8%85%BE%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装和配置 MySQL我在 Windows 10 上面使用 MySQL Instller 安装的 MySQL-8.0.15，安装完成后，启动和使用 MySQL 遇到了不少问题，特此记录踩坑记。 只要你的网络稳定，按照默认安装，整个安装过程还算顺利。 安装过程中需要设置密码，我设置的账号和密码都是 root，所以下面的操作都是基于这个账号和密码进行的。 安装完成后，将 mysql server 的 bin 目录加入到系统的 path 变量中去，如图： 系统环境变量 path 中加入 %MySQL_Home%\bin 即可。 加入成功之后，就可以使用 mysql 命令了。 题外话，我们在命令行使用的 mysql 命令其实是对应 MySQL Server 8.0\bin\mysql.exe，可以使用 where 命令看一下其可执行文件的位置，如下： 12$ where mysqlC:\Program Files\MySQL\MySQL Server 8.0\bin\mysql.exe 同理， mysqld 命令对应的是 mysqld.exe可执行文件。 查看安装的 mysql-server 版本，可以执行下面的命令： 1mysql --version 可以得到下面的输出，可以看出当前版本是 8.0.15: 1C:\Program Files\MySQL\MySQL Server 8.0\bin\mysql.exe Ver 8.0.15 for Win64 on x86_64 (MySQL Community Server - GPL) 我用的命令行终端工具是 Git bash（安装Git客户端就自带该工具，个人觉得挺好用的，[嘿哈]）。 用管理员身份运行 Git bash，然后在该终端工具中执行如下命令： 1mysqld --install 如果不用管理员身份运行终端的话，会报类似下面的错误： 1Install/Remove of the Service Denied! 运行成功的话，可以看到如下提示： 1Service successfully installed. 再次启动 MySQL80，一定要用管理员身份启动终端，否则会报 发生系统错误 这样的错误（如果你是使用管理员身份启动终端的还是报这个错误，也有可能是该服务已经启动了），执行： 1net start MySQL80 注意：这里使用的是 MySQL80，这个是服务的名称 （安装时候我设置的服务名称） ，不是 mysql，下面会讲解为什么这样做，如果你没有这个 MySQL80 服务只需要启动名称为 mysql 的服务即可。 如果出现类似 “MYSQL 服务无法启动” 的提示，可以在 Windows 的任务管理器中找找是否已经启动了 mysqld 服务，可以手动关闭后再来启动。 如果始终启动失败，可以执行下面的命令： 1mysqld --initialize 启动成功后，显示如下： 12MySQL80 服务正在启动 .MySQL80 服务已经启动成功。 可以使用下面命令查看是否成功启动 MySQL80 服务，如下： 1netstat -aon|findstr "3306" 看到如下提示表示启动成功，如下： 12345TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 10344TCP 0.0.0.0:33060 0.0.0.0:0 LISTENING 10344TCP [::]:3306 [::]:0 LISTENING 10344TCP [::]:33060 [::]:0 LISTENING 10344TCP [::1]:3306 [::1]:56962 TIME_WAIT 0 登录 MySQL80 服务，执行如下命令： 123$ mysql -uroot -prootmysql: [Warning] Using a password on the command line interface can be insecure.ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES) 很不幸的是，登录失败（ERROR 1045）。 那我们就来解决这个问题，这个版本的 MySQL 和之前的 8.0.x 版本解决方案不同，网上找过很多解决方案有修改配置文件的，忙了半天还是没有搞定，最后在 StackOverflow 上面找到方案，结合个人实践总结了一下，还烦请大家务必往下看。 解决登录 MySQL 受限在看下面内容之前，务必完成文中前面说的步骤，否则下面的内容对你来说没有太大价值。 新版本的 MySQL 加强了安全方便的因素，所以使用新版本比较费劲，如果你不想折腾，可以安装 MySQL 的 5.x 版本。 Step-1：停止 MySQL80 服务 使用快捷键 win+R 输入 services.msc，打开如下视图并找到 MySQL80 服务： 停止 MySQL80 服务，或者在命令行执行 net stop MySQL80 命令。 Step-2：另一种方式启动 MySQL80 服务 使用管理员身份运行终端1，并执行： 1mysqld --console --skip-grant-tables --shared-memory 此时可以成功启动 MySQL80 服务，但是在 Windows 的服务中是看不到的，不用理会。继续。 Step-3：启动另一个终端2 上述步骤启动完成后，再用管理员身份运行另一个 Windows 的终端2(CMD)，用系统自带的或者 Git Bash 都可以，但是如果使用 Git Bash 的话，必须在登录mysql 的时候使用 winpty（Git Bash自带的工具）命令，否则登录会卡住不动。命令使用如下： 1winpty mysql -uroot -proot Step-4：终端登录 mysql 执行下面命令登录服务： 1mysql -u root -p root 如下图可以登录成功，如下截图： Step-5：置空密码 在上述命令行状态下，执行： 123use mysqlupdate user set authentication_string='' where user='root'; Step-6：退出 mysql 服务 1quit Step-7：关闭 mysqld 启动的 MySQL80 服务 需要关闭以 -console --skip-grant-tables --shared-memory 启动的 MySQL80 服务，直接在终端1中 ctrl+c 即可。 Step-8：启动 MySQL80 服务 使用Step-1步骤中的方式打开 Windows 的服务启动或者在终端1中执行 net start MySQL80 启动 MySQL80 服务。 Step-9： 无密码登录 mysql 在步骤 Step-5 中已将密码置空，现在可以无密码状态登录 mysql 服务，输入登录命令： 1mysql -u root -p 登录成功后，修改密码（永远不过期的密码）执行： 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'newpwd123' PASSWORD EXPIRE NEVER; 我把原来的密码修改为 newpwd123，你可以根据自己的爱好设置为其他的密码。 如果在此步骤出现类似下面的错误: 1ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement 请执行下面的SQL语句，如下命令： 1flush privileges; Step-10：退出 mysql，重新登录 退出 mysql，然后重新使用修改过的密码登录 mysql，完事。 MySQL配置文件？这也是个神奇的问题，最后在 MySQL 的官方手册里找到了 Answer。 在 Windows 系统中 C 盘有个隐藏的文件夹，我们来揭开它的神秘面纱。 打开 C 盘文件，按照下面1、2、3顺序就可以看到 ProgramData文件夹，如下： 进入该文件夹，就可以看到 MySQL 的配置文件，如下： 上面我们已经说过，启动 MySQL80 服务就默认使用的是该配置文件，可以在 Windows 服务中点击 MySQL80 查看其属性，可以看到下面的描述： 12可执行文件的路径：C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld.exe" --defaults-file="C:\ProgramData\MySQL\MySQL Server 8.0\my.ini" MySQL80 其中，--defaults-file=&quot;C:\ProgramData\MySQL\MySQL Server 8.0\my.ini&quot; 就是指定配置文件路径的。 而在 Windows 服务中点击 MySQL，看到的属性是这样的： 12可执行文件的路径："C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld.exe" MySQL 并没有指定配置文件，这也是为什么让大家启动的时候执行 net start MySQL80 的原因。 顺便修改一下配置文件，把默认编码改为 utf-8，如下配置（记得是在[client]和[mysql]标签下）： 1234567891011[client]# pipe=# socket=MYSQL# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8[mysql]no-beep# 设置默认编码default-character-set=utf8 还有奇葩的错误 会持续记录各种奇葩错误。 1、ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061) 登录 mysql 服务，报上面的错误，说明没有启动成功 MySQL80 服务，最大的可能是你修改了配置文件要么是格式错了要么是配置的东西 mysql 不认。 只能把配置文件修改正确才能启动服务。 我们要学会做自己精神领域内的君王，不要成为别人情绪世界里面的奴隶。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>MySQL Win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 部署服务]]></title>
    <url>%2F2019%2F10%2F31%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[简介在 微服务系列 文章中，跟大家从环境搭建、Web工程创建、提供Restful接口、热部署、Git使用以及Swagger生成文档分享了SpringBoot的入门知识。今天继续分享如何使用IDEA和maven对工程进行打包操作，然后发布代码到服务器进行部署的过程。 大家有任何问题，或者文中有不正确的地方欢迎留言评论，共同进步，再次感谢大家的阅读。 IDEA 打包在 File/Project Structure 打开视图，或者使用快捷键 Ctrl+Alt+Shift+S 打开视图。 打开的视图如下： 按照 1、2、3 步骤打开下面视图，如下： 配置该视图的内容，分别设置 Main Class 和 选择 JAR files，如下： 这里特别要注意，选择生成 MANIFEST.MF 文件目录放到 resources 下面，默认会放在 main\java 目录下。 如果不修改这个目录，最终运行生成的 jar 文件，会报下面的错误： 1Invalid or corrupt jarfile &#123;project_name&#125;.jar 配置完成后，点击 OK 关闭对话框即可。 接下来需要编译，点击 IDEA 的 Build 菜单，选择 Build Artifacts...，如下截图： 点击 Build Artifacts... 后出现视图 第一次直接选择 Build 选项，后续可以选择 Rebuild 或者 Clean 选项，根据你的需要进行选择即可。 等待 IDEA 打包完成后，在工程文件中会生成 out 目录和 resources 目录下面生成 META-INF 目录和对应的文件，如下图所示： 在 springboot_jar 目录下面有打包成功的 jar 文件，即 springboot.jar 文件，另外也将 tomcat 等一些其他依赖包都打包到一起了。 打开终端，执行 java -jar springboot.jar 就可以运行该项目了。 如果发现由于端口被占用而无法启动的情况，可以查看端口占用情况： 1netstat -ano | findstr 8080 查到类似如下结果： 12TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 18948TCP [::]:8080 [::]:0 LISTENING 18948 这里演示的进程ID是 18948，强制关闭端口进程即可 1taskkill -F -PID 18948 部署到服务器我使用虚拟机（Ubuntu）来简单介绍一下部署过程。虚拟机是 VMWare 其版本是 15.0.2，Ubuntu 系统版本是 19.04。如何安装虚拟机、如何在虚拟机中安装 Ubuntu 系统以及如何在 Ubuntu 中安装 Java 环境请大家自行查找资料完成，这里不赘述。 可以通过上面的方式（IDEA打包）完成后，将生成的 springboot_jar 目录拷贝到虚拟机的用户目录下，然后通过 java -jar springboot_jar/springboot.jar 来启动服务。 我们还可以通过 IDEA 的 maven 工具进行打包，步骤如下： 1、打开工程的maven视图 2、按照标红的1、2、3、4操作即可 成功后在 target 目录会生成对应的可执行的 jar 文件，该 jar 包包括了所有的 SpringBoot 相关的包如下图： 同理，复制 springboot-0.0.1-SNAPSHOT.jar 到虚拟机的用户目录，通过 java -jar springboot-0.0.1-SNAPSHOT.jar 运行服务即可。 查看 Ubuntu 的主机IP地址，可以通过 ifconfig 来获取，也可以在设置里面查找其IP地址。 ifconfig 需要按照 net-tools，安装命令如下： 1sudo apt install net-tools 我的虚拟机的IP地址是 192.168.142.128，即 http://192.168.142.128:8080 是 Ubuntu 的 IP 地址和 Tomcat 的运行端口，回到 Windows 主机上面访问虚拟机的服务，通过下面图可以看出是成功的。 这里只是简单的介绍了一下如何将自己写的 SpringBoot 服务部署到服务器上面，在你的实际项目中部署没这么简单，我算是抛砖引玉吧，后续随着学习的深入我再跟大家分享一下在实际大项目中部署遇到的一些问题。 生活并没有那么复杂，要是你喜欢，大可以说我是在探索生命。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot mvn package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看《银河补习班》有感]]></title>
    <url>%2F2019%2F10%2F26%2F%E7%9C%8B%E3%80%8A%E9%93%B6%E6%B2%B3%E8%A1%A5%E4%B9%A0%E7%8F%AD%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[简介写这个话题，情不自禁的想起上学考试的作文题目，既有字数限制又要能表达中心思想，好不容易吭哧吭哧地写完了，结果作文分数也不一定理想，毕竟老师的心情指数变幻莫测。 看完电影《银河补习班》心中五味杂陈，想想自己陪孩子的时间屈指可数，从他出生到现在已经7个多年头了，大部分时间都是他妈妈陪着，我这个做父亲的跟马皓文比起来不止差一个银河系。 电影中搞笑片段不算多但恰到好处，马飞母亲的扮演者任素汐（看过他主演的电影《驴得水》，冷幽默风格的一部电影）和马飞后爹的扮演者梁超戏份不多但几乎担当了电影中搞笑的全部内容。特别是梁超那句 “儿子，你别的不多，就是爸爸多”，让人即感动又好笑。我相信每个人的上学生涯中都会遇到类似“闫主任”这样角色的老师，严厉的像个自私鬼，在片中简直就像一个名副其实的大反派，那句“莫名其妙、荒谬绝伦”搭配闫主任的短裤简直绝了。 电影的剧情有点理想化，但里面的很多道理值得我们去学习和反思，这是一部送给儿子和父亲的电影。 重要的是让孩子看你做什么很多朋友觉得我的字写的还算不错，高中时候我的确经常参加书法比赛也拿过很多名次，但是我总是感觉自己的字写的很一般还需要更加努力。所以上学的时候只要有写字的机会我就会利用上，比如出黑板报，帮老师在黑板上面抄题，这些活我都很乐意干。后面参加工作了，自己也保持着写日记的习惯，用笔在笔记本上面写出来的字感觉特别亲切，那些字就好比有温度的灵魂。 在写字方面特别要感谢我的父亲，记得刚上初中那会，父亲从外地打工回来特地给我买了一本字帖，最让我感动的是他刚下车就亲自送到学校来了，一直倔强且不善于表达爱的他递给我字帖的那一刻，我才明白真正的爱不是经常挂在嘴边的而是在心里在行动上，请相信不管一个多平凡的爸爸，都会以自己的方式爱你。父亲的字写的比我好，那时候我就树立了一个目标：“将来一定要像父亲一样，把字写好，不能给他丢人“，现在想想自己挺幼稚的。 电影里面有个片段，深夜里马飞突然睡醒了，看到还在工作的马皓文说：“爸爸，我可以不睡觉吗？”，马皓文说：“那是你自己的事，以后这种事不用问我”。 每个人都会经历初为人父人母，难免自己也会犯下一些错误，就像电影里面马皓文对自己的儿子马飞说：“对不起！爸爸也是第一次做爸爸”，看到这里我不禁潸然泪下，感觉特别真诚。我和老婆约定一定不要在孩子面前吵架，不要在孩子面前随便发脾气，如果那样做了会给他们心灵上面造成一定的伤害，孩子们的学习模仿能力都比较强，大人的坏脾气会影响到孩子。周末有时间，我都会故意在孩子面前看书，他看我看的那么认真也忍不住过来凑热闹，时间久了他也爱上了看书，他的第一个书架就是这么来的，书架上面的书有些是图书馆借来的，有些是我和老婆买给他的，有些是他和其他小朋友换来的。 一定要做自己做喜欢的事情 今年国庆节放假当天，我六点半起床准备做早餐，发现儿子一个人坐在客厅写作业，我当时惊呆了，这小子怎么这么早就起床了居然还在写作业，如果按照我以前的脾气一定会批评他。就悄悄走过去，轻轻的拍拍他的肩膀说：“你怎么这么勤奋呀？”，他头也不回的说：“今天你不是要带我去玩吗，我想先把作业写完”，我忽然一愣，原来我有过这个承诺，我说：“行，你写完之后给我检查一下，如果问题不大我们今天就早早出发”，他自信的说：”没问题“。 小的时候家里比较贫寒，我又比较喜欢读书，白天除了上学外其他时间几乎都需要帮助父母干农活，也只有晚上有时间来读书和写作业。北方的冬天很冷，有时候连电我都舍不得用，偷偷的点上蜡烛，母亲经常半夜起来看我，她也没有说我什么，只是告诉我不要太晚了，后来她还给我准备了一个小火炉。每次考试结果不管是好还是差，她总是告诉我要继续努力。如果你已经是一名学生的家长了，看到孩子在努力不要轻易打断他，你只需要鼓励和支持Ta就好了。喜欢电影中的一句台词：“孩子都有一个神奇的感受器，能知道你是不是真的爱TA”。 现在社会竞争压力确实很大，父母为了孩子也是操碎了心，担心孩子将来怎么办，于是各种学习资料，补习班把孩子压得气喘吁吁。作为父母不督促孩子学习和进步，是我们的失职，但是过度的压迫孩子就是在犯罪，每个孩子都有自己的爱好和梦想，我们应该教导他要努力去实现自己的目标，而不是告诉他你只有考上清华北大才能继续自己的人生，就像电影里面说的： “你有没有想过长大要干什么”？ “清华北大啊，妈妈说的”。 “清华北大只是过程，不是目的”。 “等你长大了一定要做自己喜欢的事情”。 只有做自己喜欢的事才有可能创造奇迹！ 需要独立思考的能力我家那个小子很喜欢拼图，喜欢一个人默默无闻的在房间拯救各种卡片，仿佛只有他才能让散装的奥特曼复活。每次拼装完成他都要过来炫耀一番，当然我也会给他一个大大的赞。 我们在网上买一些东西，只要他在家他都会要求去拆装。记得上次买了一个吸尘器，我打电话给我老婆说等我回来组装。没过一会，我老婆告诉我说，你儿子已经组装好了。我回来一看组装虽然没有那么完美，但是对于一个不到6岁的孩子来说已经很不错了。之前总是担心孩子做任何事一定做不好，所以处心积虑的避开他，生怕他要自己去做，自从自己看过几期关于孩子如何独立的课程后大大的改变了我的想法。 记得自己小时候，父母都很忙。看到他们太累了就想着自己一定要学会做饭，于是自己就从下面条开始，慢慢的从洗碗洗锅变成了一个小厨师，妈妈为了这个事骄傲了很久。父母不能总是阻止孩子去做他感兴趣的事情，我们只需要做好引导即可，放心，他们很靠谱！就拿孩子跌倒这件事来说，很多爷爷奶奶看到孩子不小心摔倒就迫不及待的去抱起来，其实这是不对的，我们应该引导孩子如何自己站起来，Ta下次就知道即使跌倒也要自己爬起来。 孩子在生活中也会遇到一些问题，孩子们有自己的小世界，别以为他们就没有烦恼和困难。在遇到问题的时候，我们不要直接自以为是的给出答案，问问Ta能不能再动动脑筋想想其他办法？ 我们的孩子到底需要怎么样的教育？答案是：孩子需要培养独立思考，勇敢面对这个世界、做自己喜欢事情的教育。 在马飞遇到暴雨而被困住的情况下，马皓文歇斯底里的说：“我是爸爸，动动你的脑子，看看你周围有什么，你一定能出来的”，结果奇迹出现了，马飞自救了。虽然有点夸张，但是它告诉我们如果不是父亲的引导不是儿子的自信和思考这将是一场悲剧，至少我看哭了。 银河补习班，到底给我们补了什么？ 每个人心中都有自己的答案，对我来说至少让我认识到了陪伴和鼓励很重要！ 记得让孩子做自己喜欢的事情，你只需要鼓励和相信他！ 真正的人生难题，不会像考卷那样，会自动跳出ABCD四个选项，有且只有一种标准答案。而是会有EFGHIJK的岔路，甚至能开出XYZ的脑洞。~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Swagger生成Markdown文档]]></title>
    <url>%2F2019%2F10%2F13%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Swagger%E7%94%9F%E6%88%90Markdown%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[国庆放假期间，看了一部 2018年上映的电影 《本杰明.巴顿奇事》，豆瓣评分 8.9。影片讲述了一出生便拥有80岁老人形象的本杰明·巴顿，随着岁月的推移逐渐变得年轻，最终回到婴儿形态，并在苍老的恋人黛茜怀中离世的奇异故事。 如果没有看过这部影片的小伙伴抽时间可以去看看，里面有很多关于人生的哲理。 本次文章封面图来自该电影。 简介文章 微服务: Swagger让你可以多抽一支烟 给大家分享了如何在自己的 SpringBoot 工程中集成 Swagger 以及如何使用 Swagger 生成在线文档。今天跟大家分享以下如何使用 Swagger 生成离线的 Markdown 格式的文档，在阅读下面内容之前，还是希望大家能看一下 微服务: Swagger让你可以多抽一支烟 这篇文章。 本人是一个热爱 Markdown 的狂热分子，无论是写日记还是工作笔记我都会使用 Markdown工具来做，那种所见即所得的感觉有点暗爽。自己在网上也找了很多关于如何使用 Swagger 生成 Markdown 格式的文档，大多数文章都比较陈旧，好不容易找到一篇自认为还可以的文章去实践发现还是存在一些问题，于是经过摸索诞生了此文。 集成 swagger2markup插件 Swagger2Markup 可以帮助我们将 Swagger 文档转换为离线的 Markdown 格式的文档，Swagger2Markup 介绍如下： 1Swagger2Markup converts a Swagger JSON or YAML file into several AsciiDoc or GitHub Flavored Markdown documents which can be combined with hand-written documentation. 可以在 mvnrepository 仓库中搜索 swagger2markup，如图： 我使用的是第一个，当前版本是 1.3.3，在工程的 pom 文件中，需要集成 swagger 和 swagger2markup，示例如下： 123456789101112131415161718&lt;!--swagger--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--swagger2markup--&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt; &lt;artifactId&gt;swagger2markup&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 如果你认为这样就可以了，那你接下来无法完成编译工作，因为根本下载不了 swagger2markup，还需要在 pom 文件中添加如下内容，示例如下： 1234567891011&lt;!--不加这个，swagger2markup 找不到--&gt;&lt;repositories&gt; &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;jcenter-releases&lt;/id&gt; &lt;name&gt;jcenter&lt;/name&gt; &lt;url&gt;http://jcenter.bintray.com&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 编写测试代码插件集成成功之后，接下来我们就可以去实现生成 Markdown 文档的梦想了，有点小鸡冻… 单元测试代码示例，如下： 12345678910111213141516171819202122232425262728293031323334353637383940import io.github.swagger2markup.Swagger2MarkupConfig;import io.github.swagger2markup.Swagger2MarkupConverter;import io.github.swagger2markup.builder.Swagger2MarkupConfigBuilder;import io.github.swagger2markup.markup.builder.MarkupLanguage;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockHttpServletResponse;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import java.net.URL;import java.nio.file.Paths;@RunWith(SpringRunner.class)@AutoConfigureMockMvc@SpringBootTestpublic class SpringbootApplicationTests &#123; @Test public void generateMarkdownFile() throws Exception &#123; Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder() .withMarkupLanguage(MarkupLanguage.MARKDOWN) .build(); URL apiUrl = new URL("http://localhost:8080/v2/api-docs"); // 指定文件名称 String markdownFileName = "src/docs/markdown/generated/MSBlog_Server_API"; Swagger2MarkupConverter.from(apiUrl) .withConfig(config) .build() //指定生成目录下生成指定文件 .toFile(Paths.get(markdownFileName)); &#125;&#125; 编写完成后，可以运行 generateMarkdownFile 这个方法，右键该方法，出现弹框如下图： 直接选择 Run generateMarkdownFile 即可开始。 不出意外的话，会失败并且报如下错误： 1Failed to read the Swagger source 我们要从 http://localhost:8080/v2/api-docs 读取内容，所以首先需要将主工程运行起来即运行项目。运行成功之后，再来执行测试代码就可以成功了。 生成的文件如下： 此时的我情不自禁的哼起了：“只要人人都献出一点爱，世界将变成美丽的人间” 的歌词，卧槽+n…总算可以了。 同理，也可以使用下面的方法生成 adoc 格式（这种格式的文档需要使用其他工具生成 PDF 或者 HTML 文件）的文档，如下： 12345678910111213141516@Testpublic void generateDocsFile() throws Exception &#123; Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder() .withMarkupLanguage(MarkupLanguage.ASCIIDOC) .build(); // 该地址不要写错 URL apiUrl = new URL("http://localhost:8080/v2/api-docs"); // 指定目录 String dirName = "src/docs/markdown/generated"; Swagger2MarkupConverter.from(apiUrl) .withConfig(config) .build() //指定生成目录 .toFolder(Paths.get(dirName));&#125; 如果你在使用 generateDocsFile() 这个方法发生如下的错误： 1java.lang.NoClassDefFoundError: nl/jworks/markdown_to_asciidoc/Converter 需要在你的 settings.xml 文件（一般在 C:\Users\username\.m2 目录下面，如果没有就新建一个吧）中增加阿里的镜像，如下： 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/jcenter&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 保存，然后去 IDEA 中重新运行测试方法即可。 如果你之前修改过 settings.xml 文件的位置，可以参考 idea设置maven配置文件setting.xml的位置 这篇文章去找到该文件再修改。 打烊，手工！ 一件事无论太晚或者太早，都不会阻拦你成为你想成为的那个人，这个过程没有时间的期限，只要你想，随时都可以开始~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot Swagger Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Swagger让你可以多抽一支烟]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Swagger%E8%AE%A9%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%A4%9A%E6%8A%BD%E4%B8%80%E6%94%AF%E7%83%9F%2F</url>
    <content type="text"><![CDATA[简介Swagger，可用于生成、描述、调用和可视化 RESTful 风格接口的API，是一套规范和完整的开发框架，并且能对接口进行单独测试。 另外， Swagger 在 Github 上面是开源的。 无论对于后端开发，还是前端开发以及测试同事，Swagger 都可以基本满足使用需求。 在 SpringBoot 中集成 Swagger，后端同事写完接口就可以自动生成API文档，可以给到前端同事看，测试同事可以直接测试该接口。 在本篇中，跟大家分享如下内容： 1、在 SpringBoot 中项目如何集成 Swagger？ 2、如何使用 Swagger，如何在不同的环境中开启和关闭 Swagger？ 3、如何将同类的接口使用 Swagger 注解进行聚合？ 更多关于 SpringBoot 的文章，可以点击 微服务项目系列文章 了解，完整代码示例请前往 Github 查看。 集成 Swagger在 MavenEwpository 搜索 Springfox，可以找到 Swagger2 和 Swagger UI，如图所示。 截止到目前， Swagger2 和 Swagger UI 最新版本是 2.9.2 版本。 修改工程的pom文件，增加 Swagger2 和 Swagger UI 的依赖，如下： 1234567891011&lt;!--swagger--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 因为我的项目已经集成了 starter-web，如下 pom 文件中的 dependency： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 这样默认会集成 com.fasterxml.jackson.core: 相关的库，不需要额外再去集成 jackson-databind 了，如下图所示： 否则你需要单独增加 jackson-databind 的依赖，同样的道理你可以在 MavenEwpository 搜索 jackson-databind 选择合适的版本即可。 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 工程已经集成了 Swagger，接下来我们看看如何使用。 使用 Swagger1、创建Swagger配置新建一个配置类 MSSwaggerConfig，该文件名称和位置你可以放到你的工程的任意目录，根据自己的项目目录来放置即可。 MSSwaggerConfig 示例代码如下： 123456789101112131415161718192021222324252627282930@Configuration@EnableSwagger2public class MSSwaggerConfig &#123; @Bean public Docket msblogDocket() &#123; Docket docket = new Docket(DocumentationType.SWAGGER_2); String pkgName = "com.veryitman.springboot.controller"; return docket.apiInfo(msblogAPIInfo()).select() .apis(RequestHandlerSelectors.basePackage(pkgName)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo msblogAPIInfo() &#123; ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); String apiTitle = "MSBlog Server API"; String apiDes = "API for MSBlog"; String apiVersion = "1.0.0"; String homePage = "http://veryitman.com"; String emailUrl = "veryitman@126.com"; Contact contact = new Contact("itman", homePage, emailUrl); return apiInfoBuilder.title(apiTitle).description(apiDes) .version(apiVersion) .contact(contact) .license("Apache 2.0") .licenseUrl("http://www.apache.org/licenses/LICENSE-2.0.html") .build(); &#125;&#125; 记得添加 @Configuration、 @EnableSwagger2 这两个注解。 对于 apis(RequestHandlerSelectors.basePackage(pkgName)) 目的是只扫描指定包名下面 Controller 的 Swagger 注解，这样就不会去扫描其他包下面的类了。 对于这个配置类，主要是用来生成一些摘要信息，如图： 2、注解 Controller在 微服务-简单的用户名注册和登录 给大家分享了如何写注册和登录的API，今天还是拿注册的例子来进行 Swagger 的演示。 下面代码是用户注册的示例代码。 123456789101112131415@RestController@RequestMapping(value = "signup")public class MSSignupController &#123; @CrossOrigin(origins = &#123;"*"&#125;) @PostMapping(value = "/name") @ApiOperation(value = "用户注册", httpMethod = "POST", notes = "用户名和密码注册") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "username", value = "注册的用户名", required = true), @ApiImplicitParam(name = "userpwd", value = "注册的密码", required = true) &#125;) public MSResponse signup(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; // 省略 &#125;&#125; 可以看到如下的注解： 12345@ApiOperation(value = "用户注册", httpMethod = "POST", notes = "用户名和密码注册")@ApiImplicitParams(&#123; @ApiImplicitParam(name = "username", value = "注册的用户名", required = true), @ApiImplicitParam(name = "userpwd", value = "注册的密码", required = true)&#125;) 这些注解就是 Swagger 的注解，@ApiOperation 说明了该接口的用途，@ApiImplicitParams 中有两个 @ApiImplicitParam 用来对接口的参数进行说明。 如果接口只有一个参数，可以直接使用 @ApiImplicitParam 注解即可。 3、在线文档配置完成之后，可以启动 SpringBoot 项目，在浏览器中打开下面地址，就可以看到生成的在线文档了。 1http://localhost:8080/swagger-ui.html#/ 点击对应的 Controller 就可以看到对应接口的详细说明了，并且还可以对接口进行测试。 分环境开启 Swagger在实际项目中，我们一般只会在开发和测试环境使能 Swagger，在沙盒和生成环境会关闭 Swagger，那如何控制呢？ 在工程的 Resources 目录下面，新建几个跟环境相关的 properties 文件。 这些文件的命令要满足 application-{profile}.properties 的格式，其中 {profile} 你可以自定义名字，如下我自定义了4个环境，分别是开发、生产、沙盒和测试环境。 我们知道，在 application-{profile}.properties 中配置的选项与在 application.properties 中配置的选项如果名称相同，优先会使用 application-{profile}.properties 中配置。 在 application.properties 中配置如下： 1234# 配置使用哪个环境spring.profiles.active=dev# 默认不启用 swaggerswagger.enable=false 对应的在 application-dev.properties 和 application-test.properties 中开启 swagger，如下： 12# 启用 swaggerswagger.enable=true 选项配置完成后，我们在代码中使用该选项，修改 MSSwaggerConfig 如下(只列出了修改部分的关键代码)： 12345678910111213141516171819@Configuration@EnableSwagger2public class MSSwaggerConfig &#123; @Value("$&#123;swagger.enable&#125;") private boolean enableSwagger; @Bean public Docket msblogDocket() &#123; Docket docket = new Docket(DocumentationType.SWAGGER_2).enable(enableSwagger); String pkgName = "com.veryitman.springboot.controller"; return docket.apiInfo(msblogAPIInfo()) .select() // 只扫描指定包名下面的Controller中的Swagger注解 .apis(RequestHandlerSelectors.basePackage(pkgName)) .paths(PathSelectors.any()) .build(); &#125; 在下面的代码中读取配置 12@Value("$&#123;swagger.enable&#125;")private boolean enableSwagger; 然后调用 Docket 的 enable(enableSwagger) 方法来决定是否开启 Swagger，如果配置不开启，效果图如下： 还有其他方式来控制在不同环境下配置 Swagger 是否开启，比如可以结合注解 @Profile 通过不同的 profile 给 Swagger 的依赖设置不同的 scope，还可以使用注解 @ConditionalOnProperty(name = &quot;swagger.enable&quot;, havingValue = &quot;true&quot;)，大家自行选择适合自己项目的方案即可，目的都是一样。 聚合接口在上面实例中，我们可以看到登录和注册都属于用户模块，使用注解 @API 可以聚合显示这些接口。 在登录和注册的 Controller 中可以添加下面注解，从而来聚合显示接口。 1@Api(value="xxx", tags="用户模块") 注册 Controller 添加注解，如下： 12345@Api(value="signup", tags="用户模块")@RestController@RequestMapping(value = "signup")public class MSSignupController &#123;&#125; 登录 Controller 添加注解，如下： 12345@Api(value=&quot;signin&quot;, tags=&quot;用户模块&quot;)@RestController@RequestMapping(value = &quot;signin&quot;)public class MSSigninController &#123;&#125; 显示效果如下： 你眼睛看到的不一定是事实的全部~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot Swagger doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 简单的用户名注册和登录]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[内容概要在本篇中我们要完成一个目标：提供注册、登录的接口给前端或者客户端来使用。 涉及到的内容主要有下面几个： 1、SpringBoot 中常用的注解如何使用？ 2、 如何对接口进行单元测试？ 其他相关的微服务文章，可以点击 微服务项目系列文章 了解。 常用注解控制器 Controller 是 Spring 中最基本的组件，主要是处理跟用户交互的，一般每个业务逻辑都会有一个 Controller，提供 HTTP 请求接口，用户请求接口进行数据访问。 跟 Controller 相关的几个注解主要有 @Controller，@RestController，@RequestMapping，@PathVariable，@RequestParam，@GetMapping 等。 @Controller：标注 Controller 类，处理 HTTP 请求。 @RestController：标注 Controller 类，Spring 4 新加注解，相当于 @Controller + @ResponseBody ，主要是为了使 HTTP 请求返回数据格式为 json 格式，正常情况下都是使用这个注解。 @RequestMapping：配置 URL 映射，即请求的地址。 @PathVariable，@RequestParam ，@QueryParam ，@PathParam 注解，可以参考 微服务: 学习几个容易混淆的URL注解 这篇文章。 @GetMapping，@PostMapping，@PutMapping 称之为组合注解，它们等价于 @RequestMapping 单独指定映射再指定请求方法。举个例子，如下: 1@RequestMapping(value = "/signup/name", method = RequestMethod.POST) 等价于下面的注解： 1@PostMapping(value = "/signup/name") 编写实体不管是登录还是注册，都是每个用户进行的操作，我们先定义用户实体类 MSUser，代码如下： 1234567891011121314151617181920212223import lombok.Data;import java.io.Serializable;@Datapublic class MSUser implements Serializable &#123; private String userID; // 账号名称，用于登录，不可以修改 private String accountName; // 账号密码 private String accountPwd; // 昵称默认和accountName一致，可以修改 private String nickName; private Integer age; private Integer gender; // 座右铭；格言；箴言 private String motto;&#125; 大家可以看到，在实体类 MSUser 中，我们用到了注解 @Data ，该注解来源于 lombok，需要自己在IDEA中安装该插件，安装方法请大家自行搜索解决。 注解 @Data 相当于给我们自动实现了 Get 、Setter、toString、 equals 和 hashCode 方法以及构造方法，不需要我们自己再去写这些代码。 HTTP 的请求响应结果，也可以被封装为实体类，如下 MSResponse 就是用来承载HTTP返回的响应。 12345678import lombok.Data;@Datapublic class MSResponse&lt;T&gt; &#123; private int code; private String msg; private T results;&#125; 编写接口一般来说，用户注册需要将用户的信息存下来，存到数据库中方便后续使用这份数据，这个行为称之为 数据持久化 ，现在我们不做这个操作，只是纯粹的提供接口让用户可以注册、登录我们的系统，后续再来考虑和实现数据持久化。 这个阶段注册功能只提供 用户名+密码 的方式，该请求是个 POST 请求，主要核心代码如下： 123456789101112131415161718192021222324@RestController@RequestMapping(value = "signup")public class MSSignupController &#123; @CrossOrigin(origins = &#123;"*"&#125;) @PostMapping(value = "/name") public MSResponse signup(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; MSResponse response = new MSResponse(); MSUser user = null; if (null == userName || null == userPwd || userName.length() &lt;= 0 || userPwd.length() &lt;= 0) &#123; MSResponseEnum signupError = MSResponseEnum.SignupInvalidInfo; response.setMsg(signupError.getMsg()); response.setCode(signupError.getCode()); &#125; else &#123; response.setCode(MSResponseEnum.SUCCESS.getCode()); response.setMsg(MSResponseEnum.SUCCESS.getMsg()); user = MSUserUtil.createUser(userName, userPwd); &#125; response.setResults(user); return response; &#125;&#125; 同理，登录功能也只提供 用户名+密码 的方式，该请求是个 GET 请求，主要核心代码如下： 12345678910111213141516171819202122232425@RestController@RequestMapping(value = "signin")public class MSSigninController &#123; @CrossOrigin(origins = &#123;"*", "http://localhost:8082"&#125;) @RequestMapping(value = "/name", method = RequestMethod.GET) public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; MSResponse response = new MSResponse(); MSUser user = null; if (null == userName || null == userPwd || userName.length() &lt;= 0 || userPwd.length() &lt;= 0) &#123; MSResponseEnum responseEnum = MSResponseEnum.Login4SiginInvalidInfo; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123; user = MSUserUtil.createUser(userName, userPwd); MSResponseEnum rspEnum = MSResponseEnum.SUCCESS; response.setCode(rspEnum.getCode()); response.setMsg(rspEnum.getMsg()); &#125; response.setResults(user); return response; &#125;&#125; 单元测试在 IDEA 中新建 SpringBoot 工程后，默认就会创建一个测试目录。 即 test 目录下会有 SpringbootApplicationTests 类文件，其中 pom 文件中已经添加好了 spring-boot-starter-test 启动器。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; springboot－test 包中已经包括了 junit 和 mockito 类库，不需要我们额外再去添加这些库。 借助于 MockMvc 我们可以对接口进行简单的单元测试了。主要的测试核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@RunWith(SpringRunner.class)@AutoConfigureMockMvc@SpringBootTestpublic class SpringbootApplicationTests &#123; @Autowired private MockMvc mvc; /* 登录的接口测试，GET 请求 */ @Test public void signinTest() throws Exception &#123; //直接写接口的映射地址就可以了，不需要写host和port String url = "/signin/name?username=itman&amp;userpwd=123"; MvcResult mvcResult = mvc.perform(MockMvcRequestBuilders.get(url) .accept(MediaType.APPLICATION_JSON)) //断言返回结果是json .andReturn(); MockHttpServletResponse response = mvcResult.getResponse(); //HTTP响应的返回码 int status = response.getStatus(); //HTTP响应的内容 String contentAsString = response.getContentAsString(); System.err.println(status); System.err.println(contentAsString); &#125; /* 注册的接口测试，POST 请求 */ @Test public void signupTest() throws Exception &#123; String url = "/signup/name"; MvcResult mvcResult = mvc.perform(MockMvcRequestBuilders.post(url) .accept(MediaType.APPLICATION_JSON) .param("username", "itman") .param("userpwd", "123567")) .andReturn(); MockHttpServletResponse response = mvcResult.getResponse(); int status = response.getStatus(); String contentAsString = response.getContentAsString(); System.err.println(status); System.err.println(contentAsString); &#125;&#125; 在上面编写的测试代码中，解释一下几个用到的注解和类。 1、@RunWith(SpringRunner.class) ，SpringRunner 是 SpringJUnit4ClassRunner 的简写，用于提供测试时的 Spring 应用上下文信息。 2、MockMvc ，MockMvc 是测试 Spring MVC 应用程序的主要入口，为我们的测试提供了一个模拟的应用上下文的环境。 3、@Autowired，可以对类成员变量、方法及构造函数进行标注，完成自动装配。不需要手动创建该对象，这个跟 Spring 的 IOC 机制有关。 代码写好之后，就可以进行单元测试了，直接在 signinTest 或者 signupTest 右键运行即可，不需要启动整个工程。如下图所示： 运行之后，可以在输出的控制台中看到信息： 前端请求在 跨域和OPTIONS这对欢喜冤家 和 减少跨域中的OPTIONS请求 这两篇文章中，已经跟大家分享过如何在前端页面中进行接口访问了，其中也重点讲解了如何在 SpringBoot 中解决跨域问题，这里不再赘述，感兴趣的朋友可以去看看这两篇文章。 文中的完整示例代码都在 Github 上面，需要的可以自行clone，感谢您的阅读。 临渊羡鱼不如按退而结网~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot 微服务 项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减少跨域中的OPTIONS请求]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%87%8F%E5%B0%91%E8%B7%A8%E5%9F%9F%E4%B8%AD%E7%9A%84OPTIONS%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[简介这篇是继 跨域和OPTIONS这对欢喜冤家 后的一篇文章，在本篇中我们继续探索跨域中的 OPTIONS 请求，主要分享一下： SpringBoot 中除了 CrossOrigin 注解外还有哪些方式可以解决跨域问题？ 如何使用 SpringBoot 结合 CORS 减少 OPTIONS 请求？ 阅读下面内容之前，强烈建议先阅读之前的 跨域和OPTIONS这对欢喜冤家 这篇文章。 文中使用的代码都可以在 Github 找到，大家根据需要自行采纳。 用上 Nginx这次使用 Nginx 作为 Web 容器，在本地将HTML跑起来，上次是在 Chrome 中直接打开 HTML 文件的方式来验证跨域问题的。我们知道只要端口不同也会造成跨域问题，那么只需要在 Nginx 中配置一个端口不同于服务端口的虚拟主机就可以达到目的了。 由于我是在 Win10 上面做的例子，包括 Nginx 也是 Windows 版本的，如果没有安装的小伙伴请去 下载Nginx 直接解压即可。 我把 Nginx 解压放到：D:\portable\nginx-1.15.12 这个目录，你可以解压到你认为比较合适的地方。 打开 Nginx 的配置文件 nginx.conf 即在 安装目录\conf 下面，增加一个虚拟主机配置项，修改完成后保存配置文件即可。 1234567891011# 自定义虚拟主机，可以同时配置多个虚拟主机server &#123; listen 8082; # 不同于服务端口 server_name localhost; location / &#123; # 文件路径，注意路径分隔符是 `/` 不是 `\` root E:/examples/cors-options; # 默认页面 index index.html index.htm; &#125;&#125; 注意：E:/examples/cors-options; 是我的 HTML 文件(options.html )路径，你要根据自己实际HTML路径来配置这个选项，否则后面无法打开该文件。 这里我把这个文件命名为 options.html，HTML文件内容大致如下： 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;options-demo&lt;/title&gt; &lt;script type="text/javascript" src="./jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./jquery.json.js"&gt;&lt;/script&gt; &lt;script&gt; function getReq() &#123; var url = "http://localhost:8080/signin/name?username=jack&amp;userpwd=123"; $.ajax(&#123; url: url, type: 'GET', dataType: 'json', contentType: 'application/json', headers: &#123; token: "yu7rX98xxxx_iii^ddd", userId: 123, openid: 231232 &#125; &#125;).done(function (result) &#123; console.log("success"); console.log(result); &#125;).fail(function () &#123; console.log("error"); &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick="getReq()"&gt;用户名登录-GET&lt;/button&gt;&lt;/html&gt; 现在启动 Nginx，启动 Nginx 很简单，打开 Windows 终端或者 Git 的终端(如果你安装了 Git 的话，即使没有安装我也强烈建议你安装，因为太好用了)，然后 cd到 Nginx 的安装目录。 1start nginx.exe 打开 Chrome 浏览器，输入下面的网址进行访问： 1http://localhost:8082/options.html 不出意外的话，可以看到显示一个按钮的视图，顺便把 Chrome 的审查视图(Ctrl+Shift+i)打开，大概是下面截图的样子。 指定域名列表Nginx 配置完成，文件也可以正常的打开，那我们就来试试是否跟预想的一致？ SpringBoot 关键示例代码如下： 12345678@RestController@RequestMapping(value = "signin") // 注意这里不要在signin前后加"/"public class MSSigninController &#123; @RequestMapping(value = "/name", method = RequestMethod.GET) public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; // 省略 &#125;&#125; 启动 SpringBoot 服务（默认运行在8080端口不同于网页运行端口8082）完成后，点击 Chrome 视图中的按钮进行请求，截图如下： 可以看到跟我们预期一致，的确造成了跨域请求，并且进行了 OPTIONS 请求。 在 SpringBoot 的某个方法上面添加 CrossOrigin 注解可以解决跨域问题，并且可以指定域名列表，示例代码如下： 12345678public class MSSigninController &#123; // 指定域名列表 @CrossOrigin(origins = &#123;"http://localhost:8082"&#125;) @RequestMapping(value = "/name", method = RequestMethod.GET) public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; // 省略 &#125;&#125; 重启服务后，再去验证一下发现请求就可以通过了。 如果你感兴趣，可以修改一下 CrossOrigin 注解中的域名列表端口号，再去请求就会失败。 使用 CrossOrigin 注解指定域名列表，可以从更小的粒度上面控制跨域请求。 那么除了使用 CrossOrigin 注解意外，在 SpringBoot 中还可以怎样解决跨域问题呢？ 解决跨域的其他计策目前除了使用 CrossOrigin 注解，还可以使用下面几种方法来解决跨域问题。 1、自定义Filter自定义 Filter 可以解决跨域问题，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;import java.util.HashSet;import java.util.Set;@Componentpublic class MSCorsFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; if ("OPTIONS".equals(request.getMethod())) &#123; System.out.println("HTTP's OPTIONS Coming"); &#125; HttpServletResponse response = (HttpServletResponse) res; // 设置所有的请求域名都可以 response.setHeader("Access-Control-Allow-Origin", "*"); // 设置允许的请求方法 response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE"); // 设置缓存时间单位为秒，在改时间内不需要再发送预检验请求，即缓存该结果 // 设置为0就相当于不设置缓存，即每次都会有OPTIONS请求 response.setHeader("Access-Control-Max-Age", "0"); // 设置允许跨域请求包含content-type头 response.setHeader("Access-Control-Allow-Headers", "*"); System.out.println("Filter has been used."); chain.doFilter(req, res); &#125; public void init(FilterConfig filterConfig) &#123; &#125; public void destroy() &#123; &#125;&#125; 这里我们是通过设置 Access-Control-Allow-Origin 允许所有的域名(通配符*)都可以访问，如下： 1response.setHeader("Access-Control-Allow-Origin", "*"); 也可以设置指定域名才可以，示例如下： 1response.setHeader("Access-Control-Allow-Origin", "http://localhost:8082"); 那我们需要思考一下了，setHeader 方法只能设置一个指定的域名，如果我想设置多个域名怎么办？ 首先告诉你通过下面的方式肯定不行，如下： 12response.addHeader("Access-Control-Allow-Origin", "http://localhost:8082");response.addHeader("Access-Control-Allow-Origin", "http://localhost:8083"); 具体原因大家可以看一下源码就秒懂了。 有一个解决方案，把可以通过跨域访问的域名做成数组也是大家在业务上面经常说的白名单，示例如下： 12345678// 设置多个域名支持，类似白名单String[] allowDomain = &#123;"http://localhost:8082", "http://localhost:8083", "http://localhost:8085", "http://localhost:8087"&#125;;Set allowedOrigins = new HashSet(Arrays.asList(allowDomain));String originHeader = ((HttpServletRequest) req).getHeader("Origin");System.out.println("originHeader: " + originHeader);if (allowedOrigins.contains(originHeader)) &#123; response.setHeader("Access-Control-Allow-Origin", originHeader);&#125; 再来思考一个问题，上面那种方式自定义Filter会对所有URL即全局的请求都起作用了，能否对指定URL进行过滤呢？ 做过Spring的同学肯定知道，我们可以设置 WebFilter，示例如下： 1@WebFilter(urlPatterns = &#123; "/signin/name" &#125;) 这样修改后，需要修改一下SpringBoot相关的代码，首先去掉 Component 注解，示例如下： 1234//@Component@WebFilter(urlPatterns = &#123; "/signin/name" &#125;)public class MSCorsFilter implements Filter &#123;&#125; 然后需要在 Application 中添加 ServletComponentScan 注解，示例如下： 1234@ServletComponentScan@SpringBootApplicationpublic class SpringbootApplication &#123;&#125; 结合 Filter 我们可以做出更细粒度更多功能来解决和控制跨域问题。Filter 这种方式对跨域的 GET 和 POST 请求都是支持的。 2、WebMvcConfigurationSupport在 SpringBoot 中还可以自定义配置来解决跨域问题，通过继承 WebMvcConfigurationSupport 配置 CROS，示例代码如下： 12345678910111213@Configurationpublic class MSCorsConfig extends WebMvcConfigurationSupport &#123; @Override protected void addCorsMappings(CorsRegistry registry) &#123; super.addCorsMappings(registry); registry.addMapping("/**") .allowedOrigins("*") .allowCredentials(true) .allowedMethods("GET", "POST", "DELETE", "PUT") .maxAge(3600); &#125;&#125; 还可以指定 URL 和域名，修改如下： 12345678910111213@Configurationpublic class MSCorsConfig extends WebMvcConfigurationSupport &#123; @Override protected void addCorsMappings(CorsRegistry registry) &#123; super.addCorsMappings(registry); registry.addMapping("/signin/name") .allowedOrigins("http://localhost:8082", "http://localhost:8083") .allowCredentials(true) .allowedMethods("GET", "POST", "DELETE", "PUT") .maxAge(3600); &#125;&#125; 这样配置后，只允许请求域名是 http://localhost:8082 和 http://localhost:8082 并且请求服务端URL是 /signin/name 的请求才可以使用 CORS 机制。 3、CorsFilter这种方法早在 SpringBoot1.x 版本中使用，使用方法如下： 12345678910111213141516171819202122232425262728293031import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class MSCorsFilterConfig &#123; private CorsConfiguration getConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); // 允许任何域名使用 corsConfiguration.addAllowedOrigin("*"); // 允许任何头 corsConfiguration.addAllowedHeader("*"); // 允许任何HTTP方法 corsConfiguration.addAllowedMethod("*"); corsConfiguration.setAllowCredentials(true); corsConfiguration.setMaxAge(60L); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source; source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", getConfig()); return new CorsFilter(source); &#125;&#125; 这种方式跟上面的解决方法基本都是大同小异，大家根据实际情况选择使用，对提供的方法举一反三即可。 减少OPTIONS请求虽然我们支持网页对服务端进行 OPTIONS 请求，但是请求如果多了势必会影响服务器性能。 如果在没有必要的情况下尽量减少由于跨域请求带来的 OPTIONS 请求，我们可以通过设置缓存时间来解决这个问题。 比如使用自定义 Filter 的方式设置600秒的缓存时间，示例代码如下： 1response.setHeader("Access-Control-Max-Age", "600"); 在大家进行测试的时候，记得不要勾选 Chrome 审查视图中 Network 选项中 Disable cache 这一项，否则每次都会进行 OPTIONS 请求，给你造成设置服务端缓存时间没有效果的假象。 常用Nginx命令下面给出Windows版本的Nginx常用命令。 1、启动 Nginx 1start nginx.exe 2、验证配置是否正确 1nginx.exe -t 3、修改配置文件后，重新加载 1nginx.exe -s reload 4、快速关闭 1nginx.exe -s stop 5、正常关闭退出 1nginx.exe -quit 6、查看Nginx版本 1nginx.exe -V 坚持做好一件事，需要付出比常人更多的努力~]]></content>
      <categories>
        <category>Server</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP OPTIONS CORS SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域和OPTIONS这对欢喜冤家]]></title>
    <url>%2F2019%2F08%2F31%2F%E8%B7%A8%E5%9F%9F%E5%92%8COPTIONS%E8%BF%99%E5%AF%B9%E6%AC%A2%E5%96%9C%E5%86%A4%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[简介相信做过前端开发的同事，包括做小程序或者小游戏的码友们应该都看过类似下面的错误，这个错误是由于 JavaScript 代码向服务器发送了 HTTP 请求引起的。 123Access to XMLHttpRequest at 'http://www.xxx.com/yyy' from origin 'null' has been blocked by CORS policy:Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. 如果是第一次遇到，你肯定会觉得很好奇，忍不住会去一探究竟~ 还有些同事会遇到另一个神奇的错误，即发送GET或者POST请求之前，居然先给服务器发送了一个 OPTIONS 请求，让人不可思议的是这个 OPTIONS 请求是自动发的，服务器在没有任何设置的条件下直接将这个请求夭折掉，如下返回 403 错误，也可能是其他错误。 1OPTIONS http://www.xxx.com/yyy 403 引起这些问题的罪魁祸首就是 跨域 ，今天我跟大家一起以实际的例子来看看这个神奇的 跨域 问题。 文中使用的代码都可以在 Github 找到，大家根据需要自行采纳。 同源策略域，是指由 协议 + 域名 + 端口号 组成的一个虚拟概念。 如果两个域的 协议、域名、端口号 都一样，就称他们为同域，但是只要三者之中有一个不一样，就不是同域。 那么 跨域请求 简单来说，就是在一个域内请求了另一个域的资源，由于域不一致会有安全隐患如 CSRF （Cross-site request forgery）攻击。 在百度百科里面是这样定义 同源策略 的，如下： 123同源策略（SOP，Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 听起来，这玩意挺高大上的，简单理解 同源策略 就是一种安全策略，为了安全而生的一种限制措施。它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略，也是必须遵守的一个策略。 那么 同源策略 中的 同源 是指 域名，协议，端口 三者必须相同，如果有任何一个不同就会引起跨域。 下表给出了相对 http://a.xx.com/yy/zz.html 同源检测的示例: URL 结果 原因 http://a.xxx.com/ff/other.html 成功 域名、协议、端口(默认80)一致 http://a.xxx.com/gg/hh/another.html 成功 域名、协议、端口(默认80)一致 https://a.xxx.com/secure.html 失败 不同协议 ( HTTPS和HTTP ) http://a.xxx.com:81/dir/etc.html 失败 不同端口 ( 81和80) http://a.wpq.com/yy/other.html 失败 不同域名 ( xxx和wpq) http://123.21.122.12/dir 失败 域名IP不等同于域名 http://xx.xxx.com/dir2/ 失败 主域相同，子域不同 简单来说，HTML 代码运行在一个web主机上面（假设域名是 http://a.xx.com/yy/zz.html），而HTML代码中有需要请求服务器某 API 接口（http://api.user.com/name）的，那么就会造成跨域问题。 同源策略会影响： （1） Cookie、LocalStorage 和 IndexDB 无法读取； （2） DOM 无法获得； （3） AJAX 请求不能正常发送，有可能还会引起 OPTIONS 请求； OPTIONS请求大家所熟知的HTTP请求最多的应该就是 GET 和 POST 请求，这两种请求也是软件开发中用的最多的。 GET：向特定的资源发出请求，一般对服务器来说是一个只读的请求，不会对资源进行写操作。 POST：向指定资源提交数据进行处理请求，例如提交表单或者上传文件，数据被包含在请求体（body）中，该请求可能会对服务器资源进行读写操作。 除了这两种请求外，HTTP还有其他种类的请求，如下： PUT：向指定资源位置上传其最新内容，一般用于资源的整体更新，而下面的 PATCH 用于资源的部分更新。 DELETE：请求服务器删除所标识的资源。 HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回，可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向Web服务器发送 ‘*’ 的请求来测试服务器的功能性。该请求不会修改服务器资源，相对比较安全。 CONNECT：是 HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。 PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新。当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已存在的资源进行更新。 其中 GET, POST 和 HEAD 方法是 HTTP1.0 定义的三种请求方法，在 HTTP1.1 又新增了六种请求方法，即 OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。如果想了解更多 HTTP 历史的朋友，可以阅读我之前的写的一篇文章 HTTP 演进史，嘿哈🙋‍。 再说一下 OPTIONS 请求，该请求与 HEAD 请求有点类似，一般也是用于客户端查看服务器的性能。 OPTIONS 方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行CORS跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 那么需要满足哪些条件才会触发 OPTINS 请求呢？ 实例验证在没有回答上面的问题之前，我们还是来做个实验吧~ 你需要将 Chrome 浏览器的审查视图打开，最好把 Disable Cache 也勾选上禁止 Chrome 使用网络缓存，这样才不会影响下面的实验。 下面是 Springboot 关于登录的一个示例代码，如下： 1234567891011121314151617181920212223242526import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value = "signin")public class MSSigninController &#123; @RequestMapping(value = "/name", method = RequestMethod.GET) public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; MSResponse response = new MSResponse(); MSUser user = null; if (null == userName || null == userPwd || userName.length() &lt;= 0 || userPwd.length() &lt;= 0) &#123; MSResponseEnum responseEnum = MSResponseEnum.Login4SiginInvalidInfo; response.setCode(responseEnum.getCode()); response.setMsg(responseEnum.getMsg()); &#125; else &#123; user = MSUserUtil.createDefaultUser(userName, userPwd); MSResponseEnum rspEnum = MSResponseEnum.SUCCESS; response.setCode(rspEnum.getCode()); response.setMsg(rspEnum.getMsg()); &#125; response.setResults(user); return response; &#125;&#125; 你大可不必去了解这个代码的具体逻辑，现在你只需要知道他是用来给 JavaScript 调用的一个登录API即可。 再来一个 HTML 文件，模拟请求登录的API，请求 HTTP 使用 Ajax，代码如下： 12345678910111213141516&lt;script&gt;function getReq() &#123; var url = "http://localhost:8080/signin/name?username=jack&amp;userpwd=123"; $.ajax(&#123; url: url, type: 'GET', dataType: 'json', &#125;).done(function (result) &#123; console.log("success"); console.log(result); &#125;).fail(function () &#123; console.log("error"); &#125;)&#125;&lt;/script&gt; 使用 Chrome 浏览器直接打开这个HTML文件即可，然后启动 Java 服务，在浏览器中点击按钮进行 GET 请求。 此时请求会报下面的错误： 1Access to XMLHttpRequest at 'http://localhost:8080/signin/name?username=jack&amp;userpwd=123' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 确实是造成了跨域请求，导致请求失败。 但是令人遗憾的是并没有看到发出 OPTIONS 请求，使用 Fiddler 抓包，可以看到只有 GET 请求，如图所示： 难道是自己写代码的姿势不对吗？！ 其实，在 HTML 中使用 HTTP 请求，发生 OPTIONS 请求是需要几个条件的： 1、必须是跨域请求 2、自定义了请求头 3、请求头中的 content-type 是 application/x-www-form-urlencoded，multipart/form-data，text/plain 之外的格式 满足1和2或者满足1和3就会发生 OPTIONS 请求，首先我们确定了上面的示例是跨域请求，但是不满足后面的两个条件之一。 我们修改一下HTML代码增加一个 content-type，如下： 1234567891011121314151617&lt;script&gt;function getReq() &#123; var url = "http://localhost:8080/signin/name?username=jack&amp;userpwd=123"; $.ajax(&#123; url: url, type: 'GET', dataType: 'json', contentType: 'application/json', &#125;).done(function (result) &#123; console.log("success"); console.log(result); &#125;).fail(function () &#123; console.log("error"); &#125;)&#125;&lt;/script&gt; 此时在浏览器中（需要使用 Chrome 的审查视图）可以看到报错信息： 123OPTIONS http://localhost:8080/signin/name?username=jack&amp;userpwd=123 403Access to XMLHttpRequest at 'http://localhost:8080/signin/name?username=jack&amp;userpwd=123' from origin 'null' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. 抓包工具中也可以看到发生了 OPTIONS 请求，如下图： 也可以自定义 Header 头来进行验证，代码如下： 123456789101112131415161718192021&lt;script&gt;function getReq() &#123; var url = "http://localhost:8080/signin/name?username=jack&amp;userpwd=123"; $.ajax(&#123; url: url, type: 'GET', dataType: 'json', headers: &#123; token: "yu7rX98xxxx_iii^ddd", userId: 123, openid: 231232 &#125; &#125;).done(function (result) &#123; console.log("success"); console.log(result); &#125;).fail(function () &#123; console.log("error"); &#125;)&#125;&lt;/script&gt; 验证结果和上面一致，也会发生 OPTIONS 请求。 再聊OPTIONS在 RFC2616-HTTP/1.1 中关于 OPTIONS 有详细的描述，感兴趣的可以看一下 9.2 OPTIONS 小节。 OPTIONS 请求方法的主要用途有两个： 1、获取服务器支持的 HTTP 请求方法； 2、用来检查服务器的性能，如上面例子中的AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，用以判断实际发送的请求是否安全； HTT P的 OPTIONS 请求，有很多地方也被称之为预请求或者预检请求，换句话说就是试探性的请求不算是正式请求。 为了避免对服务器产生一些副作用，类似上面例子中的网页中的请求就会产生 OPTIONS 请求，也算是一种对服务器的保护。只有当服务器允许后，浏览器才会发出正式的请求，否则不发送正式请求。 我们可以使用 curl 模拟 OPTIONS 请求，例如下面请求谷歌： 1curl -i -v -X OPTIONS https://www.google.com 可以看到请求的响应情况： 1234567891011121314151617181920&lt; HTTP/2 405&lt; allow: GET, HEAD&lt; date: Sat, 31 Aug 2019 02:17:03 GMT&lt; content-type: text/html; charset=UTF-8&lt; server: gws&lt; content-length: 1592&lt; x-xss-protection: 0&lt; x-frame-options: SAMEORIGIN&lt; alt-svc: quic=":443"; ma=2592000; v="46,43,39"&lt;&#123; [5 bytes data]100 1592 100 1592 0 0 13606 0 --:--:-- --:-- 13606HTTP/2 405allow: GET, HEADdate: Sat, 31 Aug 2019 02:17:03 GMTcontent-type: text/html; charset=UTF-8server: gwscontent-length: 1592x-xss-protection: 0x-frame-options: SAMEORIGINalt-svc: quic=":443"; ma=2592000; v="46,43,39" SpringBoot 解决跨域话说，同源策略引起了跨域问题，本身是为了安全起见为何我们还要去解决这个问题呢？这是因为 Web 前端是我们自己开发的，也就是说我们是知道自己的 Web 请求是安全的（类似于白名单客户），就需要让它顺利访问后端服务，所以解决这个跨域问题势在必行。 解决跨越的问题，在网上有很多的路子，目前大概有下面几种解决方案，如下： JSONP 简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。但它仅支持GET方法不支持POST等其他请求方法，而且可能会遭受XSS攻击。 CORS postMessage websocket Node 中间件代理 Nginx 反向代理 window.name+iframe location.hash+iframe document.domain+iframe 今天我们使用 SpringBoot 自带的注解来解决这个问题😃。 在说解决方案之前，还是先了解一下 CORS（Cross-origin resource sharing），其全称是”跨域资源共享”，是 W3C 的一个标准。 CORS 允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而克服了AJAX只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。幸运的是目前几乎所有的浏览器都支持该功能，唯一美中不足的是IE浏览器的版本不能低于IE10。 实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。SpringBoot 自带注解 CrossOrigin 可以用来解决跨域问题。 修改一下 Controller 的代码，增加 CrossOrigin 注解，示例代码如下： 12345@CrossOrigin@RequestMapping(value = "/name", method = RequestMethod.GET)public MSResponse sigin(@RequestParam(value = "username") String userName, @RequestParam(value = "userpwd") String userPwd) &#123; // 省略&#125; 重新启动服务，抓包工具可以看到 OPTIONS 和 GET 请求都正常执行，返回码都是200。 可以针对某个方法添加 CrossOrigin 注解，也可以对整个 Controller 添加该注解。 关于 CrossOrigin 注解，大家可以自行实践，这里不再赘述。 一直坚持在学习的路上努力~]]></content>
      <categories>
        <category>Server</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP OPTIONS CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳绳的故事]]></title>
    <url>%2F2019%2F08%2F24%2F%E8%B7%B3%E7%BB%B3%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[夏天的太阳永远都是那么强劲有力，南方尤为突出。整个地面都冒着热气，像一双无形的双手紧紧地抱着你，马路上反射的光纵然你火眼金金也会心生敬畏。不知道你有没有发现，即使这么热的天，篮球场上还有很多“战士”奋不顾身的拼个你死我活。倒不是他们不怕热不怕累，而是因为他们喜欢这项运动更愿意为了这项运动而付出。 讲一个听来的故事~ 公司将要进行跳绳比赛，各个小组积极备战，需要大家一起努力配合才能把绳跳好。 组长发现刚开始大家都很难保持动作的一致性，经过一番练习之后，大部分人能动作一致了，还有一小部分人做起来有点困难。 组长试着让有经验的人带着那些跳不好节奏的人，这样又练习了一段时间，绝大部分人已经能很好的配合了，其余跟不少节奏或者怎么都调教不好的人只能去啦啦队那里呐喊助威了。 在我们团队中也一样，有人能带着大家往前走，自然就会有人拖住大家的后腿，我曾今把这种现象叫做“相对论”。在团队中，发现有人掉队了或者很吃力的在前进，试着去调整一下他的工作或者找人帮帮他，经过一段时间的调整如果还是没有好转，只能让他另谋高就了，对大家都好。 虽然很残忍，但事实确实如此！ 我们能做的就是找好自己的位置，并且在这个位置上发挥自己最大的价值。 时间可以改变一切，但你得做点什么！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>团队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还有你不知道的Java枚举特性(下篇)]]></title>
    <url>%2F2019%2F08%2F11%2F%E8%BF%98%E6%9C%89%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E6%9E%9A%E4%B8%BE%E7%89%B9%E6%80%A7-%E4%B8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[简介这篇是博文 还有你不知道的Java枚举特性(上篇) 的下篇，可以点击下面的链接前往。 本篇主要内容： Java 枚举是一个特殊的类，聊聊其方法的重写 如何使用接口来组织 Java 枚举？ 如何使用枚举实现 Java 的单例模式 JDK 数据结构中关于枚举的集合 EnumSet 和字典 EnumMap 重写枚举的方法所有的枚举类都继承自 Enum，在这个父类当中 toString、equals 和hashCode 的三个方法，可以看一下，源码如下： 1234567891011public String toString() &#123; return name;&#125;public final boolean equals(Object other) &#123; return this == other;&#125;public final int hashCode() &#123; return super.hashCode();&#125; 可以看出在这三个方法当中，我们只能重写 toString 方法，另外两个方法都是 final 修饰的方法，不可以被子类重写。 我们在自定义的枚举中，可以重写 toString 方法的，示例如下： 1234567891011121314151617public enum Color &#123; RED("red color"), GREEN("green color"), BLUE("blue color"), YELLOW("yellow color"); Color(String name) &#123; _name = name; &#125; private String _name; @Override public String toString() &#123; return "this.name: " + _name; &#125;&#125; 关于 Enum 的源码，可以在博文 Java 枚举的本质 中的文末翻阅。 对于 Java 中所有枚举都是继承自 Enum，大家可以去使用 javap 命令反编译看看，如下代码是 javap 后的简单示例： 123456789public final class com.veryitman.Color extends java.lang.Enum&lt;com.veryitman.Color&gt; &#123; public static final com.veryitman.Color RED; public static final com.veryitman.Color GREEN; public static final com.veryitman.Color BLUE; public static final com.veryitman.Color YELLOW; public static com.veryitman.Color[] values(); public static com.veryitman.Color valueOf(java.lang.String); static &#123;&#125;;&#125; 可以看到 Color 是继承自 java.lang.Enum 的，Enum 是一个抽象类并实现了 Comparable 和 Serializable 这两个接口，如下： 1public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable 使用接口组织枚举当我们定义的枚举过多且又有很多嵌套，可以使用接口来组织这些枚举，将其归类，这样一来不仅代码看起来很规范，并且也很好管理代码。 如下示例，使用接口 MobileTool 来组织两个枚举。 123456789public interface MobileTool &#123; enum Phone implements MobileTool &#123; HUAWEI, iPhone, OPPO, XIAOMI &#125; enum Pad implements MobileTool &#123; iPad, WEPad, sPad &#125; &#125; 简单的可以这样使用，示例如下： 12345MobileTool mphone = MobileTool.Phone.HUAWEI;mphone = MobileTool.Phone.iPhone;MobileTool mpad = MobileTool.Pad.iPad;mpad = MobileTool.Pad.sPad; 枚举实现单例模式在 Effective Java 这本书籍中，作者有个这样下面的描述： 1"This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, a single-element enum type is the best way to implement a singleton." 核心的意思是 1使用枚举实现单例的方法虽然还没有广泛采用，但单元素的枚举类型已经成为实现 Java 单例模式的最佳方法。 我们用枚举实现一下单例模式，示例代码如下： 1234567public enum Foo &#123; INSTANCE; public void printFoo() &#123; System.out.println("Foo here."); &#125;&#125; 相比 Java 中其他的单例实现方式，此时此刻你会发现，枚举实现单例的代码会精简很多。 那么，枚举实现单例模式到底有哪些优势呢？或者换句话说，就这样实现单例靠谱吗？ 经过大量例子和 Java 编程专家的讲解，枚举实现单例模式相当靠谱，它具有以下一些特点： 1、枚举实现的单例模式是线程安全的 本质上面来讲，枚举实现的单例之所以是线程安全的，这个跟 Java 的类加载机制有关。从上面反编译的代码来看，枚举是 final class 并且每个枚举值都是 static 的，这里牵扯到 ClassLoader 的相关知识，如果有兴趣建议大家去研究一下。 总之，对于我们任何一个枚举在第一次被真正用到之时，会被 Java 虚拟机加载并且完成初始化，而这个初始化过程是线程安全的，所以你需要记住枚举实现的单例模式是多线程安全的就可以了。 2、枚举可解决反射/反序列化问题 我们知道，一般的单例模式都存在两个问题，一个是可以通过反射调用，另一个就是可以通过序列化和反序列化来破坏单例。 一般解决反射调用可以通过私有构造方法中做处理，示例代码如下： 1234567891011private static boolean flag = false;private Foo() &#123; synchronized (this) &#123; if (false == flag) &#123; flag = true; &#125; else &#123; throw new RuntimeException("不能反复创建"); &#125; &#125;&#125;; 了解序列化原理的同学，可以通过在单例类中实现 readResolve 方法就可以避免反序列化攻击这个问题了。示例代码如下： 123private Object readResolve() &#123; return INSTANCE;&#125; Java 的枚举的反序列化实现并不是通过反射实现的，也就是说枚举的序列化和反序列化是有经过特殊定制和处理的，这就可以避免反序列化过程中由于反射而导致的单例被破坏问题。 总之，枚举实现的单例模式不仅可以防止反射破坏，还可以防止序列化破坏单例。 除枚举实现单这种方式以外，我一般使用下面两种方式来实现单例模式。 饿汉式的单例模式写法 1234567891011public class Foo &#123; private static Foo instance = new Foo(); private Foo () &#123; &#125; public static Foo getInstance() &#123; return instance; &#125;&#125; 静态内部类实现单例模式 12345678910111213public class Foo &#123; private static class FooHolder &#123; private static final Foo INSTANCE = new Foo(); &#125; private Foo () &#123; &#125; public static final Foo getInstance() &#123; return FooHolder.INSTANCE; &#125;&#125; 枚举集合EnumSet 是一个专为枚举设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举值。 EnumSet 类结构图如下： EnumSet 是一个抽象类，无法被实例化，但是可以通过静态方法获取该类的实例。 12public abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt; implements Cloneable, java.io.Serializable EnumMap 类结构图如下： EnumMap 定义如下： 12public class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K, V&gt; implements java.io.Serializable, Cloneable EnumSet 保证集合中的元素不重复；EnumMap 中的 key 是 enum 类型，而 value 则可以是任意类型。 关于这两个数据结构的使用方法，大家可以参考 JDK 手册。 赠人玫瑰，手留余香~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java enum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还有你不知道的Java枚举特性(上篇)]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%BF%98%E6%9C%89%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E6%9E%9A%E4%B8%BE%E7%89%B9%E6%80%A7(%E4%B8%8A%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[简介博文 Java 枚举的本质 跟大家一起学习了 Java 语言中枚举到底是什么，探索其本质和原理。用一句话来概括其本质就是：“Java 中的枚举是一个特殊的 Java 类”，有兴趣的同学可以点击了解上面那篇文章。 今天跟大家一起学习和总结一下 Java 中的枚举的其他特性和用途，由于内容较多，这次的分享分为两篇文章来写，欢迎大家拍砖、指正和交流！ 本篇主要内容： Java switch 语句支持枚举类型以及注意事项 Java 枚举的常量使用 如何在自定义枚举中自定义成员变量和成员方法、静态方法 Java 枚举实现接口 下篇主要内容： Java 枚举是一个特殊的类，聊聊其方法的重写 如何使用接口来组织 Java 枚举？ JDK 数据结构中关于枚举的集合 EnumSet 和字典 EnumMap switch 语句支持枚举JDK1.5 才开始有枚举类型，同时可爱的 Java 组织丰富了 switch 语句，即支持枚举。 我们还是动手写个例子~ 定义一个枚举 Color，示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); // 构造方法 Color(String name, int id) &#123; _name = name; _id = id; &#125; private String _name; private int _id; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125; public static Color getColor(int max) &#123; Random random = new Random(System.currentTimeMillis()); int num = random.nextInt(max); switch (num) &#123; case 0: return Color.RED; case 1: return Color.GREEN; case 2: return Color.BLUE; case 3: return Color.YELLOW; default: return Color.BLUE; &#125; &#125;&#125; 为枚举 Color 提供了一个静态方法 getColor，可以获取随机的颜色值。 那么，可以结合 switch 语句这样使用，示例代码如下： 123456789101112131415161718192021public static void main(String[] args) &#123; int len = Color.values().length; Color color = Color.getColor(len); switch (color) &#123; case RED: System.out.println("select " + "RED"); break; case GREEN: System.out.println("select " + "GREEN"); break; case BLUE: System.out.println("select " + "BLUE"); break; case YELLOW: System.out.println("select " + "YELLOW"); break; default: System.out.println("select " + "unknow!!"); break; &#125;&#125; 可以看出，switch 语句中条件值是 Color 对象。 这里提醒大家要注意一个问题，如果 case 的条件带上类的名字，代码是无法通过编译的。如下面的代码（错误示例）： 1234// Errorcase Color.RED: System.out.println("select " + "RED"); break; 编译的错误信息： 1Error: An enum switch case label must be the unqualified name of an enumeration constant 即 switch case 语句结合枚举使用时，只能写枚举类定义的变量名称，不能加类名。 当常量使用一般在 Java 中我们定义常量最常用的方式就是使用下面的方式，如下： 1public static final int MAX_NAME_LENGTH = 0x1112; 有了枚举之后，也可以使用枚举来定义常量。 123public enum Color &#123; YELLOW, BLANK, RED, GREEN&#125; 这样就可以把一些相关的常量放到定义的枚举当中了。 自定义方法、成员变量上面的例子中自定义的一个枚举 Color，大家可以看到可以给它添加成员变量 _id、_name，构造方法和其他方法 getColor（静态方法）。 如果这部分很难理解，建议去阅读 Java 枚举的本质 这篇文章。 实现接口所有的枚举类都继承自 Enum，因为 Java 不支持多继承，所以枚举无法继承其它类。 枚举既然是和 Java 的普通类基本一样，那么，枚举当然也可以实现接口。 下面是枚举 Color 实现接口 Paint 的例子，如下： 123456789101112131415161718192021interface Paint &#123; void setColor(); &#125;public enum Color implements Paint &#123; RED("red color"), GREEN("green color"), BLUE("blue color"), YELLOW("yellow color"); Color(String name) &#123; _name = name; &#125; private String _name; @Override public void setColor() &#123; System.out.println("Current paint color: " + _name); &#125;&#125; 还可以采用匿名内部类的方式，让每个枚举值实现接口 Paint 的方法，示例如下： 12345678910111213141516171819202122232425262728293031323334353637public enum Color implements Paint &#123; RED("red color") &#123; @Override public void setColor() &#123; System.out.println("Current paint color: " + RED._name); &#125; &#125;, GREEN("green color") &#123; @Override public void setColor() &#123; System.out.println("Current paint color: " + GREEN._name); &#125; &#125;, BLUE("blue color") &#123; @Override public void setColor() &#123; System.out.println("Current paint color: " + BLUE._name); &#125; &#125;, YELLOW("yellow color") &#123; @Override public void setColor() &#123; System.out.println("Current paint color: " + YELLOW._name); &#125; &#125;; Color(String name) &#123; _name = name; &#125; private String _name; @Override public void setColor() &#123; System.out.println("Current paint color: " + _name); &#125;&#125; 可以写个方法测试一下，如下： 12345public static void main(String[] args) &#123; for (Color color : Color.values()) &#123; color.setColor(); &#125;&#125; 输出结果，如下： 1234Current paint color: red colorCurrent paint color: green colorCurrent paint color: blue colorCurrent paint color: yellow color 人生没有永远的赢家，切勿大喜大悲，要以平常心对待一切~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java enum switch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 学习几个容易混淆的URL注解]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%AD%A6%E4%B9%A0%E5%87%A0%E4%B8%AA%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84URL%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[了解 URL首先，大家需要知道下面这三个东西的定义： URI，Universal Resource Identifier，统一资源标志符 URL，Universal Resource Locator，统一资源定位符 URN，Universal Resource Name，统一资源名称 在 WWW 上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫 URL，它是 WWW 的统一资源定位标志，就是指网络地址。 URL 是 URI 的子集，所有的 URL 都是 URI，但不是每个 URI 都是 URL，还有可能是 URN，他们的关系可以用下面的图来表示： 换句话说，URI 分为三种，URL 或者 URN 或者是 URL 和 URI 的组合。 不管怎么说，大家平时使用HTTP请求的地址基本都是称之为 URL，所以暂时不必要纠结于三者的区别之中而无法自拔，搞懂 URL 的组成部分和规范才是重点。 URL 由三部分组成即资源类型、存放资源的主机域名和资源文件名。 URL 的一般语法格式为： 1scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] 具体参数释义如下： scheme：传送协议有些地方也写作protocol，如http、https、ftp等 user:password：访问资源需要的凭证信息，可省略 host：服务器地址，通常为域名，有时为IP地址 port：端口号，以数字方式表示，一般使用端口默认值80，可省略 path：路径，以“/”字符区别路径中的每一个目录名称 query：查询，GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题 fragment：片段，以“#”字符为起点 常用的 URL 如下： 123http://www.veryitman.com/article/name=itman&amp;pwd=123http://www.veryitman.com/article/1/2 大部分的编程语言都会有针对 URL 处理的系统函数库，最常用的如 URLEncode、URLDecode 针对 URL 编解码的类。 下面跟大家分享一下在 SpringBoot 中经常使用的 RequestParam、QueryParam、PathVariable 和 PathParam 这三个注解。 @RequestParam注解 @RequestParam 可以从每个 HTTP Request 中获取参数，该注解支持下面四种参数： defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值 name 绑定本次参数的名称，要跟 URL 上面的一样，否则会请求失败 required 用来标示对应的参数是不是必须的，默认是 true，如果对某个参数做可选值可以设置该值为 false value 是 name 属性的一个别名，value 和 name 只能出现一个否则会请求报错 下面是注解 @RequestParam 的源码： 1234567891011121314151617181920212223package org.springframework.web.bind.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestParam &#123; @AliasFor("name") String value() default ""; @AliasFor("value") String name() default ""; boolean required() default true; String defaultValue() default "\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n";&#125; 这里重点说一下 value 这个值，举个例子。 1234@RequestMapping(value = "/friends", method = RequestMethod.GET)public String getFrieds(@RequestParam(value = "page") String page, @RequestParam(value = "pageSize") String pageSize) &#123; return "Get friend list. " + "page: " + page + " - pagesize: " + pageSize;&#125; 该方法有两个参数，分别是 page 和 pageSize，注意这里的参数 pageSize 是大写的，在注解 @RequestParam 中对应的 value 值也是大写的 pageSize，现在启动工程后，请求一下下面的地址。 1http://localhost:8080/friends?page=1&amp;pageSize=2 这个时候可以正常访问且能返回正确的结果，假如我们将 @RequestParam 中对应的 value 值改为小写的 pagesize 再来使用上面的地址访问呢？ 就会报下面的错误，如图所示： 所以需要修改访问地址，即将 pageSize 改为 pagesize： 1http://localhost:8080/friends?page=1&amp;pagesize=2 那我们再思考另外一个问题，是否可以修改注解 @RequestParam 中对应的value值的 page 和 pageSize 为其他的比如 xx、yy？ 动手试试就知道了！ 1234@RequestMapping(value = "/friends", method = RequestMethod.GET)public String getFrieds(@RequestParam(value = "xx") String page, @RequestParam(value = "yy") String pageSize) &#123; return "Get friend list. " + "page: " + page + " - pagesize: " + pageSize;&#125; 函数本身的参数名称 page 和 pageSize 没有做任何修改，只是将注解中的修改为 xx 和 yy 了，再次访问下面的URL： 1http://localhost:8080/friends?xx=1&amp;yy=2 一如既往的正常~ 所以，对于注解 @RequestParam 的参数，URL中对应的参数一定要和value对应。 @QueryParam这个跟 @RequestParam 基本一致，都是以键值对的方式来或者参数。 只不过，该注解需要在 pom 文件中导入依赖，如下： 12345&lt;dependency&gt; &lt;groupId&gt;javax.ws.rs&lt;/groupId&gt; &lt;artifactId&gt;jsr311-api&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 然后在工程类中需要导入包，如下： 1import javax.ws.rs.QueryParam; 注解 @QueryParam 源码： 12345678910111213@Target(&#123;ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface QueryParam &#123; /** * Defines the name of the HTTP query parameter whose value will be used * to initialize the value of the annotated method argument, class field or * bean property. The name is specified in decoded form, any percent encoded * literals within the value will not be decoded and will instead be * treated as literal text. E.g. if the parameter name is "a b" then the * value of the annotation is "a b", &lt;i&gt;not&lt;/i&gt; "a+b" or "a%20b". */ String value();&#125; 可以看到 @QueryParam 只有 value 一个属性，value 对应的值要和函数参数保持一致，否则可能请求会得不到预期的响应结果，这个跟注解 @RequestParam 是不一样的。下面给个示例，如下： 1234@RequestMapping(value = "/friends", method = RequestMethod.GET)public String getFrieds(@QueryParam(value = "page") String page, @QueryParam(value = "pageSize") String pageSize) &#123; return "Get friend list. " + "page: " + page + " - pageSize: " + pageSize;&#125; 在浏览器请求下面的地址即可。 1http://localhost:8080/friends?page=1&amp;pageSize=2 @PathVariable注解 @PathVariable 与上面的刚说的注解 @RequestParam 是不同的，@PathVariable 需要从 URI 中获取参数，比如下面的例子，如下： 1234@RequestMapping(value = "/friends/&#123;page&#125;/&#123;pagesize&#125;", method = RequestMethod.GET)public String getFrieds(@PathVariable(value = "page") String page, @PathVariable(value = "pagesize") String pageSize) &#123; return "Get friend list. " + "page: " + page + " - pagesize: " + pageSize;&#125; 在 @RequestMapping 中写了 {page}/{pagesize}，二者带上了 {} 这样 @PathVariable 才能识别。 请求下面的地址，可以正常访问。 1http://localhost:8080/friends/1/2 相当于 page=1，pagesize=2，所以注解 @PathVariable 是从URI 中匹配参数的，他不是以键值对方式获取对应的值。 @PathVariable 源码如下： 123456789101112131415161718192021package org.springframework.web.bind.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface PathVariable &#123; @AliasFor("name") String value() default ""; @AliasFor("value") String name() default ""; boolean required() default true;&#125; 有三个属性 value、name 和 required，其中 value 也是 name 的别名。 @PathParam注解 @PathParam 源码如下： 123456789101112package javax.websocket.server;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.PARAMETER&#125;)public @interface PathParam &#123; String value();&#125; 可以看出，@PathVariable 和 @RequestParam 是 org.springframework.x 包下面的即属于spring框架，而 @PathParam 属于 javax.websocket.x 包下面的。 注解 @PathParam 只有一个属性 value，没有其他属性了。@PathParam 里面的value对应的值一定要和函数参数名称一致（包括大小写），示例： 1234@RequestMapping(value = "/friends", method = RequestMethod.GET)public String getFrieds(@PathParam(value = "page") String page, @PathParam(value = "pageSize") String pageSize) &#123; return "Get friend list. " + "page: " + page + " - pageSize: " + pageSize;&#125; 在浏览器中请求下面的地址，请求和响应都是正常的。 1http://localhost:8080/friends?page=1&amp;pageSize=2 如果 @PathParam 中 value 对应的值和函数参数不一致，请求得不到预期的响应。现在修改 value 的 pageSize 为 pagesize，如下： 1234@RequestMapping(value = "/friends", method = RequestMethod.GET)public String getFrieds(@PathParam(value = "page") String page, @PathParam(value = "pagesize") String pageSize) &#123; return "Get friend list. " + "page: " + page + " - pageSize: " + pageSize;&#125; 在浏览器中请求下面的地址： 1http://localhost:8080/friends?page=1&amp;pagesize=2 就会得到下面的结果，如下图所示： 但是你使用 http://localhost:8080/friends?page=1&amp;pageSize=2 对于上面的代码请求和响应也是正常的，这就说明注解 @PathParam 中请求的 URL 参数是以函数参数为主的，他和注解 @QueryParam 、@RequestParam 都是以键值对方式获取对应的值。 所以，注解 @PathParam 中 value 对应的值和函数参数尽量保持一致。 学海无涯苦作舟~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot 微服务 注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 立志做个伟大的项目]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%AB%8B%E5%BF%97%E5%81%9A%E4%B8%AA%E4%BC%9F%E5%A4%A7%E7%9A%84%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[简介在开篇 微服务: 步步为营 里面我们已经定下一个小目标（以终为始的策略），即使用 Spring Boot 写 API 提供给 iOS、Android 客户端或者网页端来调用。 接下来我们开始完成我们这个超级梦想吧！在启航之前，我们还是给这个 App 起个名字吧，该 App 就是给用户展示 Blog 的，所以暂且称之为 MSBlog 吧！ 朋友做了一个关于 人工智能的教程，教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！点 这里 可以跳转到教程，对人工智能感兴趣的同学可以了解一下。 原型图项目 MSBlog 的原型图是用 Balsamiq Mockups 3 画的，这个画图工具使用起来非常简单，画出来的效果也相当凑合！ 1、登录、注册页面 登录和注册页面相对比较简单，第一个版本我们只支持用户名登录，后面再支持其他登录方式。 下图左边是登录页面，右边是注册页面，如图所示： 2、四个Tab页面 这四个主页面，分别是首页、文章分类、好友、个人页面，如下图所示： 上面的原型图只做了登录、注册和 Tab 主页面，从这几个页面已经可以看出这个 App 的构造了。 1、首页（Home）：主要展示推荐的文章，以及广告展示页（Banner）。 2、分类（Category）：文章分类，按照评论数、发布时间、热度对所有文章进行分类。 3、好友（Friends）：App 中所有的好友，需要支持本地搜索。 4、个人（Profile）：个人中心，基本是任何一个 App 的标配。 项目计划从上面的原型图中，我们基本了解接下来要做什么了。 首先，把登录、注册页面搞定，接着再把四个 Tab 页面搞起来，对于 App 初学者来说，这个压力着实不小了，没关系慢慢来，一步一个脚印的走下去。 无论是哪个页面，都需要服务端提供相关的接口（API）和数据，简单描述一下吧，如下： 1、登录（Signin）：需要服务端提供登录接口，即支持用户名和密码登录的API能力。 2、注册（Signup）：需要服务端提供注册的接口，即支持用户名和密码注册的API能力。 3、首页（Home）：需要提供查询推荐文章的API，后期需要考虑智能推荐。 4、分类（Category）：需要提供查询所有文章分类的API。 5、好友（Friends）：需要提供查询每个人所有好友的API。 6、个人（Profile）：需要提供当前登录用户的所有信息，如用户名、头像、昵称等信息。 第一步，先把这登录注册做好，服务端把登录、注册的 API 准备好； 第二步，然后再做 Tab 页面，服务端把其他 API 准备好； 第三步，客户端和服务端联调数据，确保我们能正常使用客户端。 客户端先从 iOS 开始，Android 版本的 MSBlog 后续再补上，iOS 客户端的项目采用 MVC 的架构，开发语言采用 Swift（Swift版本为5.0），IDE 采用高大上的 Xcode，项目代码使用 Git 来管理，用 Github 作为代码仓库。 到这里，是不是觉得自己还有很多东西需要学习比如 Swift 编程语言。当然了，如果你会 Flutter 或者 Javascript 也可以写客户端代码。别担心，我从容的告诉你，编程语言这个东西没有你想象中的那么难，多动手写就可以了，遇到不会就去查手册。世上本没有路，走的多了就有了，对于编程也一样，写的多了就能融会贯通，举一反三。真正难的是你不动手总是在那里埋怨！ 后期有可能会使用 Flutter 来写这个 App，待定。 祝好，加油！是时候动手写起来了！ 改变，从你我相识开始~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot 微服务 项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务：本地热部署]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9A%E6%9C%AC%E5%9C%B0%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[简介在项目开发中，难免会经常修改代码来验证一些问题，如果每次修改都需要进行重新关闭、启动这样的操作会让人有点不爽，如果能实现代码的热部署就好了。 所谓热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。通俗来讲，热部署就是在修改代码后，不需要重新启动服务器，就可以加载修改后的代码，看到修改后的效果。对于 IDEA 来说，热部署就是不需要反复的通过开始、停止来进行项目的启动，而是修改代码保存后自动加载修改后的代码。 Spring Boot 提供了热部署能力。可以使用 Spring Boot Loader 的方式，也可以使用 Spring Boot Devtools的方式来进行，二者实现方式是不同的，大致总结如下： Spring Boot Loader：真正的热部署。 Spring Boot Devtools：重新部署来实现热部署。 这两种热部署也是本地热部署，真正的远程服务器热部署方案另有方案，这个不是今天分享的点后续牵涉到部署方案再说！今天只分享如何使用 devtools 实现 Spring Boot 项目的热部署。 朋友做了一个关于 人工智能的教程，教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！点 这里 可以跳转到教程，对人工智能感兴趣的同学可以了解一下。 spring-boot-devtools在 IDEA 中使用 devtools 需要修改 IDEA 的设置和工程的 pom 文件，具体操作步骤如下。 1、修改pom.xml文件，增加devtools 在 pom.xml 文件中的 dependency 下增加 devtools，如下： 1234567&lt;!--Devtools--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt; 在 build 标签下增加 configuration/fork 配置，如果没有该项配置，devtools 不会起作用，即应用不会重启。 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、修改IDEA编译选项 在IDEA中打开 File/Settings，如下图所示： 3、修改IDEA中的Registry 在 IDEA 中 Help/Find Action...，打开下面的对话框，输入registry 进行搜索，如下图： 双击 Registry，出现下面弹框，如图操作，选中 Compiler autoMake allow when app running 即可。 也可以使用快捷键 ctrl + shift + alt + / 打开 Registry，如图： 4、重新启动项目 重新运行项目进行验证。 1234@RequestMapping(value = "/user")public String user() &#123; return "Greate user!";&#125; 浏览器打开：http://localhost:8080/user 可以看到效果。 修改原来的 user 方法和增加一个 user2 方法，再来验证。 123456789@RequestMapping(value = "/user")public String user() &#123; return "Greate user, welcome!";&#125;@RequestMapping(value = "/user2")public String user2() &#123; return "Greate user!";&#125; 分别在浏览器打开：http://localhost:8080/user 和 http://localhost:8080/user2 现在不需要在 IDEA 中重新启动、关闭这种麻烦操作了。 如果你足够细心就会发现，使用 devtools 后，每次修改控制台自动的重新启动了 Spring Boot 项目，所以 devtools 是使用了重新部署的方式从而实现了热部署的功能。 注意几个问题1、代码修改不会立即生效随着工程越来越大，修改代码或者配置后需要稍等几秒钟（一般3s以内）就会自动重新启动工程，控制台就会看到日志的输出。 2、代码修改后控制台没有自动的重新启动工程这个就需要按照这篇文章说的，重新检查一下如下设置： pom 文件，检查一下是否把必要的配置被修改了。 IDE 的设置是否和本文一致。 改变，从你我相识开始~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot 微服务 热部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认知]]></title>
    <url>%2F2019%2F06%2F23%2F%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[任何时候都不要轻易的开口说：“这不可能”，就跟在任何情况下都不要轻易说放弃一样重要。 在很多场合下，你这么一说不仅暴露了你的学识，而且还会暴露你的心态。特别是程序员，在产品说要实现xxx功能或者UE说要实现yyy效果的时候，很容易用“这个无法实现”这样的语句来“抗拒”需求。 我记得有这样一件小事。 程序员A说：“这个框架已经限制了，无法实现这个功能，别白费力气了!”。 程序员B说：“我们可以再试试，或许还有其他办法呢？”。 A显得很不耐烦，说到：“你要是不相信我，你就自己搞吧，我不管了!”。 B没有和A继续争论而是默默地转去想办法解决问题。功夫不负有心人，下午B就找到了解决方案，这个方案不仅简单而且高效，只需要在框架的基础上简单封装一下就好。 这样的场景，我相信参加过工作的开发大大们经常遇到。之所以我们说出一些类似“不可能”的华语，要么是心态不对，要么是认知不够。很多人在工作当中面对复杂事情的时候会说“这不可能”或者“这绝不可能”的话，可能你都没有思考过就随口说出来了，一方面显得自己知识不足，另一方面会拒别人于千里之外。 刚入职场的程序员和工作已久且爱思考的程序员有着很不一样的认知。刚入职场的程序员或者工程师，面对产品经理提出的需求基本都是一一顺从，无论需求是否合理，他们都会老老实实的把需求转化为一行行的代码，稍微有点想法的估计因为“胆小”而不敢发声。随着职场的磨练，业务能力的增强他们开始有了自己的想法和思考，敢于产品经理“抗衡”了，对于不合理的需求会与产品大大们针锋相对，有时候你会发现产品需求会议俨然一场分崩离析的内战。项目做的多了，编程能力、业务能力和沟通能力又上了一层楼，优秀的程序员们不仅能挑出不合理的需求（伪需求）而且还能提出更合理的需求帮助产品更上一层楼，提升产品的逼格和实用性，不仅减少了开发成本而且还提升了团队作战的士气，更重要的是产品经理以后不敢小瞧你了，你自己也会获得无行的成就感。经历事情（如项目经历），思考和总结事情的发展、经过、结局，从而不断的提高自己的业务水平是提升自我认知的一个有效途径。 年轻时候的嬴政敢爱敢恨，个性很强，下面是吕不韦和嬴政的一段对话。 吕不韦：我为了王上的千秋大业，有些事情，王上一时不可理解。嬴政：不可理解？有些事情，还要使劲才能理解呀？吕不韦：我只能告诉你，当一个人还不够成熟的时候，他所看到的事情，未必是真实的。嬴政：未必真实？那我看到的是什么？吕不韦：你看到的，只是真实的影子。嬴政：那就请仲父告诉我，如何才能理解你的真实？吕不韦：王上现在还没这个能力！ 统一六国之后，嬴政面对李斯感慨：“如今天下已经一统，那么大秦现如今的仲父又是谁呢？”可见吕不韦在嬴政心中的地位举足轻重，非同一般。 我从 “深入理解Linux内核” 这本书中，看到了这样一段话: Linux 是非抢占式（nonpreemptive）内核。 自从接触Linux以来，在个人的认知中Linux都是抢占式的。那么为什么这里却说它是非抢占式的呢？ 这本书又很权威，难道是自己错了？我就硬着头皮又去找相关的资料，结果算是搞清楚了来龙去脉。 Linux分为内核抢占和用户抢占，Linux内核版本2.4支持内核抢占但不支持用户抢占，一直到Linux内核版本2.6才都支持内核抢占和用户抢占，”深入理解Linux内核” 这本书是基于Linux内核版本2.4之前讲解的，所以说法并没有错误。 活到老学到老，讲的是人无论在那个阶段都不应该放弃学习，因为只有不断的学习才能提高自己的认知。对于新鲜事物，我们一定要保持敬畏之心，因为你没有这方面的经验，虚心请教和借鉴才能避免一定的损失。我记得有一次参加一个技术培训，老师提问：“谁能简单解释一下什么是 墨菲定律 ？”，我看了一下全场，半分钟没有人回答，于是自己就斗胆站起来说了：“你总是担心的事情，它总会发生的。”，老师满意的点了点头，我相信当时会场中有能比我解释更好的人，可能是他不敢也有可能是他不屑于回答。说这个事情并不是要彰显我自己有多么厉害，而是要告诉大家多读书是提高自我认知能力的一种方式。 墨菲定律主要内容有四个方面： 一、任何事都没有表面看起来那么简单； 二、所有的事都会比你预计的时间长； 三、会出错的事总会出错； 四、如果你担心某种情况发生，那么它就更有可能发生。 “墨菲定律”的根本内容是“凡是可能出错的事有很大几率会出错”，指的是任何一个事件，只要具有大于零的机率，就不能够假设它不会发生。 对于人的认知大概可以分为四个阶段，如下图所示： 以后工作中或者生活中遇到一些自己不知道的事情，首先要摆正心态，然后去找比你更强的人来请教。这样做的话，你即结交了朋友又学到了知识，两全其美，何乐而不为呢？ 知之为知之，不知为不知~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>认知 自我成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: Git入门]]></title>
    <url>%2F2019%2F06%2F09%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-Git%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[代码管理如果你还没有Github账号，赶紧点击 这里 去创建一个，很简单，然后下载 Git GUI 安装即可，如果你还不会这些操作，请行动起来去搜索对应的方法，这里不再赘述。 在项目开发过程中，除了写代码之外，还需要对代码进行管理。在说如何管理代码之前，先跟大家分享几个实际开发中关于代码管理的场景。 案例1：入门的小旺 小旺是名入门不久开发之路的编程狂魔，对代码有颗执着的心。平时编写的代码全部放在自己的那台Macbook Pro上面，有一天小旺不小心把自己编写的重要代码给删除了，万恶的 rm -fr code 呀！心中一万头草泥马奔驰而过。这让小旺伤透了脑筋，只能熬夜硬着头皮再把它给码起来，自己犯的错只能默默地承受着。 案例2：新手小李和小刚 小李和小刚是一对编程搭档（公司只有他们两个Android开发，相依为命吧），两位都是开发的新手。每次小李和小刚分别提交代码到仓库，都要经历一场惨目忍睹的博弈。所谓的博弈指的是两位要花很长时间来解决代码冲突的问题，哎，除了写代码还要解决这些无聊的问题，烦！ 如果小旺知道使用Git管理代码，也可以避免误删的风险。 小李和小刚要比小旺机智，至少知道代码要提交到仓库，当然小李和小刚工作经验丰富，公司也要求代码必须提交。但是二位却没有用好代码管理工具，从而带来了一些烦恼。 是的，管理代码很重要，无论使用SVN还是Git，至少你要熟练掌握其中一个，我建议还是直接学习Git吧，毕竟现在大多数公司都在用它。 在 Spring Boot 系列的文章中，使用 Github 作为我们的代码管理仓库，使用Git工具进行代码的提交、修改、合并和删除以及对分支的管理和使用。 Git 提交把在 微服务: 想办法让项目运行起来 写好的代码提交到代码仓库中，这样即使本地代码被误删也可以从远程找回来，安全。假如你更换一台电脑进行编程也可以从远程仓库拉下代码进行编程，随时随地撸代码。 提交代码，很简单，windows上面安装git工具即可。我使用的是 Git GUI，它自带 Git Bash，有种Unix终端的风范，贼亲切！ 我比较喜欢使用命令行来进行操作，打开工程目录，如下： 然后在空白地方右键，会显示 Git Bash，选他就会打开命令终端工具，如下图所示： 在终端操作命令如下： 123456# 添加所有文件git add -A *# 提交到本地仓库并加上注释git commit -m "Create a greate project"# 推送到远程master分支git push origin master 如果你之前没有进行任何git提交的话，首次提交会提示你输入用户名和密码，此时你输入自己的github账号和密码即可。 三步操作完成后，工程也就提交成功了。为了验证提交是否成功，你也可以到远程仓库(使用浏览器打开你的仓库地址)刷新看看有没有刚才提交的内容，如果网络不好就等会在瞅瞅。 创建分支为了不影响主干(master)上面的代码，我们可以创建一个个人分支来进行开发，例如我的个人分支 veryitman-feature 分支。 1git chekcout -b veryitman-feature 上面的git命令意思是在本地创建一个名为 veryitman-feature 的分支。 注意：git chekcout -b xxx 相当于进行下面两步操作 123git branch xxxgit checkout xxx 主干 master 本身也是一个分支，只是开发者为了协助和代码管理方便创建了各自的分支，等代码测试或者验收通过再从自己的分支合并代码到主干 master 上面，所以一般 master 分支上面的代码都会认为是相对理性、安全的代码。 分支的存在是为了方便代码的管理，类似于SVN的trunk、tag、branch文件夹管理代码一样。 创建完成后，提交分支到远程仓库即可，终端操作命令如下： 1git push origin veryitman-feature 去远程代码仓库中，刷新页面后，在Branch可以看到刚才创建的 veryitman-feature 分支，如下图所示： 也可以使用下面的方式进行创建和推送分支代码，操作步骤如下： 123456# 在本地创建新的veryitman-feature分支 git branch veryitman-feature# 切换到新的veryitman-feature分支 git checkout veryitman-feature# 将新的分支推送到仓库git push origin veryitman-feature 切换分支在上面的操作中，大家已经看到我们创建了 veryitman-feature 分支，加上原来默认的 master 分支，一共是两个分支了。 一般来说，master 分支上面的代码应该是经过测试并且稳定的版本，保证其稳定不会出错。而其他分支如上面的 veryitman-feature 是我们需要进行开发的个人分支，不保证其稳定性（因为在开发嘛）。等 veryitman-feature 开发完成再合并到 master 分支上面，关于分支的合并操作，后续再说吧！ Git 支持在分支之间自由切换，比如你在 veryitman-feature 分支，提交完成代码后，可以切换到 master 分支。切换分支的命令如下： 1git checkout master 如果再想从 master 分支切换到 veryitman-feature 也可以，如下： 1git chekcout veryitman-feature 切换分支一般用在下面几个场景中： 合并代码 多分支开发 修复问题 删除分支Git 提供了可以删除分支的方法和命令。 删除分支分为两类，一个是仅仅删除本地分支，另一个是删除远程分支。 删除本地分支意思是删除已经存储在你本地计算机上面的文件，如下： 12# 在本地删除veryitman-feature分支git branch -d veryitman-feature 删除远程分支意思是删除存在 GitHub 上面的代码文件，如下： 12# 在github远程端删除veryitman-feature分支git push origin --delete veryitman-feature 关于Git的使用还有很多，今天先说这么多，用到的时候再补充。现在最重要的是需要你去注册一个 Github 账号折腾起来，熟能生巧，动手实践才是王道！ 改变，从你我相识开始~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot SpringCloud 微服务 Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调侃C中的define]]></title>
    <url>%2F2019%2F06%2F08%2F%E8%B0%83%E4%BE%83C%E4%B8%AD%E7%9A%84define%2F</url>
    <content type="text"><![CDATA[二狗子二狗子这个名字，在大街小巷，在电视剧中几乎都能听到。我也不知道老一辈的父母为什么这么喜欢给自己的孩子取这样的名字，唯一能让我信服的理由是：顺口！大叔大伯们之所以叫这个名字还有一个理由，之前孩子多，希望孩子像小狗儿一样好喂养。 正好我们村有个孩子也叫二狗子，大名叫张力万，无论是叫二狗子还是叫张力万，都指的是同一个人。我们大多数情况下还是叫他二狗子，他也习惯了倒也觉得亲切，叫张力万一般都是在正式场合。 有些企业文化中规定：“不允许在公司直接喊同事的名字，每个人必须有个英文名”。比如二狗子入职到这样的企业，大家不允许喊他二狗子或者张力万，于是二狗子又有了一个英文名：“Jack”，你看 “Jack” 这个名字既符合企业文化又听起来高大尚。 无论是 “二狗子“ 还是 “Jack“ 都是张力万的别名。 在 C 语言中，关键字 define 和 typedef 就可以用来取别名，但是二者又有不同点，今天主要分享一下 define 的用法。 下面是使用 define 来模拟别名，示例如下： 1234567891011#define Zhangliwan1 "二狗子"#define Zhangliwan2 "Jack"#define Zhangliwan "张力万"int main(int argc, const char *argv[])&#123; printf("我们村的%s可以叫他%s也可以叫他%s\n", Zhangliwan, Zhangliwan1, Zhangliwan2); return 0;&#125; 输出结果： 1我们村的张力万可以叫他二狗子也可以叫他Jack 虚构一下丹尼斯·里奇 一个伟大而低调的牛人，是Unix之父、C语言之父。 丹尼斯·里奇还将Unix的设计原则定为 KISS 原则 即 Keep it simple stupid，保持简单和直接，所以Unix一直都是经典中的经典。这也说明丹尼斯·里奇不仅是一个优秀的工程师，还是一个优秀的产品经理。 我在想，当初丹尼斯·里奇和肯·汤普逊在实验室里没事也会讨论C语言的事情。 丹尼斯·里奇：“老兄，你看我们现在的语言是不是过于复杂了？” 肯·汤普逊：“的确有点复杂，我有个大胆的想法，不知当讲不当讲？” 丹尼斯·里奇：“你还跟我墨迹啥，有话直接说呗，呵呵！” 肯·汤普逊：“嗯，我们可以开发一门新的语言，他要足够的简单、高效。” 丹尼斯·里奇：“想法是挺好的，那就开干吧！” 于是C语言诞生了。 肯·汤普逊：“你有没有觉得我们在定义常量的时候不太方便？” 丹尼斯·里奇：“是呀，这样你看行不行，弄个预处理器可以让我们任意定义常量，暂时称他为 ‘宏’ 吧！” 肯·汤普逊：“我觉得完全没有问题，来，徒手写一个。” 丹尼斯·里奇：“哈哈，给力！” 于是 define 就有了。 以上纯属个人猜想，并不是冒犯两位大师，本故事纯属虚构，如有雷同，纯属巧合。Unix和C语言的大道至简，对后代科学的发展奠定了不可磨灭的贡献和影响。 基本用法关键字 define 是 C 语言中的预处理命令，它用于宏定义，在大多数定义下可以提高代码的可读性，为编程提供方便。 在 C 语言中预处理命令以 “#” 号开头，如 #include、#ifdef、#endif 和宏定义命令 #define 等。 关键字 define 的用法如下： 1#define 新类型名 原类型名 12345678#define INTEGER intINTEGER a = 100;#define PI 3.1415927#define UserName "user_name"#define MAX(x, y) (x)&gt;(y)?(x):(y); 在 C 语言中，关键字 define 的定义的常量都会在预处理阶段将用到的别名直接被原样替换掉。例如在编写源程序时，所有用到 3.1415927 的地方都可用 PI 代替，而编译时，将先由预处理程序进行宏代换即用 3.1415927 去置换所有的宏名 PI，然后再进行编译。 关键字 define 还可以结合 “#”、“##”、“#@” 使用。 符号 “#”，表示将其字符串化。 符号 “##”，表示连接变量。 符号 “#@”，表示将其字符化。 12345678#define M(x) x##x#define L(x) #xint main(int argc, const char *argv[])&#123; // M(1): 11, L(1): "1" printf("M(1): %i, L(1): %s\n", M(1), L(1));&#125; 我使用 “#@” 定义，无论是GCC编译器还是Clang编译器都无法通过编译，错误信息：“ ‘#’ is not followed by a macro parameter ”，但是在 Visual Studio 中编译就没有问题。示例如下： 1#define K(x) #@x 关键字 define 给我们写代码带来了一定的便利，但是如果过多的乱用它也会代码不小的麻烦，比如下面的例子： 12345678910#define square(x) x*xint main()&#123; int i; i = 64/square(4); printf("i = %d\n", i); return 0;&#125; 定义宏 square(x) 本来是求某个数的平方，按理说 64/16 结果应该是 4，但是运行程序你会发现结果是 64. 我们把上面的例子展开，因为 define 是直接原样替换，如下： 123i = 64/4*4;i = 16*4;i = 64; 修改一下程序中 define 的定义，结果就对了。 1234567891011#define square(x) (x*x)int main()&#123; int i; i = 64/square(4); // 4 printf("i = %d\n", i); return 0;&#125; 其实最安全的做法是这样定义，如下： 1234#define square(x) (&#123; \typeof(x) y = (x); \y*y; \&#125;) 作用域可以在C文件的开头，也可以在方法体里面，还可以在方法的声明前都可以使用 define 关键字。 定义在文件开头： 1234567#define NAME "name"int main()&#123; printf("Define NAME: %s\n", NAME); return 0;&#125; 定义在方法中： 12345void play()&#123; #define NAME "name" printf("Define NAME: %s\n", NAME);&#125; 这里要注意，定义在方法中，并不是指该宏定义 NAME 只能用在该方法里面，其他地方照样可以使用。 1234567891011void play()&#123; #define NAME "name" printf("Define NAME: %s\n", NAME);&#125;/* 注意：该方法一定是在define定义之后才能使用NAME */void eat()&#123; printf("Define NAME: %s\n", NAME);&#125; 条件编译在C语言中或者在类C语言中如Objective-C和C++中，我们会经常用到条件编译语句，如下： 12345#ifdef NAME#else#endif 大家在做一些跨平台开发工作的时候，也会用到条件编译语句。 12345#ifdef ANDROID#define PLAYFORM 1#else#define PLAYFORM 2#endif 还有就是类似防止重复包含（重复定义）头文件，也会用到条件编译，如下： 123#ifndef __Header_Person_H__#define __Header_Person_H__#endif 下面是来自Linux Kernel里面的代码片段： 1234567#if defined(CONFIG_ALPHA_GENERIC)#define GAMMA_BIAS alpha_mv.sys.t2.gamma_bias#elif defined(CONFIG_ALPHA_GAMMA)#define GAMMA_BIAS _GAMMA_BIAS#else#define GAMMA_BIAS 0#endif 既然我们可以定义宏，那么是否可以取消宏定义呢？答案是当然可以。 12345678910111213141516void play()&#123; #define NAME "name" printf("Define NAME: %s\n", NAME);&#125;#ifdef NAME// 取消宏定义#undef NAME#endifvoid eat()&#123; // Compile errror: Use of undeclared identifier 'NAME' printf("Define NAME: %s\n", NAME);&#125; 这份 GNU Macors 在线文档介绍了很多关于宏定义的知识，可以点击前往学习。 时间可以改变一切，但你得做点什么！]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>define typedef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回忆高考]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%9B%9E%E5%BF%86%E9%AB%98%E8%80%83%2F</url>
    <content type="text"><![CDATA[楔子转眼间，我人生中的高考距今已十几年有余了，那时候意气风发，踌躇满志，随时迎接高考的灵魂拷问。幸运的是自己跌跌撞撞的考上了大学，阴差阳错的变成了一名程序猿。 今天是2019年高考的第一天，作为一名 “资深” 的程序猿我还是想用编程的方式来记录这一天，算是对学子们的祝福和对自己的高中生活的一点回忆吧。 祝所有高考中的学者们都能如愿以偿的考上自己心中的那所大学，你们的人生即将辉煌，加油！ 不期而遇在我们那个年代特别是在我们老家人多且穷，谁能上大学简直就是 “光宗耀祖” 的事情，然而很多人对学习的欲望并不强，他们大部分都向往着外面的世界。其实，我也很渴望外面的世界，有过逃离那种压抑的高中生活的想法。但是回过头仔细想想出去后环境难道就没有障碍吗？生活就能如日中天吗？不可能的，尤其是对农村出来的孩子来说没有学历想在大城市中好好的活下去犹如天方夜谭。出来工作这么多年，生活的艰辛印证了我当初的想法。 凡事不忘初心，每当你想放弃的时候就好好想想当初自己为什么这么做。 我记得高考结束的那天下午，父母一起来学校准备接我回家，这是上高中三年以来第一次父母一起来学校。我知道父母是担心我，他们没有问我考的怎么样，让我把被子收拾一下跟他们回家。我怕他们担心就告诉他们：“别担心，我感觉自己考的还可以”，我永远忘不了父母那一刻展露出的欣慰的笑容。 高考结束的那一夜我没有和父母一起回家，而是跟同学们在网吧守了一夜等着高考试题的答案出来，想给自己和父母一个交代，那个晚上陪受煎熬。 这是我人生中第一次真正的接触电脑，也是第一次感觉到要上大学的喜悦。 基础很重要大家应该听说过这样的话题：“兄弟，把数学学那么好干什么，你上街买菜会用对数(log)跟大妈算账吗，买鸡蛋需要开根号吗？”。 听上去好像很有道理的样子，但是这里不完全合理。 首先，说话者是抱着一种嫉妒的心态而不是学习的心态，很消极的一种说法。 其次，说话者把数学知识的使用的范畴建立在买菜买鸡蛋的基础上了，假如你要搞算法扎实的数学基础和思维必须要具备，否则寸步难行，随着机器学习、AI 和大数据分析的发展，数学知识成为了一个必备学科。 再者，随着时代和科技的发展，说不定卖菜的大爷大妈们用的数学知识让你应接不暇。 所以，好好学习并没有错。基本学科能让你扎实自己的基础，拓展自己的思维。 学点编程几年前国外、国内的很多人都在说：“以后编程是人人都应该具备的基本技能，就像会骑车子一样那么简单！”。 对于这个 “以后” 谁也没有给出具体期限，就好比我小时候羡慕别人家有彩色电视一样，没想到过了几年这个东西居然也出现在了自己的家中，如获至宝，欣喜若狂。 现在很多教育机构已经提供了针对儿童编程的课程，大多是可视化编程。有孩子的家长们也许都发现了现在的孩子接受面和接受能力都远超我们那代人，这跟社会环境、家庭环境和营养饮食都有一定的关系，再加上兴趣班的催化让现在大多数孩子变得有点 “鬼机灵”。比如你的电脑莫名其妙的被打开并且还能自动被播放动画片，还有你明明设置的 iPad 密码很复杂竟然也能让他们给 “破解”，最气愤的是他居然可以趁你不注意用你的零钱给对方发了红包~ 如果有条件的话，家长们可以孩子接触编程知识，培养他们思考问题的习惯。培养学习编程知识，不一定非要买个高端的 PC 或者昂贵的 iPad，可以从搭积木和一些简单的数学知识开始，也可以让他参加一些例如机器人课的兴趣班，参观参观科技博物馆之类的。 高考的学子们，无论高考结果如何，不要刻意的去强迫自己，因为人生的路还有很长，及时的调整心态后面比高考更难的 ”考试试题“ 还等着你们呢！ 高考结束了，如果你是理科的学生建议大家可以去看看编程方面的知识，懂点编程的知识对你以后的工作还是很有好处的。把编程当做一种乐趣而不是工作，这样才有可能创造无限的可能。 祝大家金榜题名，端午安康！ 时间可以改变一切，但你得做点什么！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>高考 端午</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 想办法让项目运行起来]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E6%83%B3%E5%8A%9E%E6%B3%95%E8%AE%A9%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[必备工具最新的 Spring Boot 发布版本是 2.1.4，需要JDK版本最小为8即 JDK8，构建工程的工具 Maven 最小版本为3.3，Gradle 最小版本为4.4，当然了 Maven 和 Gradle 任选一个即可，接下来分享的文章中基本都使用 Maven 来构建工程。 1、Spring Boot 2.1.4 2、JDK8 3、IntelliJ IDEA2019 收费版 有稳定可用的网络，保证工程构建和一些依赖的下载。 具体 Spring Boot 对其他工具的版本要求，可以参考这里的 getting-started-system-requirements 文章内容。 建议大家使用Chrome作为默认浏览器，测试、调试API数据和安装对应的插件很方便。 认识 Github如果你还没有 Github 账号，就去注册一个，打开 这个地址 即可。 注册完成后，可以新建一个 Repo(可以存放代码的仓库)，本文涉及的所有代码都放在 Github 上面。 Spring Boot 系列文章也会跟大家一起学习 Git 的使用。 创建工程新建工程，打开IDEA，File/New/Project，下一步即可 填写工程信息，然后下一步 这里注意：Artifact 要求是全是小写字母，否则无法创建工程。 选择依赖，Core 中选择 Lombok，这个使用起来比较方便，建议大家选择，不选也可以的。 紧接着在 Web 中选择 Web 即可，下一步 保存工程，启动后在右小角提示下面内容，直接 Enable Auto-Import 和 Enable plgins 即可，如果你之前安装过 Lombok 插件，这里也不会提示 Enable plgins 了。 然后安装 Lombok 插件，点击 ok 即可。 等待IDEA构建完成，工程显示如下： 如果你的工程加载其他库加载失败，可以重新导入，操作如下： Run起来直接运行已经构建成功的工程。 打开浏览器，输入 http://localhost:8080/ 能看到下面的内容： 说明工程已经成功运行起来了，你距离伟大的目标越来越近了。 为了让浏览器显示一个正常的语句，我们需要增加点东西。 新建一个 MSUserController，代码如下： 12345678910111213package com.veryitman.springboot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class MSUserController &#123; @RequestMapping(value = "/user") public String user() &#123; return "Greate user"; &#125;&#125; 打开浏览器，输入 http://localhost:8080/user 能看到下面的内容： 说点神奇的1、创建工程还有其他方式吗？ 除了使用IDEA提供的方法来创建 Spring Boot 工程，也可以使用官方提供的 Spring Initializr 来创建工程。 本质上，IDEA是集成了 Spring Initializr 这个工具，所以二者同宗同源。 2、为什么点个按钮就Run起来了？ Spring Boot 已经内置了 Tomcat 服务器作为 Web Server，所以可以直接跑起来。 Spring Boot 就是这么简单，约定大于配置的思想贯彻其始终。 改变，从你我相识开始~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot SpringCloud 微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务: 步步为营]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E6%AD%A5%E6%AD%A5%E4%B8%BA%E8%90%A5%2F</url>
    <content type="text"><![CDATA[上图是我从 spring.io 首页介绍截图过来的，简洁而不失霸气！ 最近两年，Spring Boot 伴随着微服务的发展而越发火热，很多公司也纷纷开始使用 Spring Boot 和 Spring Cloud 来开发自己的服务，Java开发的浪潮愈发汹涌。这年头不知道微服务不知道 Spring Boot 就感觉生活缺点什么似的。我们还是抱着学习的心态来学习一下这个时代宠儿吧，不要盲目吹捧就可以了。 由 Pivotal 提供的 Spring Boot 是一套基于Java语言的开发框架，之前的 Spring 框架配置比较复杂，设计 Spring Boot 目的是用来简化 Spring 的开发过程，一定程度的去尽力解放程序员，换句话说 Spring Boot 是建立在 Spring 基础之上的。Spring Boot 更像是一个框架仓库，它拥有你基本想要的东西，简单到只需要你添加配置就可以，并且 Spring Boot 可以帮你处理各个库之间的依赖兼容问题，不用我们去关心这些问题。“约定优于配置” 的思想贯穿 Spring Boot 的始终，约定优于配置（Convention Over Configuration），也被称之为按约定编程，它是一种软件设计范式、思想，约定优于配置旨在减少开发人员需做决定的数量、获得简单的好处，而又不失灵活性，对于我们来说是一种编程的新体验。 为了自己学习，也为了方便想学习 Spring Boot 的小伙伴，准备搞一套 Spring Boot 系列文章来滋润一下无聊的生活。 Spring Boot 系列文章我准备采用以终为始的方式来分享，所谓的以终为始就是我们先给自己顶个目标，然后再想方案来完成目标，细化每个实施步骤。 至于什么是 微服务，什么是 Spring Boot 大家可以去网上搜索了解，后续分享的文章中我也会渗透式的分享一下相关的知识。这里强调一点，微服务不等于 Spring Boot 或者 Spring Cloud，他们只是实现微服务的一种手段而已。 学习要求 1、你得会Java基础知识，至少会用JDK的基本类。如果不会，赶紧去补补，学习没那么难，只要你别太懒！ 2、你要使用过IDEA这个无与伦比的集成开发工具，放弃 Eclipse 吧！不是它不好，只是IDEA太优秀。 3、英语要凑合，有没有四级证书真的无所谓，官方文档大多都是英文的却都是精华。 4、坚强的毅力，乐观的心态，很多困难都是纸老虎，当你搞定它了之后你就知道自己有多厉害了。 5、多运动多思考，身体是革命的本钱，其他的都是扯淡！ 以终为始 大目标：基于 Spring Cloud 构建微服务开发一个APP。 实施计划： 1、了解和学习 Spring Boot 目标：使用 Spring Boot 构建一个简单的服务，客户端或者WEB端可访问该服务。 如果你不会移动开发，可以使用C/C++、C#或者JS来开发一个客户端，哪怕终端程序也是可以的。 刚开始学习的时候，如果遇到不理解的知识点先记下来，不要因为这些东西阻挡你的学习，等学到一定的时候再回过头来研究，这就好比你刚上球场学习打篮球一样，能先稳稳的拿住球再传给队友就很了不起了，得不得分那是后面的事情。 在这一部分，我们做好登录和注册即可。 2、深入学习 Spring Boot 继续学习 Spring Boot 的知识，用户完成了注册，然后登录进入我们的APP需要给他们展示更加丰富的场景。这个时候需要配合后台服务进行开发工作，借助这次机会可以更加深入的学习和认识 Spring Boot了。 3、 了解和学习 Spring Cloud 在这个阶段，需要使用 Spring Cloud 改造我们已经开发的单体应用服务了。 微服务的关键不是如何将你的服务拆的如何 “微”，而是如何做好服务治理。于是在 Spring Boot 基础之上便有了 Spring Cloud，它是完全基于 Spring Boot 开发的，对外提供了在微服务架构中如何做好服务治理的一套解决方案。 学习完 Spring Boot 之后需要了解一些关于 Spring Cloud 的知识，进入 Spring Cloud 的世界一窥究竟，这部分我们一起学习如何做服务治理，服务部署等知识。 4、做一次架构师 综合 Spring Boot 和 Spring Cloud 相关的知识，我们重新梳理一下之前做的东西。把整个系统串起来，画出流程图和架构图。 设计包括服务本身的设计、数据库和缓存等设计。 5、完善和优化服务 借鉴业界好的案例对我们的服务进行优化，包括数据库、缓存、API和其他设计做一次重构，并对我们这个微项目进行一次复盘。 最重要的是要奖励一下自己。 Spring Boot 系列文章我会努力坚持写下去，希望能帮到大家。 干就完了！ 改变，从你我相识开始~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot SpringCloud 微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务项目系列文章]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[狂风暴雨的那个周末，突发奇想，想把微服务相关的内容分享给大家，思前想后还是决定用项目的形式来推进否则很难进行下去，于是就有了项目的这些文章（持续更新中…）。 他们都是有生命的，对我来说。 项目开篇 微服务: 步步为营 学习微服务的计划。 Spring Boot微服务: 想办法让项目运行起来 使用IDEA搭建第一个SpringBoot项目。 微服务: Git入门 写过的代码就是自己的财富，需要把他管理起来，代码管理我用Git管理工具。 微服务: 本地热部署 如何热部署项目，不需要每次都手动重启。 微服务: 立志做个伟大的项目 确定学习微服务的项目。 微服务: 学习几个容易混淆的URL注解 学习跟URL相关的几个注解，如 @RequestParam、@QueryParam、@PathVariable、@PathParam。 微服务: 简单的用户名注册和登录 写注册和登录的接口，并完成接口的单元测试。 微服务-Swagger让你可以多抽一支烟 接口编码完成之后，结合 Swagger 可以同时完成文档的编写。 微服务-Swagger生成Markdown文档 如何生成离线文档。 微服务: 部署服务 如何部署已经写好的服务。 MySQL8-0-15在Win10上的折腾记 安装MySQL。 微服务: MySQL基本操作 使用MySQL数据库。 微服务: 结合MySQL实现登录注册 前端登录注册界面访问 API，读写数据库实现数据的存储和读取实战。 微服务: Actuator实现服务监测 如何安全的使用 Actuator。 微服务: Admin与服务监测和管理 如何使用 spring-admin（client&amp;server）实现服务管理和监测。 微服务-配置Nginx反向代理 Nginx 作为反向代理的实践知识。 ngrok让服务近在咫尺 ngrok 实现内网穿透。 微服务-ConfigurationProperties配置 properties 到 Bean 的转换。 微服务-多-Module-管理工程 管理工程，规范工程。 Win10-安装-Redis 微服务-SpringBoot-集成-Redis Redis 的简单使用。 Spring Boot 番外篇 跨域和OPTIONS这对欢喜冤家 解决跨域问题。 减少跨域中的OPTIONS请 如何减少跨域请求，使用 SpringBoot 完成实例。 短地址原理 实例（SpringBoot）讲解短地址实现原理。 Spring Cloud待更新😜 客户端Android 相关 微服务-Android客户端-实现注册和登录 使用Android实现MSBlog项目，本篇实现了工程框架的搭建、注册和登录功能。 iOS 相关待更新😜 不经历风雨怎么见彩虹，没有人能够随随便便成功~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>SpringBoot SpringCloud 微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员这个职业]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%AA%E8%81%8C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[今天想跟大家聊聊关于程序员职业的话题~ 谣言可畏如果你是做编程这个行业的，一定会听到很多人抱怨这个行业太辛苦了，网上也流行着这么一句话：“程序员挣得多，死得早”，简直扎心！ 关于 “程序员挣得多，死得早” 这句话其实是不完全合理的。 我记得几年前，一个加班的周末我一个人坐电梯上去正好碰到一位送水的大爷。大爷瞄了我一眼说：”小伙子这个点再这里还上班的一定是搞编程的吧？“。我点了点头：”大爷，行家呀，没想到被你一眼识破“。大爷接着说道：”这个行业好呀，挣得多，你们一个月最少也有好几万吧？“，我当时被大爷说出来的数字吓了一跳，那可是我不吃不喝一年的工资呀！我尴尬的笑着说：”大爷，你真逗！“，然后简单聊了几句就下了电梯，大爷的话久久不能让我释怀，感觉自己做了一份假工作。 “挣得多” 完全是谣言，“死得早” 倒是有可能，想想都疼。关于程序员，加班到是家常便饭，在你职业生涯的早期加班是因为自己能力不足，随着你 “键”步如飞能力的提升，自以为不用再这么拼命了，谁曾想…新的编程语言横穿出世，新的技术层出不穷，如果不学习不努力只能被这个行业给淘汰掉。 如果你有足够好的运气能遇到好的项目，遇到好的团队，肯定能从中获益，比如你在支付宝、或者在王者荣耀团队，或者你在微信，又或者你在今日头条。 好的运气并不是每个人都有，因为好的运气更需要好的自己，你要做好充分的准备去迎接 ”好运气“ 的到来。 建立人脉和你相处的同事当中，肯定会有诙谐幽默的型的，理智理性型的，还有感情用事说话很直接的类型的人，也许还有小肚鸡肠卑鄙小人型的。直到我读到明朝历史，我才知道皇帝还可以几十年不上朝的，称其为 ”无为而治“。所以，世界那么大，遇到形形色色的人是一件再正常不过的事情，没什么大惊小怪的。 不过我接触的程序员的同事中，幽默诙谐的人不多，和这类人一起工作你会觉得很开心。这类人更容易缓解团队紧张而又沉闷的氛围，更容易被人选为组长。我建议大家该放松的时候就放松，别整天摆着脸给人一种 ”欠你钱“ 的错觉。 和同事搞好关系，可以给你日后的工作带来很大的帮助。比如，你在工作中遇到阻碍或者困难，同事们都会帮你出谋划策，哪怕一个小小的提示可能就能让你灵光一闪，轻松解决问题。你在公司的时间久了，除了和同部门的同事处理好关系，还有跟其他部门的同事多接触。开发和质量管理部、运维中心、设计部以及业务部门多少都会有一些工作上的接触，不妨跟他们多咨询一些非你本专业的知识，这样既可以学到知识又可以结交朋友，职场的交际能力是门大学问。 不知道你有没有发现，公司很多的业务主管都是公司有交际能力的老员工来担当？为什么呢，因为这些人在公司待的时间久，沟通能力有强，所以很多跨部门的协调工作他都能轻而易举的搞定。 除了自己要加强交际能力，还有加强自己的技术能力以及技术影响力，比如你带头在短时间内解决了一个遗留很久的问题，这个会很快让你成为大家心目中的技术佼佼者。 另外，自己要多去帮助别人，当你有困难的时候有人帮助你，那么当别人有困难的时候你也要能及时的帮助别人，这样大家彼此才能建立信任感，送人玫瑰手留余香，很简单的道理。 自我定位也许有一天，你被公司高层盯上了。高层觉得你很不错，各方面都比较优秀，决定选你为部门负责人。 作为部门负责人，你新官上任可千万别乱放火，你要知道水能载舟亦能覆舟！很多人当上部门领导后，喜欢动用人事部门开始进行裁员行动，有些很优秀的员工都被他给赶走了。大哥，这不是封建社会了，你以为自己是秦始皇吗？！切！ 就跟大家上学选班长一样，大家为什么选你做班长？一般是因为你学习努力成绩优秀并且能带动大家一起学习和进步，在工作当中也一样，选你做负责人，是让你能带领团队一起作战拿下公司定下的目标，让你帮助大家解决问题而不是让你仗势欺人，摆出一副高高在上的姿态让人难以 ”望其项背“。 特别是技术出身的部门领导，一定要做好自我定位。除了帮大家帮团队解决问题，你自己的技术能力不能落下也就是说不能丧失编程的能力，否则你连最后保住饭碗的能力都没有了。 万一，那天你做了管理者，要想清楚你能做什么以及你不能做什么，最重要的是找好自我定位，别忘了你以前也是一个程序员。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO中神奇的flush]]></title>
    <url>%2F2019%2F05%2F19%2FJavaIO%E4%B8%AD%E7%A5%9E%E5%A5%87%E7%9A%84flush%2F</url>
    <content type="text"><![CDATA[这篇文章在之前已经写过，只是没有在公众号发布过。该文阅读量已经达到了 36553 次了，有必要分享给大家。 后续我会陆续的把一些大家评论比较多并且很好的知识点在公众号分享给大家，希望和大家在编程的道路上一起进步，把苦涩的日子变得有趣一点。 无意中发现了一个巨牛的人工智能教程，忍不住分享一下给大家。教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以跳转到教程。 内容概要Java IO 流的设计不得不让人拍案叫绝，佩服设计者鬼斧天工的手法。 如果你是 Java 初学者，我敢保证第一次接触 Java 的 IO 类，一定会 ”狂晕！”，倒不是因为它有多么难学而是太多让人难以琢磨，让人有种 “不识庐山真面目” 的感觉，当你用心学完之后也会收获 “只缘身在此山中” 的顿悟。 在 Java 编程的日子中尤其是在网络编程中，几乎离不开 Java 的 IO 流，所以学好和用好它是很有必要的。 关于 Java 的 IO 流的分类，可以去找找相关的资料，今天跟大家分享一下其中比较神奇的 flush 方法。 flush 与 OutputStream该类实现了 Flushable 接口，所以重写了 flush 方法，看看 flush() 源码，会更加的让你明白： 1public void flush() throws IOException &#123; &#125; Sorry，该实现为空。这里的 flush() 居然是一个空方法，什么也没做。看清楚啊，该方法不是抽象方法，是一个实实在在的方法。除了方法体中一无所有，其它还好！看JDK的API如何解释吧！ 12345678flush public void flush() throws IOException 刷新此输出流并强制写出所有缓冲的输出字节。flush 的常规协定是：如果此输出流的实现已经缓冲了以前写入的任何字节，则调用此方法指示应将这些字节立即写入它们预期的目标。 如果此流的预期目标是由基础操作系统提供的一个抽象（如一个文件），则刷新此流只能保证将以前写入到流的字节传递给操作系统进行写入，但不保证能将这些字节实际写入到物理设备（如磁盘驱动器）。OutputStream 的 flush 方法不执行任何操作。指定者： 接口 Flushable 中的 flush 抛出： IOException - 如果发生 I/O 错误。 开始，我安慰自己，该类是一个抽象类，它的子类肯定重写了该方法。 好吧，OutputStream 的直接子类有：ByteArrayOutputStream 、FileOutputStream、FilterOutputStream、ObjectOutputStream 、OutputStream、PipedOutputStream 等几个类。 注意：这里的子类 OutputStream 是包 org.omg.CORBA.portable 的。 对于 FileOutputStream、ByteArrayOutputStream、org.omg.CORBA.portable.OutputStream 类它们的 flush() 方法均是从父类继承的 flush 方法。 FilterOutputStream 类重写了 flush() 方法，但是实质还是调用父类的 flush() 方法。ObjectOutputStream、PipedOutputStream 类重写了 flush() 方法。 JDK 中，有两大类IO流即字节流和字符流（包括输入和输出），这些流类中有些是带有缓冲区功能的有些是没有的。BufferedInputStream 和 BufferedOutputStream 是字节缓冲区类；BufferedReader 和 BufferedWriter 是字符缓冲区类。 来举两个小例子，第一个例子主要是使用非缓冲区的 IO 流向文本中写入指定的字符串，第二个例子是使用带有缓冲区的 IO 流向文本中写入一定的字节数据。 1、例子1：向文本中写入字符串 1234567891011121314151617import java.io.BufferedOutputStream; import java.io.DataOutputStream; import java.io.File; import java.io.FileOutputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); DataOutputStream dos = new DataOutputStream(fos); dos.writeBytes("java io"); &#125; &#125; 这段代执行后，会在当前目录下产生 1KB 的文件（内容为 java io）。 特别注意，这里没有调用 flush 方法，只是调用了 writeBytes 方法。调用流程图如下： 2、例子2：向文本中写入一定字节的数据 1234567891011121314151617import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] b = new byte[1024*8]; bos.write(b); bos.flush(); &#125;&#125; 这段代执行后，会在当前目录下产生 8KB 字节的文件。调用关系如下： 现在我们修改第二个例子的代码，主要修改两个地方 （1）、注释掉调用 flush() 方法； （2）、将 byte 大小改为 1024 大小。 修改如下： 1234567891011121314151617import java.io.BufferedOutputStream;import java.io.File;import java.io.FileOutputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] b = new byte[1024]; bos.write(b); //bos.flush(); &#125;&#125; OK，再次运行代码，额的神啊？？？文件大小居然是0字节。 why？ 仔细的你会发现，第一个例子中的代码中并没有调用 flush() 方法，居然可以正常的写入。为什么第二个就不可以呢？还是从源码入手找答案吧！ DataOutputStream 继承 FilterOutputStream ，实现了 DataOutput 接口。我们知道 FilterOutputStream 类重写了 flush() 方法，但是实质还是调用父类的 flush() 方法。DataOutputStream 类的 flush() 方法效仿其父类 FilterOutputStream 的做法，如下： 123public void flush() throws IOException &#123; out.flush(); &#125; 那么，即使你在第一个例子的代码后面加上 dos.flush() 结果也是正常的，与不加是一样的效果，因为它们的父类 flush() 方法均为空，这就是为什么第一个代码的神奇所在。 再看看第二个代码的 “病因” 在哪里？先看看 BufferedOutputStream 类的结构： 1public class BufferedOutputStream extends FilterOutputStream 再看看，它的 flush() 方法： 123456789101112public synchronized void flush() throws IOException &#123; flushBuffer(); out.flush();&#125; /** Flush the internal buffer */ private void flushBuffer() throws IOException &#123; if (count &gt; 0) &#123; out.write(buf, 0, count); count = 0; &#125; &#125; 不错，该类重写了 flush() 方法，不像前面几个类那样不是继承就是山寨父类的 flush() 方法。BufferedOutputStream 类是一个使用了缓冲技术的类，这种类一把都会自己实现 flush() 方法。 那么，有人会问使用这种类的时候，难道必须使用 flush() 方法吗，当然不是喽？？！！不过有个前提，你的字节数据必须不能小于 8KB。实例代码，注意没有 flush()方法。 （1）、写入的数据不小于8KB 如下示例代码，byte 大小改为 8KB： 1234567891011121314151617import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] b = new byte[1024*8]; bos.write(b); //bos.flush(); &#125;&#125; 执行代码，会产生大小为 8KB 的文本文件。 （2）、修改默认缓冲区大小 如下示例代码，修改一下构造 BufferedOutputStream 的方法，设置默认缓冲区大小为 1024。 123456789File file = new File("text4.txt");if (!file.exists()) &#123; file.createNewFile();&#125;FileOutputStream fos = new FileOutputStream(file);BufferedOutputStream bos = new BufferedOutputStream(fos, 1024);byte[] b = new byte[1024];bos.write(b);//bos.flush(); 执行代码，会产生 1KB 大小的文本文件。 这里提醒一下，如果你的文件读写没有达到预期目的，十之八九是因为你没有调用 flush() 或者 close() 方法。 另外，字符流类大多数都实现了 flush() 或者 close() 方法，只不过，它们调用的是 StreamEncoder 类的该方法。该类位于 sun.nio.cs 包下面，其源码在我们JDK中是没有的。 可以点击 StreamEncoder.java 查看源码。 flush 与 Writer该类 Writer 是一个抽象类，声明如下： 1public abstract class Writer implements Appendable, Closeable, Flushable Writer 类的 flush() 方法是一个抽象方法，其子类一般都实现了该方法。 所以，一般使用字符流之后需要调用一下 flush() 或者 close() 方法。 1abstract public void flush() throws IOException; 细节请看JDK的API，或者Java的源码以及上面的 StreamEncoder 类源码。 今天就说到这里吧，本文主要借助Java IO中字节流与字符流的 flush() 方法，来说明学编程语言看源码和思考是很重要的。 总之，不管你使用哪种流（字符、字节、具有缓冲的流）技术，不妨调用一下 flush() 或者 close() 方法，防止数据无法写到输出流中。 学习没有一蹴而就的方法，坚持思考、练习才是王道~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>flush OutputStream JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 生成 RSA 公钥和私钥]]></title>
    <url>%2F2019%2F05%2F11%2FmacOS-%E7%94%9F%E6%88%90-RSA-%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%2F</url>
    <content type="text"><![CDATA[如果你没有安装 openssl，请先使用 brew 安装它。 生成 RSA 私钥在 macOS 终端输入下面命令，会生成1024位的私钥，如下： 1openssl genrsa -out rsa_private.pem 1024 执行成功后，在当前目录会生成 rsa_private.pem 文件了。 注意：这里生成的是 PKCS1 格式的文件，也称之为传统的私钥格式。 生成 RSA 公钥得到私钥后，执行如下命令可以得到公钥，命令如下： 1openssl rsa -in rsa_private.pem -out rsa_public.pem -pubout 执行成功后，在当前目录会生成 rsa_public.pem 的文件，这个就是公钥。 格式转换 有些后端服务需要 PKCS8 格式的密钥，可以使用 openssl 工具把 PKCS1 和 PKCS8 进行互转。 PKCS 全称是 Public-Key Cryptography Standards，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准。 把 RSA 私钥转 PKCS1 转换为 PKCS8 格式，执行如下： 1openssl pkcs8 -topk8 -inform PEM -in rsa_private.pem -outform PEM -nocrypt -out rsa_private_pkcs8.pem 把 RSA 私钥 PKCS8 格式转换为 PKCS1 格式，执行如下： 1openssl rsa -in rsa_private_pkcs8.pem -out pkcs1.pem 以上生成的 RSA(pem) 文件，可以使用 vim、vscode 等文本编辑器打开查看。 无论是 PKCS1 还是 PKCS8，它们都是 PEM 编码存储的格式。 PEM 格式PEM 格式既是对 DER 编码转码为 Base64 字符格式，通过解码，将会还原为 DER 格式。即 PEM 是建立在 DER 编码之上的一种格式。 总之，PEM 是明文格式，可以包含证书或者是密钥，其内容通常是以类似 —–BEGIN …—– 开头，以 —–END …—– 为结尾的这样的格式，如下示例： 123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQDX+VXh+9zZBC3jRLcLyGGygb/vuiQj13x9ElH9pQmUg29UJ0q1hcSFuoKmt4id8jyj82fI2PMISzoGucqQFm9HXIV65UcgeUx7REDhgZOBmSCWZ2lWe2Fnf/htyiy9YVEN4jL7H+b67cIcEDHgYZLtPvSZgyr0UyOMC+E40kTcnQIDAQABAoGBAKKsYD7l6VPgrPuY31LVrJi62ComB2Cjx1WhffZR3+RoF2vImNtkB0E+2Xffl9x3/6ry1IMove3KTzadrHBZJZi1Y6lmHE95uv0O4p16ETnqvKzO8MkcH3qVQe1ZEyNd/wXr4A8DW3ZlNP/QIPOgzK949yTiP53wapiRwExEf7nhAkEA7CbbdoslRzhQ9YY1Sdbmc7NHpZdKhkgZwOVJZBoRwfHtSnFcpQUlOzLGCOxP+tGn5mpzhmpDFeURbv7mgaQvtQJBAOogUtiJbffk0p3uu7r5nCBmC6BqbG8yVqBVk+r/gS5iHBeBQVypFGYYLPQ9daHWluNku07MhqarPcXytEk7ekkCQDBjofK/fmsCkixNTNwNiflJUiVOW/n6CjTphslZQhIGNb5cTkSOMlvYApZPffACR+pCA9wWKBrzbkgVOTx1XUUCQQDEKJLg47wkLy6brhLss6ewqW7iV3hEfhuAOFM3WB1mvEKnGt+lf/AcXfMEK54sGzvOh2475jaG3ABkoiWVGeUpAkAgckc/Pf7KVRF/mDVruMJBbJLYL4H4s78nssFQ4d9VyXKsIM/AHUxZ5ZKiC7vtEtaGrTLAiuIuQZzBgGpSHX/e-----END RSA PRIVATE KEY----- 以下是证书文件名称，来自维基百科 X.509 的截图。 要始终保持学习的激情~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>RSA OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C函数中返回字符数组]]></title>
    <url>%2F2019%2F05%2F10%2FC%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[内容简介在阅读本篇文章之前，建议大家看一下下面2篇文章： 不见得你会计算C字符串长度 双宿双飞的 malloc 和 free 这篇文章主要分享三个点： 1、为什么作为局部变量的字符数组不能直接返回，而字符指针却可以? 2、当字符数组是局部变量的时候，函数如何返回它？ 3、字符数组(char [])和字符指针(char *)如何互转？ 局部变量的字符数组在C中如果我们直接返回字符数组，编译会直接报警告。如下示例： 12345char * fork_user_name()&#123; char name[] = "veryitman"; return name;&#125; 在Xcode中编译警告信息是这样的： 1Address of stack memory associated with local variable 'name' returned 在Linux上面GCC编译显示警告是这样的： 1warning: function returns address of local variable [-Wreturn-local-addr] 无论哪种警告信息，基本意思都是告诉我们不应该返回一个局部变量 name 的地址（函数内部的变量在栈内存上）。 如果我们修改一下代码，将 char 改为指针变量 char * ，示例如下： 12345char * fork_user_name2()&#123; char *name = "veryitman"; return name;&#125; 无论是Linux的GCC还是Xcode的Clang编译器都不会报出警告。 首先我们要知道，常量是放在数据段里面的。 这里比较特殊，局部变量 name 保存在栈中，但是字符串 veryitman 的值是一个常量，保存在常量区。即便函数返回了，数据段里面的常量数据也还不会消亡，它会直到程序结束才会消失，其内存空间直到程序运行结束才会被释放。 所以，返回的地址是一个实际存在的有效地址。 12345678910111213141516171819char * fork_user_name()&#123; char name[] = "veryitman"; return name;&#125;char * fork_user_name2()&#123; char *name = "veryitman"; return name;&#125;int main()&#123; printf("fork_user_name: %s\n", fork_user_name()); printf("fork_user_name2: %s\n", fork_user_name2()); return 0;&#125; 用GCC编译、运行后的打印结果，如下： 12fork_user_name: (null)fork_user_name2: veryitman 总之，在函数中的局部变量只要是返回类似 int[]、char[]、long[] 地址的，都是不正确的做法。 一切皆有可能下面例子是不正确的，如下： 12345char * v_string()&#123; char rest[10] = &#123;'\0'&#125;; return rest;&#125; 1、使用 static 在C语言中，用 static 限定外部变量与函数，该外部变量或者函数除了对该所在的文件可见外，其他文件都无法访问。 而用 static 声明内部变量，则该变量是某个特定函数的局部变量，只能在该函数中使用。但它与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。 所以使用static修饰一下，就没有问题了。示例如下： 12345char * v_string()&#123; static char rest[10] = &#123;'\0'&#125;; return rest;&#125; 2、使用 malloc 这种方式可以解决这个问题，是因为使用 malloc 分配的内存是在堆上而不是在栈内存上面。但是要记得将其在调用方使用 free 释放申请的内存空间，否则容易造成内存泄漏问题。 具体可以看看 双宿双飞的 malloc 和 free) 这篇文章。 123456char * v_string()&#123; char *p = (char *)malloc(10 * sizeof(char)); p = "\0"; return p;&#125; 3、全局变量 这个很好理解。全局变量在程序真个生命周期中都是有效的，所以使用全局变量也可以解决类似问题。 但是这种方案就会让这个封装的方法不够内聚，因为它依赖了全局变量。 123456char g_rest[100];char * v_string()&#123; strcpy(g_rest, "verytiamn"); return g_rest;&#125; 4、返回形参指针变量 在Linux Kernel(内核源码版本5.0.7)中，函数 strcpy 的实现如下： 1234567891011121314151617#ifndef __HAVE_ARCH_STRCPY/** * strcpy - Copy a %NUL terminated string * @dest: Where to copy the string to * @src: Where to copy the string from */#undef strcpychar *strcpy(char *dest, const char *src)&#123; char *tmp = dest; while ((*dest++ = *src++) != '\0') /* nothing */; return tmp;&#125;EXPORT_SYMBOL(strcpy);#endif 参考内核实现，我们可以修改一下自己的代码，示例如下： 123456char * v_string(char *s1, char *s2)&#123; char *tmp = s1; // 省略... return tmp;&#125; 这里补充另外一个知识点，函数 strcpy 在glibc和Linux Kernel中实现不一样。 在glibc的新版中(2.29版本)，本质是调用了函数 memcpy， 实现如下： 123456789101112131415#include &lt;stddef.h&gt;#include &lt;string.h&gt;#undef strcpy#ifndef STRCPY# define STRCPY strcpy#endif/* Copy SRC to DEST. */char * STRCPY (char *dest, const char *src)&#123; return memcpy (dest, src, strlen (src) + 1);&#125;libc_hidden_builtin_def (strcpy) 包括 strncpy 在glibc和Linux Kernel中实现也不一样，有兴趣的可以去看看源码。 字符数组和字符指针的互转char [] 转 char *这种情况下，可以直接进行赋值，示例如下： 12345678int main()&#123; char c_str_array[] = "veryitman.com"; char *p_str; p_str = c_str_array; printf("p_str: %s\n", p_str); return 0;&#125; char * 转 char []是不是也可以直接进行赋值呢？撸段代码看看，如下： 12345678int main()&#123; char c_str_array[] = "veryitman.com"; char *p_str = "veryitman.com"; c_str_array = p_str; printf("c_str_array: %s\n", c_str_array); return 0;&#125; 很遗憾，编译报错，GCC编译错误截图如下： Clang编译错误如下： 1Array type &apos;char [14]&apos; is not assignable 可以考虑使用 strncpy 来实现，示例代码如下： 123456789101112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char c_str_array[] = "veryitman.com"; char *p_str = "veryitman.com"; strncpy(c_str_array, p_str, strlen(p_str)); printf("c_str_array: %s\n", c_str_array); return 0&#125; 时间可以改变一切，但你得做点什么！]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>strcpy char[]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双宿双飞的 malloc 和 free]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%8F%8C%E5%AE%BF%E5%8F%8C%E9%A3%9E%E7%9A%84-malloc-%E5%92%8C-free%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介函数 malloc 和 free 是一对好朋友，几乎是形影不离。有 malloc 的地方就应该有 free 的存在。 今天跟大家聊聊 malloc 和 free 这对好基友，这两个函数都是对堆内存进行管理的函数，另外还有 calloc、realloc、reallocf、valloc 等堆内存管理函数。 void *在进行下面话题之前，我们先回忆一下 void * 是什么？ void * 表示未确定类型的指针。C/C++规定，void * 类型可以强制转换为任何其它类型的指针。 void * 也被称之为无类型指针，void * 可以指向任意类型的数据，就是说可以用任意类型的指针对 void * 赋值，如下示例： 123void *p1;int *p2;p1 = p2; 但一般不会反过来使用，如下示例在有些编译器上面可以编译通过，有些就不行： 123void *p1;int *p2;p2 = p1; 可以修改一下代码，将 void * 转换为对应的指针类型再进行赋值，如下示例： 123void *p1;int *p2;p2 = (char *)p1; 由于 GNU 和 ANSI 对 void * 类型指针参与运算的规定不一样，所以为了兼容二者并且让程序有更好的兼容性，最好还是将 void * 转换为有明确类型的指针再参与运算，如下示例。 1234void *pd;char *pc = (char *)pd;pc ++;pc += 1; malloc函数原型： 1void * malloc(size_t size); malloc 向系统申请分配指定 size 个字节的内存空间，即 malloc 函数用来从堆空间中申请指定的 size 个字节的内存大小，返回类型是 void * 类型，如果成功，就会返回指向申请分配的内存，否则返回空指针，所以 malloc 不保证一定成功。 查看函数手册或者直接在Linux、macOS等Unix系统上面直接 man malloc 会显示对应的函数信息： 1234The malloc() function allocates size bytes of memory and returns a pointer to the allocated memory.If successful, malloc() function return a pointer to allocated memory. If there is an error, they return a NULL pointer and set errno to ENOMEM. 另外需要注意一个问题，使用 malloc 函数分配内存空间成功后，malloc 不会对数据进行初始化，里边数据是随机的垃圾数据，所以一般结合 memset 函数和 malloc 函数 一起使用。 123456int *arr;arr = (int *)malloc(10 * sizeof(int));if (NULL != arr) &#123; memset(arr, 0, 10 * sizeof(int)); printf("arr: %p\n", arr);&#125; 123456char *arr;arr = (char *)malloc(10 * sizeof(char));if (NULL != arr) &#123; memset(arr, '\0', 10 * sizeof(char)); printf("arr string: %s\n", arr);&#125; 为了安全起见，建议可以考虑使用 calloc() 函数，后面会提到它。 函数 free、malloc、calloc() 都被包含在 stdlib.h 头文件中，当然了 malloc.h 头文件也有对应的函数声明，实现在 malloc.c 文件中。 关于 malloc 函数中的 size 参数务必要大于指针本身的数值，在32位操作系统上，指针占用4字节的大小；在64位操作系统上，指针占用8字节的大小。 free函数原型： 1void free(void *ptr); 我们知道在 C 语言中， 堆上的内存空间不会自动释放（Java 有自动回收机制，而 C 语言没有），直到调用 free 函数，才会释放堆上的存储空间，即 free 函数会释放指针指向的内存分配空间。 下面是函数手册查到关于 free 函数的资料： 12The free() function deallocates the memory allocation pointed to by ptr.If ptr is a NULL pointer, no operation is performed. 对于 free 函数我们要走出一个误区，不要以为调用了 free 函数，变量就变为 NULL 值了。本质是 free 函数只是割断了指针所指的申请的那块内存之间的关系，并没有改变所指的地址（本身保存的地址并没有改变）。如下示例： 12345678910111213char *pchar = (char *)malloc(10 * sizeof(char)); if (NULL != pchar) &#123; strcpy(pchar, "blog"); /* pchar所指的内存被释放，但是pchar所指的地址仍然不变 */ free(pchar); /* 该判断没有起到防错作用，此时 pchar 并不为 NULL */ if (NULL != pchar) &#123; strcpy(pchar, "it"); printf("pchar: %s", pchar); &#125;&#125; 正确且安全的做法是对指针变量先进行 free 然后再将其值置为 NULL，如下下面示例： 123456789101112131415char *pchar = (char *)malloc(10 * sizeof(char)); if (NULL != pchar) &#123; strcpy(pchar, "blog"); /* pchar所指的内存被释放，但是pchar所指的地址仍然不变 */ free(pchar); /* 将其置为 NULL 值 */ pchar = NULL; /* 该判断没有起到防错作用，此时 pchar 并不为 NULL */ if (NULL != pchar) &#123; strcpy(pchar, "it"); printf("pchar: %s", pchar); &#125;&#125; 函数 free 只能释放alloc的内存空间，对于其他非alloc的指针变量使用free会出现错误，如下面的例子： 1234int a = 0x2010;int *p;p = &amp;a;free(p); 运行后直接跪了，报类似下面的错误信息： 1pointer being freed was not allocated. 另外，告诉大家一个秘密，free 一个空指针没问题。如下例子： 123int *p;p = NULL;free(p); 代码可以正常运行，在 free 函数源码为证： 1234/* free(0) has no effect */if (mem == 0)&#123; return; &#125; 而 NULL 在源码（在 morecore.c 文件中）中定义就是0，如下： 123#ifndef NULL# define NULL 0#endif malloc、free 小结1、连续内存块 malloc 函数申请的是连续的一块内存，如果所申请的内存块大于目前堆上剩余内存块，则内存分配会失败，函数返回 NULL 值。 注意：上面说的 堆上剩余内存块 不是所有剩余内存块之和，而是连续的内存。 2、双宿双飞才好 调用 malloc 函数多余 free 函数会发生内存泄漏，这个很好理解，因为申请过的内存没有被释放完。调用 malloc 函数少于free 函数，肯定会出错。换句话说，在程序中 malloc 的使用次数务必要和 free 相等，否则必有隐患或者发生错误。 如下面的例子 free 两次指针变量就会在运行时报错： malloc: *** error for object 0x10071be90: pointer being freed was not allocated，也称之为 double free。 123char *pchar = (char *)malloc(10 * sizeof(char));free(pchar);free(pchar); 对指针变量进行 free 之后，一定要记得对其赋值为 NULL，否则该指针就是一个野指针，这个在上面已经说明。 3、0字节的内存有毒 使用 malloc 函数也可以申请0字节的内存，该函数的返回值并不是 NULL，而是返回一个正常的内存地址，所以如果使用这种方式申请的内存很危险，如下面的例子，指针 pchar 是一个使用 malloc 函数创建的占用0字节的内存空间的一个指针变量，if (NULL == pchar) 并没有生效，而是执行了 else 语句中的代码。 1234567char *pchar = (char *)malloc(0);if (NULL == pchar) &#123; printf("malloc 0 byte memory failed.\n");&#125; else &#123; printf("malloc 0 byte successfully and pchar: %s.\n", pchar); printf("pchar: %s.\n", pchar);&#125; 这中方式的指针类似于一个野指针，可以使用但有风险，不知道这个指针后面的内存空间被谁使用着，要是被核心进程使用，会造成相应程序的崩溃。 4、调皮的free 使用非alloc方式创建的内存，使用 free 函数会报错，这个要注意。另外，free 空指针没有影响。 calloc、realloc、reallocf、valloc1、calloc 函数 1void * calloc(size_t count, size_t size); 在堆上，分配 n*size 个字节，并初始化为0，返回 void *类型，返回值情况跟 malloc 一致。 函数 malloc() 和函数 calloc() 的主要区别是前者不能初始化所分配的内存空间，而后者能。如果由 malloc() 函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存曾经被分配过，则其中可能遗留有各种各样的数据。也就是说，使用 malloc() 函数的程序开始时(内存空间还没有被重新分配)能正常进行，但经过一段时间(内存空间还已经被重新分配)可能会出现问题。 函数 calloc() 会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存，那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。 123The calloc() function contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory.The allocated memory is filled with bytes of value zero. 2、realloc() 函数 1void * realloc(void *ptr, size_t size); realloc() 会将 ptr 所指向的内存块的大小修改为 size，并将新的内存指针返回。假设之前内存块的大小为 n，如果 size &lt;= n，那么截取的内容不会发生变化，如果 size &gt; n，那么新分配的内存不会被初始化。 对于上面说的新的内存指针地址可能变也可能不变，假如原来alloc的内存后面还有足够多剩余内存的话，realloc后的内存=原来的内存+剩余内存，realloc还是返回原来内存的地址即不会创建新的内存。假如原来alloc的内存后面没有足够多剩余内存的话，realloc将申请新的内存，然后把原来的内存数据拷贝到新内存里，原来的内存将被free掉，realloc返回新内存的地址。 另外要注意，如果 ptr = NULL，那么相当于调用 malloc(size)；如果 ptr != NULL且size = 0，那么相当于调用 free(ptr)。 当调用 realloc 失败的时候，返回NULL，并且原来的内存不改变，不会释放也不会移动。 123456789The realloc() function tries to change the size of the allocation pointed to by ptr to size, and returns ptr. If there is not enough room to enlarge the memory allocation pointed to by ptr, realloc() creates a new allocation, copies as much of the old data pointed to by ptr as will fit to the new allocation, frees the old allocation, and returns a pointer to the allocated memory. If ptr is NULL, realloc() is identical to a call to malloc() for size bytes. If size is zero and ptr is not NULL, a new, minimum sized object is allocated and the original object is freed. When extending a region allocated with calloc(3), realloc(3) does not guarantee that the additional memory is also zero-filled. 看一下源码的关键部分，如下： 123456789101112void * __libc_realloc (void *oldmem, size_t bytes)&#123; // 省略... #if REALLOC_ZERO_BYTES_FREES if (bytes == 0 &amp;&amp; oldmem != NULL) &#123; __libc_free (oldmem); return 0; &#125;#endif // 省略...&#125; 这里可以看出，如果 oldmem 不为NULL且 bytes 为0的情况下，会自动进行 free 操作。如下面的例子运行后会报错。 123456789101112131415#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt; int main()&#123; char *pre_ptr = (char *)malloc(20); int bytes = 0; if(NULL != pre_ptr) &#123; void *ptr = realloc(pre_ptr, bytes); // 对pre_ptr进行了double free，这种条件下源码中会进行一次free free(pre_ptr); &#125; return 0;&#125; 所以为了保险起见，要对 bytes 进行判断再做处理。 传递给 realloc 的指针变量必须是先前通过 malloc()、 calloc() 或 realloc() 等alloc分配的，否则会报 pointer being realloc&#39;d was not allocated. 错误。如下例子（运行直接报错）： 12char *p = "";void *newP = realloc(p, 10); 3、reallocf() 函数 1void * reallocf(void *ptr, size_t size); reallocf() 函数是由 FreeBSD 实现的，它会在任何情况下释放输入的指针（即使是再分配失败之后）。reallocf() 一样会调用 realloc 函数，但是只有我们在获得空的指针之后才会调用 free 函数。 下面是 reallocf 函数具体的实现部分： 12345678void * reallocf(void *p, size_t size) &#123; void *ptr = realloc(p, size); if (!p) &#123; free(p); &#125; return ptr;&#125; 123The reallocf() function is identical to the realloc() function, except that it will free the passed pointer when the requested memory cannot be allocated.This is a FreeBSD specific API designed to ease the problems with traditional coding styles for realloc causing memory leaks in libraries. 4、valloc() 函数 1void * valloc(size_t size); 这个函数是最少见也是最少用的一个函数。 malloc 或 realloc 返回的是以8字节对齐的内存地址，在64bits上是16字节对齐。然而 memalign 或 valloc 可以更大的粒度进行字节对齐。 valloc 是一个废弃的函数，分配 size 大小的字节，返回已分配的内存地址指针，其内存地址将是页大小(page size)的倍数，如果分配失败返回 NULL。 123The valloc() function allocates size bytes of memory and returns a pointer to the allocated memory. The allocated memory is aligned on a page boundary. 说了这么多，接下来我们看一下例子，如下代码示例： 123456789101112131415161718192021222324252627// 对其分配内存，这个时候pchar值是随机的垃圾值char *pchar = (char *)malloc(16);// 手动初始化pchar的值，下面的方法则不需要memset(pchar, 0, 16);// calloc分配内存，会自动设置为0，不需要memsetchar *pchar_orig = (char *)calloc(12, sizeof(char));// 在原内存基础上，在堆内存空间中连续增加内存// 如果原内存没有连续空间可拓展，realloc会新分配一个空间，将原有内存copy到新空间，然后释放原内存 // 注意：realloc和malloc，只分配内存不进行赋值操作char *pchar_dest = (char *)realloc(pchar_orig, 10); // 相当于 malloc(60)char *pchar_ini = (char *)realloc(NULL, 60);free(pchar);pchar = NULL;free(pchar_orig);pchar_orig = NULL;free(pchar_dest);pchar_dest = NULL;free(pchar_ini);pchar_ini = NULL; glibc 与 libc上面说过这些内存管理函数都在头文件 stdlib.h 中，函数实现都在 malloc.c 文件中，这些都可以在 glibc 中找到对应的代码，我下载的 glibc 是 2.29 这个版本。 libc 是 Stantard C Library 的简称，它是符合ANSI C标准的一个标准函数库。libc库提供C语言中所使用的宏，类型的定义，字符串操作符，数学计算函数以及输入输出函数等。正如ANSI C是C语言的标准一样，libc只是一个函数库标准，每个操作系统都会按照该标准对标准库进行具体实现。通常我们所说的libc是特指某个操作系统的标准库，比如：在Linux操作系统下所说的libc即glibc。glibc是类Unix操作系统中使用最广泛的libc库，它的全称是GNU C Library. glibc是 Linux 下的 C 函数库。libc 库是Linux下的ANSI C的函数库也泛指一切符合C规范的库，glibc 是Linux下的GNU C函数库，是一种 libc 的实现。glibc 本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准C库。Linux下面的标准C库不仅有这一个，如 uclibc、klibc，但是 glibc 无疑是用得最多的，用 glibc 作为系统的C函式库，是GNU/Linux演进的一个重要里程碑，可以查看 维基百科 对 glibc 的介绍。 还有比如Android的Bionic库也是一种libc的实现，只是在Android上面使用罢了。Bionic是Google为Android操作系统提供的BSD标准C库的衍生库，专门为移动计算而精心设计的，针对移动设备上有限的CPU周期和可用内存进行了裁剪以提高工作效率。 这里也说一下基本的C语言函数库，这个库可以根据头文件划分为 15 个部分，其中包括： 文件 assert.h：包含宏和信息，用于进行诊断，帮助程序调试； 文件 ctype.h：包含用来测试某个特征字符的函数的函数原型，以及用来转换大小写字母的函数原型； 文件 errno.h：定义用来报告错误条件的宏； 文件 float.h：包含系统的浮点数大小限制； 文件 math.h：包含数学库函数的函数原型； 文件 stddef.h：包含执行某些计算 C 所用的常见的函数定义； 文件 stdio.h：包含标准输入输出库函数的函数原型，以及他们所用的信息； 文件 stdlib.h：包含数字转换到文本，以及文本转换到数字的函数原型，还有内存分配、随机数字以及其他实用函数的函数原型； 文件 string.h：包含字符串处理函数的函数原型； 文件 time.h：包含时间和日期操作的函数原型和类型； 文件 stdarg.h：包含函数原型和宏，用于处理未知数值和类型的函数的参数列表； 文件 signal.h：包含函数原型和宏，用于处理程序执行期间可能出现的各种条件； 文件 setjmp.h：包含可以绕过一般函数调用并返回序列的函数的原型，即非局部跳转； 文件 locale.h：包含函数原型和其他信息，使程序可以针对所运行的地区进行修改。地区的表示方法可以使计算机系统处理不同的数据表达约定，如全世界的日期、时间、美元数和大数字； 文件 limits.h：决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值； 在 glibc 库中可以找到 malloc.c 文件(路径是 glibc-2.29/malloc/malloc.c )，从中可以看到如下别名的定义： 1234567891011strong_alias (__libc_calloc, __calloc) weak_alias (__libc_calloc, calloc)strong_alias (__libc_free, __free) strong_alias (__libc_free, free)strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)strong_alias (__libc_memalign, __memalign)weak_alias (__libc_memalign, memalign)strong_alias (__libc_realloc, __realloc) strong_alias (__libc_realloc, realloc)strong_alias (__libc_valloc, __valloc) weak_alias (__libc_valloc, valloc)strong_alias (__libc_pvalloc, __pvalloc) weak_alias (__libc_pvalloc, pvalloc)strong_alias (__libc_mallinfo, __mallinfo)weak_alias (__libc_mallinfo, mallinfo)strong_alias (__libc_mallopt, __mallopt) weak_alias (__libc_mallopt, mallopt) __malloc 是 __libc_malloc 的别名，malloc 也是 __libc_malloc 的别名。其他以此类推。 所以看 malloc 函数的源码，直接看 __libc_realloc 函数实现即可，看 free 的源码可以看 __libc_free 的实现。 12void *__libc_realloc (void *oldmem, size_t bytes) 也可以在线查看 glibc 的源码，点击 这里 前往欣赏！ 以后要是有人问你在哪里可以下载libc的源码，你就可以告诉他libc只是一个标准，不同的平台上面有不同的libc实现，比如glibc，bionic等。 锄禾日当午，汗滴禾下土，五一节快乐~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>malloc free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C实现抽象类]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%94%A8Objective-C%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[插图的花是我上个月发工资当天晚上加班回家的路上从一个老人家那里买的，一枝独秀！ 上周在微信公众号发布的一篇名为 反向代理) 的文章，居然真被微信给封掉了，当时在写的时候我还在想是不是会被微信给封杀掉，真是怕什么来什么，完全符合墨菲定律！那篇文章我就是想给大家分享一下如何设置 Nginx 的反向代理，其中的一些概念可能是因为牵涉到了敏感词汇，本无恶意！ 不说这件事情了，还是回到今天分享的主题上面来吧~ 在软件设计或者架构设计领域，架构师都会跟大家强调对业务一定要抽象，把具体的业务场景抽象为程序实现很考验一个人的编程和思维能力。所以在面向对象的编程中，抽象是一种必备的能力。 设计框架的时候，一般我们都会约定一些协议，各个模块在交互通信中能够遵守和实现这些协议，就可以保证通信的畅通性，就好比大家遵守排队规则一样，一个一个来就不会乱。 协议可以使用接口的形式或者抽象类的形式都可以定义，不同的编程语言有不同的形式。例如，在Java中提供给开发者的有接口 Interface 还有抽象类 Abstract，示例如下： 123456789/** 接口 */interface ISeverListener &#123; public void covertService(String name);&#125;/** 抽象类 */abstract class AbstractServer &#123; protected abstract String destroyService(String serverID);&#125; 在 C++ 中也有抽象类，示例如下： 12345678class Point&#123;protected: int x, y;public: //纯虚函数 virtual void disp()=0;&#125;; 在 Objective-C 中提供了协议 protocol，没有提供抽象类的东西，但是我们可以借助 protocol 模拟实现抽象类。 DownloaderProtocol.h 协议 123456789101112131415#import &lt;Foundation/Foundation.h&gt;@protocol DownloaderProtocol &lt;NSObject&gt;@required- (BOOL)checkDownloader;- (void)startDownload:(id)url;- (void)stopDownload;- (void)deleteAllDownloadFile;@end AbstractDownloader.h 12345678#import &lt;Foundation/Foundation.h&gt;#import "DownloaderProtocol.h"@interface AbstractDownloader : NSObject &lt;DownloaderProtocol&gt;- (void)setDownloadUrl:(NSString *)url;@end AbstractDownloader.m 12345678910111213141516171819202122232425262728293031323334353637383940414243#import "AbstractDownloader.h"#define AbstractMethodNotImplemented() \@throw [NSException exceptionWithName:NSInternalInconsistencyException \reason:[NSString stringWithFormat:@"You must override %@ in a subclass.", NSStringFromSelector(_cmd)] \userInfo:nil]@implementation AbstractDownloader- (instancetype)init&#123; NSAssert(![self isMemberOfClass:[AbstractDownloader class]], @"AbstractDownloader is an abstract class, you should not instantiate it directly."); return [super init];&#125;- (BOOL)checkDownloader&#123; AbstractMethodNotImplemented();&#125;- (void)startDownload:(id)url&#123; AbstractMethodNotImplemented();&#125;- (void)stopDownload&#123; AbstractMethodNotImplemented();&#125;- (void)deleteAllDownloadFile&#123; AbstractMethodNotImplemented();&#125;- (void)setDownloadUrl:(NSString *)url&#123; NSLog(@"AbstractDownloader's url = %@", url);&#125;@end 从上面的代码可以看出AbstractMethodNotImplemented()是模拟抽象类的关键，有了这个宏动议之后，凡是需要继承AbstractDownloader必须要实现对应的方法，否则会报错。ImageDownloader继承 AbstractDownloader 并且实现对应的方法，示例如下： ImageDownloader.h 12345#import "AbstractDownloader.h"@interface ImageDownloader : AbstractDownloader@end ImageDownloader.m 123456789101112131415161718192021222324252627#import "ImageDownloader.h"@implementation ImageDownloader- (BOOL)checkDownloader&#123; NSLog(@"ImageDownloader checkDownloader..."); return YES;&#125;- (void)startDownload:(id)url&#123; NSLog(@"ImageDownloader startDownload...");&#125;- (void)stopDownload&#123; NSLog(@"ImageDownloader stopDownload...");&#125;- (void)deleteAllDownloadFile&#123; NSLog(@"ImageDownloader deleteAllDownloadFile...");&#125;@end 这样做的话，团队相关的开发人员就知道自己继承自 AbstractDownloader 应该做什么了。 这里只是给大家提供一种设计思路，有更好的思路欢迎交流，感谢每一位关注者、阅读者。 一直致力于让开发变得更美好的公众号~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 抽象类 Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu19安装Swift5]]></title>
    <url>%2F2019%2F04%2F20%2FUbuntu19%E5%AE%89%E8%A3%85Swift5%2F</url>
    <content type="text"><![CDATA[内容概要通过实践，分享如何在 Ubuntu19 下面如何安装 Swift5. 安装必备库在使用 apt-get 之前，有必要做一次更新，如下： 1sudo apt-get update 更新完成后，安装对应的库文件，如下： 1sudo apt-get install git cmake ninja-build clang python uuid-dev libicu-dev icu-devtools libbsd-dev libedit-dev libxml2-dev libsqlite3-dev swig libpython-dev libncurses5-dev pkg-config libblocksruntime-dev libcurl4-openssl-dev systemtap-sdt-dev tzdata rsync 然后再安装下面的库，如下： 1sudo apt-get install clang libicu-dev libpython2.7 最后，一定要安装下面的库，执行安装即可。 12sudo apt-get install libtinfo5sudo apt install python-dev 否则会报错： 123/bin/lldb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory/bin/lldb: error while loading shared libraries: libpython2.7.so.1.0: cannot open shared object file: No such file or directory 下载 Swift下载 Swift 源码，使用 wget 下载即可。 1wget https://swift.org/builds/swift-5.0-release/ubuntu1804/swift-5.0-RELEASE/swift-5.0-RELEASE-ubuntu18.04.tar.gz 下载成功后，解压源文件，如下： 1tar zxvf swift-5.0-RELEASE-ubuntu18.04.tar.gz 为了使用方便，可以对解压后的文件重新命名，这里我改为了 swift5.0 1mv swift-5.0-RELEASE-ubuntu18.04 swift5.0 配置环境变量将 swift 对应的加入到环境变量中，编辑 ~/.bashrc 文件即可。 1vim ~/.bashrc 添加下面内容在文件最后，如下： 1export PATH=/home/username/developer/swift_linux/swift5.0/usr/bin:$&#123;PATH&#125; 注意：/home/username/developer/swift_linux/swift5.0/usr/bin 是你自己解压后的目录。 为了验证 Swift 是否安装成功，可以让 ~/.bashrc 文件 立即生效，命令如下： 1source ~/.bashrc 在终端执行以下下面命令： 1swift -version 成功会显示如下信息： 12Swift version 5.0 (swift-5.0-RELEASE)Target: x86_64-unknown-linux-gnu Done. 人生总是在不断的上演着重逢和离别~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>swift linux Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反向代理]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇内容概要不知道大家有没有问过别人，或者是自己偷偷在网上搜过类似 “什么是正向和反向代理“ 类似的问题，即使问过、搜过是不是也很懵？ 总结一句粗话：正向代理就是代理客户端的代理服务，反向代理就是代理服务端的代理服务。 那我们今天就来掰扯掰扯这个问题。 VPN 和正向代理小明：“你昨天看了我给你发的视频链接了吗？超级好看哟！”。小丽：“哦，那个链接根本打不开呀，看个pi！”，小明失望的看了看小丽。小明：“好吧，肯定是你没有使用 VPN 软件，所以你看不了…”。 相信你也有经历过类似的场景，朋友给了一个需要你拥有 VPN 才能打开的链接，无论你是万兆光纤也好还是亿兆光纤也罢，死活都无法打开。 这里所说的 VPN 就是人们通常所说的正向代理服务器，VPN(虚拟私人网络 Virtual Private Network)，是一种加密通讯技术。VPN 有很多的具体实现，比如 PPTP、L2TP、IPSec 和 openvpn。VPN 不是为了翻墙而生的，他只是一中技术，就好比菜刀本来是用来切菜的道理一样。使用 VPN 来爬楼梯基本已经作废了，但当大家谈及 fanqiang 的时候说得最多的还是 “你有好用的 VPN 吗？”，所以把 VPN 当成 fanqiang 工具的代名词也情有可原。 如果你有了 fanqiang 软件就可以轻松访问全世界的网站了，特别是程序员，可以在知识的海洋里遨游。简单来说正向代理服务器类似于下面图所示： 反向代理和 Nginx这里可以给大家举个例子，假如你想让电信公司给你安装宽带或者网络电视，这个时候你可能需要打电话咨询一下相关的内容，于是你拿起了手机给电信公司打电话，经过一番复杂操作后终于可以等待人工服务了。电信的人工客服人员有很多，系统会根据一定的规则给你分配一个人，接下来可能是美眉也可能是汉子为你服务，究竟是谁给你提供语音服务取决与系统的分配，而不是你可以决定的。 系统分配和调度的功能就类似于反向代理服务器，对用户来说没有感知。类似于下面图所示： 在软件设计中，服务端开发经常会用到反向代理服务器，比如 Nginx、Apache 等，它们经常也被用作为 WEB 服务器，Nginx 被当做代理服务器比较多，所谓的代理服务器是架设在 WEB 服务器和网络中断(比如手机客户端)之间的服务器，换句话说，Nginx 提供了反向代理服务的能力。 由于 Nginx 和 Apache 各自的优势，现在很多开发者选择让两者在服务器中共存。在服务器端让 Nginx 在前 Apache 在后，由 Nginx 做负载均衡和反向代理，并且处理静态文件，将动态请求交给 Apache 去处理。 下图是一个典型的 Nginx 作为反向代理服务器部署 ELK 的架构图，如下： 用 Nginx 的反向代理，用户可以从外部访问到 Kibana，并且它本身具有负载均衡的作用，也能够提高了其性能。 再看一个微服务架构中的架构图（在网关前面也部署了 Nginx），如下图所示： 关于 Nginx 作为负载均衡器的配置和实例，下一次跟大家分享。你现在只需要聚焦在 Nginx 作为反向代理服务器上面的功能即可。 Nginx 配置反向代理Nginx 本身已经提供了反向代理服务的能力，下面我们结合实例给大家分享一下，假设你本机已经安装了 Nginx 并且会基本的操作命令。 1、启动 Nginx 1sudo nginx 在浏览器打开 http://localhost:80，确保 Nginx 启动成功。 2、配置 host 我们配置一下本机的 host，vim 编辑即可。 1sudo vim /etc/hosts 增加下面一行： 1127.0.0.1 www.ithome.com 在浏览器打开 http://www.ithome.com:80，跟刚才显示一样的WEB 界面。 3、配置 Nginx 编辑 Nginx 配置，如下： 1sudo vim /usr/local/etc/nginx/nginx.conf 在 http { 节点下增加下面内容： 12345678910111213141516server &#123; # 监听80端口号 listen 80; # 监听访问的域名 server_name www.ithome.com; # 根据访问路径配置 location / &#123; # 设置 http 版本 proxy_http_version 1.1; proxy_set_header Connection ""; # 把请求转发到 https://www.baidu.com proxy_pass https://www.baidu.com; &#125;&#125; 重新启动 Nginx，重新加载配置文件，操作命令如下： 1sudo nginx -s reload 在浏览器打开 http://www.ithome.com:80，此时打开的是百度首页。至此，简单的配置 Nginx 作为反向代理服务器的功能已经完成，当然想配置好 Nginx 还需要大家多去实践和看官方技术手册。 proxy_pass 默认使用的是 http 1.0，可以通过 proxy_http_version指令让它使用 http 1.1，以便开启 keepalive 之类的功能。官方说明 如下： 123Sets the HTTP protocol version for proxying. By default, version 1.0 is used. Version 1.1 is recommended for use with keepalive connections and NTLM authentication. 另外，nginx 还可以设置透明代理，可以参考 IP Transparency and Direct Server Return with NGINX and NGINX Plus as Transparent Proxy 这篇文章。 附录：Nginx 命令1、查看 nginx 的配置信息 1nginx -V 注意：是大写字母 V。 2、查看 nginx 版本信息 1nginx -v 3、启动 nginx 1sudo nginx 4、查看 nginx 进程 1ps -ef|grep nginx 5、重启 nginx 1nginx -s reload 6、完美停止 nginx 1kill -QUIT `cat /var/run/nginx.pid` 7、快速停止 nginx 1kill -TERM `cat /var/run/nginx.pid` 或者 1kill -INT `cat /var/run/nginx.pid` 8、完美停止工作进程，主要用于平滑升级 1kill -WINCH `cat /var/run/nginx.pid` 9、强制停止 nginx 1pkill -9 nginx 10、检查 nginx.conf 修改是否正确 1nginx -t 11、停止 nginx 的命令 1nginx -s stop 推荐阅读 图解正向代理、反向代理、透明代理：可能是你见过的讲解最透彻的代理技术教程 HttpProxy模块 不经历风雨怎么见彩虹，没有人能够随随便便成功~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Nginx VPN 代理服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 自动装箱、拆箱引起的耗时]]></title>
    <url>%2F2019%2F04%2F07%2FJava-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E6%8B%86%E7%AE%B1%E5%BC%95%E8%B5%B7%E7%9A%84%E8%80%97%E6%97%B6%2F</url>
    <content type="text"><![CDATA[耗时问题在说 Java 的自动装箱和自动拆箱之前，我们先看一个例子。 这个错误我在项目中犯过(尴尬)，拿出来共勉！ 12345678910111213141516private static long getCounterResult() &#123; Long sum = 0L; final int length = Integer.MAX_VALUE; for (int i = 0; i &lt; length; i++) &#123; sum += i; &#125; return sum;&#125;public static void main(String[] args) &#123; long startCountTime = System.currentTimeMillis(); long result = getCounterResult(); long endCountTime = System.currentTimeMillis(); System.out.println("result = " + result + ", and take up time : " + (endCountTime - startCountTime) / 1000 + "s");&#125; 在我的电脑(macOS 64位系统，配置较高)，打印结果如下： 1result = 2305843005992468481, and take up time : 12s 居然使用了 12s，是可忍叔不可忍，再正常不过的代码怎么会耗时这么久呢？如果在配置差一点的电脑上运行耗时会更久(惊呆了.jpg)。 我们不妨先阅读下面的内容，再来分析、解决上述耗时的问题。 基本概念 自从 jdk1.5 之后就有了自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)。 自动装箱，就是 Java 自动将原始(基本)类型转换成对应的封装器(对象)类型的过程，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。 自动拆箱，就是 Java 自动将封装器(对象)类型转换成基本类型的过程，如将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。 之所以称之为自动装箱和拆箱，是因为这些操作并非人工(程序猿)操作的，而是 Java 自带的一个特性。 下表是 Java 中的基本类型和对应的封装类型的对应表： 基本类型 封装器类 int Integer byte Byte long Long float float double Double char Character boolean Boolean 自动装箱示例： 12int a = 3;Integer b = a; 自动拆箱示例： 12Integer b = new Integer(7);int a = b; Integer/int 自动拆箱和装箱下面这段代码是 Integer 的源码中 valueOf 方法。 1234567891011121314151617181920212223/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; // 如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; // 否则返回 new 一个Integer 对象 return new Integer(i);&#125; 我们在执行下面的这句代码，如下： 1Integer i = 100; 上面的代码等同于下面的代码： 1Integer i = Integer.valueOf(100); 结合上面的源码可以看出来，如果数值在 [-128，127] 之间(双闭区间)，不会重新创建 Integer 对象，而是从缓存中(常量池)直接获取，从常量池中获取而不是堆栈操作，读取数据要快很多。 我们再来看一下常见的基础面试题(请给出打印结果)，如下: 123456789101112131415161718192021public static void main(String[] args) &#123; // ⓵ Integer a = new Integer(121); Integer b = new Integer(121); System.out.println(a == b); // ⓶ Integer c = 121; Integer d = 121; System.out.println(c == d); // ⓷ Integer e = 129; Integer f = 129; System.out.println(e == f); // ⓸ int g = 50; Integer h = new Integer(50); System.out.println(g == h);&#125; 分析结果： ⓵: false, 两个对象进行比较分别指向了不同堆内存⓶: true, 自动装箱且数值在 [-128，127] 之间(双闭区间)⓷: false, 自动装箱且数值不在 [-128，127] 之间(双闭区间)⓸: true, 自动拆箱且数值在 [-128，127] 之间(双闭区间) 解析耗时问题类 Long 对应的也有一个 valueof 方法，源码如下： 1234567public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125; 这个和 Integer 的很像，道理上面说过，这里不再赘述。 在开篇的例子中，getCounterResult 方法有下面这句代码，如下： 1Long sum = 0L; 很明显我们声明了一个 Long 的对象 sum，由于自动装箱，这句代码并没有语法上面的错误，编译器当然也不会报错。上面代码等同于如下代码： 1Long sum = Long.valueof(0); 在 for 循环中，超过 [-128，127] 就会创建新的对象，这样不断的创建对象，不停的申请堆内存，程序执行自然也就比较耗时了。 修改一下代码，如下： 1234567891011121314151617private static long getCounterResult() &#123; // 修改为普通的基本类型数据 long sum = 0L; final int length = Integer.MAX_VALUE; for (int i = 0; i &lt; length; i++) &#123; sum += i; &#125; return sum;&#125;public static void main(String[] args) &#123; long startCountTime = System.currentTimeMillis(); long result = getCounterResult(); long endCountTime = System.currentTimeMillis(); System.out.println("result = " + result + ", and take up time : " + (endCountTime - startCountTime) / 1000 + "s");&#125; 执行时间大大缩短。 优柔寡断，是人生最大的负能量。对，别犹豫了赶紧扫码关注~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自动拆箱 自动装箱 autoboxing unboxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dumpdecrypted 砸壳：导出头文件]]></title>
    <url>%2F2019%2F04%2F07%2Fdumpdecrypted-%E7%A0%B8%E5%A3%B3%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 导出头文件在 iOS 逆向: dumpdecrypted 砸壳记中已经给大家分享了对 ipa 文件如何砸壳了， 接下来就可以导出其头文件了。 这里需要用到 class-dump 工具。如果你使用 class-dump, 出现如下错误： 1Error: Cannot find offset for address 0xxxxxxxxx in stringAtAddress 报这种错误说明你即将 dump 的文件是 OC 和 Swift 混编的项目，class-dump 这个工具对它们无能为力。 还好, 伟大的程序员们给我们解决了这个问题。 去获取 class-dump 改进版 源码, 然后使用 Xcode 编译即可. 编译完成后生成的 class-dump 就可以拿来使用了. 改变其可执行的权限: 1234567chmod +x class-dump``` 查看 decrypted 文件的 arm 架构:```shclass-dump --list portkey-prod.decrypted 显示为：arm64 开始 dump: 123mkdir portkey-headerclass-dump -H portkey-prod.decrypted -o portkey-header/ 遇到问题dumpdecrypted 砸壳出现了问题, 错误信息如下: 12dyld: could not load inserted library 'dumpdecrypted.dylib' because no suitable image found. Did find:dumpdecrypted.dylib: required code signature missing for 'dumpdecrypted.dylib' 解决方案, 重新签名 dumpdecrypted 后将其拷贝到 Documents 目录. 12345## 列出可签名证书, 找到 mac 上面已经安装的证书security find-identity -v -p codesigning## 为 dumpecrypted.dylib 签名codesign --force --verify --verbose --sign "iPhone Developer: xxx xxxx (xxxxxxxxxx)" dumpdecrypted.dylib 注意：iPhone Developer: xxx xxxx (xxxxxxxxxx) 为你自己本机安装的开发者证书名称. 看到的工具 class-dump-swift 针对 Swift 的工具。这个需要自己先编译 llvm，然后才能使用. dumpdecrypted, 比较自动化的一个版本，但我使用这个没有砸壳成功(估计是需要针对这个文件进行签名)。 Clutch 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 一个神奇的二维码~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oh-my-zsh 配置]]></title>
    <url>%2F2019%2F04%2F03%2Foh-my-zsh-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[喜欢使用终端的朋友都知道在 linux、macOS 上面默认使用的是 bash shell，虽然 bash 比较强大，但是比起 zsh 还是稍逊一筹。zsh 虽然好用但配置比较复杂，于是乎 oh-my-zsh 就诞生了，它统一管理 zsh 的配置。 macOS 上面安装 oh-my-zsh 后，感觉敲命令更爽了，特别是在进行 git 操作的时候，很方便。 安装比较简单，可以在终端通过 curl 也可以通过 wget 方式，安装方法如下。 1、通过 curl 方式 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 2、通过 wget 方式 1sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" oh-my-zsh 支持 linux、macOS 和 windows，但是在 linux 和 macOS 上面支持最好。 安装成功后，原来在系统 shell 配置的环境变量需要让 oh-my-zsh 知道，配置一下 ~/.zshrc 文件，在该文件中的 User configuration 下面增加下面两行配置就可以了。 12source ~/.bash_profilesource /etc/profile 配置完成后保存文件，在终端执行： 1source ~/.zshrc 这样之前配置的环境变量在 oh-my-zsh 下就生效了。 oh-my-zsh 支持三方插件和主题配置，默认的配置已经够用了，有兴趣的可以自行探索。 工欲善其事必先利其器]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>zsh git tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Follow your heart]]></title>
    <url>%2F2019%2F03%2F24%2FFollow-your-heart%2F</url>
    <content type="text"><![CDATA[今天不聊技术，聊聊人生~ 最近天气像疯了一样，气温反复无常，时冷时热，让人有点应接不暇。 正好刚搬完家，家里很多东西需要购买，首先考虑的是给自己买对舒服的桌椅。实体店里面的桌椅实在是贵的离谱，动辄告诉我说是实木哟，现在低价处理之类的，还好我不是很傻。最后索性就在网上购买了，性价比也比较高，我也算是来了一把沉浸式的疯狂购物体验。 现在物流服务很是贴心，关注对应的公众号就可以及时告诉你当前物流的进度。相比之前，无论是送货速度还是服务都有显著提升，主要是实惠。 网上淘的这个桌子比较重，要想自己把这个桌子弄到家还是相当费劲的。快递员看出了我的窘境，说：“我这个推车反正现在也闲着，你先拿去用吧！”，我连忙道谢，有了这个推车搬起来就容易多了。 不到十分钟的时间，我就把货送到家了。心理一直想别人也许这会需要急着用车，就赶紧下楼，走到楼下拐角的时候，突然被一个人喊住，我回头一看是一个陌生的快递员。 他语调比较高：“喂，先生，你那个车子放到我这里就可以了，是我们的！”。我瞄了他一眼，说道：“你是哪个快递公司的，我不是从你手上拿的车呀！”，这哥们依旧强势：“我是xx快递，这车就是我们的。”。 我心想这两个快递员是不是认识，这个车子原本就是眼前这个气势汹汹的人的？ 心理正在犯着嘀咕，决定还是要物归原主。 我没有再理他，继续朝着原来收快递的地方走去，把车还给了主人。我顺便问道：“刚才有个xx快递的小哥说车子是他的？”，他说：“可能是他看错了，你看这车子上面有我们公司的标记呢”。我仔细一看果然是，庆幸自己没有把车交给别人。 人生中，仿佛也有很多类似上面的场景，假如你遇到了会怎么处理呢？ 就拿婚姻来说，你认定的自己的另一半就是这辈子要娶或者要嫁的那个人，但是你身边的朋友或者家人并不看好你们，甚至他们压根不承认你的另一半，你又会怎么办？ 我觉得遇到这样的事情，要听从自己的内心(Follow your heart)，不要因为别人的三言两语，你就轻易放弃当初的选择，而应该更加理性的做出判断，相信自己的判断不会错，只有这样你才不会后悔，至少爱过。 学习、工作和生活也是一样，既定了目标就应该勇往直前，在路上遇到的任何困难那是再正常不过的，别人的冷嘲热讽也好，打击刺激也罢，你要做的就是坚守你自己的内心，一帆风顺得到的幸福终究会昙花一现。 ~ 充满酸甜苦辣的人生才值得回味，不是吗？ 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 枚举的本质]]></title>
    <url>%2F2019%2F03%2F16%2FJava-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[概要本文跟大家一起探讨一下 Java 枚举的本质，这篇文章的内容是我在 2012年09月05日 发布到 CSDN 上面的一篇博文 Java 枚举：理解枚举本质，虽然已经不在 CSDN 上面耕耘了，但偶尔也会去看看朋友们的留言，毕竟感情在那里！今天偶然看到有小伙伴评论这篇文章，一时兴起就想再次分享给大家。 学习编程语言，会用只是最基本的要求，了解和熟悉其实现、运行机制才使得你有别于常人！ C 枚举在 C 语言中，可以这样来定义枚举，如下示例： 123enum color &#123; RED=0, GREEN, BLUE, YELLOW&#125; col; 关键字 enum 定义枚举，在定义枚举的同时，声明该枚举变量 col. 注意：C 语言中枚举成员的值是根据上下文自动加 1 的（GREEN = 1，BLUE = 2 等）。 C 语言中 switch 语句支持枚举类型，如下示例： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main() &#123; enum color &#123; RED=0, GREEN, BLUE, YELLOW &#125; col; int cl; printf("0=red, 1=green, 2=blue, 3=yellow. seclect:\n"); scanf("%d",&amp;cl); col=(enum color) cl; switch(col) &#123; case RED: printf("the color is red\n"); break; case GREEN: printf("the color is green\n"); break; case BLUE: printf("the color is blue\n"); break; case YELLOW: printf("the color is yellow\n"); break; defalut: printf("no this color\n"); break; &#125; return 0;&#125; Java 枚举那么，Java 里面的枚举与其类似，但是又不是完全一样。Java 语言中定义枚举也是使用 enum 关键字，如下示例是 Java 语言的枚举： 123public enum Color &#123; RED, GREEN, BLUE, YELLOW;&#125; 上述定义了一个枚举类型 Color（可以说是类，编译之后是 Color.class）. 上面的定义，还可以改成下面的这种形式: 123public enum Color &#123; RED(), GREEN(), BLUE(), YELLOW();&#125; 到这里你可能会觉得迷茫（如果你是初学者的话），为什么这样子也可以，why？ 其实，枚举的成员就是枚举对象，只不过它们是静态常量而已。 使用 javap 命令（javap 文件名&lt;没有后缀.class&gt;）可以反编译 class 文件，如下：​​​​ 我们可以使用普通类来模拟枚举，下面定义一个 Color 类，如下： 123456public class Color &#123; private static final Color RED = new Color(); private static final Color GREEN = new Color(); private static final Color BLUE = new Color(); private static final Color YELLOW = new Color();&#125; 结合上图反编译的结果，做一下对比，你是否看出了一点端倪（坏笑），如果没有看出来，那就接着往下看吧。 如果按照这个逻辑，是否还可以为其添加另外的构造方法？答案是肯定的！ 123456789101112public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); Color(String name, int id) &#123; _name = name; _id = id; &#125; String _name; int _id;&#125; 为 Color 声明了两个成员变量，并为其构造带参数的构造器。 如果你这样创建一个枚举: 1234public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3);&#125; 编译器就会报错: 1The constructor EnumDemo.Color(String, int) is undefined 到此，你应该看明白了，枚举和普通的 Java 类很像。 对于类来讲，最好将其成员变量私有化，并且为成员变量提供 get、set 方法。 按照这个原则，可以进一步写好 enum Color，如下示例： 12345678910111213141516171819202122232425262728public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); Color(String name, int id) &#123; _name = name; _id = id; &#125; private String _name; private int _id; public void setName(String name) &#123; _name = name; &#125; public void setId(int id) &#123; _id = id; &#125; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125;&#125; 但是 Java 设计枚举的目的是提供一组常量，方便开发者使用。如果我们冒然的提供 set 方法（外界可以改变其成员属性），好像有点违背了设计的初衷。 那么，我们应该舍弃 set 方法，保留 get 方法。 1234567891011121314151617181920public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); Color(String name, int id) &#123; _name = name; _id = id; &#125; private String _name; private int _id; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125;&#125; 对于普通的基本类可以将其实例化，那么，能否实例化枚举呢？ 在回答这个问题之前，先来看看 Color.class 文件: 1234567891011121314151617181920public static enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); private String _name; private int _id; private Color(String name, int id) &#123; this._name = name; this._id = id; &#125; public String getName() &#123; return this._name; &#125; public int getId() &#123; return this._id; &#125;&#125; 可以看出，编译器淘气的为其构造方法加上了 private，那么也就是说，我们无法实例化枚举。 所有枚举类都继承了 Enum 类的方法，包括 toString、equals、hashcode 等方法。因为 equals、hashcode 方法是 final 的，所以不可以被枚举重写（只可以继承），但可以重写 toString 方法。 文末的附录中提供了 Enum 的源码，有兴趣可以查看阅读！ 那么，使用 Java 的类来模拟一下枚举，大概是这个样子： 1234567891011121314151617181920212223242526272829303132333435363738394041package mark.demo;import java.util.ArrayList;import java.util.List;public class Color &#123; private static final Color RED = new Color("red color", 0); private static final Color GREEN = new Color("green color", 1); private static final Color BLUE = new Color("blue color", 2); private static final Color YELLOW = new Color("yellow color", 3); private final String _name; private final int _id; private Color(String name, int id) &#123; _name = name; _id = id; &#125; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125; public static List&lt;Color&gt; values() &#123; List&lt;Color&gt; list = new ArrayList&lt;Color&gt;(); list.add(RED); list.add(GREEN); list.add(BLUE); list.add(YELLOW); return list; &#125; @Override public String toString() &#123; return "the color _name=" + _name + ", _id=" + _id; &#125;&#125; 附录Enum.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package java.lang;import java.io.Serializable;import java.io.IOException;import java.io.InvalidObjectException;import java.io.ObjectInputStream;import java.io.ObjectStreamException;/** * This is the common base class of all Java language enumeration types. * * @author Josh Bloch * @author Neal Gafter * @version %I%, %G% * @since 1.5 */public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; /** * The name of this enum constant, as declared in the enum declaration. * Most programmers should use the &#123;@link #toString&#125; method rather than * accessing this field. */ private final String name; /** * Returns the name of this enum constant, exactly as declared in its * enum declaration. * * &lt;b&gt;Most programmers should use the &#123;@link #toString&#125; method in * preference to this one, as the toString method may return * a more user-friendly name.&lt;/b&gt; This method is designed primarily for * use in specialized situations where correctness depends on getting the * exact name, which will not vary from release to release. * * @return the name of this enum constant */ public final String name() &#123; return name; &#125; /** * The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this field. It is designed * for use by sophisticated enum-based data structures, such as * &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. */ private final int ordinal; /** * Returns the ordinal of this enumeration constant (its position * in its enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this method. It is * designed for use by sophisticated enum-based data structures, such * as &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. * * @return the ordinal of this enumeration constant */ public final int ordinal() &#123; return ordinal; &#125; /** * Sole constructor. Programmers cannot invoke this constructor. * It is for use by code emitted by the compiler in response to * enum type declarations. * * @param name - The name of this enum constant, which is the identifier * used to declare it. * @param ordinal - The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). */ protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125; /** * Returns the name of this enum constant, as contained in the * declaration. This method may be overridden, though it typically * isn't necessary or desirable. An enum type should override this * method when a more "programmer-friendly" string form exists. * * @return the name of this enum constant */ public String toString() &#123; return name; &#125; /** * Returns true if the specified object is equal to this * enum constant. * * @param other the object to be compared for equality with this object. * @return true if the specified object is equal to this * enum constant. */ public final boolean equals(Object other) &#123; return this==other; &#125; /** * Returns a hash code for this enum constant. * * @return a hash code for this enum constant. */ public final int hashCode() &#123; return super.hashCode(); &#125; /** * Throws CloneNotSupportedException. This guarantees that enums * are never cloned, which is necessary to preserve their "singleton" * status. * * @return (never returns) */ protected final Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException(); &#125; /** * Compares this enum with the specified object for order. Returns a * negative integer, zero, or a positive integer as this object is less * than, equal to, or greater than the specified object. * * Enum constants are only comparable to other enum constants of the * same enum type. The natural order implemented by this * method is the order in which the constants are declared. */ public final int compareTo(E o) &#123; Enum other = (Enum)o; Enum self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; &#125; /** * Returns the Class object corresponding to this enum constant's * enum type. Two enum constants e1 and e2 are of the * same enum type if and only if * e1.getDeclaringClass() == e2.getDeclaringClass(). * (The value returned by this method may differ from the one returned * by the &#123;@link Object#getClass&#125; method for enum constants with * constant-specific class bodies.) * * @return the Class object corresponding to this enum constant's * enum type */ public final Class&lt;E&gt; getDeclaringClass() &#123; Class clazz = getClass(); Class zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? clazz : zuper; &#125; /** * Returns the enum constant of the specified enum type with the * specified name. The name must match exactly an identifier used * to declare an enum constant in this type. (Extraneous whitespace * characters are not permitted.) * * @param enumType the &lt;tt&gt;Class&lt;/tt&gt; object of the enum type from which * to return a constant * @param name the name of the constant to return * @return the enum constant of the specified enum type with the * specified name * @throws IllegalArgumentException if the specified enum type has * no constant with the specified name, or the specified * class object does not represent an enum type * @throws NullPointerException if &lt;tt&gt;enumType&lt;/tt&gt; or &lt;tt&gt;name&lt;/tt&gt; * is null * @since 1.5 */ public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException("Name is null"); throw new IllegalArgumentException( "No enum const " + enumType +"." + name); &#125; /** * prevent default deserialization */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125; private void readObjectNoData() throws ObjectStreamException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125; /** * enum classes cannot have finalize methods. */ protected final void finalize() &#123; &#125;&#125; 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>macOS java enum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json-c]]></title>
    <url>%2F2019%2F03%2F10%2Fjson-c%2F</url>
    <content type="text"><![CDATA[简介json-c 是 C 语言写的一套构建和解析 JSON 的库。 12JSON-C implements a reference counting object model that allows you to easily construct JSON objects in C, output them as JSON formatted strings and parse JSON formatted strings back into the C representation of JSON objects. It aims to conform to RFC 7159. 使用 C 语言编写的 JSON 库还有很多，可以在 介绍 JSON 中查找到，除了 C语言的还有其他语言编写的 JSON 开源库。 所有发布的 json-c 库版本在 这里 都可以找到，本篇编译的是 json-c-0.13.1-20180305 这个版本。 编译一、下载、解压 直接下载最新版本 json-c-0.13.1-20180305，截止到本文发布该版本为最新版本。 解压刚才下载好的文件，解压后将文件夹重命名为 json-c-src，当然你也可以不重名它。 打开 macOS 终端，进入 json-c-src 文件夹 1cd json-c-src 二、源码编译 在编译之前，确保你已经在 macOS 中安装了下面的工具： 1、gcc, clang, 或者其他 C 编译器；2、libtool 工具，版本不能低于 2.2.6b；3、autoconf 工具，版本不能低于 2.64 (autoreconf)；4、automake工具，版本不能低于 1.13； 如果没有安装上面的工具，可以使用 Homebrew 进行安装。 在桌面新建个文件夹 json-c，这个文件夹用来放待会编译后的文件（库和头文件）。 执行下面的命令开始配置和编译，如下： 12345./configure --prefix=/Users/man/Desktop/json-cmakemake install 注意：/Users/man/Desktop/json-c 要写绝对路径，否则编译报错。 如果要支持多线程，可以加上 --enable-threading 这个选项，即： 12345./configure --enable-threading --prefix=/Users/man/Desktop/json-cmakemake install 编译成功后，在 json-c 会生成对应的库和头文件，如下： 使用 json-c编译成功后，可以试用一下 json-c 这个库了，我把 libjson-c.a 和对应的 include 文件夹放进 macOS 工程，编译无法通过，报错，然后换为 libjson-c.4.dylib 编译通过但是运行报错，意思是无法加载该库。 同样道理，在 iOS 工程上面直接使用这两个库也是无法使用。 于是我就使用 lipo 来查看一下库所支持的架构，看一下下面的结果。 1234567$ lipo -info libjson-c.a Non-fat file: libjson-c.a is architecture: x86_64$ lipo -info libjson-c.4.dylib Non-fat file: libjson-c.4.dylib is architecture: x86_64 可以看出两个库均可以支持 x86_64，按道理是可以支持 macOS 和 iOS 模拟器运行的，macOS 上面可以使用 set | grep &quot;MACHTYPE&quot; 命令查看其操作系统架构。 libjson-c.a 是静态库，libjson-c.4.dylib 是动态库，可以使用 file 命令查看。 1234567$ file libjson-c.a libjson-c.a: current ar archive$ file libjson-c.4.dylib libjson-c.4.dylib: Mach-O 64-bit dynamically linked shared library x86_64 注意：显示 ar archive 表示是静态库。 最后自己没有找到好的办法，只能采取第二个办法，源码直接放进 Xcode 工程里面编译使用。 在放进 Xcode 工程之前，需要将下载的源码进行配置操作，即： 1./configure 这样会产生对应 config.h 等文件，然后将源码中所有 .h 和 .c 的文件拷贝至工程中即可编译使用了。 注意：如果不执行 ./configure 操作，拷贝的源文件不全，无法通过编译。 简单例子，如下： 1234567891011121314151617181920212223#import "ViewController.h"#import "json-c/json.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; json_object *jsonObj = NULL; jsonObj = json_tokener_parse("&#123; \"uid\": 12, \"name\": \"foobar\", \"isComer\": 1, \"age\": 21, \"extras\": [ 11, 52, 3, \"unknow\", 75 ] &#125;"); const char *jsonString = json_object_to_json_string(jsonObj); printf("obj.to_string()=%s\n", jsonString);&#125;@end 对应输出结果，如下： 1obj.to_string()=&#123; &quot;uid&quot;: 12, &quot;name&quot;: &quot;foobar&quot;, &quot;isComer&quot;: 1, &quot;age&quot;: 21, &quot;extras&quot;: [ 11, 52, 3, &quot;unknow&quot;, 75 ] &#125; 疑问Objective-C 已经提供了关于 JSON 的库了，干嘛还折腾 json-c 呢？ 的确，自从 iOS 5.0+，macOS 10.7+ 之后，Foundation 框架已经提供了 NSJSONSerialization，我主要是好奇 json-c 这个库，看他的跨平台能力而已。 关于 NSJSONSerialization 可以查看 API 文档。 本次分享，告辞！ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C json json-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不见得你会计算C字符串长度]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%B8%8D%E8%A7%81%E5%BE%97%E4%BD%A0%E4%BC%9A%E8%AE%A1%E7%AE%97C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 C 字符串在 C 语言中，字符串实际上是使用字符 &#39;\0&#39; 终止的一维字符数组。 以下几种方式表示的都是 C 字符串的正确表达方式。 1234567891011121314// 要以 '\0' 结尾char greeting[6] = &#123;'H', 'e', 'l', 'l', 'o', '\0'&#125;;// 要以 '\0' 结尾char greeting[] = &#123;'H', 'e', 'l', 'l', 'o', '\0'&#125;;// 默认会在末尾增加'\0'char greeting[] = &#123;"Hello"&#125;;// 上面的简写形式char greeting[] = "Hello";// 默认会在末尾增加'\0'char *greeting = "Hello"; 看下面另外一种声明方式： 123char greeting[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;printf("greeting: %s\n", greeting); 输出结果： 1greeting: hello\376 这个结果在不同编译器下面可能还会不一样，总之输出都不是我们想要的结果。这种方式创建的字符串没有 &#39;\0&#39;，不算是真正的 C 字符串，所以建议大家在声明 C 字符串的时候使用字符指针（char *）的方式。 string.h 里面声明了很多关于操作 C 字符串的库函数。 字符串长度这里在说计算字符串长度的前提是字符编码都是按照UTF-8（中文占用3个字节，英文占用1个字节）的编码形式为前提的。我们先来看下面这个例子，如下： 123456789101112char *greeting1 = "hello";char greeting2[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;char greeting3[] = &#123;'h', 'e', 'l', 'l', 'o', '\0'&#125;;char greeting4[] = "hello"; printf("greeting1 sizeOf: %ld, strlen: %ld\n", sizeof(greeting1), strlen(greeting1));printf("greeting2 sizeOf: %ld, strlen: %ld\n", sizeof(greeting2), strlen(greeting2));printf("greeting3 sizeOf: %ld, strlen: %ld\n", sizeof(greeting3), strlen(greeting3));printf("greeting4 sizeOf: %ld, strlen: %ld\n", sizeof(greeting4), strlen(greeting4)); 如果你能说出上面 printf 的结果，基本上关于计算字符串长度的问题就迎刃而解了。 按照 UTF-8 编码，上面例子的输出结果如下所示： 1234greeting1 sizeOf: 8, strlen: 5greeting2 sizeOf: 5, strlen: 7greeting3 sizeOf: 6, strlen: 5greeting4 sizeOf: 6, strlen: 5 如果输出结果令你无法相信，可以选择继续往下看或者你自己写代码试试。 sizeof、strlen在 linux.die 可以查到 strlen 的说明，如下： 123456789Synopsis:#include &lt;string.h&gt;size_t strlen(const char *s);Description:The strlen() function calculates the length of the string s, excluding the terminating null byte (aq\0aq).Return Value:The strlen() function returns the number of bytes in the string s. 函数 strlen 返回字符串里的字符数，不包括终止字符 &#39;\0&#39;，这里注意 strlen 是一个 C 的函数，而 sizeof 只是一个操作符。 我们知道，sizeof 操作符的参数可以是数组、指针、类型、对象、函数等，函数 strlen 的参数只能是字符串。 对于 sizeof， 其参数不同时，其返回的值也不一样，如下： 1、数组：编译时分配的数组空间大小；2、指针：存储该指针所用的空间大小(32位机器上是4，64位机器上是8)；3、类型：该类型所占的空间大小；4、对象：对象的实际占用空间大小(这个指的是在 C++ 中)；5、函数：函数的返回类型所占的空间大小。函数的返回类型不能是 void 类型； 那我们再回头看看上面的例子，我把要说明的写在注释上面了。 1234567891011121314151617181920212223242526// 注意这里是指针char *greeting1 = "hello";// 没有结束符 '\0'，其 strlen 结果不确定char greeting2[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;char greeting3[] = &#123;'h', 'e', 'l', 'l', 'o', '\0'&#125;;char greeting4[] = "hello"; /* 结果是 8、5 *//* greeting1是指针，sizeOf计算的是其存储该指针所用的空间大小，因为我使用的是64位 macOS，所以输出是8 *//*strlen 计算的是字符个数但是不包括结束符 '\0'*/printf("greeting1 sizeOf: %ld, strlen: %ld\n", sizeof(greeting1), strlen(greeting1));/* 结果是 5、7 *//* sizeof 计算的是编译时分配的数组空间大小，这里是5 *//* greeting2没有结束符，strlen 的计算结果不确定 */printf("greeting2 sizeOf: %ld, strlen: %ld\n", sizeof(greeting2), strlen(greeting2));/* 结果是 6、5 *//* sizeof 计算的是编译时分配的数组空间大小，这里是6，因为多了结束符 *//*strlen 计算的是字符个数但是不包括结束符 '\0'*/printf("greeting3 sizeOf: %ld, strlen: %ld\n", sizeof(greeting3), strlen(greeting3));/* 结果是 6、5，这里类似上面的情况，不再赘述 */printf("greeting4 sizeOf: %ld, strlen: %ld\n", sizeof(greeting4), strlen(greeting4)); 小结： 1、sizeof 是一个操作符，而 strlen 是 C 语言的库函数。 2、sizeof 的参数可以是任意数据类型或者表达式，而 strlen 只能以结尾为 &#39;\0&#39; 的字符串作参数。 3、sizeof 的结果在编译时就计算出了，而 strlen 必须在运行时才能计算出来。 4、sizeof 计算数据类型占内存的大小，strlen 计算字符串实际长度，要记住 strlen 计算出来的结果不包括结束符 &#39;\0&#39;。 5、sizeof 反应的并非真实字符串长度而是所占空间大小，所以memset 初始化字符串的时候用 sizeof 较好。 6、系统函数返回值是 char * (字符指针)类型的会在末尾加上结束符 &#39;\0&#39;。 7、无论是 sizeof 还是 strlen 计算结果的单位都是字节。 我们还需要注意一点，strlen 函数，当数组名作为参数传入时，实际上数组就退化成指针了。举个例子，如下图所示： 可以看出传入进来的参数会被退化为指针。 探索无止境在文章的开始，我给出了几种 C 字符串的正确表达方式，那我们再来看另外一种。 1char greeting[4] = "blog"; 这种方式看起来好像很完美的样子，其实是不对的，写个例子给大家，如下： 123456789int main(int argc, const char *argv[])&#123; char greeting[4] = "blog"; size_t len = strlen(greeting); printf("greeting len: %ld\n", len); printf("greeting: %s\n", greeting); return 0;&#125; 编译运行，结果如下： 12greeting len: 10greeting: blog\330\365\277\357\376 苍天呀，这结果让人无语。。。 对于 char greeting[4] = &quot;blog&quot; 其实是定义一个长度为 4 的字符数组，但是字符串 &quot;blog&quot; 实际是要包括结束符 \0 的，也就是说下面的代码 1char greeting[4] = "blog"; 本质和下面代码是一样的，如下： 1char greeting[] = &#123;'b', 'l', 'o', 'g'&#125;; 显然是不正确的，那我们修改一下代码，如下： 12345678910int main(int argc, const char *argv[])&#123; // 注意这里是 5 char greeting[5] = "blog"; size_t len = strlen(greeting); printf("greeting len: %ld\n", len); printf("greeting: %s\n", greeting); return 0;&#125; 或者这样写： 12345678910int main(int argc, const char *argv[])&#123; // 这里干脆不要写数字 char greeting[] = "blog"; size_t len = strlen(greeting); printf("greeting len: %ld\n", len); printf("greeting: %s\n", greeting); return 0;&#125; 这样修改后，再编译运行结果就对了，如下： 12greeting len: 4greeting: blog 我们知道的东西是有限的，我们不知道的东西则是无穷的。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C char strlen sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用 libcurl]]></title>
    <url>%2F2019%2F03%2F03%2FiOS-%E4%BD%BF%E7%94%A8-libcurl%2F</url>
    <content type="text"><![CDATA[libcurl 简介libcurl 是用C语言写的一套 开源 库，是为网络客户端提供数据传输功能的函数库。 libcurl 支持 SMTP、HTTP、HTTPS、FTP、TELNET 等协议和各种 SSL 安全认证，支持 Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS 等平台，在 Android 和 iOS 上面也可以使用 libcurl 这个库。 下面是官网的英文简介： 123456libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!libcurl is highly portable, it builds and works identically on numerous platforms, including Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS and more...libcurl is free, thread-safe, IPv6 compatible, feature rich, well supported, fast, thoroughly documented and is already used by many known, big and successful companies. 分享内容今天跟大家分享 libcurl 在 iOS 上面如何使用，主要分享内容如下： 1、iOS 工程集成 libcurl以及集成注意事项。2、利用 libcurl 发送 HTTP GET 和 POST 请求。3、使用 springboot 搭建本地服务，这个只是为了演示不是分享的重点。 搭建本地服务本地服务采用 Spring Boot 开发，开发语言是 Java，JDK 版本1.8，Spring Boot 版本是 v2.1.3.RELEASE，集成 Web 组件即可，比较简单。关于如何搭建 Spring Boot的开发环境，大家自行搜索解决，也可以直接使用我的 git 工程，猛戳前往 即可获取完整代码示例。 工程结构如下图所示： 关键代码如下： 该工程只是为了配合 libcurl 的使用而诞生的，没有什么难度。 集成 libcurl1、新建 iOS 工程 这里工程为 tutorial_libcurl_iOS。 2、准备库文件、头文件 libcurl 可以自己编译，也可以使用别人编译好的二进制文件。我使用的是 curl-android-ios 这个工程里面编译好的文件。 3、给工程 tutorial_libcurl_iOS 添加库和头文件 将上面的文件拷贝至工程目录即可，现在工程目录如下： 4、设置路径 在 xcode 中 Building Settings 找到 User Header Search Paths 为如下内容： 1$(SRCROOT)/tutorial_libcurl_iOS/Classes 这一步不是必须的，我个人比较喜欢这样整理和设置目录。 5、添加 libz.tbd 如果不添加这个库，编译无法通过，会显示如下错误： 发送 HTTP 请求下面说一下如何使用 libcurl 来发送 HTTP 的 GET 和 POST 请求。只给出核心示例代码，其余的大家去 tutorial_libcurl 获取完整示例代码，包括 Spring Boot 的。 ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#import "ViewController.h"#import "curl/curl.h"// 我本机的 IP 和端口，实际你要换成你自己的#define HOST_URL @"http://172.20.10.2:8080/user"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad];&#125;- (IBAction)doHTTPGETToFileAction:(id)sender&#123; NSString *reqUrl = [NSString stringWithFormat:@"%@%@", HOST_URL, @"?id=1&amp;name=veryitman"]; const char *url = [reqUrl cStringUsingEncoding:NSUTF8StringEncoding]; http_get_req(url);&#125;- (IBAction)doHTTPPOSTToFileAction:(id)sender&#123; const char *url = [HOST_URL cStringUsingEncoding:NSUTF8StringEncoding]; const char *data = "id=2&amp;name=veryitman"; http_post_req(url, data);&#125;#pragma mark - Cvoid http_get_req(const char *url)&#123; CURL *curl; const char *fpath = rspDataPath(@"http_get_rsp_data.log"); FILE *fp; fp = fopen(fpath, "wt+"); struct curl_slist *headers = NULL; //增加HTTP header headers = curl_slist_append(headers, "Accept:application/json"); headers = curl_slist_append(headers, "Content-Type:application/json"); headers = curl_slist_append(headers, "charset:utf-8"); //初始化 curl = curl_easy_init(); if (curl) &#123; //改协议头 curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_POST, url); //wt+：读写打开或着建立一个文本文件；允许读写 if (NULL != fp) &#123; // 请求结果写入到文件当中 curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); &#125; CURLcode rsp_code = curl_easy_perform(curl); if (CURLE_OK == rsp_code) &#123; NSLog(@"请求返回成功"); &#125; else &#123; NSLog(@"请求返回失败，返回码是 %i", rsp_code); &#125; curl_slist_free_all(headers); curl_easy_cleanup(curl); &#125; fclose(fp);&#125;void http_post_req(const char *url, const char *req_data)&#123; const char *fpath = rspDataPath(@"http_post_rsp_data.log"); FILE *fp; fp = fopen(fpath, "wt+"); CURL *curl; curl = curl_easy_init(); if (curl) &#123; curl_easy_setopt(curl, CURLOPT_URL, url); NSLog(@"length: %ld", strlen(req_data)); /* size of the POST data */ curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(req_data) + 1); /* pass in a pointer to the data - libcurl will not copy */ curl_easy_setopt(curl, CURLOPT_POSTFIELDS, req_data); if (NULL != fp) &#123; // 请求结果写入到文件当中 curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); &#125; CURLcode rsp_code = curl_easy_perform(curl); if (CURLE_OK == rsp_code) &#123; NSLog(@"请求返回成功"); &#125; else &#123; NSLog(@"请求返回失败，返回码是 %i", rsp_code); &#125; curl_easy_cleanup(curl); &#125; fclose(fp);&#125;@end 启动 Spring Boot 项目，启动成功后，再运行 xcode 工程，可以测试。 点击对应的按钮就可以发送 GET 和 POST 请求了。 请求返回的结果被写入到了沙盒文件中，可以在终端使用 cat 命令查看对应的响应结果。 GET 响应结果： 1cat ~/Library/Developer/CoreSimulator/Devices/BA882AC3-7977-49C7-8B0D-65EFD1541B68/data/Containers/Data/Application/3A21CFC5-3044-4FC0-9BFA-B311A59187AF/Documents/http_get_rsp_data.log 1user info: id=2 name=veryitman POST 响应结果: 1cat ~/Library/Developer/CoreSimulator/Devices/BA882AC3-7977-49C7-8B0D-65EFD1541B68/data/Containers/Data/Application/86E7D457-97B1-4D8C-80D5-E8179B691F76/Documents/http_post_rsp_data.log 1user info: id=2 name=veryitman 后续为大家分享如何使用回调来接收 HTTP 响应数据、其他网络请求的情况以及 Android 上面如何使用 libcurl 库。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>curl libcurl springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emscripten：JS 调用 C、C++]]></title>
    <url>%2F2019%2F03%2F02%2FEmscripten%EF%BC%9AJS-%E8%B0%83%E7%94%A8-C%E3%80%81C%2F</url>
    <content type="text"><![CDATA[在 了解 Emscripten 中，给大家简单分享了 Emscripten 是什么以及其使用场景。今天继续分享如何使用 JS 调用 C/C++ 代码。 神奇的 main 函数下面是 了解 Emscripten 中的例子代码，只有一个 main 函数。 123456#include &lt;stdio.h&gt;int main(int argc, char ** argv) &#123; printf(&quot;Emscripten show in browser...\n&quot;);&#125; 使用 Emscripten SDK 编译后生成了对应的 html、js 和 wasm 文件。 第一次编译会较慢, 编译完成后会在 ~/.emscripten_cache 生成缓存目录和缓存文件, 以后再次编译就比较快了. 可以在火狐或者 Chrome 或者 Safari 上面运行 h_emcc.html 文件. 这里在火狐浏览器上面可以直接打开 mz.html 文件, 如果是在 Chrome 或者 Safari 需要执行下面命令: 1emrun mz.html 或者指定浏览器打开该文件. 1emrun --browser chrome mz.html 关于 emrun 的其他用法，可以使用 emrun --help 来查看。这里在浏览器可以看到对应 main 函数的输出，说明 Emscripten 生成的代码默认会调用 main 函数。 EMSCRIPTEN_KEEPALIVE既然 Emscripten 生成的代码默认会调用 main 函数，那么如果想使用其他函数怎么办呢？ 我们可以在函数前添加 EMSCRIPTEN_KEEPALIVE，它在emscripten.h 文件中有声明，这个可以通过源码查看。 下面还是举个例子来说明。 my.html 123456789101112131415161718&lt;!doctype html&gt;&lt;html lang="en-us"&gt;&lt;!-- 省略... --&gt; &lt;body&gt;document.querySelector('.mybutton').addEventListener('click', function()&#123; alert('检查控制台'); var result = Module.ccall('sum', // name of C function null, // return type null, // argument types null); // arguments &#125;); &lt;/script&gt; &lt;script async type="text/javascript" src="hello3.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 里面引用了 hello3.js 并且使用 Module.ccall 调用了 C 函数 sum。 hello.c 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;emscripten/emscripten.h&gt;int main(int argc, char ** argv) &#123; printf("Hello emcc\n");&#125;#ifdef __cplusplusextern "C" &#123;#endifint EMSCRIPTEN_KEEPALIVE sum() &#123; printf("sum = %i\n", 100); return 1;&#125;#ifdef __cplusplus&#125;#endif 编译 hello.c 1emcc -o hello.html hello.c -O3 -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[&apos;ccall&apos;]&quot; 注意：EXTRA_EXPORTED_RUNTIME_METHODS 设置了 Module 的导出函数，不导出 ccall 的话，会报以下错误: 1&apos;ccall&apos; was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ) 现在可以运行 my.html 1emrun my.html 可以修改一下 sum 函数，使其带参数，修改如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;emscripten/emscripten.h&gt;int main(int argc, char ** argv) &#123; printf("Hello World emcc\n");&#125;#ifdef __cplusplusextern "C" &#123;#endifint EMSCRIPTEN_KEEPALIVE sum(int a, int b) &#123; printf("sum = %i\n", (a+b)); return 1;&#125;#ifdef __cplusplus&#125;#endif 需要修改 my.html 文件，修改内容如下： 1234var result = Module.ccall('sum', // name of C function null, // return type ['number'], // argument types [12, 13]); // arguments 注意 argument types 和 arguments 的填写，运行可以看到预期效果。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Emscripten wasm JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冷笑话的启示]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%86%B7%E7%AC%91%E8%AF%9D%E7%9A%84%E5%90%AF%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[几乎所有人都比较喜欢听或者看笑话故事，笑话故事可以让你开心，也可能让你随时哈哈大笑。下面几则笑话故事，在笑的同时可以想想其中蕴藏的道理。 女浴室起火，里面人乱作一团，赤裸身体往外跑，只见大街上白花花一大群，一老者大喊“快捂住”，众裸女突然醒悟，但身上要紧部位有三处，手忙脚乱捂不过来，不知所措。这时老者又大喊：“捂脸就行，下面都一样！” 😆 在特殊情况下抓工作不可能面面俱到，要抓住重点。 少妇报案：“我把钱放在胸衣内，在拥挤的地铁内被一帅哥偷走了…”警察纳闷：“这么敏感的地方你就没觉察到？”少妇红着脸答：“谁能想到他是摸钱呢？” 😆 让客户的钱在愉快体验中不知不觉地被摸走，是商业模式的最高境界。 某富翁想娶老婆，有三个人选，富翁给了三个女孩各一千元，请她们把房间装满。第一个女孩买了很多棉花，装满房间的1/2。第二个女孩买了很多气球，装满房间的3/4。第三个女孩买了很多蜡烛，让光线充满房间。 最终，富翁选了胸部最大的那个。 😆 把握客户内心猥琐但真实的需求至关重要。 很多年前认识一小三，当然是别人的小三，但这小三算是有本领的，不仅人长的漂亮，长发飘飘，也很有脑。爱上某金融界人士，但人家已有妻室，这小三不屈不挠，投其所好，知道男人热爱古诗词，小三楞是用了不长的时间将唐诗三百首倒背如流，小三便转正了。 😆 没有拆不散的夫妻，只有不努力的小三！ 一男子在狱中闲来无事训练蚂蚁，蚂蚁可在他指令下倒立、翻跟头 、鞠躬…. 出狱后，男子迫不及待去酒吧炫耀他的绝活，他点了一杯啤酒，然后，掏出蚂蚁放在桌上对服务员说：看，这只蚂蚁。服务员转身一掌拍死了蚂蚁，抱歉地对他说说：对不起先生，我马上给您换一杯! 😆 遇事要三思而后行。 从前有只羊，它一天干10个小时的活。有一天它的主人告诉它，你好好干，多干活有奖励，于是它照做了。接下来每个月它的主人把它身上的羊毛剪了三分之一 ，年底到了，给它织了件毛衣，然后告诉它：诺，这是你的奖励，恭喜你，继续努力吧！ 😆 这笑话告诉我们：羊毛出在羊身上。 赵四小姐从十六岁开始跟张学良。跟一年，属奸情；跟三年，算{敏感词}；跟六十年，便成为千古爱情！ 😆 很多事情不看做不做，而看你做多久。 民国初名妓小凤仙，如果跟了民工，就属于扫黄对象；她跟了蔡锷，则千古留芳了；倘若她跟了孙中山，那便可能成为国母。 😆 不在于你干什么，而看你跟谁干。 组织几个人收保护费，那是黑社会。朱元障组织几百万人抢下王位，就是伟大的皇帝。武则天睡了公公睡儿子，虽属乱*伦，但乱的够大，故成为女皇。 😆 不在你干没干坏事，而在于干多大！ 一公司在小便池上贴上条：“往前一小步，文明一大步”，结果地上仍有许多尿渍。后来公司认真吸取教训，重新设计成：“尿不到池里说明你短；尿到池外说明你软”，结果地上比以前干净许多。 😆 给客户的投资建议一定要具体，确切，中要害。 某日，女秘书神色凝重地说：王总，我怀孕了。 王继续低头看文件，然后淡淡一笑：我早结扎了。 女秘书楞了一会媚笑道：我和您开玩笑呢! 王抬起头看了她一眼，喝了口茶说：我也是。 😆 在江湖上混的人，遇事不要慌，先让子弹飞一会。 男子去提亲，女方家长：请自我介绍。 A说：我有一千万； B说：我有一栋豪宅，价值两千万； 家长很满意。就问C，你家有什么？ C答：我什么都没有，只有一个孩子，在你女儿肚子里。 AB无语，走了。 😆 核心竞争力不是钱和房子，是在关键的岗位有自已的人。 一男干部怕吃苦不愿援藏，谎称眼睛突然失明。领导闻听，出面让一美女脱光站在他面前，问“看见了吗”？答：看不见。领导飞起一脚给他臀部：狗日的，老二都直了还看不见？收拾行李，明天进藏。 😆1.人性化才能真正了解人。2.组织比个人高明。3.本能会出卖你 一小朋友问一富翁说 叔叔你为什么这么有钱。富翁摸摸小朋友的头说：小时候我爸给了我一个苹果，我卖掉了它有了两个苹果，后来我又赚到了四个苹果。小朋友若有所思的说 哦…叔叔，我好像懂了。富翁说，“你懂你妹阿，后来我爸死了，我继承了他的财产… 😆 不要痴迷于从阅读成功人士的传记，从中寻找经验，这些书大部分经过了精致的包装，很多重要的事实不会告诉你。例如盖茨的的书不会告诉你他母亲是IBM董事，是她给儿子促成了第一单大生意，巴菲特的书只会告诉你他8岁就知道去参观纽交所，但不会告诉你他国会议员的父亲带他去的，是高盛的董事接待的。 参考 lupaworld 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笑话 冷笑话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给 Homebrew 设置代理]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%BB%99-Homebrew-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 可以给 Homebrew 工具设置代理，设置方法和步骤如下。 1、打开终端，进入用户根目录 1cd ~/ 2、查看当前目录 1ls -al 查看是否有 .curl 文件，如果没有，新建一个吧 1touch .curl 3、编辑 .curl 文件 写入下面内容，如下： 1proxy=ip:port 把 ip 和 port 改为你的代理 ip 和端口值，如: 1proxy=127.0.0.1:8087 保存文件即可。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS brew proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解 Emscripten]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%86%E8%A7%A3-Emscripten%2F</url>
    <content type="text"><![CDATA[广告时间，见谅勿怪，看到了就点一下链接吧，感激不尽🙇‍！ 最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。 点 这里 可以直接看教程。 ## Emscripten 是什么？Emscripten 是一个 开源的编译器，可以将 C/C++ 的代码编译后高效运行在现代浏览器上面。Emscripten 的底层是基于 LLVM 编译器的，可以查看其开源的 emscripten llvm 和 emscripten clang。 下图是其编译 C/C++ 的代码的流程图： 官网 对 Emscripten 的定义： Emscripten is a toolchain for compiling to asm.js and WebAssembly, built using LLVM, that lets you run C and C++ on the web at near-native speed without plugins. 截止本文发布，Emscripten 最新版本是 1.38.27. 安装条件以下是我安装和使用 Emscripten 的条件。 macOS 版本 10.14 Git，可通过 Homebrew 安装 CMake，可通过 Homebrew 安装 Xcode 10.1 Python 2.7.x，Mac 系统自带 稳定快速的网络环境，最重要和最关键的的是要有(neng)梯(fan)子(qiang) 解决问题的态度和毅力 通过 emsdk 安装安装 Emscripten 可以通过安装 emscripten SDK 来完成，emscripten SDK 可以简单的理解为是 Emscripten 的一套工具链。 在你自己的电脑上面任意新建一个目录，如我的 ~/dev/emscwork，打开终端，进入此目录。 1、下载 emsdk 1git clone https://github.com/juj/emsdk.git 2、进入 emsdk 目录 1cd emsdk 3、开始安装 1234567891011# Fetch the latest version of the emsdk (not needed the first time you clone)git pull# Download and install the latest SDK tools../emsdk install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file)./emsdk activate latest# Activate PATH and other environment variables in the current terminalsource ./emsdk_env.sh 注意: 每次更新完 emsdk 后，依旧需要执行上面命令重新安装和激活。 另外一个比较常用的是 ./emsdk update-tags 这个命令，可以直接更新 emsdk 的最新 tags 版本，更新 tags 完成后，重新安装和激活最新版的 emsdk 套件。 配置 emsdk如果你想在任意路径下都可以使用 emsdk 里面的各种工具(就是一些二进制可执行文件)，需要为其设置环境变量。 编辑 ~/.bash_profile 文件，新增如下代码: 1234export EMSDK=~/emscwork/emsdkexport EMSCRIPTEN=$EMSDK/emscripten/1.38.27export BINARYEN_ROOT=$EMSDK/binaryen/master_64bit_binaryenexport PATH=$EMSDK:$EMSCRIPTEN:$BINARYEN_ROOT:$PATH 执行下面命令, 使刚配置的文件生效。 1source ~/.bash_profile 至此，安装和设置环境变量完成。 可以使用下面命令来查看 emsdk 的安装情况。 1emcc --version 1234emcc (Emscripten gcc/clang-like replacement) 1.38.27 (commit ea5d631a5446632e195765d89a53ead71cd6de45)Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)This is free and open source software under the MIT license.There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. emcc 是一个可执行脚本，该脚本在 emsdk/emscripten/1.38.27 目录下。 1emcc --help 上面命令可以查看更多关于 emcc 的使用方法. 编译 C/C++ 代码这里举个实际的例子。 main.c 123456#include &lt;stdio.h&gt;int main(int argc, char ** argv) &#123; printf("Emscripten show in browser...\n");&#125; 使用 emcc 编译，如下： 1emcc main.c -s WASM=1 -o mz.html 这里要注意 WASM=1 这个选项，现在新版 SDK 默认 WASM=1 了，如果不想生成 .wasm 这个文件，需要指定 WASM=0 选项。 生成另外三个文件如下： 1mz.html mz.js mz.wasm 简单介绍一下这三个文件 1、mz.wasm 二进制的 wasm 模块代码 2、mz.js 胶水代码，包含了原生 C 函数和 JavaScript/wasm 之间转换的 JS 文件 3、mz.html 用来加载、编译和实例化 wasm 代码并且将其输出在浏览器显示上的 HTML 文件 最后执行下面的命令，可以在 Safari 浏览器中显示效果 1emrun mz.html main.cpp 12345678910#include &lt;iostream&gt;using namespace std;int main(int argc, char ** argv)&#123; cout &lt;&lt; "Emscripten show in browser..." &lt;&lt; endl; return 0;&#125; 编译 C++ 文件(main.cpp) 1emcc main.cpp -s WASM=1 -o mzcpp.html 同样的方式编译和运行 mzcpp.html 即可看到同样的效果。 Emscripten 应用场景Emscripten 只是一个编译器，能将我们的高级语言编译为浏览器可以识别并运行的程序，这个看起来确实很诱人。 就目前来说，Emscripten 应用场景可以使用在安全和游戏上面。 1、安全 C/C++ 代码经过编译之后，会生成 wasm 格式 的二进制文件，这个安全级别较高，即使在浏览器中运行，破解者也不会很轻松的破解代码，这样一些在 JS 中涉及到安全的问题，可以使用 C/C++ 来写结合一些加密技术，然后用 Emscripten 编译。 2、游戏 如果能把用 C/C++ 语言写的游戏，转为可在浏览器直接运行的H5游戏，那就很美好了，用户不需要下载游戏，直接玩。现代浏览器技术的更新和发展已经让这个想法变成了现实，至少在主流的浏览器上面。 推荐大家看看这篇文章 JavaScript是如何工作的：与WebAssembly比较及其使用场景 参考文档About Emscripten Download and install 编译 C/C++ 为 WebAssembly WebAssembly 概念 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Emscripten wasm JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 结构体指针初始化]]></title>
    <url>%2F2019%2F02%2F08%2FC-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在使用指针之前，务必要将其初始化。这个是我们最早学习 C 语言的时候，书上经常说的一个问题。在工作中，我们反而会经常忘记这条金科玉律。 本篇文章的所有代码都经 gcc-7 编译器编译过。关于在 macOS 中如何安装和使用 gcc，可以参考 GCC: Homebrew 安装 GCC 和 Binutils 这篇文章。 结构体成员指针的初始化 结构体成员指针的初始化，指的是初始化结构体中指针变量的成员。 我们举个例子，下面是 Animal 的结构体。 123456struct Animal &#123; char *name; //指针成员 int age; char info[200]; //字符数组 struct Animal *nextAnimal; //指针成员&#125;; 结构体 Animal 含有4个成员变量，其中 name、info 和 nextAnimal 是指针变量。 写一段测试代码，如下： 12345678int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); return 0;&#125; 运行结果正常，终端输出如下： 1animal&apos;s name: (null), age: 0, info: 我们来验证一下 Animal *nextAnimal 在没有初始化的情况下，会不会有什么问题。 123456789101112int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 程序编译没有问题，运行报错 123animal's name: (null), age: 0, info: animal.nextAnimal: 0x1127fa036Segmentation fault: 11 修改一下代码，初始化一下 animal.nextAnimal 这个指针，如下： 123456789101112131415int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 再次编译重新运行，还是报错。还需要初始化 animal.nextAnimal-&gt;name 这个变量。 123456789101112131415161718int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); // 初始化 name 变量 animal.nextAnimal-&gt;name = "cat"; printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 编译运行，一切正常。 123animal's name: (null), age: 0, info: animal.nextAnimal: 0x10f0f1036animal.nextAnimal-&gt;name: cat, age: 0, info: 通过上面的例子，结构体指针变量有些会给默认值，有些又不会给，所以都要初始化指针变量。修改一下代码，示例如下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Animal &#123; char *name; //指针成员 int age; char info[200]; //字符数组 struct Animal *nextAnimal; //指针成员&#125;;int main(int argc, const char *argv[])&#123; struct Animal animal; animal.name = "cat"; strcpy(animal.info, "This is a cat."); printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); // 初始化变量 animal.nextAnimal-&gt;name = "cat"; strcpy(animal.nextAnimal-&gt;info, "This is a cat."); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 结构体指针的初始化 指的是初始化结构体指针变量。 12345678int main(int argc, const char *argv[])&#123; struct Animal *ptAnimal; printf("ptAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;name, ptAnimal-&gt;age, ptAnimal-&gt;info); return 0;&#125; 编译运行报错： 1Segmentation fault: 11 同样的道理，需要初始化指针变量。完成后的示例代码如下： 12345678910111213141516171819202122int main(int argc, const char *argv[])&#123; struct Animal *ptAnimal; // 初始化结构体指针 ptAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;info, "This is a big dog"); printf("ptAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;name, ptAnimal-&gt;age, ptAnimal-&gt;info); // 初始化结构体指针的成员指针变量 nextAnimal ptAnimal-&gt;nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;nextAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;nextAnimal-&gt;info, "This is a big dog"); printf("ptAnimal-&gt;nextAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;nextAnimal-&gt;name, ptAnimal-&gt;nextAnimal-&gt;age, ptAnimal-&gt;nextAnimal-&gt;info); return 0;&#125; 完整示例main.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Animal &#123; char *name; //指针成员 int age; char info[200]; //字符数组 struct Animal *nextAnimal; //指针成员&#125;;int main(int argc, const char *argv[])&#123; /// 验证结构体指针成员变量 &#123; struct Animal animal; animal.name = "cat"; strcpy(animal.info, "This is a cat."); printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); // 初始化变量 animal.nextAnimal-&gt;name = "cat"; strcpy(animal.nextAnimal-&gt;info, "This is a cat."); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); &#125; /// 验证结构体指针 &#123; struct Animal *ptAnimal; // 初始化结构体指针 ptAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;info, "This is a big dog"); printf("ptAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;name, ptAnimal-&gt;age, ptAnimal-&gt;info); // 初始化结构体指针的成员指针变量 nextAnimal ptAnimal-&gt;nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;nextAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;nextAnimal-&gt;info, "This is a big dog"); printf("ptAnimal-&gt;nextAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;nextAnimal-&gt;name, ptAnimal-&gt;nextAnimal-&gt;age, ptAnimal-&gt;nextAnimal-&gt;info); &#125; return 0;&#125; 编译 1gcc-7 main.c -o main 运行 1./main 运行结果如下： 12345animal's name: cat, age: 0, info: This is a cat.animal.nextAnimal: 0x0animal.nextAnimal-&gt;name: cat, age: 0, info: This is a cat.ptAnimal's name: dog, age: 0， info: This is a big dogptAnimal-&gt;nextAnimal's name: dog, age: 0， info: This is a big dog 小荷才露尖尖角，早有蜻蜓立上头~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>gcc macOS struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致结婚8周年]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%87%B4%E7%BB%93%E5%A9%9A8%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[自己明明是个理科生，偏偏有颗文科生的心，多愁善感，心理总有道不完的情结。 很多人问我：“写博客是不是很费时间，把写博客的时间腾出来做点其他的不是更好吗？“ 言下之意在说，反正你也成不了作家，干嘛浪费这个时间呢？人生有很多有乐趣的事情可以做，兴趣是最好的老师，不是吗？写博客的确是费时间，但这是个人的一个小爱好，所以，在我看来不算是浪费时间。坚持阅读和写作是我唯一没有放弃的爱好之一，因为它们能给我带来快乐，也是我忙碌之后停歇的港湾，能让我独立思考，静下心来憧憬美好的未来。 所以，爱你所爱吧！ 2010年农历12月21日我们结婚了，在结婚之前我和太太认识了大概5年的时间，风风雨雨的一路走来，坎坷而又幸福，一个女人能为你坚守这么多年，并且总是能帮你，娶她两遍都不为过，哈哈！ 那个时候家里条件很不好，在我的记忆深处，家里总是有还不完的债，每个学期的学杂费让父母焦头烂额，但最终还是被父母搞定了，所以我觉得他们很了不起。我坚持着自己的信念：“必须要考上大学，走出这里！”，母亲是家里最赞成我上学的，可能是被我炽热的学习热情给感染到了，这辈子不能忘记母亲为我上学奔波的日子，母爱之所以伟大是因为他为自己的孩子能倾出所有，并且不求回报！ 大学时期，平时自己会找一些家教做，算是补贴一下日常的开销，寒暑假是我最盼望的日子，因为可以和太太在一起打工挣钱了，那时候挣钱只有一个目的，赚到学费！一到开学她就把自己积累的钱都给我了，简直是义薄云天，她还壮志豪情的说：“拿去花！”，我也厚颜无耻的接过来了。当时我在想，这姑娘就不怕我以后跑掉吗？！关于这个事情，后来我问过她，她说：“我相信你！”，朴实的回答让我无言以对。其实，当我看见她的第一眼，就毅然决定这辈子非她不娶了！ 我们结婚后没几天，就离开了老家赶往深圳，我们手里也没有钱，穷的叮当响，记得去深圳的盘缠还是弟弟给我的。在深圳刚工作的日子里，每天中午我们还要自己做饭，粗茶淡饭的倒也觉得开心，就是在那个时候太太开始会做饭了，特别是捞面和蛋炒饭，至今还让我记忆犹新，每天晚上下班我都会去接她，在月光下她瘦小的身影显得格外别致，一起牵手回家，我们决定就这样幸福的奋斗下去！ 结婚前我们彼此骂过、切磋过，多半是我的过错但我总是觉得自己是个男人，不能低头，不然真他妈没面子。现在想想自己挺可笑的，所以婚后我基本上没有和太太打骂过，女人的脾气很奇怪，一会晴天一会雨天，自己忍一忍就过去了，不要再火上浇油了，就像这句话所说的：“你虽然赢了吵架，但是你却输了感情”，退一步海阔天空！ 2012年3月，儿子出生了，这个小家伙的到来让我们的生活变得更加忙碌了，我们算是步入了父母的行列了。太太算告别了所有的打工生涯，全职在家照顾孩子，我负责在外挣钱，一家三口幸福的生活在一起！太太自从有了儿子之后，儿子就像是他的全部，把孩子照顾的无微不至，做事情比以前认真了很多，开始关注一些公众号，读一些育儿书籍，学习别人是怎么养育孩子的，孩子在成长，太太也在成长。也许，女人从一名妻子的角色转换为母亲的角色的这个过程，算是一次蜕变，尤其是母亲的角色，她扮演的十分精彩！ 2019年1月，我们的第二个孩子出生了，是个可爱的千金，我们之前也讨论过到底要不要二胎，我说生孩子太辛苦了，有一个孩子就够折腾的了，不要二胎也罢。太太坚决反对，说一个孩子太孤单，以后遇到事情连个商量的亲人都没有，必须要二胎，就这样我们孕育了这个小千金。无论你跟你的太太有多大的仇多大的冤，她能为你生孩子，就值得你为她付出一辈子。 今年是我们结婚8周年，7年之痒的传说没有在我们两个身上发生，我们会这样继续幸福下去，迎接下一个周年。 祝大家新年新气象，身体健康，阖家幸福，万事如意，诸事顺利！祝天下有情人终成眷属！ 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class、isa、元类]]></title>
    <url>%2F2019%2F01%2F29%2FClass%E3%80%81isa%E3%80%81%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[声明本文的所涉及到的源码是 objc4 源码，截止到写本文最新的是 objc4-750 这个版本。 Class我们在学习面向对象的学习中，接触最多的就是类，那么在OC类是由Class类型来表示的，Class是用C的数据结构来表示的。 看一下 NSObject 的声明，在头文件中，如下图所示： 123456@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wobjc-interface-ivars" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 可以看到：1、NSObject 是实现了 &lt;NSObject&gt; 协议的。2、NSObject 中有 Class 类型的 isa 成员变量，外界是无法访问的，另外 isa 指针可能在将来也会被隐藏起来(OBJC_ISA_AVAILABILITY标示了)。 继续看一下 Class 到底是什么？ 在上面的文件中可以看到 Class 的定义，如下代码： 123typedef struct objc_class *Class;typedef struct objc_object *id; 可以看出 Class 是一个指向 objc_class 的结构体指针，Objective-C 中的类是由 Class 类型来表示的，它实际上是一个指向 objc_class 结构体的指针。 在下面的头文件中看一下 objc_class 的定义，如下： 12345678struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // ....&#125; 可以看出，objc_class 用来描述OC中的类，而 objc_object 用来描述OC中的对象，类(objc_class)其实也是一个对象(objc_object)，另外 id 是代表对象的，它是指向 objc_object 的结构体指针，它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中 void * 指针类型的作用。 这里要注意，objc_class 的定义在 objc-runtime-old.h中和 objc-runtime-new.h 中的不一样。这里以 objc-runtime-new.h 为主，建议可以看看 被误解的 objc_class 这篇文章。 再来看一下 objc_object，如下图所示： 12345struct objc_object &#123;private: isa_t isa;// ...&#125; objc_object 是一个结构体，里面有个私有成员变量 isa 是 isa_t 类型的。 而 isa_t 是一个 union 类型的，如下代码： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 总之在OC中，类也是一个对象称之为类对象，根据凡是对象都有自己的类的原理，那么类对象的肯定存在自己的类，这个类就是元类(meta-class)。 元类在说元类之前，先看一下下面的例子，创建一个 NSMutableDictionary 实例对象 dict，即向 NSMutableDictionary 发送 alloc 和 init 消息。 1NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; 上面代码的大概执行流程如下几个步骤： 1、先执行 [NSMutableDictionary alloc]，但是 NSMutableDictionary 没有 +alloc 方法，于是再去父类NSObject 中查找该方法。 2、NSObject 响应 +alloc 方法，开始检测 NSMutableDictionary 类，并根据其所需的内存空间大小开始分配内存空间，然后把 isa 指针指向 NSMutableDictionary 类。同时，+alloc 也被加进 cache 列表里面。 3、接着，执行 -init 方法，如果 NSMutableDictionary 响应该方法，则直接将其加入 cache，如果不响应，则去父类查找。 4、在后期的操作中，如果再以 [[NSMutableDictionary alloc] init] 这种方式来创建字典对象，则会直接从 cache 中取出相应的方法，直接调用。 上面是创建一个实例对象的大致流程，接下来我们说说元类。 元类简单来说就是类对象的类。类描述的是对象，那么元类描述的就是Class类对象的类。元类定义了类的行为（类方法），在平时开发时，meta-class 基本是用不着接触的，但最好还是要知道它的存在，这样可以更好的理解OC的设计。 1NSMutableDictionary *tDatas = [NSMutableDictionary dictionaryWithCapacity:5]; 拿上面的示例来说，向 NSMutableDictionary 发送 dictionaryWithCapacity 这个消息的时候，Runtime 会在这个类的 meta-class 的方法列表中查找，通过 SEL 找到后取出方法中的 IMP 函数入口指针，并执行该方法，如果找不到就进行消息转发的流程中，最终可能会导致 Crash，消息转发的原理和机制可以参考 消息机制 这几篇文章。 元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有则该元类会向它的父类查找该方法，直到一直找到继承链的头。 1Class object_getClass(id obj); object_getClass 可以获取一个对象的 class object，其源码实现如下： 12345Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 举个例子吧，示例如下： 123456789101112131415161718NSObject *obj = [NSObject new];Class obj1 = object_getClass(obj);Class obj2 = object_getClass([NSObject class]);Class obj3 = objc_getMetaClass("NSObject");Class obj4 = object_getClass(obj1);const char *name = [NSStringFromClass(obj1) UTF8String];NSLog(@"name: %s", name); //name: NSObjectClass obj5 = objc_getMetaClass(name);Class obj6 = objc_getClass(name); NSLog(@"obj : %@, -&gt;%p: ", obj, obj); NSLog(@"obj1: %@, -&gt;%p: ", obj1, obj1);NSLog(@"obj2: %@, -&gt;%p: ", obj2, obj2);NSLog(@"obj3: %@, -&gt;%p: ", obj3, obj3);NSLog(@"obj4: %@, -&gt;%p: ", obj4, obj4);NSLog(@"obj5: %@, -&gt;%p: ", obj5, obj5);NSLog(@"obj6: %@, -&gt;%p: ", obj6, obj6); 打印结果如下： 1234567obj : &lt;NSObject: 0x600002b19d70&gt;, -&gt;0x600002b19d70:obj1: NSObject, -&gt;0x10c96bf38:obj2: NSObject, -&gt;0x10c96bee8:obj3: NSObject, -&gt;0x10c96bee8:obj4: NSObject, -&gt;0x10c96bee8:obj5: NSObject, -&gt;0x10c96bee8:obj6: NSObject, -&gt;0x10c96bf38: 可以看出，obj 是一个实例对象，obj1和obj6是一个 class object，其二者地址也一致，obj2、obj3、obj4 和 obj5 都获取到的是元类。 通过类对象调用的 object_getClass 得到的是该类对象的 meta-class，如 obj2 和 obj4，而通过实例对象调用的object_getClass 得到的是该实例对象的类对象，如 obj1，objc_getClass 这个方法获取是实例对象的类对象，与object_getClass 还是有点不一样的。而 objc_getMetaClass 可以直接获取 meta-class，如 obj3。 总之:1、objc_getClass 参数是类名的字符串，返回的就是这个类的类对象。2、object_getClass 参数是 id 类型，它返回的是这个 id 的 isa 指针所指向的Class；如果传参是Class，则返回该Class的meta-class。 在 NSObject.mm 中，可以看到 self 和 class 方法都要实例和类方法，class 方法返回的都是类对象。 12345678910111213141516171819+ (id)self &#123; return (id)self;&#125;- (id)self&#123; return self;&#125;+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125; 所以，无论是类还是实例调用 class 方法，返回的都是同一个 class object，举例： 123456Class objClz1 = [NSObject class];Class objClz2 = [[[NSObject alloc] init] class]; if (objClz1 == objClz2) &#123; NSLog(@"objClz1: %@, -&gt;%p", objClz1, objClz1);&#125; 输出结果是： 1objClz1: NSObject, -&gt;0x10fa30f38 isa下面的例子来源自 这里，感谢 kingizz’s blog，代码中 Son 是 Father 的子类，而 Father 是 NSObject 的子类。 123@interface Father : NSObject@end 123@interface Son : Father@end 我们结合下面这个图来理解一下，子类、父类、元类以及 isa 指针。 一个实例对象的 isa 指向对象所属的类，这个类的 isa 指向这个类的元类，而这个元类的 isa 又指向 NSObject 的元类，NSObject 的元类的 isa 指向其本身，最终形成形成一个完美的闭环。 在OC中，所有的对象都有一个 isa 指针，指向对象所属的类，类也是一个对象，类对象的 isa 指针指向类的元类。 参考文章1、Objective-C 中的对象、类、元类 2、Objective-C Runtime(一)对象模型及类与元类 3、被误解的 objc_class 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>元类 isa class meta-class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被误解的 objc_class]]></title>
    <url>%2F2019%2F01%2F28%2F%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84-objc-class%2F</url>
    <content type="text"><![CDATA[网上绝大多数的博客讲 objc_class 的定义，基本上都使用了下面的代码一来讲解，与 objc4 源码 objc-runtime-new.h 中关于 objc_class 中的定义完全不一样，我认真地去探究了一下，发现这个世界上实属雷同的事件还是蛮多的，老实做事做学问的人少的可怜！ 本文的所涉及到的 objc4 源码，截止到写本文最新的是 objc4-750 这个版本。 代码一：简洁版也称坑货版 1234567891011121314151617struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 在上面的代码中 OBJC2_UNAVAILABLE 看起来让人觉得有点奇怪，从字面意思上可以理解为在OC2.0版本不可用了，还有一个 OBJC_ISA_AVAILABILITY 是在表示 Objective-C 都可以使用吗？ 在 objc-api.h 中有关于这两个宏的定义，如下： 代码二：关键宏定义 12345678910111213141516171819202122/* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */#if !defined(OBJC_ISA_AVAILABILITY)# if __OBJC2__# define OBJC_ISA_AVAILABILITY __attribute__((deprecated))# else# define OBJC_ISA_AVAILABILITY /* still available */# endif#endif/* OBJC2_UNAVAILABLE: unavailable in objc 2.0, deprecated in Leopard */#if !defined(OBJC2_UNAVAILABLE)# if __OBJC2__# define OBJC2_UNAVAILABLE UNAVAILABLE_ATTRIBUTE# else /* plain C code also falls here, but this is close enough */# define OBJC2_UNAVAILABLE \ __OSX_DEPRECATED(10.5, 10.5, "not available in __OBJC2__") \ __IOS_DEPRECATED(2.0, 2.0, "not available in __OBJC2__") \ __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __BRIDGEOS_UNAVAILABLE# endif#endif 从定义来看，OBJC_ISA_AVAILABILITY 在OC2.0版本中标示已经过时了，OBJC2_UNAVAILABLE 标示在OC2.0中已经不可用了，将来会被移除的。 我们不妨来摘录完整的代码，如下： 代码三：完整版也称整明白版 123456789101112131415161718192021222324252627282930313233#if !OBJC_TYPES_DEFINED/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// An opaque type that represents a category.typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */#endif 这里居然还有个宏 OBJC_TYPES_DEFINED，看一下其在 objc-private.h 中的定义，如下： 1#define OBJC_TYPES_DEFINED 1 那么 #if !OBJC_TYPES_DEFINED 已经限制了其到 #endif 中间的代码都是无效的，所以关于代码一处的代码其实已经没有实际意义了，网上的朋友们请不要拿这段代码再 骗人 了。 源码 objc-runtime-new.h 中关于 objc_class 中的定义代码如下： 代码四：正解版 123456789101112131415161718192021222324252627struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // ....&#125;struct objc_object &#123;private: isa_t isa;// ...&#125;union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 无论是学知识还是做知识，老实认真应该是最基本的要求，千万不要以讹传讹，误人子弟！ 只要你想做，总会有办法的~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS objc_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合对象可变与不可变的那点事]]></title>
    <url>%2F2019%2F01%2F13%2F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介在文章 NSString NSMutableString 可变与不可变的那些事儿 分享了关于 NSString 和 NSMutableString 与 copy 以及 mutableCopy 之间的点滴。 今天跟大家分享一下集合类数据的可变与不可变性，再结合 copy 以及 mutableCopy 说一说注意事项。如果你仔细看过 NSString NSMutableString 可变与不可变的那些事儿 这篇文章，那么接下来看本篇会很轻松。 本篇内容主要涉及以下几个方面: 在 OC 中的集合对象 集合对象的 copy、mutableCopy 可变与不可变集合对象之间等号赋值 property 中的集合对象的 copy 和 strong 实际案例分析 为了说明问题，这里，我选用数组(NSArray)作为集合对象的代表，其他的集合类以此类推即可。 集合对象在 Objective-C 中，非集合类对象指的是 NSString、NSNumber、NSValue 之类的对象，除了 NSString 有对应的可变类 NSMutableString 外，NSNumber、NSValue 都没有可变类与其对应。 集合类对象是指 NSArray、NSMutableArray、 NSDictionary、NSMutableDictionary、NSSet、NSMutableSet 之类的对象。 集合对象的 copy、mutableCopy看一个具体例子，请接着看下面的示例代码和说明。 例子1：NSArray 的 copy、mutableCopy 12345678910111213141516171819202122NSArray *array = [NSArray arrayWithObjects:@"veryitman.com", nil];NSLog(@"array addr: %p, array: %@ ", array, array);// 地址未变和array一致，内容也一致NSArray *array1 = array;NSLog(@"array1 addr: %p, array1: %@", array1, array1);// 地址未变和array一致，内容也一致// copy 之后仍然是不可变的数组对象id array2 = [array copy];NSLog(@"array2 addr: %p, array2: %@", array2, array2);// 地址改变id array3 = [array mutableCopy];NSLog(@"array3 addr: %p, array3: %@", array3, array3);// 进一步说明了经过mutableCopy后，array3变成了可变数组[(NSMutableArray *)(array3) addObject:@"my blog"];NSLog(@"array3 addr: %p, array3: %@", array3, array3);// 因为array3地址变了，不会影响array的地址和值NSLog(@"array addr: %p, array: %@ ", array, array); 小结 1： 1、不可变数组 copy 之后，仍然是不可变数组，其地址和内容不变，即拷贝了原对象的内容和指针，属于指针拷贝。 2、不可变数组 mutableCopy 之后，变成了可变数组，其地址发生了变化，即只拷贝了原对象的内容，指针没有拷贝，属于内容拷贝。 3、不可变数组之间的等号(=)赋值，是指针拷贝。 例子2：NSMutableArray 的 copy、mutableCopy 1234567891011121314151617181920212223242526272829NSMutableArray *marray = [NSMutableArray arrayWithObjects:@"veryitman.com", nil];NSLog(@"marray addr: %p, marray: %@ ", marray, marray);// 地址未变和marray一致，内容也一致NSMutableArray *marray1 = marray;NSLog(@"marray1 addr: %p, marray1: %@ ", marray1, marray1);// copy 之后，地址改变且变成了不可变的数组对象id marray2 = [marray copy];NSLog(@"marray2 addr: %p, marray2: %@ ", marray2, marray2);// mutableCopy 之后，地址改变但仍是可变数组对象id marray3 = [marray mutableCopy];NSLog(@"marray3 addr: %p, marray3: %@ ", marray3, marray3);// Crash：进一步说明了可变数组对象经过 copy 之后变成了不可变的marray2// -[__NSSingleObjectArrayI addObject:]: unrecognized selector sent to instance 0x600002cbd320// *** Terminating app due to uncaught exception 'NSInvalidArgumentException',// reason: '-[__NSSingleObjectArrayI addObject:]: unrecognized selector sent to instance 0x600002cbd320'// [(NSMutableArray *)(marray2) addObject:@"my blog"];// NSLog(@"marray2 addr: %p, marray2: %@ ", marray2, marray2);// 进一步证明了mutableCopy 之后，marray3是可变数组[(NSMutableArray *)(marray3) addObject:@"my blog"];NSLog(@"marray3 addr: %p, marray3: %@ ", marray3, marray3);// 因为marray3地址改变了，所以对marray3的操作不会影响原来的数组对象marray// marray 地址和内容保持不变NSLog(@"marray addr: %p, marray: %@ ", marray, marray); 小结 2： 1、可变数组 copy 之后，会变成不可变数组，其内容不变，但是地址改变了，即只拷贝了原对象的内容，没有进行指针拷贝，属于内容拷贝。 2、可变数组 mutableCopy 之后，仍然是不可变数组，其地址发生了变化，内容没有变化，即只拷贝了原对象的内容，指针没有拷贝，属于内容拷贝。 3、可变数组之间等号(=)赋值，是指针拷贝。 例子3：NSMutableArray 和 NSArray 之间等号赋值 123456789101112131415161718192021222324252627/** 向不可变数组赋值可变数组 */&#123; NSMutableArray *tDatas = [NSMutableArray arrayWithObjects:@"veryitman.com", nil]; NSLog(@"--1--- tDatas addr: %p, tDatas: %@", tDatas, tDatas); // 类似但不同于可变数组的mutableCopy操作，此时 array 的地址未变和tDatas地址一致 // array的内容和地址未发生变化，和tDatas一致 NSArray *array = tDatas; NSLog(@"--2--- array addr: %p, array: %@", array, array);&#125; /** 向可变数组赋值不可变数组 */&#123; NSArray *tDatas = [NSArray arrayWithObjects:@"veryitman.com", nil]; NSLog(@"--1--- tDatas addr: %p, tDatas: %@", tDatas, tDatas); // 类似进行了不可变数组的 copy 操作 // array 仍旧是不可变的，地址和内容与tDatas一致 NSMutableArray *array = tDatas; NSLog(@"--2--- array addr: %p, array: %@", array, array); // crash: 还是不可变的数组 // -[__NSArrayI addObject:]: unrecognized selector sent to instance 0x6000025499c0 // Terminating app due to uncaught exception 'NSInvalidArgumentException', // reason: '-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x6000025499c0' // [array addObject:@"blog"];&#125; 输出结果，如下： 12345678910111213--1--- tDatas addr: 0x6000023a8bd0, tDatas: ( "veryitman.com")--2--- array addr: 0x6000023a8bd0, array: ( "veryitman.com")--1--- tDatas addr: 0x600002dbbf00, tDatas: ( "veryitman.com")--2--- array addr: 0x600002dbbf00, array: ( "veryitman.com") 以上是使用 NSArray、NSMutableArray 来进行测试的，NSDictionary 和 NSSet 以及其对应的可变类型都遵循上面总结的内容。 copy、strong 修饰属性在属性中，我们如何来选择 copy 或者 strong 来作为集合数据的修饰语呢？ 根据上面示例分析结果可以看出，在属性中，如果使用 strong 修饰不可变数组，那么在使用过程中(被可变数组赋值)该不可变数组有可能会变为可变数组。如果使用 copy 修饰可变数组，那么在使用过程中（被不可变数组赋值）该可变数组有可能变为不可变数组。 小结 3： 当修饰可变类型的属性时，如 NSMutableArray、NSMutableDictionary、NSMutableSet 等集合类型时，用 strong 修饰。 当修饰不可变类型的属性时，如 NSArray、NSDictionary、NSSet 等集合类型时，用 copy 修饰。 大家如果有兴趣可以参考文章 NSString NSMutableString 可变与不可变的那些事儿 的做法来验证上面的理论知识。 实际案例分析再给大家举个实际的开发案例，我们需要定时上报目采集APP的数据，这个需求看起来是没有任何难度的。 我们使用代码来模拟一下上报数据的这个过程。 1234567// 采集到的数据NSMutableDictionary *tDatas = [NSMutableDictionary dictionaryWithCapacity:5];[tDatas setObject:@"https://" forKey:@"req_m"];NSLog(@"--采集数据--- tDatas addr: %p, tDatas: %@", tDatas, tDatas);// 开始发送[self sendDatas:tDatas];NSLog(@"--上报完成，原数据--- tDatas addr: %p, tDatas: %@", tDatas, tDatas); 发送数据的模拟示例如下： 1234567891011- (void)sendDatas:(NSDictionary *)datas&#123; NSLog(@"--上报中--- datas addr: %p, datas: %@", datas, datas); /** 下面两行代码只是为了模拟原数据被外界在传输过程中被改变，比如其他采集线程改变了它 */ if ([datas isKindOfClass:[NSMutableDictionary class]]) &#123; [(NSMutableDictionary *)datas setObject:@"veryitman.com" forKey:@"test_m"]; &#125; NSLog(@"--上报完成--- datas addr: %p, datas: %@", datas, datas);&#125; 根据上面例子3提到的，不可变向可变等号赋值时，原不可变对象会变成可变对象。 控制台输出日志，如下所示： 1234567891011121314151617--采集数据--- tDatas addr: 0x600000b788e0, tDatas: &#123; req_m = https://;&#125;--上报中--- datas addr: 0x600000b788e0, datas: &#123; req_m = https://;&#125;--上报完成--- datas addr: 0x600000b788e0, datas: &#123; req_m = https://; test_m = veryitman.com;&#125;--上报完成，原数据--- tDatas addr: 0x600000b788e0, tDatas: &#123; req_m = https://; test_m = veryitman.com;&#125; 下面代码的代码，我是为了模拟原数据被其他代码改变了的情况，只是为了说明，不可变对象容易被外界影响和改变。 1234/** 下面两行代码只是为了模拟原数据被外界在传输过程中被改变，比如其他采集线程改变了它 */if ([datas isKindOfClass:[NSMutableDictionary class]]) &#123; [(NSMutableDictionary *)datas setObject:@"veryitman.com" forKey:@"test_m"];&#125; 上面的总结又提到无论是可变对象还是不可变对象经过 copy 之后都是不可变对象的原理，我们修改一下代码，示例如下： 1234567891011121314- (void)sendDatas:(NSDictionary *)datas&#123; NSDictionary *copy_datas = [datas copy]; NSLog(@"--上报中--- copy_datas addr: %p, copy_datas: %@", copy_datas, copy_datas); if ([copy_datas isKindOfClass:[NSMutableDictionary class]]) &#123; [(NSMutableDictionary *)copy_datas setObject:@"veryitman.com" forKey:@"test_m"]; &#125; else &#123; NSLog(@"Yes, copy_datas 是不可变字典。"); &#125; NSLog(@"--上报完成--- copy_datas addr: %p, copy_datas: %@", copy_datas, copy_datas);&#125; 输出结果如下： 1234567891011121314151617 --采集数据--- tDatas addr: 0x600003b08740, tDatas: &#123; req_m = https://;&#125;--上报中--- copy_datas addr: 0x600003b08700, copy_datas: &#123; req_m = https://;&#125;Yes, copy_datas 是不可变字典。--上报完成--- copy_datas addr: 0x600003b08700, copy_datas: &#123; req_m = https://;&#125;--上报完成，原数据--- tDatas addr: 0x600003b08740, tDatas: &#123; req_m = https://;&#125; 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 集合对象 可变 不可变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS下生成字符串md5]]></title>
    <url>%2F2019%2F01%2F13%2FmacOS%E4%B8%8B%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2md5%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 在 macOS 系统下生成任意字符串的 md5 值，很简单，直接使用 md5 命令即可。 例如，要生成 veryitman.com 这个字符串的md5值，直接使用下面的命令即可，示例如下： 1md5 -s veryitman.com 对应生成的结果如下： 1MD5 (&quot;veryitman.com&quot;) = c5c401dcdacd95052eef360c3533a8bd 这里要注意，有些使用者会这样来计算： 1echo &quot;veryitman.com&quot; | md5 生成结果如下： 1bc239ea4ba4ebbd4ef9e61c160fcac3c 发现和上面的结果不一致，这是因为 echo 默认会添加一个换行符，导致计算的md5值不一致，修改一下： 1echo -n &quot;veryitman.com&quot; | md5 生成结果 c5c401dcdacd95052eef360c3533a8bd 与上面一致了。 注意： echo -n 用来不显示结尾的换行符。 更多关于 md5 的命令 可以问男人(man)，如下： 1man md5 MD5(Message-Digest Algorithm 5) 全称是报文摘要算法，此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件也能产生相同的报文摘要，但是可能性是极其小的。 MD5 算法 常常被用来验证网络文件传输的完整性，防止文件被人篡改，但是现在 MD5 的算法并不安全了。 在 macOS 上面还有 md5sum 这个命令，一般用来计算文件的md5值。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>macOS string md5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中如何使用对象的弱引用]]></title>
    <url>%2F2019%2F01%2F06%2FiOS-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介我们都知道使用 UIImage imageNamed 创建的 UIImage 对象会被持有(强引用)，如果图片太大会占用内存，损耗 APP 的性能，影响用户体验，如果能改造对其的强引用变为弱引用就可以解决问题。 我们可能会有类似上面的场景，有些对象暂时保存起来，可能后面会用到，也有可能不会使用，但是又不想去管理它们的生命周期，如果它们能够自己被销毁就很省事，不需要去关心这些对象到底耗费了多少内存。 今天跟大家聊聊如何在 iOS 开发中保持对对象的弱引用而不是强引用，希望看完之后，能帮助到大家去解决实际问题。 NSObject retainCount在 iOS 中创建一个对象，该对象的引用计数就会加1，例如下面的例子： 12NSObject *obj = [NSObject alloc] init];NSLog(@"obj retain count: %zd", [obj retainCount]); 上面的例子输出是1，当然在 ARC 下是无法使用 retainCount 这个方法的，只有在非 ARC 条件下才可以，如果要运行上面的例子，对应的文件需要设置为 -fno-objc-arc. 1- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE; 可以在 usr/include/objc/NSObject.h 中查看，retainCount 是 NSObject 协议（@protocol NSObject）中定义的一个方法，而 NSObject 类是实现了该协议的，如下： 1@interface NSObject &lt;NSObject&gt; 所以，任何OC对象都具有 retainCount 方法。另外，你添加一个视图，视图其实也是被容器引用了，其计数也会加1被容器持有其强引用，再例如在数组中添加一个对象，会使对象的引用计数加1，被数组所持有。 NSValue valueWithNonretainedObject在 iOS 中，NSValue 的类方法 valueWithNonretainedObject 可以保持对对象的弱引用。 1+ (NSValue *)valueWithNonretainedObject:(nullable id)anObject; This method is useful if you want to add an object to a Collection but don’t want the collection to create a strong reference to it. 大概意思是，该方法可以不持有对象的强引用，换句话说，只持有对象的弱引用。 举个栗子~ MZDog.h 123@interface MZDog : NSObject@end MZDog.m 12345678910#import "MZDog.h"@implementation MZDog- (NSString *)description&#123; return [NSString stringWithFormat:@"MZDog-obj retain count: %zd", [self retainCount]];&#125;@end 这里 MZDog 是设置了非 ARC 的，如图： 在测试文件中使用 MZDog，如下： 123456789101112131415// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 对 dog 使用弱引用，此时其引用计数还是1NSValue *value = [NSValue valueWithNonretainedObject:dog];NSLog(@"dog: %@, value: %@", dog, value); // 获取 value 对应的对象id obj = value.nonretainedObjectValue;NSLog(@"obj isKindOfClass MZDog: %i", [obj isKindOfClass:[MZDog class]]);if (obj == dog) &#123; NSLog(@"The obj is same dog object.");&#125; 对应的控制台输出，如下： 1234dog: MZDog-obj retain count: 1dog: MZDog-obj retain count: 1, value: &lt;308cf600 00600000&gt;obj isKindOfClass MZDog: 1The obj is same dog object. 从上面的例子可以看出，valueWithNonretainedObject 对 MZDog 对象 dog 是没有强应用的。修改代码，示例一下： 123456789101112// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 对 dog 使用弱引用，此时其引用计数还是1NSValue *value = [NSValue valueWithNonretainedObject:dog];NSLog(@"dog: %@, value: %@", dog, value); // 经过NSValue包装后，可以放到对应的集合对象(如数组，字典等)中，这样这些集合就不会对 dog 进行强引用了NSArray *array = [NSArray arrayWithObjects:value, nil];// dog 的引用计数还是1NSLog(@"dog: %@, array: %@", dog, array); 对应的输出日志： 123dog: MZDog-obj retain count: 1dog: MZDog-obj retain count: 1, value: &lt;40b7a401 00600000&gt;dog: MZDog-obj retain count: 1, array: ("&lt;40b7a401 00600000&gt;") 方法 valueWithNonretainedObject 等同于 1NSValue *theValue = [NSValue value:&amp;anObject withObjCType:@encode(void *)]; 上面的示例，可以改写一下： 123456789101112// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 对 dog 使用弱引用，此时其引用计数还是1NSValue *value = [NSValue value:&amp;dog withObjCType:@encode(void *)];NSLog(@"dog: %@, value: %@", dog, value);// 经过NSValue包装后，可以放到对应的集合对象(如数组，字典等)中，这样这些集合就不会对 dog 进行强引用了NSArray *array = [NSArray arrayWithObjects:value, nil];// dog 的引用计数还是1NSLog(@"dog: %@, array: %@", dog, array); 输出日志： 123dog: MZDog-obj retain count: 1dog: MZDog-obj retain count: 1, value: &lt;40568a02 00600000&gt;dog: MZDog-obj retain count: 1, array: ("&lt;40568a02 00600000&gt;") 此时 dog 的引用计数还是没有增加~ 自写弱引用的集合分类根据上面的理论知识，我们可以使用 NSValue 写出弱引用的集合对象，思路很简单，创建集合类的分类，然后使用 NSValue 来进行包装。看下面的示例代码即可。 NSArray+MZWeak.h 1234567891011@interface NSArray (MZWeak)- (id)mz_weak_objectAtIndex:(NSUInteger)index;@end@interface NSMutableArray (MZWeak)- (void)mz_weak_addObject:(id)obj;@end NSArray+MZWeak.m 123456789101112131415161718192021222324#import "NSArray+MZWeak.h"@implementation NSArray (MZWeak)- (id)mz_weak_objectAtIndex:(NSUInteger)index&#123; NSValue *value = [self objectAtIndex:index]; return value.nonretainedObjectValue;&#125;@end@implementation NSMutableArray (MZWeak)- (void)mz_weak_addObject:(id)obj&#123; NSValue *value = [NSValue valueWithNonretainedObject:obj]; if (nil != value) &#123; [self addObject:value]; &#125;&#125;@end 在文件中使用，示例如下： 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); NSMutableArray *array = [NSMutableArray arrayWithCapacity:1];// 弱引用[array mz_weak_addObject:dog]; // 此时 dog 的引用计数还是1NSLog(@"dog: %@", dog); 依次类推，对于其他集合类 NSDictionary、NSSet 都可以实现。当然实现方式不止这一种，这里只是举了一个 NSValue 包装对象来实现的例子。 当然你也可以使用 NSProxy 或者 block 来解除对对象的强引用。关于 block 的解除方法，可以参考开源项目 HXImage，另外开源项目 YYWeakProxy 里面使用了 NSProxy 来解除强引用。 那么，除了上面提到的方法，系统类库中有没有现成的类呢？聪明的你一定猜到了，一定有！ 是的，往下看。。。 NSPointerArray、NSMapTable、NSHashTable集合类 NSArray、NSDictionary 和 NSSet 以及其对应的可变版本，都可以用来存储 OC对象的, 但是对其中的对象都是强引用的。 从 iOS6.0 版本及以后的版本中，系统给我们提供了 NSPointerArray、NSMapTable 和 NSHashTable 分别对应 NSArray、NSDictionary 和 NSSet，最大的不同就是，NSPointerArray、NSMapTable 和 NSHashTable 对对象是弱引用而不是强引用。 现在大部分的 iOS APP 或者 iOS 游戏应该都至少在 iOS7 以上了吧，所以可以尽情使用这些系统提供的类库了。 使用 NSPointerArray 保存弱引用的对象，需要使用下面三种方式来创建 NSPointerArray 对象，如下： 12345678// 创建 NSPointerArray 对象方式一NSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray]; // 创建 NSPointerArray 对象方式二NSPointerArray *pointerArray1 = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory]; // 创建 NSPointerArray 对象方式三NSPointerArray *pointerArray2 = [NSPointerArray pointerArrayWithOptions:NSPointerFunctionsWeakMemory]; 那么下面还是以 MZDog 来举例子，如下： 12345678910111213141516171819// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 创建 NSPointerArray 对象方式一// 注意 weakObjectsPointerArray 而不是 strongObjectsPointerArrayNSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray];[pointerArray addPointer:(__bridge void *)(dog)]; // 创建 NSPointerArray 对象方式二NSPointerArray *pointerArray1 = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];[pointerArray1 addPointer:(__bridge void *)(dog)]; // 创建 NSPointerArray 对象方式三NSPointerArray *pointerArray2 = [NSPointerArray pointerArrayWithOptions:NSPointerFunctionsWeakMemory];[pointerArray2 addPointer:(__bridge void *)(dog)]; // dog 引用计数还是1NSLog(@"dog: %@", dog); 对应的输出 dog 对象的 retainCount 仍然是 1，其引用计数没有增加。 对应 NSMapTable 和 NSHashTable 的示例如下： NSMapTable 示例 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 弱应用对象NSMapTable *map = [NSMapTable weakToWeakObjectsMapTable];[map setObject:dog forKey:@"first"]; // 引用计数还是1，没变NSLog(@"dog: %@", dog); NSHashTable 示例 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 弱应用对象NSHashTable *hashTable = [NSHashTable weakObjectsHashTable];[hashTable addObject:dog]; // 引用计数还是1，没变NSLog(@"dog: %@", dog); NSPointerArray 与 NULL在 NSMutableArray 中添加的对象不可以是 nil，而 NSPointerArray 中却可存储 NULL(nil 经过转换得到C指针为 NULL)，也可以用来存储weak对象。weak类型的对象释放之后，NSPointerArray 的对应位置会自动变成 NULL，使用count 属性, 会将 NULL 元素也计算进来，即 NULL 算是它的一员。下面示例可以证明，如下： 123456789101112MZDog *dog = nil; NSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray];void *cobj = (__bridge void *)(dog);NSLog(@"obj: %@", cobj); //NULL[pointerArray addPointer:cobj];// 虽然存储的是 NULL，但是 count 仍然是 1NSLog(@"pointerArray count: %zd", [pointerArray count]);NSArray *array = [pointerArray allObjects];NSLog(@"pointerArray allObjects: %@", array); 一般这样删除 NSPointerArray 中的 NULL 元素，如下： 12[pointerArray addPointer:NULL];[pointerArray compact]; 这里要注意，将OC对象转换为C指针要使用 (__bridge void *) 这种方式，不要使用 (__bridge_retained void *) 或者 CFBridgingRetain，这二者会对 dog 对象进行强引用。如下示例： 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray];// 这里会 retain dog 对象，使其引用计数加1，此时retainCount 是 2[pointerArray addPointer:(__bridge_retained void *)dog];// 这里会 retain dog 对象，使其引用计数再加1，retainCount 是 3[pointerArray addPointer:CFBridgingRetain(dog)]; // 此时的 retainCount 是 3NSLog(@"dog: %@", dog); 如果你对 (__bridge_retained void *) 或者 CFBridgingRetain 感兴趣，可以看看 C 指针与 OC 对象之间的转换 这篇文章。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>weak strong NSPointerArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018，不会重来]]></title>
    <url>%2F2018%2F12%2F31%2F2018%EF%BC%8C%E4%B8%8D%E4%BC%9A%E9%87%8D%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[今天是2018年的最后一天，即2018年12月31日。提前祝愿所有人2019身体健康，万事如意，阖家幸福！ 这篇文章 再见 2016 是在2016年末写的，算是一个hin随心的小结。比较遗憾的是在2017年没有给自己写个总结，所以，不能再错过2018了，我怕老了没有可以寻迹的回忆！ 2018 有太多需要感谢的人了，感谢所有工作上，生活上关心、支持和鼓励我的人们，感谢我的家人给予了我太多的理解和包容，非常感谢你们！ 工作2018年我的职业没有太大的变化，仍然是奋斗在一线工作岗位上的一名软件工程师，我喜欢这份职业，它没有过多的纷争，工程师之间的沟通简单、直接！ 唯一和以前不同的是自己开始负责一个团队了，责任比以前要大了很多，压力也随之剧增。慢慢地，写代码变成了可望不可求的事情了，因为你要处理比写代码更重要的事情，比如团队的磨合，目标的制定，任务的规划等等一系列工作。 在 《蚂蚁金服：科技金融独角兽的崛起》 这本书里讲到过： 作为领导，团队里每一个人的错误都是自己的错误，但团队里每一个人的成果未必是自己的成果，这时整个人的心态就需要重新调整。 我算是一个比较幸运的人，因为团队中有很多比自己更优秀的人，他们有想法，有执行，总是能带动其他人积极的工作。这些人是团队学习的榜样，更是我们团队的财富。 公司在改变，各个方面也越来越成熟，无论是公司文化还是技术能力都在步步高升，今年尤为看到的是 CTO 对技术中台下定的一些决心，这是让人兴奋的。公司一直在强调赋能，把更多优秀、有担当、有责任心的人提拔上来，给他们配备资源，以便发挥他们更大的潜能，大家工作的热情也更上一层楼，因为公司相信他们。 很多时候，并不是你身边没有优秀的人，只是你不愿意相信他们，前怕狼后怕虎的心态阻止了这些优秀人的发挥。其实，他们只是需要你一个肯定的答复，所以试着去改变自己，相信团队里面的每个人，给他们更多的肯定，鼓励和支持他们，结果不会让你失望的。 生活自从老婆孩子回老家之后，我就过上了“单身“的生活，每天早出晚归，努力用工作来代替对他们的思念。 我家的大宝是个天生的运动狂，感觉他总是有用不完的力气，除非他自己在拼图或者画画，否则你甭想清静。一会在家里穿上溜冰鞋给你表演各种溜冰技能，一会拿起篮球给你表演球技，再不是就让你陪他玩跳棋。 老婆大人在家待产了，自己一个人挺着肚子还要给大宝做饭，每天接送他去学校，知道她一个人在家不容易，我也经常鼓励她，她说：“为了孩子，这点苦不算什么！”。有时候，想一想二宝快要跟我们见面了，挺兴奋的。 有时候挺想念他们娘俩的，工作不忙的时候我也会请假回老家，记得上次回去离开的时候，儿子问了我一个问题，他说：“爸爸，你说是钱重要，还是人重要？”，我当时愣了一下，告诉他：“当然是人重要呀！”，他不开心的点了点头。显然，这家伙对我的离开很不满意，那天晚上我赶火车走的时候，大宝在被窝里哭了很久，其实，我也流泪了，只是不愿意承认罢了！ 你自己除了是一名员工之外，还是一名儿子、女儿，或者是一名父亲、母亲，一名丈夫、妻子，只有处理好生活上面的事情，才能更好的投入到工作当中来。无论如何，人还是需要有梦想的！我的梦想就是努力学习更多有用的知识，然后用自己的知识去教育自己的子女，让他们将来能有更好的生活，做一个有用的社会人。 用电影《中国合伙人》成东青的一句话来说：“梦想是什么，梦想就是一种让你感到坚持就是幸福的东西！”。 阅读这些年，自己唯一没有丢弃的爱好就是阅读。 工作上的忙碌，生活上的疲惫，很多时候让我们无法静下心来去阅读，甚至有时候会觉得阅读简直在浪费时间，浪费生命。如果你有这种想法，建议你请假去好好休息几天，抛开喧嚣的尘世，放空一下自己。 我一直坚持阅读，无论是技术书籍还是人文历史，抑或人物传记，平时工作也很忙，我就利用零散的时间来阅读，就算这样，每周每个月累计下来阅读量也不少了，随着阅读量的增多，感觉自己的气色好了很多，因为心态好了，遇事比以前更加沉着冷静了，也更加理性了。 您的气质里藏着你读过的那些书。 今年读到自认为不错的书籍，推荐给大家： 1. 蚂蚁金服：科技金融独角兽的崛起 2. 赋能：打造应对不确定性的敏捷团队 3. 我的情绪为何总被他人左右 4. 终身成长 20191. 加强对上沟通 沟通不能仅限于对下沟通，对上沟通尤为重要，让上级知道目前项目的进度和规划，以及遇到的问题。这一点自己做的还不够好，在2019年要加强。 2. 加强自我管理 管理，不是管理别人，而是要管理好自己，没有人愿意被管理，如果有需要被严格管理的，他可能不适合在你的团队中生存。加强自我管理是我们每个人的目标。 3. 个人、团队技术能力再上一层楼 补齐自己的短板，想尽一切办法提高自己和团队其他技术人员的技术能力，在稳定、高效的同时寻找更多自我成长的途径和方法。 4.更加关心自己的家人和身边的朋友 没有家人的支持和鼓励，你很难去投入工作，所以要好好的对待自己的家人，多关心他们，家人对你的要求不多，往往只需要知道你有没有惦记他们就够了。当然了，我很期待和我们家的二宝见面，嘿嘿😜！ 朋友多了，路才好走，记得跟朋友多聊天，多听听他们的故事，最重要的是经常约他们喝喝酒。 最后分享给大家一句话，共勉： 你的目的不是给谁打工，而是成为更好的自己，建设更好的未来！所以尽快去调整心态，停止抱怨，立即行动，积极沟通！ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString、NSMutableString 可变与不可变的那些事儿]]></title>
    <url>%2F2018%2F12%2F30%2FNSString%E3%80%81NSMutableString-%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[简介这篇文章的主要包含如下内容： 可变对象和不可变对象 NSString 的 copy 和 mutableCopy NSMutableString 的 copy 和 mutableCopy property 中 copy、strong 修饰 NSString property 中 copy、strong 修饰 NSMutableString 很多 iOS 开发的朋友会争论一个问题，我用 copy 和 strong 来修饰 NSString 对象都是一样的效果，在大部分情况下，这二者确实是没有区别，但是在特殊情况下，二者截然不同，所以我们必须搞清楚里面的道道。 我已经尽力简化了这篇文章的内容了，但依然需要你花个15分钟左右的时间，所以当你心情不错又没有其他事情的情况下，就可以来阅读了。 可变对象和不可变对象在 Objective-C 中最常用来处理字符串的是 NSString 与 NSMutableString 这两个类，NSString 被创建赋值后字符串的内容与长度不能再做动态的修改，除非重新给这个字符串赋值。而 NSMutableString 被创建赋值后可以动态的修改字符串的内容。 那么简单来说，可变对象是指，对象的内容是可变的，例如 NSMutableString 对象。不可变的对象则相反，表示其内容不可变，例如 NSString 对象。 可变与不可变是针对对象来说的。在实际开发中，要根据实际的业务场景来选择使用可变还是不可变对象。今天我们只讨论 Objective-C 中 NSString 与 NSMutableString 这两个类，关于其他集合类的可变与不可变特性，后面专门再来写文章分享。 NSString 的 copy 和 mutableCopy在 NSString.h 中，我们可以看到其定义如下： 1@interface NSString : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding&gt; NSString.h 本身实现了 NSCopying, NSMutableCopying 这两个协议，协议的定义如下内容所示： 1234567891011@protocol NSCopying- (id)copyWithZone:(nullable NSZone *)zone;@end@protocol NSMutableCopying- (id)mutableCopyWithZone:(nullable NSZone *)zone;@end 也就是说，我们可以针对 NSString 对象进行 copy 和 mutableCopy 的操作，妥妥的。 举一个简单的栗子，示例代码如下： 12345678NSString *name = @"www.";NSLog(@"name addr: %p, name content: %@", name, name); NSString *name1 = name;NSLog(@"name1 addr: %p, name1 content: %@", name1, name1); NSString *name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2); 输出结果，如下： 123name addr: 0x10090ecf8, name content: www.name1 addr: 0x10090ecf8, name1 content: www.name2 addr: 0x10090ecf8, name2 content: www. 从输出结果可以看出，三个对象的内容和地址都是一样的，经过 name 对象 copy 后的 name2 与 name 还是指向同一块内存地址。 在断点过程中，发现无论是 name 还是 name1、name2 对象，其都是 ConstantString，表明三者都是不可变对象，如下图所示： 从这张图也说明了一个问题，NSString 对象经过 copy 后仍然是不可变对象。 紧接着，我们再来看看 mutableCopy 的使用情况，例子如下： 1234567891011NSString *name = @"www.";NSLog(@"name addr: %p, name content: %@", name, name); NSString *name1 = name;NSLog(@"name1 addr: %p, name1 content: %@", name1, name1); NSString *name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2); id name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3); 对象 name3 是经过 name 对象 mutableCopy 后的，这个时候因为我不确定 name3 到底是可变的还是不可变的，所以采用了 id 来修饰 name3 对象。 可以看一下输出内容： 1234name addr: 0x104a6acf8, name content: www.name1 addr: 0x104a6acf8, name1 content: www.name2 addr: 0x104a6acf8, name2 content: www.name3 addr: 0x1c0052cf0, name3 content: www. 可以看出，name3 的地址变了，再看一下断点的截图： 充分说明了 name3 经过不可变的 name 进行mutableCopy 后变成了可变对象。那么可以将上面的示例代码稍作修改： 1234NSMutableString *name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3);[name3 appendString:@"veryitman.com"];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3); 从下面的输出结果也充分说明了 name3 经过不可变的 name 进行 mutableCopy 后变成了可变对象。输出结果如下： 1name3 addr: 0x1d0058270, name3 content: www.veryitman.com 结论 1： 不可变的 NSString 对象经过 copy 后，还是不可变对象。 不可变的 NSString 对象经过 mutableCopy 后，变成了可变的 NSMutableString 对象。 NSMutableString 的 copy 和 mutableCopy类 NSMutableString 继承自 NSString 的，其当然也是实现了 NSCopying, NSMutableCopying 这两个协议的。 1@interface NSMutableString : NSString 我们还是看例子，示例代码如下： 1234567891011121314NSMutableString *name = [NSMutableString stringWithString:@"www."];NSLog(@"name addr: %p, name content: %@", name, name);// 简单赋值NSMutableString *name1 = name;NSLog(@"name1 addr: %p, name1 content: %@", name1, name1); // 使用 copy id name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2); // 使用 mutableCopy id name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3); 因为事先我们不知道 NSMutableString 经过 copy 和 mutableCopy 之后到底会变成可变还是不可变，上面的例子暂时将 name2 和 name3 用 id 来表示。 断点截图如下： 结合一下输出的日志： 1234name addr: 0x1d044a980, name content: www.name1 addr: 0x1d044a980, name1 content: www.name2 addr: 0xa0000002e7777774, name2 content: www.name3 addr: 0x1d044a5f0, name3 content: www. 可以看出 name2 是一个不可变的 NSString 对象， name、name1 和 name3 都是可变的 NSMutableString 对象。 也可以从另外一个角度来验证一下上面的说法，我们修改一下代码： 1234567NSMutableString *name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2);[name2 appendString:@"veryitman.com"]; NSMutableString *name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3);[name3 appendString:@"veryitman.com"]; 运行后，可以看到，代码 [name2 appendString:@&quot;veryitman.com&quot;] 这里会引起 Crash，报错内容如下： 12345 -[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa0000002e7777774 *** Terminating app due to uncaught exception 'NSInvalidArgumentException'reason: '-[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa0000002e7777774' 也充分说明了，name2 是一个不可变的 NSString 对象。 结论 2： 可变的 NSMutableString 对象经过 copy 后，会变成不可变的 NSString 对象。 可变的 NSMutableString 对象经过 mutableCopy 后，仍然是可变的 NSMutableString 对象。 copy、strong 修饰 NSString创建 Employee 文件，如下： 12345@interface Employee : NSObject@property (nonatomic, copy) NSString *userName;@end 其 userName 属性是 copy。 使用示例，如下： 1234567891011121314151617181920212223Employee *employee = [Employee new];employee.userName = @"John";NSLog(@"--before-- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // 创建一个可变对象NSMutableString *newUserName = [[NSMutableString alloc] initWithString:@"new_user_name"];NSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName); // 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@"---after1--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // 试图改变 newUserName 的内容，看 employee.userName 的内容是否改变[newUserName appendString:@"_hello"];// newUserName 的内容被改变成了 new_user_name_helloNSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName);// employee.userName 的内容未变化NSLog(@"---after2--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // Crash，因为 employee.userName 还是不可变对象// [(NSMutableString *)(employee.userName) appendString:@"nana"]; 在上面的示例中，故意将 NSMutableString 对象 newUserName 赋值给不可变的 NSString 对象 employee.userName，看一下输出结果，如下： 123456789--before-- employee.userName addr: 0x100096cf8, employee.userName content: JohnnewUserName addr: 0x174070a00, newUserName content: new_user_name---after1--- employee.userName addr: 0x174023b80, employee.userName content: new_user_namenewUserName addr: 0x174070a00, newUserName content: new_user_name_hello---after2--- employee.userName addr: 0x174023b80, employee.userName content: new_user_name 按照 1可变的 `NSMutableString` 对象经过 `copy` 后，会变成不可变的 `NSString` 对象。 这个结论来看，employee.userName 肯定是不可变的对象，即使改变 newUserName 的内容也不会影响 employee.userName 这个对象的内容。 那么，我们将 employee.userName 的属性修饰符 copy 改为 strong，又会是什么样子呢？ 我们修改两处代码 Employee.h 1234567@interface Employee : NSObject//@property (nonatomic, copy) NSString *userName;@property (nonatomic, strong) NSString *userName;@end 示例代码，只是打开之前会 crash 的部分 123// employee.userName 经过 strong 修饰过后， 彻底变成了可变对象[(NSMutableString *)(employee.userName) appendString:@"_oc"];NSLog(@"---after3--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); 看一下输出日志： 1234567891011--before-- employee.userName addr: 0x1000a6cf8, employee.userName content: JohnnewUserName addr: 0x17426b280, newUserName content: new_user_name---after1--- employee.userName addr: 0x17426b280, employee.userName content: new_user_namenewUserName addr: 0x17426b280, newUserName content: new_user_name_hello---after2--- employee.userName addr: 0x17426b280, employee.userName content: new_user_name_hello---after3--- employee.userName addr: 0x17426b280, employee.userName content: new_user_name_hello_oc 可以看到 employee.userName 最终和 newUserName 的地址、内容完全相同了，彻底变成了可变对象。 另外，如果不是将可变的 NSMutableString 对象赋值给不可变的 NSString 对象，换句话说，NSString 对 NSString 赋值，那么使用 strong 和 copy 效果都是一样的。 示例代码（无论 employee.userName 使用 strong 还是 copy，效果都是 employee.userName 不可变的）： 1234567891011Employee *employee = [Employee new];employee.userName = @"John";NSLog(@"--before-- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // 创建一个不可变对象NSString *newUserName = @"new_user_name";NSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName); // 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@"---after1--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); copy、strong 修饰 NSMutableString在 property 的修饰语中，只有 copy 修饰语而没有 mutableCopy 的修饰语。 Employee.h 12345@interface Employee : NSObject@property (nonatomic, copy) NSMutableString *userName;@end 示例代码： 12345678910111213141516Employee *employee = [Employee new];employee.userName = [NSMutableString stringWithString:@&quot;John&quot;];NSLog(@&quot;--before-- employee.userName addr: %p, employee.userName content: %@&quot;, employee.userName, employee.userName);// 创建一个可变对象NSMutableString *newUserName = [NSMutableString stringWithFormat:@&quot;new_user_name&quot;];NSLog(@&quot;newUserName addr: %p, newUserName content: %@&quot;, newUserName, newUserName);// 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@&quot;---after1--- employee.userName addr: %p, employee.userName content: %@&quot;, employee.userName, employee.userName); // employee.userName 虽然是 NSMutableString 对象，但经过 copy 修饰过后，仍然是不可变对象// 所以，运行到这里会引起 crash[employee.userName appendString:@&quot;_oc&quot;];NSLog(@&quot;---after2--- employee.userName addr: %p, employee.userName content: %@&quot;, employee.userName, employee.userName); 可以看出 copy 后的的可变对象还是不可变的。 那么，我们将 employee.userName 的属性修饰符 copy 改为 strong，又会是什么样子呢？ Employee.h 12345@interface Employee : NSObject@property (nonatomic, strong) NSString *userName;@end 示例代码： 123456789101112131415161718192021Employee *employee = [Employee new];employee.userName = [NSMutableString stringWithString:@"John"];NSLog(@"--before-- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName);// 创建一个可变对象NSMutableString *newUserName = [NSMutableString stringWithFormat:@"new_user_name"];NSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName);// 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@"---after1--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // employee.userName 虽然是 NSMutableString 对象，但经过 strong 修饰过后，变成了可变对象[employee.userName appendString:@"_hello"];NSLog(@"---after2--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); [newUserName appendString:@"_oc"];// newUserName 的内容被改变成了 new_user_name_hello_ocNSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName);// employee.userName 的内容发生了变化NSLog(@"---after2--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); 经过 strong 修饰后，可变的 NSMutableString 对象还是可变的对象。 在这个部分的开始，说过在 property 中没有 mutableCopy 的修饰语，那么我们能否达到 mutableCopy 的效果呢？ 很显然是可以的，我们可以重写属性的 set 方法，改造一下 Employee 的代码，如下： Employee.h 12345@interface Employee : NSObject@property (nonatomic, copy) NSMutableString *userName;@end Employee.m 12345678910#import &quot;Employee.h&quot;@implementation Employee- (void)setUserName:(NSMutableString *)userName&#123; _userName = [userName mutableCopy];&#125;@end 这样，就达到了和是 strong 修饰语一样的效果了。 大家，可以使用同样的方法来实践一下 NSArray、NSMutableArry 等集合数据的 copy 以及 mutableCopy 的效果了。 小结 不可变的 NSString 对象经过 copy 后，还是不可变对象。 不可变的 NSString 对象经过 mutableCopy 后，变成了可变的 NSMutableString 对象。 可变的 NSMutableString 对象经过 copy 后，会变成不可变的 NSString 对象。 可变的 NSMutableString 对象经过 mutableCopy 后，仍然是可变的 NSMutableString 对象。 不可变的 NSString 对象在 property 中，尽量使用 copy 来修饰，因为使用 strong 修饰符可变字符串如果给不可变字符串赋值后，会导致你原本预期发生了变化，除非你有特殊的目的才使用 strong 修饰符。 可变的 NSMutableString 对象在 property 中，尽量使用 strong 来修饰，除非你有特殊的目的才使用 copy 修饰符。 虽然在 property 中没有 mutableCopy 修饰符，但是可以通过重写其 set 方法来达到目的。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSString NSMutableString copy mutableCopy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC: self]]></title>
    <url>%2F2018%2F12%2F23%2FOC-self%2F</url>
    <content type="text"><![CDATA[为了更好的说明 Objective-C 中的 self，我们先从 Java 的 this 关键字开始来引入话题。 Java 中的 this在 Java 中 this 关键字表示当前类对象，其只能在类的非静态方法中使用，静态方法和静态的代码块中绝对不能出现 this，this 只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的 this. 先看一个 Java 示例，能说明上面的问题，示例如下： 12345678910111213141516171819202122232425262728// 静态代码块中也不可以使用 this// Error: non-static variable this cannot be referenced from a static contextstatic &#123; // this.eat();&#125;public void play() &#123; System.out.println("play()"); // this 调用类方法 this.eat(); // this 调用实例方法 this.finish();&#125;public static void eat() &#123; System.out.println("static eat()"); // 不可以在类方法中使用 this // Error: non-static variable this cannot be referenced from a static context // this.play(); // System.out.println(this);&#125;public void finish() &#123; System.out.println("finish()");&#125; 通过实际的 Java 例子，基本表明了在静态方法和实例方法中 this 的使用场景。 Objective-C 中的 self在 Objective-C 中，self 是一个比较特殊的对象，它既可以是实例对象也可以是类对象，有点类似于上面 Java 中的 this 关键字。 下面结合实际例子，来说明 self 这个关键字。 1、实例方法中的 self实例方法中的 self 可以直接调用实例方法但不可以直接调用类方法，如下示例中，调用实例方法 finish没有问题，而调用类方法 eat 直接报编译错误。 12345678910111213141516171819202122- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------"); NSLog(@"self: %@, self -&gt; %p", self, self); // 无法使用 self 来调用类方法 // Error: No visible @interface for 'MZPerson' declares the selector 'eat' // [self eat]; // 调用实例方法 [self finish];&#125;+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------");&#125;- (void)finish&#123; NSLog(@"--------------- '- (void)finish' ----------------");&#125; 我们知道，在实例方法中可以直接通过`[类 类方法] 的方式来调用类方法，那么如果想在实例方法中使用 self 关键字，如何办呢？ 很简单，使用 [self class] 即可。 1234567- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------"); NSLog(@"self: %@, self -&gt; %p", self, self); [[self class] eat];&#125; 关于 class 后续再分享给大家，这里只需要知道可以这么使用就好了。 2、类方法中的 self这个跟 Java 的 this 有点不一样，上面的 Java 示例中我们可以看到无论是打印 this 还是使用 this 调用方法都不可以，但是在 Objective-C 中却可以使用 self，只是不能使用 self 来调用实例方法和实例变量。 123456789101112131415161718+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------"); // No known class method for selector 'finish' // [self finish]; // 调用类方法 [self beat]; // 打印 self NSLog(@"self: %@", self);&#125;+ (void)beat&#123; NSLog(@"---------------- '+ (void)beat' ------------------");&#125; 那么为什么在类方法中可以使用 self 呢？ 别着急，接着往下看。 3、实例和类方法中的 self 区别其实，在类方法中，self 表示当前类对象，在实例方法中 self 表示实例对象，这个是本质区别，务必要理解透彻。 举个例子，如下： 123456789101112131415161718192021222324252627282930313233- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------"); NSLog(@"self: %@, self -&gt; %p", self, self); // 打印对应的类地址 NSLog(@"self class: %p", [self class]); [[self class] eat]; &#125;+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------"); // No known class method for selector 'finish' // [self finish]; // 打印 self 地址 NSLog(@"self: %p", self); // 调用类方法 [self beat];&#125;+ (void)beat&#123; NSLog(@"---------------- '+ (void)beat' ------------------"); // 打印 self 地址 NSLog(@"self: %p", self);&#125; 在实例方法 play 中打印类地址，在类方法 eat 和 beat 中打印 self 的地址，输出结果是一样的，都是 0x10adb3f98 这个地址。 1234567---------------- &apos;- (void)play&apos; ------------------self: &lt;MZPerson: 0x6000000d8f90&gt;, self -&gt; 0x6000000d8f90self class: 0x10adb3f98---------------- &apos;+ (void)eat&apos; ------------------self: 0x10adb3f98---------------- &apos;+ (void)beat&apos; ------------------self: 0x10adb3f98 为了更好的说明，我给大家再举一个形象的例子帮助大家理解。 在 MZPerson 中声明两个方法，方法同名，一个是实例方法，另一个是类方法，如下： 1234567891011@interface MZPerson : NSObject- (void)play;+ (void)play;+ (void)eat;- (void)finish;@end 1234567891011121314151617181920212223242526@implementation MZPerson- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------");&#125;+ (void)play&#123; NSLog(@"---------------- '+ (void)play' ------------------");&#125;+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------"); [self play];&#125;- (void)finish&#123; NSLog(@"---------------- '- (void)finish' ------------------"); [self play];&#125;@end 在类方法 eat 中调用 [self play] 在实例方法 finish 中也调用 [self play]，那么结果如何呢？ 12345---------------- &apos;- (void)finish&apos; ------------------------------- &apos;- (void)play&apos; --------------------------------- &apos;+ (void)eat&apos; ---------------------------------- &apos;+ (void)play&apos; ----------------- 可以看出符合如期，类和实例方法中的 self 分别代表类本身和实例对象。 self 表示谁，在运行时是由编译器来决定的。 4、每个实例对象的 self 都是不一样的这个跟 Java 的 this 是一样的，每个类的实例对象对应的 this 都是不一样的，self 亦如此。 下面的例子，分别创建两个 MZPerson 实例对象，然后分别调用play 方法，如下： 12345MZPerson *iperson1 = [MZPerson new];[iperson1 play]; MZPerson *iperson2 = [MZPerson new];[iperson2 play]; 输出结果表明了上面说法的正确性。 1234---------------- &apos;- (void)play&apos; ------------------self: &lt;MZPerson: 0x600000576ee0&gt;, self -&gt; 0x600000576ee0---------------- &apos;- (void)play&apos; ------------------self: &lt;MZPerson: 0x600000576f40&gt;, self -&gt; 0x600000576f40 最后在继承关系中，使用 self 调用方法时，首先从当前类的方法列表中开始寻找，如果没有再从父类中寻找。 运行时(runtime)会使用 objc_msgSend 向对象发送消息，这个也是调用方法的本质。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C self keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark: 分析 TCP 四次挥手]]></title>
    <url>%2F2018%2F12%2F16%2FWireshark-%E5%88%86%E6%9E%90-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[简介首先要明白 TCP 协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。 其次，TCP 是全双工模式，需要两边的连接全部关闭，此 TCP 会话才算完全关闭，四次挥手使得 TCP 的全双工连接能够可靠的终止。 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 下面根据客户端(IP: 10.4.17.176)请求服务端(IP: 116.211.186.208) 来分析四次挥手(four-way handshake)的过程。 这里需要注意一个问题，任何一方执行 close() 操作即可产生挥手操作，所以断开连接端可以是 Client 端，也可以是 Server 端。 在阅读下面内容之前，我假设你已经阅读过 Wireshark: 简单分析 TCP 三次挥手 这篇文章。 分析使用 iOS 设备的浏览器客户端 Safari 访问 116.211.186.208 这个网站，关于如何开启 iOS 设备的虚拟网卡可以参考 初识 Wireshark 这篇文章。 针对 HTTP 的请求，可以进行 Follow，选择 TCP Stream 即可，如下图所示： 此时，可以看到四次挥手的抓包情况，如下图所示：另外，从上图中可以看出，首先发起 Close 的是服务端。 第一次挥手，发送 FIN 和 ACK 报文，如图： 第二次挥手，客户端发送 ACK 报文给服务端，如图： 第三次挥手，客户端发送 FIN 和 ACK 报文给服务端，如图： 第四次挥手，服务端发送 ACK 报文给客户端，如图： 从图中抓包来看，seq 和 ack 的值变化如下表： 次数 seq 值 ack 值 1 140 447 2 447 141 3 447 141 4 141 448 小结结合上面抓包的示例，小结一下四次挥手的过程。 在前面说过，断开连接端可以是 Client 端，也可以是 Server 端，我上面的例子首先发起 close 的一方是 Server 端。 第一次挥手：服务端发送一个 [FIN+ACK] 报文，表示自己没有数据要发送了，想断开连接，并进入 fin_wait_1 状态（不能再发送数据到客户端，但能够发送控制信息 ACK 到客户端）。 第二次挥手：客户端收到 [FIN] 报文后，客户端知道不会再有数据从服务端传来，发送 ACK 进行确认，客户端进入 close_wait 状态。此时服务端收到了客户端对 FIN 的 ACK 后，进入 fin_wait2 状态。 第三次挥手：客户端发送 [FIN ACK] 报文给对方，表示自己没有数据要发送了，客户端进入 last_ack 状态。服务端收到了客户端的 FIN 信令后，进入 time_wait 状态，并发送 ACK 确认消息。 第四次挥手：服务端在 time_wait 状态下，等待 2MSL(MSL是数据分节在网络中存活的最长时间) 一段时间，没有数据到来的，就认为对面已经收到了自己发送的 ACK 并正确关闭了进入 close 状态，自己也断开了到客户端的 TCP 连接，释放所有资源。当客户端收到服务端的ACK 回应后，会进入 close 状态，并关闭本端的会话接口，释放相应资源。 根据 wireshark 抓包和上面流程的分析，可以画出如下示意流程图： 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当 NTFS 遇上 MacOS]]></title>
    <url>%2F2018%2F11%2F24%2F%E5%BD%93-NTFS-%E9%81%87%E4%B8%8A-MacOS%2F</url>
    <content type="text"><![CDATA[简介自己使用的 MacBook Pro 电脑是 256G 的，这个本陪了我5个春秋，性能依旧强劲，一直舍不得抛弃换新(好吧，我承认自己穷)。 由于工作需要，里面安装了不少软件，也存储了不少资料，逐渐发现硬盘容量不足，我也一直在删除一些非必要的东西，发现还是杯水车薪，没办法，又买了一块移动硬盘，网盘用起来还是没有硬盘方便，我使用网盘的频率很低。 MacOS 挂载我觉得移动硬盘买回来，直接插在电脑上就可以使用了，最后发现硬盘只能读不能写，卧槽！ 上网查了一下，在默认情况下，NTFS 格式的硬盘插入到 MacOS 里，是只能读不能写的，需要挂载。 于是结合网上前辈的经验，弄了一个 shell 脚本，用了一段时间，发现挺好用的，但是电脑重启后，脚本就需要修改，还要查找当前硬盘到底在 disk0 还是在 disk2 上面，麻烦。 还好有一些比较成熟的工具帮我们解决问题，Paragon NTFS for MAC 就是其中一个。 这个工具是收费的，我试用了一段时间，感觉功能挺强大的，因为穷也懒得折腾破解，就找了另外一个工具 mounty，小巧可爱关键免费，在公众号上面收到的赞赏我也会 donate 给他们。 mounty 最新版本是 1.9，介绍如下： 1A tiny tool to re-mount write-protected NTFS volumes under Mac OS X 10.9+ in read-write mode. mounty 失效在使用 mounty 挂载移动硬盘时, 弹框提示以下错误: 12The volume My Passport is not re-mountable in read/write mode.Probably it was not clean unmounted before. 这种错误的原因大部分是因为在 Windows 上面使用后没有安全退出(直接拨出)而造成的，网上有两种方案，分别如下： 方案 1 插入移动硬盘到 Windows 下面 打开 dos 命令行，输入 chkdsk /f, 然后回车，输入 Y 使用右下角的安全删除后再拔出移动硬盘 将移动硬盘再次插入 Mac 打开 mounty重新挂载就可以了 反正这种方案我是没有成功，报错如下： 方案 2 在 Windows 系统中，将移动硬盘插入，使用 360软件 点击 安全退出 退出硬盘，不要直接拔掉，再在 Mac 中插入使用 mounty 重新挂载就解决问题了。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>NTFS MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F10%2F28%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组件间通信，我会优先使用路由的通信方式(iOS中需要用到 runtime，Android 中需要用到反射和注解)，组件之间按照路由协议(类似 url)实现各自的职责即可，组件间的松耦合性增强了软件设计的弹性和高可用性。 路由结合观察者模式，可以让你的组件设计更上一层楼。路由可以解决单向调用的问题，让组件之间无需知道对方是否存在。观察者模式可以让调用者(使用你框架的)可以很方便的知道组件的内部事件。 武林至尊，宝刀屠龙，号令天下，莫敢不从，倚天不出，谁与争锋? 在说观察者模式之前，先介绍一下 iOS 中的代理(delegate). 代理 delegate在 iOS 中，代理(delegate)的本质是 protocol，类似 java 中的 Interface，一般用来处理 一对一 的关系，如下图所示： 下面的例子模拟了调用和实现过程，使用 Bank 对象和 BankDelegate 代理来模拟这种模式。Bank 有变动的时候，通过 notifyAccount 来授权 onAccountChanged 通知用户。 BankDelegate.h 12345@protocol BankDelegate &lt;NSObject&gt;- (void)onAccountChanged:(NSUInteger)account;@end Bank.h 1234567@interface Bank : NSObject@property (nonatomic, weak) id&lt;BankDelegate&gt; delegate;- (void)notifyAccount;@end Bank.m 12345678910@implementation Bank- (void)notifyAccount&#123; if ([self.delegate respondsToSelector:@selector(onAccountChanged:)]) &#123; [self.delegate onAccountChanged:100]; &#125;&#125;@end 使用者实现 delegate 12345678910111213- (void)viewDidLoad&#123; [super viewDidLoad]; Bank *bank = [Bank new]; bank.delegate = self; [bank notifyAccount];&#125;- (void)onAccountChanged:(NSUInteger)account&#123; NSLog(@"Bank tell me that account is changed. %zd", account);&#125; 当然，delegate 也可以做到 一对多，改造一下 Bank 就可以实现。 1234567@interface Bank : NSObject- (void)addBankDelegate:(id&lt;BankDelegate&gt;)delegate;- (void)notifyAccount;@end Bank 内部使用数组将 addBankDelegate 得到的 delegate 存起来，notifyAccount 中就可以进行通知了。 12345Bank *bank = [Bank new];// 模拟添加多个 delegate[bank addBankDelegate:self];[bank addBankDelegate:self];[bank notifyAccount]; 观察者模式理解了 delegate，观察者模式就很好理解了。 当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新，这是观察者模式的常规定义。 观察者模式是一种 一对多 的设计模式，如下图所示： 继续上面的例子，使用 Bank 对象和 BankDelegate 来模拟这种模式，Bank 有变动的时候，通过 notifyAccount 来授权 onAccountChanged 通知所有注册了 BankDelegate 的用户。 Talk is cheap. Show me the code BankDelegate.h 12345@protocol BankDelegate &lt;NSObject&gt;- (void)onAccountChanged:(NSUInteger)account;@end Bank.h 123456789@interface Bank : NSObject- (void)addBankObserver:(id&lt;BankDelegate&gt;)delegate;- (void)removeBankObserver:(id&lt;BankDelegate&gt;)delegate;- (void)notifyAccount;@end Bank.m 123456789101112131415161718192021222324- (void)notifyAccount&#123; for (id&lt;BankDelegate&gt; delegate in self.delegates) &#123; if ([delegate respondsToSelector:@selector(onAccountChanged:)]) &#123; [delegate onAccountChanged:100]; &#125; &#125;&#125;- (void)addBankObserver:(id&lt;BankDelegate&gt;)delegate&#123; if (nil == delegate) &#123; return; &#125; [self.delegates addObject:delegate];&#125;- (void)removeBankObserver:(id&lt;BankDelegate&gt;)delegate&#123; if (self.delegates.count &gt; 0) &#123; [self.delegates removeObject:delegate]; &#125;&#125; 调用者 12345678910111213141516171819- (void)viewDidLoad&#123; [super viewDidLoad]; [self registerObserver];&#125;- (void)onAccountChanged:(NSUInteger)account&#123; NSLog(@"Bank tell me that account is changed. %zd", account);&#125;- (void)registerObserver&#123; Bank *bank = [Bank new]; [bank addBankObserver:self]; [bank addBankObserver:self]; [bank notifyAccount];&#125; 看到这里，你应该发现 delegate 的设计其实就是观察者的一种设计手段而已，它本身也是观察者模式。 在 iOS 中，除了 delegate，还有很多这种设计模式的体现，如 KVO、Notification、Observer、Block 等。 发布-订阅模式观察者模式中观察者对被观察者(Bank)是有感知的，至少需要实现对应的 BankDelegate，二者之间还是是有一定的耦合度。 那么，有没有一种方法再来降低这种耦合，让双方都不用去关心对方的存在呢？发布-订阅模式是一个不错的选择。 发布-订阅本质也是观察者模式，但是他更加的松耦合，发布者和订阅者都不用清楚对方，全部由订阅中心做处理，这样耦合度就几乎没有了。 如图展示发布-订阅模式： 在 iOS 中，Notification 就是发布-订阅模式的一种实现，NSNotificationCenter 就类似订阅中心。 12345678// 发布[[NSNotificationCenter defaultCenter] postNotificationName:@"name_protocol" object:nil];// 订阅[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onUpdate:) name:@"name_protocol" object:nil]; 争论网上有很多人说，观察者模式和发布-订阅模式是两种不同的设计模式，它们压根就是两码事，不能混为一谈。也有很多人说，两者其实都是观察者模式，只是实现手段有点不一样罢了，本质是一样的。 江湖纷争，众说纷纭！ 设计模式是一种设计思想，在观察者模式基础上你可以衍生更多的设计模式和更多的设计思想。模式的实现手段可以多样化，没有最好只有更好，就好比 MVC、MVP、MVVM 等，你说它们是设计模式也好，是设计思路也罢，关键是利用它们有没有解决业务需求，为了模式而模式的设计华而不实！ 个人觉得，发布-订阅模式只是观察者模式的一种实现手段，它本质还是观察者模式。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>架构 模块化 组件化 Observer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 中神秘的 GCC]]></title>
    <url>%2F2018%2F10%2F13%2FmacOS-%E4%B8%AD%E7%A5%9E%E7%A7%98%E7%9A%84-GCC%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 这个事情，要从编译一个简单的代码开始说起。 gcc 和 g++ 的区别gcc 是 GCC 中的 GUN C Compiler，C 编译器。 g++ 是 GCC 中的 GUN C++ Compiler，C++编译器。 就本质而言，gcc 和 g++ 并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的 GUN 编译器而已。 gcc 与 g++ 都可以编译 C 和 C++ 文件，只是处理方式不同。 可以参考 GCC的gcc和g++区别 这篇文章。 交换变量：用指针下面这段代码很简单，利用 C 指针实现交换两个变量的目的。 源文件：mz_swap.c 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;// 使用指针的方式交换两个变量int mz_swap(int *ap, int *bp);int main(int argc, char * argv[]) &#123; int xp = 901; int yp = 902; printf("--Before-- xp = %i, yp = %i\n", xp, yp); mz_swap(&amp;xp, &amp;yp); printf("--After--- xp = %i, yp = %i\n", xp, yp); return 0;&#125;int mz_swap(int *ap, int *bp) &#123; if (NULL == ap || NULL == bp) &#123; return -1; &#125; int tp = *ap; *ap = *bp; *bp = tp; return 0;&#125; 在 macOS 下使用 gcc 编译 mz_swap.c，产生可执行文件 exec_main.out，如下操作： 1gcc mz_swap.c -o exec_main.out 编译成功，执行 ./exec_main.out，正常输出结果： 12--Before-- xp = 901, yp = 902--After--- xp = 902, yp = 901 采用 g++ 来编译，如下操作： 1g++ mz_swap.c -o exec_main.out 报出如下警告，该警告的意思是在 C++ 模式下强制编译 C 文件，这里可以不予理会。 1clang: warning: treating 'c' input as 'c++' when in C++ mode, this behavior is deprecated [-Wdeprecated] 虽然有警告，但是编译可以产生可执行文件 exec_main.out 且可以正常执行的，执行结果跟上面一样。 交换变量：用引用大家都知道，C 没有 引用 这个概念，而 C++ 是有 引用 概念的，可以在此了解 C++ 引用. 试一下使用 gcc 编译使用 引用 方式编写的 C 代码，按照说法，gcc 是无法编译通过的。 源文件：mz_swap_ref.c 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;// 使用引用的方式交换两个变量int mz_swap_ref(int &amp;ap, int &amp;bp);int main(int argc, char * argv[]) &#123; int xp = 901; int yp = 902; printf("--Before-- xp = %i, yp = %i\n", xp, yp); mz_swap_ref(xp, yp); printf("--After--- xp = %i, yp = %i\n", xp, yp); return 0;&#125;int mz_swap_ref(int &amp;ap, int &amp;bp) &#123; int tp = ap; ap = bp; bp = tp; return 0;&#125; 编译 1gcc mz_swap_ref.c -o exec_main.out 编译失败，错误信息如下： 12345mz_swap_ref.c:4:21: error: expected ')'int mz_swap_ref(int &amp;ap, int &amp;bp); ^mz_swap_ref.c:4:16: note: to match this '('int mz_swap_ref(int &amp;ap, int &amp;bp); 既然按照 C 的编译方式不行，那就换成 g++ 来编译。 1g++ mz_swap_ref.c -o exec_main.out 编译成功，执行可执行文件 1./exec_main.out 12--Before-- xp = 901, yp = 902--After--- xp = 902, yp = 901 大家可以自己动手试试，使用 clang 来编译 mz_swap_ref.c 和使用 gcc 来编译都是报错，使用 clang++ 和 g++ 编译都是没有问题的。 在博客 GCC: Homebrew 安装 GCC 和 Binutils 中，我已经分享了在 macOS 中的 gcc 和 g++ 不是 GNU 提供的，而是 Apple 自己的 clang。 这里要说明的是即使使用自己安装的 gcc(gcc-4.9) 来编译 mz_swap_ref.c 也是无法编译通过的，验证如下： 1gcc-4.9 mz_swap_ref.c -o exec_main.out 错误信息： 12345mz_swap_ref.c:4:21: error: expected &apos;;&apos;, &apos;,&apos; or &apos;)&apos; before &apos;&amp;&apos; token int mz_swap_ref(int &amp;ap, int &amp;bp); ^mz_swap_ref.c:20:21: error: expected &apos;;&apos;, &apos;,&apos; or &apos;)&apos; before &apos;&amp;&apos; token int mz_swap_ref(int &amp;ap, int &amp;bp) &#123; ^ gcc、g++ 和 clang 的关系在 macOS 中，gcc 以某种方式指向 llvm-gcc 编译器，g++ 亦如此。 1In Apple&apos;s version of GCC, both cc and gcc are actually symbolic links to the llvm-gcc compiler. Similarly, c++ and g++ are links to llvm-g++. llvm-gcc 是 c/c++/oc 的编译器，用了 gcc 前端和命令行界面的 llvm. 1llvm-gcc is a C, C++, Objective-C and Objective-C++ compiler. llvm-g++ is a compiler driver for C++. llvm-gcc uses gcc front-end and gcc&apos;s command line interface. 接下来，我们看一下 llvm-gcc，可以使用 which llvm-gcc 看一下 llvm-gcc 所在位置是 /usr/bin/llvm-gcc，打开目录可以看出其实是一个符号链接，如下图所示： 1ls -l /usr/bin/llvm-gcc 1/usr/bin/llvm-gcc -&gt; clang 它们是统一指向 clang 的符号链接，可以看其原始指向，llvm-gcc 指向 clang，llvm-g++ 指向 clang++。 二者都在 /usr/bin/ 目录下： 其实在 macOS 中 cc 编译器也指向 clang。 总结通过上面的例子，我们至少可以学到如下几点知识： 1、C 语言规范中没有 引用 的概念，使用 C 编译器无法使其编译通过，但是使用 C++ 编译器是可以编译通过的。这是因为各自的编译器是遵循语言规范的。 2、macOS 中的 gcc 和 g++ 苹果开发者们并没有去改造和重写它们，只是分别指向 clang 和 clang++ 编译器。 3、如果不想使用 macOS 中的 gcc 和 g++，就需要自己重新安装 GNU 的编译套件，安装和使用方法已经在博客中有说明。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>gcc g++ clang clang++ cc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN 检出文件]]></title>
    <url>%2F2018%2F10%2F06%2FSVN-%E6%A3%80%E5%87%BA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求对于一些大工程, 整个 svn 仓库文件过大(动辄几十个G的都有)，不想把整个 checkout 下来，但是又想维持整个目录结构以方便后续使用，那么可以使用 Subversion1.5 之后的 --depth 参数来只 checkout 需要的子目录. 如果只想把 svn 仓库里面某个文件 checkout 到本地, 不想 checkout 整个目录, 如何操作呢? 实施假设需要 checkout 出来的文件是 ReadMe.md, 其 svn 地址是: http://svn.xxx.com/path/ReadMe.md，其上级目录的远程地址是 http://svn.xxx.com/path. 注意：以下出现 svn co 就是 svn checkout 的缩写. 方案一大部分人都会在第一时间想到如下的操作: 1svn co http://svn.xxx.com/path/ReadMe.md 实际上这样操作会报错的, 报错信息大概意思是 不可以 checkout 一个文件, 只能 checkout 目录。 所以，该方案不可行。 方案二第一步: checkout 目录 1svn co --depth=empty http://svn.xxx.com/path/ ./ ./ 表示当前目录，--depth=empty 表示检出空目录。 第二步: 更新文件 1svn up ReadMe.md 这里直接 svn up 就可以将你需要的文件 checkout 出来了。 修改文件后, 也可以直接提交到 svn 仓库. 使用如下命令: 1svn ci ReadMe.md -m &quot;update.&quot; 方案三使用 svn export 命令将文件导出，然后将 svn import 命令导入文件到 svn 仓库。 一般临时想 checkout 一个文件，就会使用 方案三, 比较正式的操作，我会选择 方案二，因为 方案二 这样既可在不增加磁盘大小的情况下保持 svn 仓库的目录结构，又可以任意 checkout 文件。 稀疏目录上面的 方案二，其实就是 svn 的一种稀疏检出的操作。 Subversion 1.5 开始支持稀疏检出，允许对目录设置深度（depth）。 关于 depth 几个参数的含义: –depth empty：只包含目录自身，不包含目录下的任何文件和子目录。 –depth files：包含目录和目录下的文件，不包含子目录。 –depth immediates：包含目录和目录下的文件及子目录。但不对子目录递归。 –depth infinity：这是默认的，包含整个目录树。 使用格式如下: 1svn checkout URL --depth empty|files|immediates|infinity 或者 1svn checkout URL --depth=empty|files|immediates|infinity]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>svn depth 稀疏目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods: 私有仓库]]></title>
    <url>%2F2018%2F09%2F24%2FCocoapods-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[使用场景在我之前的博客中分享了几篇关于 Cocoapods 的文章（文末有链接），今天分享另外一个主题即如何创建你自己的私有仓库以及如何使用私有仓库。 为什么会有这种需求呢？ 开发组内或者公司内，不希望把一些核心的公用代码给到外界使用（不开源），但是这些代码基本很稳定很成熟，可以做成组件给到其他人或者组内使用。 那么，就可以使用 Cocoapods 来创建自己的私有仓库，让大家共享代码，也是组件化的一种方案。 下面的分享全是基于实践所得，中间也遇到很多坑，都被我一一解决了，希望能帮到正在阅读文章的你。 创建仓库这里的创建仓库，包括两个仓库，一个是代码仓库，另一个是 pod 源的仓库。 在 Github 创建 repository，如图： 创建名为 iOS_private_lib 的 repository，这个主要用来存放我们的代码。 同样道理，创建一个 Repo 用于存放私有的 SpecRepo 源，我创建的是 https://github.com/veryitman/private_spec_repo.git 这个仓库。 为了说明问题，这里我使用了 Public 来模拟 Private 仓库。在实际开发中，一般都是使用公司自己搭建的私有 git 服务器来做，我这里主要是为了说明问题。 创建代码工程1. 先 clone 刚才创建的 repo 到本地 123cd ~/workspace/git clone https://github.com/veryitman/iOS_private_lib 2. 创建工程 在 ~/workspace/iOS_private_lib 下使用 pod lib create 创建工程，工程名字为 CoreHTTP，执行命令如下： 123cd ~/workspace/iOS_private_libpod lib create CoreHTTP 根据提示输入对应的信息即可完成创建，如图： 创建成功后，包含一个 Example 例子工程，工程目录如下： 使用 Xcode 打开例子工程，在 CoreHTTP/Classes 中创建文件即可，如下图所示： 3. 编辑 podspec 文件 12345678910111213141516171819Pod::Spec.new do |s| s.name = &apos;CoreHTTP&apos; s.version = &apos;0.1.0&apos; s.summary = &apos;CoreHTTP for create private pod, it is a demo only.&apos; s.description = &lt;&lt;-DESC The project of CoreHTTP is a private pod, it is a demo only. DESC s.homepage = &apos;https://github.com/veryitman/iOS_private_lib.git&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;veryitman@126.com&apos; =&gt; &apos;veryitman@126.com&apos; &#125; s.platform = :ios, &quot;7.0&quot; s.source = &#123; :git =&gt; &apos;https://github.com/veryitman/iOS_private_lib.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;CoreHTTP/Classes/**/*&apos; s.requires_arc = trueend 这里需要注意，如果 s.source_files 写的不对，会报下面的错误。 1- ERROR | [iOS] file patterns: The `source_files` pattern did not match any file. CoreHTTP 的名字必须是你代码存放的文件夹名，而且这个文件件要与 podspec 文件在同一级文件目录下，从上面截图的目录结构可以看出。 另外一个提示的错误点，可能是因为空目录的问题造成的，如果这样的话，可以在各个文件夹下面创建 .gitkeep 文件，该文件的作用是为了提交空文件夹，因为 git 默认是不会添加空文件夹到仓库的。 创建 .gitkeep 文件的命令如下： 123cd 文件夹下touch .gitkeep 这里我折腾了蛮久，最后思考和参考了自己之前的开源项目管理博客，才解决这个问题。 4. 检查和验证本地 podspec 文件 123cd CoreHTTP pod lib lint CoreHTTP.podspec 验证通过会显示如下图所示的成功提示 使用 Xcode 打开工程，删除对应以 Test开头 的相关的库和文件夹，确保 Xcode 能编译通过，选择模拟器即可。 这里一定要先清空 cocoapods 的缓存，否则后面远程验证还是报错，无法通过验证。 清空 cocoapods 的缓存，命令如下： 123rm ~/Library/Caches/CocoaPods/Pods/External/CoreHTTPrm ~/Library/Caches/CocoaPods/Pods/Specs/External/CoreHTTP 5. 上传工程到 Github 远程代码仓库 1234567cd ~/workspace/iOS_private_libgit add CoreHTTP/git commit -m "Add lib."git push 6. 给版本添加 tag 12345cd ~/workspace/iOS_private_libgit tag 0.1.0 -m "Add lib and example project."git push --tags 7. 进行远程验证 123cd ~/workspace/iOS_private_libpod spec lint CoreHTTP/CoreHTTP.podspec --verbose --use-libraries --allow-warnings 注意：--verbose 选项是为了看编译和验证信息，--use-libraries 是为了能支持 i386 架构，如果不加此参数，私有库无法通过验证，--allow-warnings 参数是允许有警告。 验证成功的示意图： 提交私有 podspec1. 向本地的 cocoapods 仓库添加私有 Spec Repo 123cd ~/workspace/iOS_private_libpod repo add PrivateSpec https://github.com/veryitman/private_spec_repo.git 这里一定要注意：对应的地址是 SpecRepo 仓库地址而不是代码仓库地址。 本地存放 spec 的私有仓库名称，我这里取名为 PrivateSpec，你也可以取其他名字，但是记住在下面的步骤中要保持一致。 1ls -alt ~/.cocoapods/repos/ 可以看到已经成功添加本地 repo 中，其他 master 是 cocoapods 官方公开的源，其他为私有源。如下图所示： 2. 向私有的 Spec Repo 中提交 podspec 下面的 PrivateSpec 是与上面的名称对应的。 123cd ~/workspace/iOS_private_libpod repo push PrivateSpec ./CoreHTTP/CoreHTTP.podspec --verbose --use-libraries --allow-warnings 这里要注意，添加私有库和之前博文 Cocoapods 管理开源项目 中提到的 pod trunk push 是不一样的操作。 使用私有库1. 搜索库 1pod search CoreHTTP 如果搜索不到，可以执行下面的两条命令: 123rm ~/Library/Caches/CocoaPods/search_index.jsonpod setup 然后继续搜索就可以了，搜索成功会显示如下内容： 123456CoreHTTP (0.1.0) CoreHTTP for create private pod, it is a demo only. pod &apos;CoreHTTP&apos;, &apos;~&gt; 0.1.0&apos; - Homepage: https://github.com/veryitman/iOS_private_lib.git - Source: https://github.com/veryitman/iOS_private_lib.git - Versions: 0.1.0 [PrivateSpec repo] 为了避免和其他私有库命名冲突，建议在自己的私有库前面加上公司或者其他标示，如 TepdCoreHTTP、FphCoreHTTP 等。 2. 在 Podfile 文件的顶部添加 source 12source &apos;https://github.com/veryitman/private_spec_repo.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos; 注意一个是我们私有 SpecRepo 地址（非私有代码库地址），另一个是官方公有源地址。 使用私有库的工程的 Podfile 写法示例如下： 12345678source &apos;https://github.com/veryitman/private_spec_repo.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;7.0&apos;target &apos;TestCoreHTTP&apos; do pod &apos;CoreHTTP&apos;, &apos;~&gt; 0.1.0&apos;end 在工程中可以直接使用私有库了，示例代码如下： 1234567891011121314151617#import &quot;ViewController.h&quot;#import &lt;CoreHTTPHeader.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *lib_desc = [CoreHTTPHeader libDesc]; NSLog(@&quot;The HTTP&apos;s library desc: %@&quot;, lib_desc);&#125;@end pod 命令12345678//将工程添加到本地 repo 中 pod repo add [本地私有仓库名] [远程仓库地址]//移除本地 repopod repo remove [本地私有仓库名]//查看本地 repopod repo 12345//只从本地验证你的pod能否通过验证pod lib lint *.podspec//从本地和远程验证你的pod能否通过验证pod spec lint *.podspec 参考文档Private Pods 我的其他文章Mac install Cocoapods Cocoapods 问题集锦 Cocoapods 管理开源项目 iOS 项目: 打造本地 pod 库 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>iOS cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈客户端模块化]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%B5%85%E8%B0%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[回忆大学那会喜欢跟着老师在实验室折腾，感觉每天大脑中都有新知识鱼贯而入。 当我被告知要做一个最小单片机系统的时候，兴奋而又紧张！ 最小单片机系统示意图： 从画 PCB 到制板、洗板，再到选择元器件，最后组装调试和写代码，我花费了两个多月的时间，当板子上面的跑马灯亮起来的那一刻，我激动的无法言语。 大家可以看到这个最小单片机系统上面有很多组件组成，有电阻、电容、电阻、二极管和卡槽等，当然还有最核心的组件就是单片机，当时用的是51单片机。 各个元器件就好比组件，功能单一，职责明显，组件之间遵循协议构成模块，最终组合成为（最小单片机）系统。 上面的回忆是为了引出今天的分享，分享的主要内容是客户端开发中常用的模块化、组件化、插件化以及热更新等技术辞藻，并没有涉及到具体的技术问题。 模块化和组件化从程序设计的角度出发，无论是模块化还是组件化，都是指软件架构的范畴，是一种设计思想。两者并没有严格意义上面的区分，二者的目的一致，就是将工程结构化，达到可复用可伸缩的能力，最终提供工作效率。 在说模块化和组件化之前，先解释一下什么是高内聚低耦合。 高内聚：组件内尽可能独立完成自己的功能，坚持单一职责的原则 SRP，不依赖于其他组件的代码。 低耦合：模块与模块之间尽量不要互相引用，模块之间联系越复杂耦合度越高，修改的成本就越高。 组件更加强调可替换可复用的特性，职责和功能比较单一、独立，与其他组件之间没有耦合性。 模块更加强调组合特性，更加偏重于业务，比如一个社区项目，登录注册、论坛和个人中心都是模块，这些业务模块又是有很多个组件组合而成。 下图展示的是一个简易的论坛系统示例图，如下： 可以看出，各个组件可以单独使用到其他模块当中，各个模块之间相对独立，只要定义好模块之间的通信协议，就可以做到并行开发，各个模块甚至可以复用到其他系统之中。 通信机制这里说的通信机制并不是指 HTTP 或 TCP 的通信方式，而是指组件与组件之间，模块和模块之间的交互方式。 正常情况下，写业务功能的代码，在不同组件之间需要相互调用，这样就需要 import 其他组件，无形之中就增加了组件之间的耦合度。 有开发经验的同学，可能会用到类似 java 的反射机制，或者一些动态语言的运行时机制如 Objective-C Runtime，对它们不进行 import，而是动态的解析代码，达到组件之间或者是类之间相互调用的目的。 现在提倡也是比较热门的技术是通过路由通信机制，来进行组件之间的通信。这里举一个实际使用场景。 用户安装了我们的 APP，运营同事在某个节日来临之际做一个促活跃的活动，期望用户点在打开推送通知的时候，打开 APP 后可以直接跳转到对应的活动详情页面。大致流程如下： 这是一个再常规不过的需求了，相信经历过产品开发的朋友都见过这种需求。 很显然，我们可以使用路由的通信机制来完成这个需求，开发的流程图大致如下： 这里关键的核心得益于 iOS 和 Android 平台的 scheme 机制，对于 scheme，通俗的讲就是一种可以跨进程或者进程内的通信协议，例如可以在 APP 中打开某个应用商店。 例如下面的 URL： 1bbs://page/activity/activity_detail?id=8978&amp;user_id=67890432 其中，bbs 就是 scheme，可以看到该 URL 完全可以被各自平台来解析。 iOS 和 Android 平台各有很多开源的路由方案，实现手法各有差异，但是思想是一样的，建议大家去了解和学习。 不过，现在你只要知道，路由的通信机制大大降低了组件之间的耦合性就够了。 插件化插件这个词，大家应该很熟悉，例如 Chrome 浏览器中可以安装各种小工具，这些小工具就是插件，还有各种开发使用的 IDE 也支持插件安装，便于提高我们的工作效率。Chrome 和 IDE 被称之为宿主，插件寄生于他们。 支付宝和微信里面的小程序也可以看成是一个个插件，但是他们不能脱离支付宝和微信独立运行。 可以发现这些插件即使被卸载或者被删除，并不会让 Chrome 或者 IDE 受到影响，换句话说，插件让宿主锦上添花。 这种插件思想当然可以运用到 APP 中来，试想一下，如果某个 APP 在线上经过动态下载就具有了一个强大或者好用的功能，岂不美哉？！ 插件化，将 APP 拆分成很多模块，这些模块包括一个宿主和多个插件，宿主提供插件的管理和通信协议及规范，每个模块都是一个的库或者功能包。 插件化是一种编程和解决问题的思想，没有统一的定义。在 Android 上面运用比较多，iOS 上面很少，并不是 iOS 没有这样的技术，主要是因为苹果审核等各方面的限制。在 iOS8 上的 App Extension 功能，也可以看做是插件化了。 在 Android 平台中，插件化已经不是很新鲜的技术了，VirtualAPK、Atlas、Replugin 等框架相继开源，插件化技术已经进入了比较成熟的阶段了。 插件化的编程思想和实现，在不同的平台有所差异，即使在同一个平台上面都会有不同的实现手段，建议选择一个开源方案去了解其原理，然后试着动手去实现一个，千里之行始于足下！ 热更新“不好了，昨天有很多用户反馈我们的 APP 出现闪退。“ 小王一大早的开始撕喊，坐在他旁边的开发大神们顿时微笑凝固，马上去后台看上报的崩溃日志，紧接着开始复现和解决问题，最终得出结论，需要重新提审 APP，并周知渠道部门做好更新准备。 试想一下，如果一个游戏几G的大小，你让用户为了你的一个小失误来整包更新游戏，用户和你估计都要疯了。 最近几年，随着业务发展的需求，热更新技术也是得到了突飞猛进的发展。类似于上面的场景，能在用户神不知鬼不觉的情况下使用热更新的技术解决崩溃的问题，岂不是两全其美。 Android 的热更新技术如火如荼的发展着，而苹果这边严厉禁止热更新，一旦检查到立即会责令你修改或者下架 APP。我们还是从技术的角度来看这个问题，学习和了解一下对应的技术总归没有错，这里 有 iOS 上面的热更新方案，另外 Android热修复方案比较 介绍了很多 Android 热更新的开源的方案，可以了解学习一下。 站在跨平台的角度，我个人比较推荐使用 Lua 实现热更新，Lua 不仅简单高效，而且可以很好的和 C/C++ 结合在一起，而 Android 上面通过 JNI 又能与 C/C++ 通信，iOS 上面就更加不用说了。这只是我个人的一点看法，不喜勿喷。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>架构 模块化 组件化 热更新 插件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 演进史]]></title>
    <url>%2F2018%2F09%2F16%2FHTTP-%E6%BC%94%E8%BF%9B%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[精通 HTTP 吗？在面试相关开发岗位的同学中，我经常会问一些跟编程语言不相关的东西，比如下面这些问题： 1. 你平时是怎么学习的？学习渠道有哪些？2. 项目组中，你认为最重要的是什么？3. 你在项目组中遇到的最大困难（非编程问题）是什么，你是怎么解决的？4. 项目执行过程中，其他同事遇到困难，你是如何做的？ 这些问题可以让面试者自由发挥的题目，并没有固定的标准的答案。这样的问题问出来有诸多好处，首先可以让面试者稳定一下心态不至于太紧张，其次可以看看他的语言组织能力和表达能力，从中也能看出他有没有过实际的项目经验。 很多人的简历上面写的很完美，做过诸多项目，精通某某语言的编程，精通各种网络协议，熟悉各大操作系统等等，当深入问他们熟悉的知识时，发现他们的回答却含糊不清。不排除世界上有这样的全才，但是肯定不会被我们轻易遇到，至少我觉得自己还没有达到那个能力。 如果你还没有但又想精通各种知识，就慢慢去学习并精通相关的知识，循序渐进，相信自己会做到的。好了，不扯了，今天聊聊 HTTP 的发展历史。 我敢保证有绝大部分的人不知道 HTTP/2，虽然他早就来临. HTTP 0.x 到 HTTP/2HTTP/1 是 HTTP 1.0 和 HTTP 1.1 的统称，分别指 HTTP 协议的版本是 1.0 和 1.1. 1960年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）, 这成为了 HTTP 超文本传输协议标准架构的发展根基，所以他被称之为 HTTP 之父。 1989年3月在 CERN（欧洲核子研究组织）工作的 Tim Berners-Lee（蒂姆.伯纳斯.李） 提交了一个提案 Information Management: A Proposal，该提案描绘了其对万维网（World Wide Web）最初的设想即能让远隔两地的人们共享知识，Tim 是 万维网之父，成就和贡献也是不计其数。 直到1990年 HTTP 才算是问世，姑且称之为 HTTP 0.x 版本，也有些地方称之为 HTTP 0.9 版本，总之这不是一个正式版。1996年5月，HTTP 1.0 作为 HTTP 的第一个正式版本正式公布，并记载于 RFC1945 中。 随着人们对互联网的认知和技术的发展（尤其是浏览器等相关的技术），发现 HTTP 1.0 缺点还是比较多，无法满足快速的互联网发展需求。于是在1997年1月发布了 HTTP 1.1 版本，并记载于 RFC2068 中，后来在1999年6月，对 RFC2068 又做了补充和修正，称之为 RFC2616, 至此 HTTP 1.1 开始一统天下，直到现在绝大数开发者使用的都是 HTTP 1.1 版本。 另外一个版本 HTTP/2 标准于2015年5月以 RFC 7540 正式发表，多数主流浏览器已经在2015年底支持了该协议，时隔多年，HTTP/2 才问世。 苹果从 iOS9 开始支持 HTTP2.0，对 iOS 开发人员来说从 iOS9 开始 NSURLSession 可以支持 HTTP2.0 了。目前 Android 绝大部分系统不支持 HTTP/2，Android 原生 HttpURLConnection 框架并不支持 HTTP/2，但可以选用三方开源库 okhttp 作为网络框架，Android 5.0+（系统版本）设备才支持 HTTP/2。所以想全面使用 HTTP/2 还是要付出一定的代价，不过随着技术的革新，相信 HTTP/2 将会大放光彩。 HTTP 不断的改进用一张图来描述 HTTP 的不断改进和演变史，如下图所示： 下面具体看看这些协议版本的演进过程中，究竟是新增和改进了哪些东西？ HTTP 0.9HTTP 0.9 并非出自某个标准化组织，只是 Tim 的个人作品而已，比较简单。可以参阅这篇文章 The Original HTTP as defined in 1991 ，该版本规定了 HTTP 使用 TCP/IP 连接，HTTP 请求只有一个请求行，只有一个 GET 方法加上请求的URI。HTTP 响应则直接返回 HTML 文本，没有状态码，所以也没有办法区分错误消息和正常的文本。可以看出，HTTP/0.9并不完善，也不是那么完美，但是这的确是 Tim 坚持下来的结晶。 HTTP 1.0HTTP 1.0 增加了请求头域和响应头域，增加了 HEAD 和 POST 方法，响应对象不再局限于 HTML 文本，支持长连接和缓存机制等等。 HTTP 1.0 具体特点 1.可以发送更多格式的内容，如图像、视频、二进制文件，不仅仅局限于文字了。 2.增加了 POST 和 HEAD 方法。 3.改变了 HTTP 请求和回应的格式。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据，即增加了请求头信息，响应数据不再局限于 HTML 文本。 4.新增状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等功能。 5.增加了长连接的支持，不过 HTTP 1.0 需要在 request 中增加 ”Connection： keep-alive“ header 才能够支持，后面要说到的 HTTP 1.1 默认就支持了。 可以看出，HTTP 1.0在 HTTP 0.9 的基础上做了大量的扩充和改进。 HTTP 1.0 主要缺点 1.每次请求都需要建立 TCP 连接，即每对 Request/Response 都使用一个新的连接。 2.不支持断点续传。 HTTP 1.1每个新版本的诞生基本都是对上一个版本的补充和改进，就像我们的软件开发一样，协议也需要迭代。 HTTP 1.1 具体特点 1.加强和优化了持久连接即长连接。 HTTP 1.1 支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP 1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP 1.0 每次请求都要创建连接的缺点。 2.增强了缓存机制。 引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头。 3.请求头引入了 range 头域。 它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 4.将 Content-length 字段的作用进行扩充，即声明本次回应的数据长度（一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的）。 5.采用分块传输编码。 对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用流模式（stream）取代缓存模式（buffer）。 6.新增了许多动词方法：PUT、PATCH、HEAD、OPTIONS、DELETE。另外，客户端请求的头信息新增了 Host 字段，用来指定服务器的域名。 7.新增了 24 个错误状态响应码。 HTTP 1.0 主要缺点 HTTP 1.1 虽然增加了很多功能，在一定程度上已经很强大了，但是他自身也是有缺点的，换句话说有优化的空间，主要问题如下： 1.队头堵塞（Head-of-line blocking），各个请求到达的服务器的速度是不同的，如果先发的请求先到达可能会发生阻塞，剩下所有的工作都会被阻塞在那次请求应答之后，这样就降低了带宽。 为了避免这个问题，有两种方法：一是减少请求数，二是同时多开持久连接。 2.臃肿的消息头部 3.不支持服务端推送，例如要求使用 HTTP 协议做一个服务端数据变动页面立即改变的组件就不好做，可用轮询的方式进行，这样就会对带宽影响较大。 SPDY在说到 HTTP/2 之前，必须要先说说 SPDY。SPDY 是由 Google 公司推出的，SPDY 的推出是为了解决 HTTP 1.1 中存在的一些问题的。 1.多路复用（multiplexing） 多路复用通过多个请求 stream 共享一个 TCP 连接的方式，解决了HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。 2.可以对请求设置优先级 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 3.对请求头的压缩 选择合适的压缩算法可以减小包的大小和数量，这样在一定程度上可以提高网络使用效率。 4.为了数据传输的安全性，强制使用基于 HTTPS 的加密协议传输。 5.支持服务端推送。 称之为 Server Push 功能，服务器在还没有收到客户端的请求，服务器就可以把各种资源推送给客户端。 比如，客户端只请求了 index.html，但是服务器把 index.html、x.css、x.jpg 等资源全部发送给客户端。这样的话，只需要一轮 HTTP 通信，客户端就得到了全部资源，提高了通信的性能，也提高了用户体验。 HTTP/2本质上来讲，HTTP/2 是建立在 SPDY 基础之上的，借鉴了很多 SPDY 的设计思想和策略。 HTTP 具有 SPDY 的优点，同时自己也有与 SPDY 的不同点，主要如下： 1.HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。这一点 HTTP/2 相对人性化一些。 2.HTTP/2 会对请求头和响应头做压缩以提升请求性能，HTTP/2 消息头的压缩算法不同于 SPDY。 HTTP/2 采用 HPACK，SPDY 采用的 DEFLATE 算法。 HTTP/2 支持所有的 HTTP 1.1 的核心特征，其提供了 HTTP 语义的传输优化，并且在各方面做到更高效。HTTP/2 的头信息是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为帧（frame），即头信息帧和数据帧。对 HTTP/2 感兴趣的可以看一下 HTTP2 协议初识 这篇文章。 推荐文章 ATS: HTTP/HTTPS 协议介绍 ATS: HTTPS 认证 没有人能照顾你一辈子，你自己必须慢慢强大起来~]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Wireshark udp http https spdy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark: 简单分析 TCP 三次挥手]]></title>
    <url>%2F2018%2F09%2F09%2FWireshark-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-TCP-%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[话说握手你要是开发人员，相信你一定听说过 TCP（Transmission Control Protocol 传输控制协议）或是 TCP 握手的说法。 所谓握手，通俗来讲就是通信双方协商在后续通信过程中需要使用的通信信息的过程。TCP 为了建立可靠的连接需要三次握手，后续给大家分享 TLS 为了实现加密、校验、身份认证同样需要握手的过程。 TCP 三次握手可以使用下图来表达： 本篇给大家分享如何使用 Wireshark 来跟踪 HTTP 包，查看 TCP 握手的过程。 在看下面内容之前，先简单看一下 TCP 协议报头。 下图是 TCP 报头的格式： 其中，Seq(Sequence Number) 是 32 位的序列号，Acknowledgment number 称之为确认序号，也是 32 位的，但是他不是标志位 ACK，这个要区别开，当 ACK 置 1 时 Acknowledgment number 才有效，指接收方期待的下一个报文段的序列号。 TCP 报头信息中有六个控制位(标志位)，分别是：SYN、ACK、PSH、FIN、RST 和 URG。 123456SYN: 表示建立连接FIN: 表示关闭连接ACK: 表示响应PSH: 表示有数据传输RST: 表示连接重置URG: 表示紧急数据 Seq 序列号有两个作用：第一，在 SYN 置 1 时，此为当前连接的初始序列号(Initial Sequence Number, ISN)该值是个随机值，数据的第一个字节序号为此 ISN+1。 第二，在 SYN 置 0 时，为当前连接报文段的累计数据包字节数。 TCP 协议设计比较复杂，其涉及的知识较多，这里大家整不明白也没有关系，并不影响你阅读下面的内容，如果对 TCP 协议本身感兴趣，可以去拜读【TCP/IP 详解，卷 1：协议】这本书。 网络模型每次说到网络层，就要拿出类似下面的网络模型图，OSI 将网络模型分为7层，TCP/IP 模型将网络模型分为 4 层，网络 4 层模型由 7 层模型简化合并而来，没有本质的区别，如图： HTTP 仅仅是个协议，属于应用层的面向对象的协议，从上图可以看出 HTTP 是在 TCP 基础之上的。 HTTP 协议一共有五大特点 1、支持客户/服务器模式2、简单快速3、灵活4、无连接5、无状态 这里强调一下 无连接 和 无状态 这两个特点。 无连接，指的是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。Keep-Alive 特性不在本篇讨论范围，暂时你可以将其忽略。 无状态，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，不会记录任何信息。 可以利用 HTTP 的这两个特点来分析 TCP 三次握手的过程。 三次握手过程三次过程如下面草图，如下所示： 我们用实际例子来看一下这个过程，以 GET 请求下面地址为例，使用 Wireshark 抓包。 1http://www.baidu.com/news/detailV3.html?id=1279391&amp;COMMON_ACCESS_TOKEN=(null)&amp;COMMON_ACCESS_TOKEN_SECRET=(null)&amp;_cT=IOS&amp;_cV=3.1.3&amp;_cA=PM 看返回结果，选中 HTTP/1.1 200 OK 右键, 在弹出框中选择 Follow/TCP Stream，如下图所示： 关闭弹出的弹窗，回到主界面，看到如下图所示的三次（红色 1、2、3处） TCP 握手过程： 第一次，请求客户端发送一个 [SYN] 包，序列号是 0（seq=0）。 第二次，服务器收到 [SYN] 包，然后会发送一个 [SYN, ACK] 包，序列号是 0，ACK 置 1（seq=0，ack=1）。 第三次，客户端请求服务器，客户端会发送一个 [ACK] 包，序列号是 1，Ack 置 1（seq=1，ack=1）来回复服务器。 这里注意一下，大写的 ACK 是一个 bit 位表示确认，小写的 ack 是一个确认序列号，表示数值。 简单的画一个草图，如下： 这个过程，简单描述为下面三个步骤： 双方在建立连接之前都处于 CLOSED 的状态。 1、发送方给接收方发送 SYN 信号，此时发送方处于 SYN_SENT 状态。2、接收方确认并回复给发送方 SYN/ACK 信号，此时接收方处于 SYN_RCVD 状态。3、发送方给接收方发送确认 ACK 信号，发送完毕后，发送方(客户端)进入 ESTABLISHED 状态，当接收端(服务端)接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 上面的步骤，建议感兴趣的朋友去实际操作一下。 为什么是三次握手回头再来想一想，TCP 的连接为什么需要三次握手呢，为什么不是一次，两次呢？一次不就挺好吗，三次是不是有点多此一举了？ TCP 协议不是一个人定出来的而是一群人拟定的，设计三次握手固然有它的意义，是经过精心设计且在性能和效率上面衡量过的。 在知乎 TCP 为什么是三次握手，而不是两次或四次？ 上面有不错的答案，虽然有些回答比较搞笑，但是很好理解，比如这位仁兄： 我们不妨换个思路来想这个问题，TCP 协议设计初衷是 让数据进行可靠，高效，安全的传输，如果握手是一次，两次或四次，就无法很好的保证 TCP 的 可靠，安全及高效 的传输，说不定哪天有人设计出来一种可替代 TCP 协议的其他协议就是两次握手或者不需要握手，哈哈！ 参考阅读如何理解HTTP协议的“无连接，无状态”特点? TCP 为什么是三次握手，而不是两次或四次？ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark：抓取 HTTP 包]]></title>
    <url>%2F2018%2F09%2F01%2FWireshark%EF%BC%9A%E6%8A%93%E5%8F%96-HTTP-%E5%8C%85%2F</url>
    <content type="text"><![CDATA[广告时间，见谅勿怪，看到了就点一下吧，感激不尽🙇‍！ 最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。 点 这里 可以直接看教程。 开篇简要初识 Wireshark 简单介绍了强大的 Wireshark 工具，想用好或者是说想发挥 Wireshark 的巨大威力，还有很长的路要走（对我来说）。学习 Wireshark 的成本要比其他网络抓包工具的成本高，所以请做好学习的准备。 我身边很多开发同事，甚至包括一些刚入职的测试工程师都不喜欢使用抓包工具，遇到问题凭着自己的感觉在那里侃侃而谈，既耽误时间又没有解决问题，有时候还伤了和气，明明可以使用工具可以解决的问题，偏偏要各抒己见。 说到 Wireshark 更是很少人使用，至少我身边的同事是这样。如果让你一直去看那些 RFC 等网络协议，不到半小时估计你就会感到疲惫，但是结合 Wireshark 来理解网络协议就会感到无比的快乐，何乐而不为呢？！ 继续阅读下去，你可以了解到如下几个知识： 1. 如何抓取 PC 端、iOS 设备的网络包？2. 使用一些过滤条件如何查看包的内容？3. 如何在 Wireshark 中显示域名？ PC 端的 HTTP 请求打开 Wireshark，选择对应的网口，因为我使用的是无线网络（WiFi），所以选择 Wi-Fi：en0 这个网口，你可以根据你的网络使用情况来选择对应的网口，如下图： 可以看到对应有网络数据的网口，Wireshark 还在右侧显示对应的波浪，很人性化的设计。双击对应的网口，就可以使用 Wireshark 来抓包看数据了。 下面我就以 PC 端访问 www.veryitman.com 来演示 HTTP 请求的抓包情况。 查看本机的 ip 地址，我的是 10.4.17.7, 再来看一下 www.veryitman.com 对应的 ip 地址： 1ping ww.veryitman.com 显示结果如下： 164 bytes from 185.199.110.153: icmp_seq=0 ttl=52 time=317.074 ms 那么， 185.199.110.153 就是其对应的 ip 地址。总的来说，对于 PC 端，源地址是 10.4.17.7，目的地址是 185.199.110.153，对于服务器来说，正好反过来。 首先在过滤器中输入 http, 如下图所示： 然后打开浏览器，我使用的是 Chrome，打开 http://www.veryitman.com/2018/08/20/%E5%88%9D%E8%AF%86-Wireshark/ 网站站点，Wireshark 显示如下（部分截图）： 改变一下过滤语句，将之前的 http 改为 ip.src==10.4.17.7 &amp;&amp; http &amp;&amp; ip.dst==185.199.109.153， 显示如下： 可以选择任何一个请求，展示区域如下： 上图中的三个区域分别对应的是 View 中的 Packet List， Packet Details，Packet Bytes 三个视图。 选择任何一个请求，在对应的 区域2 可以看到该请求的详情。 刚才使用的过滤条件只看到 PC（客户端）的请求，没有看到服务器返回信息，我们修改一下过滤条件为 ip.src==185.199.109.153 &amp;&amp; http &amp;&amp; ip.dst==10.4.17.7，这样就看以看到服务器的回包信息了，如下图所示： 双击进入该响应，就可以看到对应的响应数据详情了。 iOS 设备的 HTTP 请求跟查看 PC 端的 HTTP 请求方式基本一致，只是此时的本机 ip 地址是手机端的而不是 pc 端的。 初识 Wireshark 中已经跟大家分享过如何去连接 iOS 设备到 Wireshark 抓包了，这里不再赘述。 至于查看 iOS 设备的 ip 地址，就很简单了，打开 设置/wifi 看一下详情就知道了。 显示域名如果你经常使用 Charles 抓包，就可以发现 Charles 展示的请求中都是以域名来显示的，但是在 Wireshark 都是显示 ip 地址，或许因此感到不适，那么，Wireshark 能否展示域名呢？ Wireshark 是可以像 Charles 那样展示域名的，只是它默认显示 ip 地址罢了。 打开 Preferences，如图： 这样 Wireshark 的显示就是另一番景象了如下图所示： 当然，你也看出来了，过滤条件还是可以使用的。 你还可以使用其他的过滤条件，如下面的一些过滤条件，能帮你快速定位你要的数据。 12345http.host == &quot;veryitman.com&quot;http.host contains &quot;veryitman.com&quot;http contains &quot;HTTP/1.1 200 OK&quot; 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Wireshark http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卖废品的一次经历]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%8D%96%E5%BA%9F%E5%93%81%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[偶遇这两天在收拾屋子，本来想把一些不重要的物品直接卖掉，省得给自己增加运输成本。但是又有些不舍，毕竟跟自己在一起生活了这么多年，每一本书，每对桌椅，每件衣服都是我和老婆努力挣钱买回来的，里面都包含着奋斗的故事。 话又说回来，无舍无得。于是，我就开始将物品分类，按照优先级挑选，重要的东西就放到箱子中，次要的就放到沙发上，不重要的就扔到大厅里，最后再来审视一遍这些不重要的物品是否还有留下来的必要，最终我把不重要的东西放到一个大袋子中，准备把它们卖给废品站。 在百度上面找了好几家附近收废品的，打电话过去都要求卖家自己把东西拿过去，态度十分不友好，我也就没再多问，就挂掉了电话。 无独有偶，中午下楼去买东西回来的时候，正好看到一个大爷骑着三轮车在我前面驰骋，大爷的车技贼溜，在小巷子中开出了赛车的感觉。还没等我张嘴，他就即将要离开我的视线，急中生智，我看到他车子后面留有电话，于是我就急忙的努力的追赶着去记住他的电话，最后迫不及待的放下手中的东西，拿出手机拨打了他的电话。 大爷办事利落，不一会就到了楼下，三下五除二的把废品收拾了一番，像是收获了一批战利品一样。他很惊诧为什么我知道他的电话，我说我看到了你车上的电话号码了，就记下来了。 大爷说：“小伙子，你的记性还真好，不愧是上过大学的人。“，我说：“是呀，我过目不忘！哈哈！”。 那天中午，我把东西半卖半送的都给这位大爷了，谁叫他夸我呢！ 思量上面这件事算不上什么大事，顶多也就算个鸡毛蒜皮的小事，但是给了我很多回忆和思考。 很多高中生也包括他们的家长们，都经常会说等上了大学就好了，不用那么累了，在大学的殿堂里可以无忧无虑的 享受 了。在我看来这是不对的，高中之所以累是因为有连绵不绝的作业和没有尽头的考试，当然还有班主任喋喋不休的教导，让你的神经时长处于紧绷的状态。高中是人生中必经的一个过程，至少我觉得它锻炼了我的意志和耐力，包括对心理上的考验，我很感激高中三年的生活。 大学生活和学习的确是一个值得向往和想象的，你可以吊儿郎当的过完几年大学生活，也可以努力拼搏过来，没有人逼你去怎么做，完全取决于你自己。 我大学的成绩算是优异，每次看到奖学金名单上有自己的名字，同学们都会说你真厉害，居然考这么好的成绩。我会说，如果你再努力一下肯定比我考的更好，就像那个大爷说我好记性一样，其实并不是我过目不忘，而是自己努力的结果，因为我知道自己并不是天才。 很多人进入社会参加工作后，发现工作并不是想象中的那般一帆风顺，自己一起进公司的同事，明明能力和自己相当甚至还不如自己，为什么别人就升职加薪，马上就要走上人生巅峰了，自己却还是原地踏步或者举步维艰呢？总是想不明白这是为什么，那是因为你自己没有看到别人比你更加努力。 还有不少人会抱怨为什么别人能力没有我强，领导偏偏把一些重要的事情交给了他，开始怀疑对方是不是对领导施了什么魔法，而自己从来都没有想过怎么去向对方请教，或者思考自己是不是真的做好了本职工作。 这件小事给了我几个启发： 1. 一定要给自己树立一个长远目标和短期目标，不断的完成短期目标，向长远目标前进。 2. 对于别人的赞美或是诋毁，要保持一颗平常心，戒骄戒躁。 3. 不要总是夸你的孩子聪明，要夸他比别人更努力，因为努力比聪明更重要。 4. 不要总是抱怨命运的不公，多去审视自己的不足，想办法去补全。 5. 有个可以交心的朋友尤为重要，可以让彼此敞开心扉，无所顾忌的交谈。 这个世上没有免费的午餐，一切都要靠你自己去奋斗去争取，机会总是留给有准备的人，坚持自己的目标一直前行，相信自己，机会总有一天会和你不期而遇。 相信总有一天，你会感激正在努力的自己！ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 感悟 学习 阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Wireshark]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%88%9D%E8%AF%86-Wireshark%2F</url>
    <content type="text"><![CDATA[使用 Charles 介绍了在 MacOS 上面的使用 Charles 工具, 虽然 Charles 很不错, 但是其只能抓 HTTP/HTTPS 的包, 对 TCP、UDP 等其他协议的网络包, 爱莫能助。 今天给大家分享强大的网络抓包工具 Wireshark，算是初步认识一下这个工具，后续分享更多关于 Wireshark 的内容。 简介Wireshark 是免费的，支持 Windows、MacOS 和 Linux，提供丰富的 GUI 交互，能分析所有的网络协议，并且是开源的。 掌握好 Wireshark，能对绝大部分的网络协议进行分析了，所以学习它的使用对你的工作不无裨益。 关于 Wireshark 本身 UI（展示的界面内容） 的部分不在本文的讨论范围内，更多关于 Wireshark 的介绍和特性，可以去 Wireshark 官网 查阅。 安装我的 MacOS 版本: 点击 Wireshark 的 下载地址, 可以去下载对应的平台版本。 注意: 之前的 Mac 系统版本可能需要安装 x11, 现在新系统不需要安装了. 抓 iOS 设备的数据包想抓 iOS 设备的网络数据，需要让 iOS 设备数据通过 MacOS 才行，因为 Wireshark 是针对网口进行抓包的。 当然了，你的 iOS 设备不需要越狱. 通过 usb 连接 iOS 设备后，接下来创建远程虚拟接口，在终端执行下面命令： 1rvictl -s 设备id(udid) rvictl 即 Remote Virtual Interface Tool。它可以通过 iOS 设备的 UDID 创建一个虚拟网卡，然后通过这个虚拟网卡监听设备上所有的网络流量。 执行成功后，Mac 会出现一个对应的虚拟网络接口，名字是 rvi0（如果有多个 iOS 设备， 则累加，rvi1，rvi2…），如下图所示： 只要启动 Wireshark，监听 rvi0 接口就能抓到 iOS 设备的数据了。 关于获取 iOS 设备 ID(UDID)，可以使用 Xcode, 在 Window/Devices and Simulators 中选择相应设备，右面设备信息的 identifier 里就是对应的 UDID. 也可以通过 iTunes 或者第三方工具如 iTools 获取. 你可以安装 ideviceinstaller 来查看设备 ID. 1brew install ideviceinstaller 然后执行下面命令： 1idevice_id -l 以抓取下面的一个 HTTP 请求为例，简单说明一下相关的知识。 GET 请求： 1/news/detailV3.html?id=1279391&amp;COMMON_ACCESS_TOKEN=(null)&amp;COMMON_ACCESS_TOKEN_SECRET=(null)&amp;_cT=IOS&amp;_cV=3.1.3&amp;_cA=PM 看返回结果，选中 Rsponse(200 OK) 右键, Follow/HTTP Stream，如图所示： 在弹出的窗口中就可以看到具体的响应内容，以及响应的 json 数据。 过滤器过滤在 Wireshark 中显示过滤器会显示很多当前网络的数据包，如果你想看指定规则的数据包怎么办？ 别担心，Wireshark 给我们提供了过滤功能，按照一定的过滤规则就可以达到你的目的。 1. 网络协议过滤 比如 TCP，只显示 TCP 协议，HTTP 只显示 HTTP 协议等。在过滤器输入框中直接输入协议名称即可，不区分大小写。 2. IP 地址过滤 如 ip.src == 192.168.1.102 显示源地址为 192.168.1.102，而 ip.dst == 192.168.1.102, 目标地址为 192.168.1.102。 3. 端口过滤 tcp.port == 80, 端口为 80 的 tcp.srcport == 80, 只显示 TCP 协议的原端口为 80 的。 4. Http 模式过滤 http.request.method == “GET”，只显示 HTTP GET 方法的。 5. 结合逻辑运算符 AND/OR 组成复杂的表达式 AND/OR 也可以写成 &amp;&amp; / || 下面举几个常用的示例，如下： 1234567891011121314//源地址或者目标地址是192.168.1.103ip.src == 192.168.1.103 or ip.dst == 192.168.1.103//显示所有目标或源地址是192.168.1.1的数据包ip.addr == 192.168.1.1 //显示目标地址是192.168.1.1的数据包ip.dst == 192.168.1.1 //显示源地址是192.168.1.1的数据包ip.src == 192.168.1.1 //tcp 连接端口为9101的数据包tcp.port == 9101 更多的过滤规则可以去 官方手册 和 CaptureFilters 查阅和学习。 美中不足Wireshark 只能查看封包，而不能修改封包的内容，或者发送封包。 对于 HTTP、HTTPS 网络封包，Wireshark 都可以捕获， 但不能直接解密 HTTPS，所以想使用 Wireshark 来分析 HTTPS 包中的内容，需要去额外配置，较麻烦，后续研究再分享给大家。 所以建议大家，分析 HTTP/HTTPS 去使用各自平台上面的其他工具， 如 Fiddler 和 Charles 等优秀的抓包工具。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip udp http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置 php7 + Nginx]]></title>
    <url>%2F2018%2F08%2F19%2F%E9%85%8D%E7%BD%AE-php7-Nginx%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 PHP7之前为了配合完成一个项目（PHP 版本为5.6），在本机搭建了 PHP56 的环境，后面自己系统升级为 macOS High Sierra，发现系统自带的 PHP 版本已经是 7.1 了，于是就开始使用系统自带的 PHP 版本了。 1php -v 显示 PHP 版本信息，如下： 123PHP 7.1.16 (cli) (built: Apr 1 2018 13:14:42) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies 系统自带的 PHP7.1 没有默认的 php.ini 文件，执行下面命令查找一下： 1php -r &quot;echo php_ini_loaded_file();&quot; 此时并没有打印对应的配置文件信息。需要我们手动去复制一份： 1sudo cp /private/etc/php.ini.default /private/etc/php.ini 再次执行上面命令，即可看到配置文件的绝对路径了。或者执行 php --ini 123456php --iniConfiguration File (php.ini) Path: /etcLoaded Configuration File: /etc/php.iniScan for additional .ini files in: (none)Additional .ini files parsed: (none) 这里有个问题需要注意，php.ini 文件复制成功后，需要下面两步操作，否则在 php 代码发生致命错误的时候，页面不会输出任何内容，只是报 HTTP ERROR 500 的错误。 第一步，修改 php.ini 文件的权限，否则无法编辑保存，默认是只读属性。 1sudo chmod 777 /private/etc/php.ini 第二步，编辑 php.ini 文件，将 display_errors = Off 改为下面 on 即可。 1display_errors = On 记得每次修改完配置文件，需要重启 php-fpm 和 nginx 服务。 PHP561. 安装 PHP56 可以参考下面两篇文章。 PHP开发准备 安装 PHP 遇到的问题 2. 卸载（删除）PHP56 执行 brew uninstall 1brew uninstall php 即可完成卸载。 如果卸载遇到问题，就打开 /usr/local/Cellar/ 目录，删除对应的 PHP 目录即可。 配置 php-fpm现在新版本的 PHP 其内核已经集成了 php-fpm，我们不需要另外安装了。 配置 php-fpm 配置文件 1sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf 修改配置文件 1sudo vi /private/etc/php-fpm.conf 找到 error_log 项，添加下面两个配置项，如下： 12error_log = /usr/local/var/log/php-fpm.logpid = /usr/local/var/run/php-fpm.pid 如果不配置上面的配置项，启动 php-fpm 会报错： 123ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)ERROR: failed to post process the configurationERROR: FPM initialization failed 接下来, 继续配置，将 www.conf.default 复制一份命名为 www.conf 即可。 123cd /private/etc/php-fpm.d/sudo cp www.conf.default www.conf 不配置上面的，会报如下错误: 12ERROR: No pool defined. at least one pool section must be specified in config fileERROR: FPM initialization failed 至此，可以启动 php-fpm 了，执行下面命令： 1sudo php-fpm -D 不出意外的话，已经成功启动，可以使用下面命令查看端口使用情况 1netstat -an | grep 9000 如果你在启动 php-fpm 遇到下面的错误： 12ERROR: unable to bind listening socket for address &apos;127.0.0.1:9000&apos;: Address already in use (48)ERROR: FPM initialization failed 有两种方式解决这个问题 1.修改 php-fpm 使用的端口号 1sudo vim /private/etc/php-fpm.d/www.conf 将 listen = 127.0.0.1:9000 改为 listen = 127.0.0.1:9001 即可。 2.杀掉9000端口占用的进程 关闭所有之前启动的 php-fpm 1killall php-fpm 找到占用端口的进程号 1netstat -an | grep 9000 然后 kill -9 pid，重新启动 php-fpm 即可。 安装和配置 Nginx1brew install nginx 创建文件 12345mkdir -p /usr/local/var/log/nginxmkdir -p /usr/local/etc/nginx/sites-availablemkdir -p /usr/local/etc/nginx/sites-enabledmkdir -p /usr/local/etc/nginx/conf.dmkdir -p /usr/local/etc/nginx/ssl 1234567sudo mkdir -p /var/wwwsudo chown :staff /var/wwwsudo chmod 775 /var/wwwvi /var/www/info.phpvi /var/www/index.htmlvi /var/www/403.htmlvi /var/www/404.html 改变 nginx.conf 配置文件 该配置文件在 /usr/local/etc/nginx/nginx.conf 下面. 我的配置: 1234567891011121314151617181920212223242526272829303132333435363738worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log debug;pid /usr/local/var/run/nginx.pid; events &#123; worker_connections 256;&#125; http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*; include /usr/local/etc/nginx/conf.d/*; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php &#125; &#125;&#125; 注意: 1234location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php&#125; 配置了我的 web 目录和支持的文件. 运行 PHP 创建 index.php 启动 php-fpm 1sudo php-fpm 或者以守护进程的方式来启动 PHP-fpm 1sudo php-fpm -D 启动 Nginx 1sudo nginx 编辑 index.php 在 web 目录(我配置的) ~/projs/phpdev/nginx/nginx_sites/ 新建文件 index.php. index.php 里面可以编写代码: 12345678910&lt;!-- lang: php --&gt;&lt;!-- ~/nginx_sites/index.php --&gt;&lt;?php echo &quot;Hello PHP&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;学习 php&quot;; echo &quot;&lt;/br&gt;&quot;; echo phpinfo();?&gt; 打开浏览器, 输入地址：http://localhost:8080/index.php 你会看到下面的页面: 也可以在该目录下创建其他 PHP 文件, 如 m.php 文件. 浏览器中输入 http://localhost:8080/m.php 可以执行相对应的文件. 注意：这里的 m.php 是新建的 PHP 文件. 重要文件1. php 配置文件 1/private/etc/php.ini 2. nginx log 文件 12345/usr/local/var/log/nginx/access.log/usr/local/var/log/nginx/error.log/usr/local/etc/nginx/logs/error.log 3. nginx 配置文件 1/usr/local/etc/nginx/nginx.conf 4. php-fpm 配置文件 1/private/etc/php-fpm.d/www.conf 常见问题502 bad gateaway 我是经常看到这个问题，但是每次引起的原因又不太一样，绝大部分是因为 php-fpm 启动不了或者是其端口错误导致的。 这种情况下，建议去看 /usr/local/etc/nginx/logs/error.log 日志文件。 例如下面的错误： 1234567[error] 61016#0: *1 kevent() reported that connect() failed (61: Connection refused) while connecting to upstream, client: 127.0.0.1, server: localhost, request: &quot;GET /3.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost:8080&quot; 最终，我修改了 /private/etc/php-fpm.d/www.conf 中端口为 9000（我之前将该端口修改了其他的），重启 php-fpm 解决问题。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>PHP MySql nginx php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单配置 Apache]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE-Apache%2F</url>
    <content type="text"><![CDATA[声明有时候, 我们希望在自己本机(PC)搭建一个 WebServer, 然后自己可以在浏览器或者手机上面可以访问对应的地址直接查看效果, 再或者希望测试下载功能等, 其实 MacOS 自带的有 Apache 服务器. 下面简单分享一下, 在 MacOS 中如何简单的使用 Apache 服务器. 常用命令常用的命令有开启/重启/停止等. 1.开启: sudo apachectl start2.重启: sudo apachectl restart3.关闭: sudo apachectl stop4.查看版本号: httpd -v 1.查看 Apache 版本号 1httpd -v 或者使用下面的命令: 1sudo apachectl -v 查看结果如下: 12Server version: Apache/2.4.28 (Unix)Server built: Oct 9 2017 19:54:20 2.启动 Apache 1sudo apachectl start 在浏览器打开: http://localhost 会显示: 1It works 3.停止 Apache 1sudo apachectl stop 如果没有开启 Apache 服务, 执行上面命令的话, 会报下面的错误: 12/System/Library/LaunchDaemons/org.apache.httpd.plist: Could not find specified service 4.重新启动 Apache 1sudo apachectl restart 如果修改了 Apache 的配置文件, 需要重新启动 Apache 服务, 执行上面的命令即可. 配置 Sites在自己的用户目录, 新建一个 Sites 目录, 例如我的用户目录是 /Users/mark, 可以在终端分别执行: 123cd /Users/markmkdir Sites 执行成功后, 可以看到如下图所示的目录: 接下来修改 Apache 中的配置文件, 执行下面命令开始编辑 httpd.conf 文件. 1sudo vim /etc/apache2/httpd.conf 打开 httpd.conf 文件，查找 userdir 关键字. 找到如下两行被注释掉的内容: 123#Include /private/etc/apache2/extra/httpd-userdir.conf#LoadModule userdir_module libexec/apache2/mod_userdir.so 将其前面的 #(注释) 去掉, 紧接着编辑这个文件, 增加如下内容: 123&lt;Directory /Users/mark/Sites&gt; Require all granted&lt;/Directory&gt; 将上面的这些代码放到如下代码下面即可: 12345&lt;Directory &quot;/Library/WebServer/CGI-Executables&quot;&gt; AllowOverride None Options All Require all granted&lt;/Directory&gt; 保存该文件并退出 vim. 执行下面的命令修改 httpd-userdir.conf 文件: 1sudo vim /private/etc/apache2/extra/httpd-userdir.conf 增加如下内容: 12345UserDir Sites&lt;IfModule bonjour_module&gt; RegisterUserSite customized-users&lt;/IfModule&gt; 注意: 如果在 /private/etc/apache2/extra/ 目录下没有该文件, 新建一个即可. 保存文件并退出即可. 我们可以将自己需要运行的 html 等文件放到该目录, 如我将 index.html 放到该目录. 重新启动 Apache 服务, 在浏览器中输入 http://localhost/~mark/, 可以看到 index.html 里面的内容. WebServer 目录上面我们提到, 启动 Apache 服务之后, 在浏览器可以看到 It Works 的字样, 那么这个是哪个文件输出的呢? 这个文件是 sudo mvim index.html.en~orig, 在如下目录: 1/Library/WebServer/Documents 可以使用 vim 编辑该文件, 然后再刷新浏览器就可以看到其变化. 我们也可以把自己的 html 文件放到这里, 如 mark.html, 内容如下: 12345&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hi, mark, Apache server works!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器中输入 http://localhost/mark.html, 可以看到对应的输出. 如果嫌配置 Sites 目录麻烦, 可以使用这种方式, 直接拷贝对应的文件或者目录放到 /Library/WebServer/Documents 中, 只不过需要 root 权限罢了. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Apache WebServer MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop: 移除常驻线程]]></title>
    <url>%2F2018%2F07%2F01%2FRunLoop-%E7%A7%BB%E9%99%A4%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概要下面两篇文章: 常驻线程是一种什么体验 NSTimer 实现常驻线程的问题 都是在 iOS 平台上如何利用 RunLoop 的特性实现常驻线程. 可能你看到本篇文章的标题 移除常驻线程, 有点不理解甚至觉得作者是不是有点神经病, 都已经需要常驻线程了, 为什么还要去退出呢? 实际应用场景中的确几乎遇不到这种情况, 所以, 本篇只是从技术的角度给大家分享 RunLoop 其他的一些知识点. 且耐住性子往下看… 为了不让大家误解, 统一一下相关的词汇和语境. 输入源, 包括 source 和 timer. 退出 RunLoop 指的是在常驻线程的方法中立即返回. 这里的 RunLoop 指的是子线程中的 RunLoop 不是主线程中的. 结合之前介绍常驻线程的文章来看现在的文章, 不然不好理解. 运行 RunLoop 的方法这里有三种方式开启运行 RunLoop, 分别如下: 12345- (void)run;- (void)runUntilDate:(NSDate *)limitDate;- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate; run 方法 看一下 API 文档如何解释 run 方法的: 12345Puts the receiver into a permanent loop, during which time it processes data from all attached input sources.If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers. 大致意思讲的是, 在没有任何输入源的情况下, run 方法会立即执行后退出, 不会保持线程的持久性, 换句话说, 在有输入源的情况下, 该方法会进入一个无限循环当中. 本质上, 在 NSDefaultRunLoopMode 模式下, 该方法是反复调用 runMode:beforeDate: 方法的. 在之前文章实现常驻线程的代码中, 我们使用了 run 方法来开启运行 RunLoop. 可以看出, 我们之前实现的常驻线程使用 run 方法是无法退出常驻线程的. runUntilDate:(NSDate *)limitDate 方法 该方法 API 释义: 12Runs the loop until the specified date, during which time it processes data from all attached input sources. 保证有输入源的情况下该方法启动的 RunLoop 可以在指定的日期内一直运行不会返回. 换句话说, 日期只要已到该方法就会立即退出 RunLoop. 示例代码: 12345678//等同于 run, 可保证一直运行[runLoop runUntilDate:[NSDate distantFuture]];//立即返回, 退出 RunLoop[runLoop runUntilDate:[NSDate date]];//然后过12秒后返回[runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:12.0f]]; runMode:(NSString )mode beforeDate:(NSDate )limitDate 方法 该方法有两个参数 mode 和 limitDate, mode 就是 RunLoop 的运行模式, limitDate 就是上面方法一样的释义即在指定的日期内. 1Runs the loop once, blocking for input in the specified mode until a given date. 可以这么理解, 该方法开启的 RunLoop 处理完之后会立即返回(once), 如果在指定日期内事件还没处理, 在该日期后会立即返回.换句话说, 如果指定的日期是当前的, 该方法执行后 RunLoop 会立即退出. 示例代码: 12345//立即返回[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate date]]; //有事件到达处理后就返回，如果没有则过12秒返回[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:12.0]]; 这三个方法, 总结一下大概如下: 这三个方法在没有任何输入源情况下会都立即返回(退出 RunLoop), 不会等待. run 可保证 RunLoop 在有输入源的情况下一直运行. runUntilDate 可以通过设置超时时间来退出 RunLoop. 超时时间一过就会立即退出 RunLoop. 使用 runMode 方式启动的 RunLoop 会在处理完事件后或者超时后, 立即返回. 即可以通过设置超时时间或者使用 CFRunLoopStop 方法来退出 RunLoop. 移除常驻线程先看一下, 在子线程执行的方法中如何实现的. 示例代码如下: 12345678910111213141516171819202122232425262728293031323334- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; _threadRunLoop = runLoop; // 保持常驻线程的方式1: source NSPort *port = [NSMachPort port]; _threadPort = port; [runLoop addPort:port forMode:NSRunLoopCommonModes]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop // [runLoop run]; while (!self.stopLoopRunning &amp;&amp; [runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantPast]]) &#123; // 这里是为了验证常驻线程是否已经退出 NSLog(@&quot;--- asyncRun ----&quot;); // 实际业务中, 建议使用空语句实现 ; //实现为空语句 &#125; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 结合上面讲解的原理, 这里选择使用 runMode 方法来开启运行 RunLoop. 大家也可以自由发挥使用其他的方法. 注意: stopLoopRunning 是定义的一个属性. 移除的示例代码如下: 12345678910111213141516171819202122232425- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; // 取消线程 // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例 BOOL canCancel = YES; if (canCancel) &#123; [[self permanentThread] cancel]; &#125; /// 停止常驻线程 &#123; self.stopLoopRunning = YES; // 移除 port // 如果是用 timer 的方式的常驻线程, 可以 invalid 对应的 timer [self.threadRunLoop removePort:self.threadPort forMode:NSRunLoopCommonModes]; // 停止 RunLoop if (nil != self.threadRunLoop) &#123; CFRunLoopStop([self.threadRunLoop getCFRunLoop]); &#125; &#125;&#125; 离开页面后, 可以发现 NSLog(@&quot;--- asyncRun ----&quot;); 停止了打印, 并且当前的 Controller 也 dealloc 了. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop 常驻线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: dumpdecrypted 砸壳记]]></title>
    <url>%2F2018%2F06%2F07%2FiOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天是一个特别的日子, 高考的第一天, 祝各位莘莘学子金榜题名. 最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 iOS 逆向: 砸壳 介绍了如何使用工具 Clutch 对 iOS 的应用进行砸壳操作, 今天继续给大家分享使用另外一个工具 dumpdecrypted 对 APP 进行砸壳. 概要有些朋友就会问了, 既然 Clutch 已经很牛B了, 为什么还需要 dumpdecrypted 这个工具呢? 刚开始的时候, 我也很排斥使用 dumpdecrypted 这个工具的, 使用起来比较复杂, 并且套路不熟的情况下还很容易出错. 之前说过 Clutch 并不是万能的, 从 App Store 下载的 App(比如 WeChat)有些并不能使用 Clutch 来进行砸壳, 换句话说, 使用 Clutch 工具来进行砸壳会失败, 那么, dumpdecrypted 就登场了. 本次砸壳的系统依然是 iOS10.3.x, 工具使用 dumpdecrypted, 砸壳的对象是 WeChat 这个 App. 准备工作 MacOS PC 越狱手机一台(我用的是iPhone6SPlus 10.3.1) dumpdecrypted class-dump 在 Cydia 中安装 cycript, 可以先不用管 cycript 是什么, 下载安装即可. iFunBox 或者其他助手工具 编译 dumpdecrypted去 Github 下载 dumpdecrypted 源码, 源码就一个 C 源文件. 下载 zip 包之后, 解压, 如图: 在当前目录, 执行 make 即可完成编译, 如图所示: 编译成功后生成 dumpdecrypted.dylib 文件. 这里有个小插曲, 编译 dumpdecrypted 的时候报错了, 错误信息如下: 1234xcrun: error: SDK "iphoneos" cannot be locatedxcrun: error: unable to lookup item 'Path' in SDK 'iphoneos'clang: warning: no such sysroot directory: '-F/System/Library/Frameworks' [-Wmissing-sysroot]dumpdecrypted.c:27:10: fatal error: 'stdio.h' file not found 无法找到对应的 SDK 和 stdio.h 文件, 这种问题大多数是 Xcode 路径造成的. 使用下面的命令看一下系统指向的 Xcode 路径: 1xcode-select -p 控制台输出: 1/Library/Developer/CommandLineTools 显然不是 Xcode 的路径, 那只能重新切换一下其路径即指向正确的Xcode 路径即可. 命令如下: 1sudo xcode-select --switch /Applications/Xcode.app 再次编译 dumpdecrypted 即可成功完成. 对 dumpecrypted.dylib 签名 如果不对该文件进行签名, 后续砸壳的操作会失败. 先找到已经在电脑上面安装的苹果开发者证书, 操作如下: 12## 列出可签名证书, 找到 mac 上面已经安装的证书security find-identity -v -p codesigning 为 dumpecrypted.dylib 签名, 命令如下: 1codesign --force --verify --verbose --sign "iPhone Developer: xxx xxxx (xxxxxxxxxx)" dumpdecrypted.dylib 其中, &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; 为你自己本机安装的开发者证书名称. SSH 连接手机使用 OpenSSH 让 Mac 和手机连接起来 这样可以很方便的在 Mac 终端使用 shell 命令来操作手机的目录了. 关于 OpenSSH 的使用请参考我之前的博文 iOS 逆向: 越狱使用 SSH. 查找目标 App 所在进程 双击 Home 按键后, 手动杀掉 iPhone 上面所有在后台的 App. Home 到手机桌面. 打开目标 App 即WeChat, 这里称之为 TargetApp. Home 到手机桌面. 查看当前运行的所有进程, 命令如下: 1ps -e 看到这个货: 在如下目录: 1/var/containers/Bundle/Application/2837EC87-7C28-45C5-9309-24FACD3A97C9/WeChat.app/WeChat WeChat.app 就是我们要找的 TargetApp. 连接 SSH 成功后, 在 MacOS 终端 ls 一下该目录, 可以发现 WeChat.app 躺在那里. 砸壳1. 查找 Documents 目录 WeChat 为当前的进程目标执行文件名称, 从上面的图可以看出, 其对应的进程 id 是 18983. 在命令行中通过 cycript 执行如下操作: 1cycript -p 18983 再执行 OC 的方法, 如下: 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 可以看到对应的输出, 如下图所示, 这就是对应的 Documents 目录. 注意: 执行过程中, 在 iPhone 上面打开运行一下 App, 不然上面的执行一直卡在那里不动. 找到目录如下: 1/var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/ 同理, 你也可以使用 iFunBox 查看该目录. 2. 拷贝 dumpdecrypted.dylib. 拷贝 dumpdecrypted.dylib 这个之前编译签名好的文件到iPhone 上面该 APP 的 Documents 目录有两种方法. 第一种方法, 直接在 mac 上面拖拽 dumpdecrypted.dylib 到 iFunBox 显示的这个目录中, 这种方法比较简单且快. 第二种方法, 使用 scp 命令进行操作. 1scp ~/dumpdecrypted.dylib root@192.168.99.231:/var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/ 192.168.99.231 是 iPhone 设备的 ip 地址. 3. 退出 cycript, 回到命令行模式 1ctrl + d 4. cd 到 Documents 目录 1cd /var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/ 5. 砸壳 终端在 Documents 目录下面, 执行下面命令即可: 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/2837EC87-7C28-45C5-9309-24FACD3A97C9/WeChat.app/WeChat 执行过程显示如下: 最后生成了 WeChat.decrypted 文件, 如下: 12345678910111213-rw-r--r-- 1 root mobile 74513728 Jun 7 15:20 WeChat.decrypteddrwxr-xr-x 14 mobile mobile 448 Jun 7 15:20 .-rw-r--r-- 1 root mobile 207760 Jun 7 15:15 dumpdecrypted.dylib-rw-r--r-- 1 mobile mobile 8 Jun 7 13:22 db.globalconfig-rw-r--r-- 1 mobile mobile 15 Jun 7 11:35 SafeMode.datdrwxr-xr-x 26 mobile mobile 832 Jun 7 11:35 MMappedKVdrwxr-xr-x 3 mobile mobile 96 Jun 7 11:35 CrashReport-rw-r--r-- 1 mobile mobile 1011 Jun 7 11:35 LocalInfo.lstdrwxr-xr-x 5 mobile mobile 160 Jun 7 11:35 MemoryStatdrwxr-xr-x 6 mobile mobile 192 Jun 7 11:35 00000000000000000000000000000000drwxr-xr-x 15 mobile mobile 480 Jun 5 13:43 MMResourceMgr-rw-r--r-- 1 mobile mobile 592 Jun 5 13:43 heavy_user_id_mapping.datdrwxr-xr-x 2 mobile mobile 64 Jun 5 10:07 OpenImResource 使用 iFunBox 或者 scp 命令将 WeChat.decrypted 文件导出到 mac 的任意目录即可. 后续会跟大家分享如何使用砸壳后的文件, 敬请期待. 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 总有一天，你一定会感激正在努力的自己~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: 砸壳]]></title>
    <url>%2F2018%2F05%2F13%2FiOS-%E9%80%86%E5%90%91-%E7%A0%B8%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介所谓的砸壳, 指的是将从 App Store 上面下载的 App 进行破解的过程. 从 App Store 上下载的 ipa 中的二进制文件是经过加密(加壳)的，需要通过破解才能让我们对其 为所欲为, 这里的破解就是通常所说的砸壳. 类似的, Android 应用(apk 文件)也有加壳操作, 如果想破解别人的 apk, 首先要进行砸壳操作. 准备工具[1]. Clutch[2]. iFunBox 或者 pp 助手[3]. 越狱手机一台(本人iPhone6sPlus iOS10.3.x 系统).[4]. 可以正常使用 SSH 功能. 如果你还没有安装上面提到的除 Clutch 之外的工具, 请先阅读 iOS 逆向: 查看系统文件目录和结构 这篇文章, 并安装对应的工具. 安装 Clutch可以在 Github 获取 Clutch 源码, 然后自己在 MacOS 上面编译得到二进制文件. 也可以去直接下载已经编译好的 二进制包, 直接使用, 我是直接下载了已经编译好的二进制包的, 截止到写这篇文章为止, Clutch 版本为 2.0.4. 下载完成后, 我将其放到 ~/Downloads 目录下面了. 准备好越狱设备, 保证可以正常连接 wifi, 使用 scp 命令将 Clutch 二进制文件复制到设备的系统目录中, 命令如下: 1scp ~/Downloads/Clutch root@192.168.91.126:/usr/bin 其中, 192.168.91.126 是我设备连接 wifi 后的 IP 地址. 复制成功后, 使用 iFunBox 可以看到 Clutch 静静地躺在那里. 你可以使用 iFunBox 或者 pp 助手, 直接将 ~/Downloads/Clutch 拖拽到 /usr/bin 目录. Clutch 的基本使用SSH 连接越狱设备, 开始使用 Clutch. 关于使用 SSH, 可以阅读一下 iOS 逆向: 越狱使用 SSH 这篇文章. 如果你发现直接执行 Clutch 说没有权限之类的提示, 可以先将其授予可执行的权限. 1chmod +x /usr/bin/Clutch Clutch 命令选项如下: 123456-b --binary-dump Only dump binary files from specified bundleID-d --dump Dump specified bundleID into .ipa file-i --print-installed Print installed application--clean Clean /var/tmp/clutch directory--version Display version and exit-? --help Display this help and exit -b 选项表示产出一个二进制文件, -d 选项表示产出一个 ipa 文件, -i 表示列出手机上面已经安装的 APP. 我们先看一下手机上已经安装的 App, 命令如下: 1Clutch -i 这些 APP 前面的数字表示指定的 id. -d 和 -b 选项都需要指定这些 id. 砸吧, 骚年我们现在开始使用 Clutch 来对 APP 进行砸壳操作, 这里以已经安装的 App 序号为 8 的为例子. 使用下面的命令开始砸壳: 1Clutch -d 8 效果如下图所示: 砸壳成功后会在 /private/var/mobile/Documents/Dumped 这个目录生成对应的 *.ipa 文件. 砸壳后的 ipa 文件, 可以从 iFunBox 中复制到 MacOS 的目录中, 然后你就可以对该 ipa 进行下一步操作了, 比如获取图片/音频/视频等资源和对应的头文件. 关于这些后续的越狱工作, 我会在下几篇博客中分享给大家. 也许有人会说了, 我自己从 pp 助手 中备份指定的 App 就可以获取资源了, 不需要使用 Clutch 这么麻烦了. 高系统版本, pp 助手 是无法直接获取 ipa 文件的, 况且我们也不仅仅是想获取别人 APP 的资源文件. 当然了, 你可以从越狱 APP 市场直接下载已经被砸壳的 App 进行玩耍, 不需要自己千辛万苦的去砸壳了. Clutch 并不是万能的上面大家可以看出, Clutch 是可以进行砸壳的并且也挺方便, 但 Clutch 并不是万能的, 也就是说, Clutch 不能将任意一个 App Store 下载 APP 进行砸壳. 拿上面序号为4 的微信来说, 执行下面命令报错: 1Clutch -d 4 砸壳执行过程如下: 1234Writing new checksum...FAILED: &lt;WeChat bundleID: com.tencent.xin&gt;Finished dumping com.tencent.xin in 28.7 seconds 还有一些 APP, 再被砸壳的时候会报如下的错误: 1could not obtain mach port either the process is dead 虽然最新版本(2.0.4)说解决了该问题, 但是实际操作过程中, 还是会出现这个问题, 无法进行砸壳. 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 特别喜欢上善如水这句话，你呢？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: 查看系统文件目录和结构]]></title>
    <url>%2F2018%2F05%2F13%2FiOS-%E9%80%86%E5%90%91-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介在 iOS 逆向: 越狱使用 SSH 中给大家分享了如何使用工具对 iOS10.3 的系统进行越狱和配置使用 SSH 的内容, 今天继续探逆向的知识. 手机被越狱之后, 我们首先要搞清楚是否能够正常的访问手机里面的文件和目录结构, 这些文件和目录结构究竟是什么样的, 虽然这些知识很基础, 但是还是很有必要去了解和学习的, 就算是为后期逆向 APP 做点准备吧. 安装 iFunBoxiFunBox 是一个可以浏览 iPhone 文件目录的文件管理工具, 支持 MacOS 和 Windows 两个平台. 点击 下载地址 可以去下载 MacOS 版本的 iFunBox. 关于 iFunBox 的介绍和特性可以去 这里 查阅. 最新版本是 1.8, 如图: 手机插上 USB 连接上 Mac 电脑, iFunBox 就可以识别你的手机了, 如图所示: 这个时候, 你点击 Raw File System 其实是看不到 iPhone 的系统目录的, 接下来在 iPhone 中安装另外一个软件就可以了. 安装 Apple File Conduit 2在 Cydia 中搜索 Apple File Conduit, 如下图所示. 点击更改/安装即可. 如果你没有搜索到, 那么就需要自己添加对应的软件源地址. 点击【软件源】–编辑/添加 –输入源地址 apt.25pp.com – 添加源, 然后再去搜索 Apple File Conduit 安装. 安装好之后, 再用 iFunBox, 就可以正常查看 iPhone 的系统目录了, 如下图所示: 看到这些目录, 是不是跟 linux 或者 MacOS 的目录有很多相似的地方, 哈哈. 安装 pp 助手既然已经安装了 iFunBox 工具, 那为什么还需要安装 pp 助手 之类的工具呢? 其实, 这个看个人的需要吧, 在某种程度上, pp 助手 的界面和便捷性要比 iFunBox 好一点. 安装好 pp 助手 后, 点击 Tools/File Manager 显示的目录导航, 如图: 可以看出, 相比 iFunBox 的界面显示, pp 助手 工具显得更加友好一些. 至于使用哪个工具, 要看个人爱好和自己的工作需要, 毕竟工具都是为了提高我们学习和工作效率的, 没有什么绝对的好与坏, 自己觉得合适顺手就好了, 最主要的是能够帮到自己. 我一般是将两者结合使用的, 当然你如果你有更好的工具也可以推荐给我. 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 每一个关注，都会激励我继续前行]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: 越狱使用 SSH]]></title>
    <url>%2F2018%2F05%2F12%2FiOS-%E9%80%86%E5%90%91-%E8%B6%8A%E7%8B%B1%E4%BD%BF%E7%94%A8-SSH%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 越狱使用苹果设备或者做 iOS 开发的朋友们，几乎都应该听说过越狱这个词. 那么究竟什么是越狱呢? iOS越狱（英语：iOS Jailbreaking）是获取 iOS 设备的 Root 权限的技术手段。iOS 设备的 Root 权限一般是不开放的。由于获得了Root 权限，在越狱之前无法查看的 iOS 的文件系统也可查看. iOS 的越狱就类似 Android 获取 root 权限一样的道理，说简单点就是获取系统的 root 权限做一些更高级的事情。 手头上面之前闲置了一台 iPhone4s，闲来无事就把他越狱了，后面不知道怎么操作的，手机变成了白苹果(开机就白屏，无法进入系统)，最后没办法，只能升级系统，这台手机也算是废了. 当时使用的工具是 盘古越狱，越狱的 iOS 系统是 7.x. 现在 iOS 已经升级到 11.x 了，很多 APP 和游戏已经不再支持 iOS8 以下的系统了，系统的安全性也越来越好了，越狱破解的难度也随之提高了，目前市面上能越狱的最高版本应该是 10.3.x 的系统(截止到该篇文章写的时候). 为了能够分析和学习一些优秀 App 的设计，我索性买了台iPhone6sPlus 拿来越狱，所以接下来的分享都是基于这台手机的. 越狱工具和设备 [1]. 设备 iPhone6s Plus，系统 iOS10.3.2[2]. 越狱工具: 爱思助手和 doubleH3lix.ipa 安装并打开 pc 上面的 爱思助手 直接开始越狱，爱思助手会帮您在设备上安装 doubleH3lix. 运行 doubleH3lix 应用，点击 jailbreak 按钮，等待设备自行重启. 手机重启后，你会看到 Cydia 静静的呆在那里了，这种方式的越狱属于非完美越狱，换句话说就是没有真正的破解 iOS 系统. 如果发现手机断电关机或者重启后 Cydia 一打开就闪退，就使用 doubleH3lix 重新越狱就可以了，如果还是不行就需要重新使用 爱思助手 了。 参考越狱教程 64位设备iOS 10-10.3.3爱思助手一键越狱教程. 安装 iOS 终端安装终端，在 Cydia 中搜索 MTerminal，安装即可. 安装好终端工具后，打开终端，输入 1su 紧接着让你输入密码，默认的 root 用户密码是 alpine. 输入改密码回车即可。 为了安全起见，修改默认密码 alpine. 1passwd 连续输入相同的密码即为呢修改后的新密码。 配置 SSH配置和使用 SSH 功能是后续越狱工作的基础，这样就可以在 MacOS 的终端中访问 iOS 系统了，各种 shell 命令让你倍感亲切，所以大家尽量要完成该步骤. 试想一下，本来手机上面文字输入的体验就不好，还需要在 iPhone 设备上面的终端中敲着命令…没法忍! iOS 10 越狱以后自带了 SSH，所以不需要单独去 Cydia 下载和安装 OpenSSH. 很多人越狱后，发现也安装了 OpenSSH，但是一旦连接 iPhone 设备就无法连接甚至报错. 如果你已经安装了 OpenSSH 并且无法使用 SSH 来操作你的 iPhone 设备，请继续往下看. [1]. 打开 Cydia，分别搜索 OpenSSL 和 Openssh，然后分别卸载 OpenSSL 和 Openssh. [2]. 打开 Cydia，添加源：http://cydia.ichitaso.com/test 点击左上角的 添加，在弹框中输入对应的源地址即可. [3]. 在 Cydia 中搜索 dropbear 并安装. 安装即可. 安装成功后，一般就可以正常使用 SSH 功能了. 打开 MacOS 终端，开始使用 SSH 连接你的 iPhone 设备. [1]. 查看 iPhone 设备的(wifi) IP 地址. 如我的是 192.168.1.105.[2]. 使用 MacOS 终端，输入: 1ssh root@192.168.1.105 成功的话，它先会警告你是否继续操作，输入 yes 即可，然后又提示你输入 root 密码，密码就是前面说的修改后的密码. 如果你没有修改密码，那就是 alpine. 操作流程如下: 12345The authenticity of host '192.168.1.105 (192.168.1.105)' can't be established.ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.1.105' (ECDSA) to the list of known hosts.root@192.168.1.105's password: 之前在 iOS 10.2.x 越狱修改对应的配置文件，就可以使用 SSH 功能了，但是在 iOS10.3.x 无济于事，如果你是iOS 10.2.x 的越狱手机，可以参考本文末附录配置 SSH，也是我之前实践的结果. usbmuxd上面是通过 wifi 来连接 iPhone 设备的，其实还有一种方式，就是借助于 usbmuxd 这个工具通过 USB 连接(手机数据线连接电脑)不需要 wifi，USB连接比 wifi 响应速度快，且无网络环境的限制. 使用 usbmuxd 的前提是你的手机可以正常的使用 SSH 功能，否则 usbmuxd 也无法救你。 [1]. MacOS 安装 usbmuxd 1brew install usbmuxd [2]. 使用 usbmuxd 自带工具 iproxy. iproxy 可以快捷的操作连接 iPhone 等操作. MacOS 上只支持 4 位的端口号，需要把 iPhone 的默认端口 22 映射到 Mac 上面一个 4 位端口号的端口上面，相当于建立一个 Mac 和 iPhone 之间的通道. iproxy 具体使用，后面再讲. 大家先安装一下即可. 12iproxy 5678 22waiting for connection 以上命令就是把当前连接设备的 22 端口(SSH端口)映射到电脑的 5678 端口，那么想和设备 22 端口通信，直接和本地的 5678 端口通信就可以了。 终端提示 waiting for connection，表示这两个端口之间已经可以通信了，保留当前终端窗口(如果关闭就停止端口之间的通信了)，新建另一个终端输入，默认密码 root 密码。 1ssh -p 5678 root@127.0.0.1 执行过程如下，类似上面通过 WIFI 操作的方式。 12345The authenticity of host '[127.0.0.1]:5678 ([127.0.0.1]:5678)' can't be established.ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '[127.0.0.1]:5678' (ECDSA) to the list of known hosts.root@127.0.0.1's password: 接下来，你就可以在 MacOS 终端上面操作你的 iPhone 设备了，尽情的享受 shell 命令吧。不使用的时候，输入 exit 即可退出 SSH. 附录[1]. iOS 10.2.x 越狱使用 SSH 功能. 首先修改 root 密码。 iOS 10.2 (越狱后)自带 OpenSSH，不需要自己重新安装 OpenSSH，但是需要修改一个文件才能使用。 在手机上安装 MTERMINAL，运行 su，输入 root 密码，执行: 1ps aux|grep dropbear 如果你看到的进程没有 dropbear，执行: 1/usr/local/bin/dropbear -F -R -p 22 然后就可以连接了，重启依然有效。 如果你看到进程是这样的: 1/usr/local/bin/dropbear -F -R -p 127.0.0.1:22 意思是只能数据线重定向连接 SSH，如果你想改成 WIFI 可以访问，需要修改 /private/var/containers/Bundle/Application/D9185B6D-EA9E-4678-B59C-BF43DEFE67BF/yalu102.app/dropbear.plist把里面有个参数 127.0.0.1:22 改成22 保存，重启手机即可。 [2]. 使用 usbmuxd 无法使用 SSH 执行 ssh -p 5678 root@127.0.0.1 后报错，如下: 1ssh_exchange_identification: read: Connection reset by peer 这种情况一般是没有正确的使用数据线连接 Mac 电脑，使用数据线正常连接 Mac 电脑即可解决问题。 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 关注不是目的，交流、学习，一起进步才是关键]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop: NSTimer 实现常驻线程的问题]]></title>
    <url>%2F2018%2F05%2F06%2FRunLoop-NSTimer-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[可行性在 常驻线程是一种什么体验 这篇文章中给大家分享了如何利用 RunLoop 的特性, 结合 NSMachPort 实现一个 常驻线程 的主题内容. 今天我们探讨一下使用 NSTimer 如何实现 常驻线程 以及注意事项. 从 RunLoop 的特性来看, 只要有 Source 或者 Timer 都会使其能自循环使用, 不会立即终止当前线程的执行, 所以从理论上来看 NSTimer 是可以达到创建 常驻线程 的目的的. 开始实践完整的例子代码, 可以从文章的附录获取和查看, 这里只给出核心代码. 创建线程 123456789101112131415- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125; 线程执行的函数 12345678910111213141516171819202122- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 保持常驻线程: 使用 NSTimer [self _attachTimerToRunLoop]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 创建定时器 12345678910111213- (void)_attachTimerToRunLoop &#123; if (nil == self.timer) &#123; // scheduledTimerWithTimeInterval 这种方式 // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中 _timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; &#125;&#125; 可以看出, _attachTimerToRunLoop 中是将 timer 加入到当前的 RunLoop 当中了. 这里注意, repeats 值被设置为 YES 了. 跟之前一样, 可以使用点击事件来模拟和验证常驻线程的有效性. 1234567- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125; 每点击一次屏幕, 都会对应执行 runAnyTime 里面的内容. 对 repeat 的思考在上面的示例中, 我将 repeat 参数设置为 YES, 试想一下如果把 repeat 参数设置为 NO, 会不会造成常驻线程失效呢? 动手试试… 12345678910111213- (void)_attachTimerToRunLoop &#123; if (nil == self.timer) &#123; // scheduledTimerWithTimeInterval 这种方式 // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中 _timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO]; &#125;&#125; 再次点击屏幕若干次, 同样会执行对应函数里面的内容. 这就说明了即使将 repeat 参数设置为 NO, 也不会影响常驻线程. 那我们再来点具有挑战的活动… 将当前页面加入 UIScrollview 这个视图, 还是保持 repeat 参数设置为 NO. 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; self.navigationItem.title = @&quot;NSTimer 创建常驻线程&quot;; // 加入滚动视图 _scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.scrollView]; self.scrollView.contentSize = CGSizeMake(1000, 1000); self.scrollView.delegate = self; // 启动线程 [self permanentThread];&#125; 因为加入了滚动视图, 我们换一种方式来模式和验证常驻线程. 在 UIScrollview 代理中来模拟, 示例如下: 1234567- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125; 运行后进入该页面, 可以发现常驻线程被终止了. 12veryitman--timerRun.veryitman--asyncRun. End Run. 当除我以为更换一下模式即使 将 repeat 参数设置为 NO, 也不会出现常驻线程被终止的问题. 如下面的代码: 12_timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 这样更换模式为 NSRunLoopCommonModes 也不行. 在这种情况(有滚动视图的)下, 将 repeat 参数设置为 YES 就不会导致常驻线程被终止了, 无论哪种方式创建的 Timer. 总结1.子线程创建中的 RunLoop 的模式不会与主线程中 RunLoop 的模式冲突, 各自运行在各自的 mode 当中. 2.使用 NSTimer 来创建常驻线程, 在有 UIScrollview 或者其子类的情况下, 需要将 repeats 设置为 YES, 否则不会创建常驻线程. 没有滚动视图的情况下, repeats 设置为 NO 也没有关系. 3.创建 NSTimer 下面两种创建 Timer 的效果是一致的. 12345[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; scheduledTimerWithTimeInterval 默认会将 Timer 加入到当前的 RunLoop 中. 12[NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode]; 附录完整示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#import &quot;MZTimerPermanentThreadController.h&quot;@interface MZTimerPermanentThreadController () &lt;UIScrollViewDelegate&gt;@property (nonatomic, strong) NSTimer *timer;@property (nonatomic, strong) UIScrollView *scrollView;@end@implementation MZTimerPermanentThreadController- (void)dealloc &#123; NSLog(@&quot;veryitman---MZTimerPermanentThreadController dealloc.&quot;);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; self.navigationItem.title = @&quot;NSTimer 创建常驻线程&quot;; // 加入滚动视图 _scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.scrollView]; self.scrollView.contentSize = CGSizeMake(1000, 1000); self.scrollView.delegate = self; // 启动线程 [self permanentThread];&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; // 取消线程 // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例 BOOL canCancel = YES; if (canCancel) &#123; [self.timer invalidate]; _timer = nil; [[self permanentThread] cancel]; &#125;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125;- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 保持常驻线程: 使用 NSTimer [self _attachTimerToRunLoop]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125;- (void)runAnyTime &#123; NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);&#125;- (void)_attachTimerToRunLoop &#123; if (nil == self.timer) &#123; // scheduledTimerWithTimeInterval 这种方式 // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中 _timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; #if 0 _timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];#endif &#125;&#125;- (void)runTimer &#123; NSLog(@&quot;--veryitman--timerRun.&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop 常驻线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常驻线程是一种什么体验]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[简说 RunLoop关于 iOS RunLoop 网上很多文章都有介绍过, 很多技术面试官也会问关于 RunLoop 的相关知识. 我把自己工作中遇到的问题和总结的经验分享出来(会做成一系列的文章), 也算是对自己的一个总结和沉淀, 欢迎大家交流. 网上的文章基本都是针对于 Apple Developer Doc - Run Loops 这篇来展开的, 所以建议大家认真的去通读这篇文章, 并写代码验证, 实践. 可以简单粗暴的这么理解一下 RunLoop, 基于事件驱动的死循环(由内核来调度和管理的), 在需要处理事情的时候就出来干点事, 否则休眠待命.RunLoop 的核心是基于 machport 的，其进入休眠时调用的函数是 mach_msg(). 类似下面的代码来说明一下: 12345678BOOL stopRunning = NO;do &#123; // 处理 App 中各种操作各种事件 // 点击屏幕, 触摸到硬件也会唤醒 RunLoop &#125; while(!stopRunning); 说到这里, 随便提及一下, 学习过 Android 开发的同事应该和好理解 RunLoop 了, iOS 的 RunLoop 跟 Android 的 Looper 机制几乎一样, 只是不同的系统之间实现有差异罢了! 有兴趣的朋友可以看一下我之前写的文章 Handler: 更新UI的方法. 今天跟大家分享如何在 iOS 中结合 RunLoop 和 machport 实现常驻线程, 先跟着实例走, 后续再去总结 RunLoop 的各种细节点. 神奇的 main开发过 iOS 应用中的朋友, 对 main.m 再也熟悉不过了, main 函数正是应用的入口函数. 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 我们将 return 代码分开写, 看看有什么蛛丝马迹可寻. 1234567891011int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int ret = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@&quot;veryitman--- UIApplicationMain end.&quot;); return ret; &#125;&#125; 无论如何你也看不到日志 veryitman--- UIApplicationMain end. 的打印, 这说明 UIApplicationMain 一直在呵护着 APP 的运行, 哈哈. 我们不妨再改一次, 如下: 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return 0; &#125;&#125; 再去运行 APP, 你会发现根本没有让 APP 运行起来, 再次说明没有了 UIApplicationMain 的呵护, APP 无法起死回生. 猜测在 UIApplicationMain 函数中，开启了和主线程相关的 RunLoop，使 UIApplicationMain 不会返回一直在运行中，从而保证了程序的持续运行, 最大的功臣就是 RunLoop. 普通线程一般我们开启的线程在执行完任务后, 就会结束该线程. 除非你写了类似下面的代码: 123while(1) &#123; // 业务处理&#125; 或者 123while (条件满足) &#123; // 业务处理&#125; 开启一个线程 123456789101112131415- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125; 执行对应的 asyncRun 函数, 如下: 123456789101112- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); // 执行其他逻辑 //... NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 可以发现 asyncRun 很快就可以执行完成 (End Run). 12veryitman--asyncRun. Current Thread: &lt;NSThread: 0x60000066c400&gt;&#123;number = 3, name = veryitman-thread&#125;veryitman--asyncRun. End Run. 子线程开启 RunLoop主线程是默认开启 RunLoop 的即 mainRunLoop 是系统默认开启的, 但是子线程中的 RunLoop 需要我们自己手动开启. 关于为什么子线程中需要手动开启, 后续文章结合源码给大家分析, 这里暂时可以理解为获取 RunLoop 对象是一种懒加载模式. 只不过主线程中, 系统帮我们开启了, 然而子线程中需要我们手动开启而已. 类似这样: 12345678910111213141516171819- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 在控制台可以看到输出: RunLoop 没有任何输入源(input source) 和定时器(timer), 这时即使开启了 RunLoop 也不会让其等待执行, 换句话说会立即结束当前的 RunLoop. 既然这样我们给子线程的 RunLoop 添加源或者定时器即可. 这里以添加 NSPort 为例. 1234567891011121314151617181920212223- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 添加 source NSPort *port = [NSMachPort port]; [runLoop addPort:port forMode:NSRunLoopCommonModes]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 再次运行, 你会发现 End Run 这个 Log 是不会打印出来的. 对应当前的 RunLoop 也有了源和定时器, 如图所示: 关于定时器和 RunLoop 的结合, 下篇再分享. 现在有这样一个需求, 需要在指定的线程中执行某项任务, 显然使用上面的方法来满足需求, 下面进入今天的正题. 验证常驻线程一定到 常驻 这个词, 就知道是能够让该线程随时待命, 保证其不挂掉. iOS 中默认就有个主线程即 main 线程, 我们的 UI 线程指的就是主线程, 一般都是在主线程中操作 UI, 从某个角度来说, 主线程就是一个常驻线程. 我们开启其他线程, 目的是为了异步完成一些任务, 这些任务一般都比较耗时, 如果放在主线程当中完成这些任务就会导致主线程的卡顿, 用户体验极其差. 说了这么多, 也许你会问, 为什么要常驻线程呢? 频繁的创建和销毁线程，会造成资源(主要是内存)的浪费, 我们为什么不让频繁使用的子线程常驻在内存中, 想用的时候就用, 不用的时候让他休眠呢?! 上面已经使用 RunLoop 来实现了让线程长时间存活而不被销毁了. 用 touchesBegan 来模拟在指定线程中再次执行任务(runAnyTime)的方法. 1234567891011- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (void)runAnyTime &#123; NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);&#125; 对应上面的 asyncRun 实现即可, 你会发现在当前页面每次点击屏幕都会执行 runAnyTime. 附录代码的完整实现 常驻线程, 可以参考具体的注释. MZCreatePermanentThreadController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@implementation MZCreatePermanentThreadController- (void)dealloc &#123; NSLog(@&quot;veryitman---MZCreatePermanentThreadController dealloc.&quot;);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; self.navigationItem.title = @&quot;创建常驻线程&quot;; // 启动线程 [self permanentThread];&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; // 取消线程 // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例 BOOL canCancel = YES; if (canCancel) &#123; [[self permanentThread] cancel]; &#125;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125;- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 添加 source NSPort *port = [NSMachPort port]; [runLoop addPort:port forMode:NSRunLoopCommonModes]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125;- (void)runAnyTime &#123; NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);&#125; 参考文档Toll-Free Bridging Run Loops]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop 常驻线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发人员需具备一点产品能力]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%8F%91%E4%BA%BA%E5%91%98%E9%9C%80%E5%85%B7%E5%A4%87%E4%B8%80%E7%82%B9%E4%BA%A7%E5%93%81%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[为了开始今天的话题, 我先来借助几个角色, 模拟一下工作中的某些场景. 设立人物小 A 是名刚入门的技术人员, 比较听话.小 B 是有工作经验的一名技术人员, 平时喜欢看看产品相关的书籍, 喜欢和产品经理撕逼.小 C 就厉害了, 不仅技术厉害, 也具有产品思维, 除了阅读产品类的书籍, 还写产品体验报告和体验竞品(和当前自己产品相关的产品).小 D 就是一名产品经理, 具有一定的产品能力, 数据分析能力和管理能力. 人物已经设立好了, 现在让他们登场. 情景再现: 需求评审这天风和日丽, 小 D(产品经理) 通知项目组的所有成员, 包括设计/开发/运营/测试等人员按时参加产品需求评审会议. 为了缓解大家的情绪, 小 D 买了很多零食和水果, 也算是犒劳一下大家. 小 D 开始给大家讲需求了, 像往常一样, 拿出精湛的原型, 口沫直飞的向大家展示其绵绵不绝的口才和产品思维. 小 A 一直在点头, 也不知道到底有没有听懂小 D 在说什么, 反正我看到有部分设计人员已经开始打瞌睡了. 突然, 小 C 中断了正在口述的小 D, 小 D 不慌不忙的停止了手中的一切动作, 聚精会神的听小 C 的意见和建议. 小 C 也有条不紊的将刚才的某项需求口述了一遍, 按照小 C 的逻辑, 目前的需求还是存在一些漏洞的, 这个时候, 小 D 开始认真的跟小 C 开始交流, 但是没有马上肯定小 C, 只是说我暂时记下这个点, 回头在思考一番. 产品小 D 稳如老狗, 继续自己的表演. 产品需求基本已经讲完了, 现在是大家提问题和交流的时间, 我看到有些同事揉了揉眼睛, 像是如梦初醒般的看着产品小 D, 不是旁边的同事拉住 Ta, 估计都能冲出会议室. 小 B 也不淡定了, 提出了不少问题, 并从技术的角度说明了实现的难度. 产品经理听的也是一脸懵逼, 心理想: “你实现是否有困难管我鸟事?”. 小 B 在产品小 D 那里并没有得到应有的表扬和鼓励, 反遭到同事小 C 的鄙视, 小 C 说, 你先不要告诉他实现方案, 先讨论这个需求的场景和真伪度. 小 D 默默的对小 C 投过赞赏的目光. 紧接着测试和其他人员提出了几个不痛不痒的问题, 都被老练的小 D 一一破解, 那气势, 啧啧! 势如破竹! 需求评审会议就这样结束了. 情景再现: 需求变更在产品进入开发和设计阶段, 按理说需求变更也算是比较正常的一件事情. 这年头, 唯一不变的就是变化. 小 B 正在聚精会神的写代码, 突然小 D 跟他说, 这个地方的需求需要修改一下, 你看改动有多大? 小 B 鄙视的看着产品经理小 D, 心理在说改动有多大你心里还没有点 B数嘛. 小 B 还是控制了自己的情绪, 接着说道, 你当初应该好好思考的, 你看我都快做完了, 你才告诉我需要改动. 噼里啪啦的说完, 估计小 B 心理也暗爽了不少, 最终还是接受了这次的变动. 小 A 负责的模块, 也被产品经理修改过, Ta 和产品经理小 D 的交流基本是, 哦, 恩, 好, 可以! 当小 C 找到小 D 的时候, 并没有直接告诉小 D 需要改东改西, 而是问问小 D, 你看这样会不会更好一些? 小 C 当然明白小 D 的目的了, 于是拿出自己看过的竞品, 并说出了自己的意见, 愉快的和小 D 交流后, 居然 TMD 的砍了一个需求. 这让旁边的小 A 和小 B 羡慕不已. 总结上面的两种情景, 我相信做过开发的同事应该都深有体会, 但是千万不要对号入座, 我只是打个比方. 从上面看出, 小 C 是一个很不错的角色, 无论是思维还是沟通能力都有别与他人, 最重要的是他没有仅仅把自己当做一名开发人员, 而是站在产品的角度去思考问题和解决问题. 需求变更是常态, 作为开发人员, 要最大限度的给产品以支持. 产品经理也是人, 当然有考虑不周的地方, 如果你不能想出更好更完美的解决方案, 请支持他的决定. 多站在别人的角度去思考问题, 换位思考, 才能保证有效的沟通. 作为一名技术人员, 尤其是在互联网行业, 多多少少都应该需要具备一定的产品思维.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>技术 生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不让 SIGPIPE signal 太嚣张]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%B8%8D%E8%AE%A9-SIGPIPE-signal-%E5%A4%AA%E5%9A%A3%E5%BC%A0%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 起因由于项目迭代比较快, 大家还没有来得及做自我调整和总结, 就需要投入到新版本当中开发新功能了. 在最近的一次版本测试和体验过程中, 很多内测用户反馈进入或者退出 App 的聊天室, 会莫名其妙的崩溃掉(Crash).对于 Crash 的问题, 我们开发同事绝对是零容忍, 于是就开始跟踪问题. 跟踪了很久, 发现这个 Crash 并不是那么的 ‘乖巧’, 很难复现!既然用户已经反馈了并且后台也有 Crash 上报, 这个问题肯定存在, 所以我们不能放弃. 好吧, 继续加班搞…苦逼中… 最终, 我们发现一个规律, 在日志后台, 看到很多类似下面的日志: 1Signal 13 was raised. SIGPIPE (_mh_execute_header + 420728) 很遗憾的是, 堆栈信息中没有提供给我们更有力的证据, 所以当时定位在 Signal 13 这个点上面. 也算是有了突破…这班没有白加… 排查问题既然所有的罪证都指向了 Signal 13, 我们就需要去跟踪它, 去调查它, 去研究它. 在 signal.h 文件中, 可以发现其定义如下: 12/* write on a pipe with no one to read it */#define SIGPIPE 13 用通俗的话来讲, 就是管道破裂. 管道破裂，这个信号通常在进程间通信产生，比如采用 FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到 SIGPIPE 信号.此外用 Socket 通信的两个进程，写进程在写 Socket 的时候，读进程已经终止.另外, 在 send/write 时会引起管道破裂，关闭 Socket, 管道时也会出现管道破裂.使用 Socket 一般都会收到这个 SIGPIPE 信号. 也就是说, 该信号是跟 Socket 的连接以及数据的读写相关联的. 这样的话，我们就知道为什么进退房间导致 Crash 了，我们的进退房间都和 Socket 有关联，这种 Crash 大都数是在用户网络不好的情况下发生的. 解决问题类似 signal 13 这种错误是系统发出来的, 和内存使用异常和野指针一样，由于是系统级别崩溃，所以不能通过 123456@try &#123;&#125;@catch(NSException *exception) &#123;&#125; 捕获到这类异常. 因此, try catch 是无法解决问题的. 目前有两个方案可用: 方案1. 忽略这类信号. 方案2. 修改源码, 在 IM 代码里面修改. 因为, IMSDK 我们是使用第三方的, 所以无法更改其源码, 所以采取了方案1: 忽略这类信号. 忽略的方案很简单, 在你连接或者初始化 IMSDK 之前, 只需要一行代码: 1signal(SIGPIPE, SIG_IGN); 示例代码: 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // ... signal(SIGPIPE, SIG_IGN); // ...&#125; 对于 方案2, 我查阅了一下 CocoaAsyncSocket 的源码: 1234// Prevent SIGPIPE signals int nosigpipe = 1;setsockopt(socketFD, SOL_SOCKET, SO_NOSIGPIPE, &amp;nosigpipe, sizeof(nosigpipe)); 所以对于 方案2, 就是增加上面的代码即可, 即设置 Socket 不发送 SIGPIPE 信号. 对于上面的两种方案, 苹果开发者文档 Avoiding Common Networking Mistakes 都有提及. 问题复现既然这个问题很难复现, 我们就想办法让他很容易复现. 可以采用手动发送 signal 的方式, 来复现这个问题. 先看一下 kill(3) - Linux man page 函数: The kill() function shall send a signal to a process or a group of processes specified by pid. The signal to be sent is specified by sig and is either one from the list given in or 0. If sig is 0 (the null signal), error checking is performed but no signal is actually sent. The null signal can be used to check the validity of pid. kill 函数是可移植操作系统接口 POSIX(Portable Operating System Interface of UNIX) 定义的, 可以参考 维基百科. 示例代码: 12345678910111213141516171819202122- (void)viewDidLoad&#123; [super viewDidLoad]; //获取进程 id pid_t cur_pid = getpid(); printf("current process's id: %i\n", cur_pid); //延时10s 为了让 Bugtags 有时间上报日志. dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; wpcSendSignal(cur_pid); &#125;);&#125;///手动发送信号int wpcSendSignal(int pid)&#123; int ret = kill(pid, SIGPIPE); return ret;&#125; 我们将 signal(SIGPIPE, SIG_IGN) 代码先注释. 运行 APP 到手机, 然后退出 Xcode 的连接. 注意: 这里如果连接 Xcode, 不会直接 Crash, 所以需要断开手机与 Xcode 的连接. 在后台可以看到类似的 Crash 日志: 除了上面使用 kill 函数外, 我们还可以使用 raise 函数来发送 signal. 关于 raise 函数, 可以查阅 手册. 或者直接问男人(man): 1man raise 问题再次来临: 与 Bugtags 的结合本以为采用上述方案就万事大吉了, 在第二次提测后, 还是有这种 Crash 的问题在后台上报. 排查了很久后才发现，问题的原因是 BugTags 也会控制这个开头，默认是不忽略，这样： 1234/** * 是否忽略 PIPE Signal (SIGPIPE) 闪退，默认 NO */@property(nonatomic, assign) BOOL ignorePIPESignalCrash; 这个默认设置为 NO, 即可以上报 PIPE Signal Crash 的问题. 这里也说明一个问题, 即使我们采用 方案1 解决 Crash 的问题了, Bugtags 还是会将这种 Crash 上报到后台. 示例代码: 12345bugtag.option.ignorePIPESignalCrash = YES;// ...signal(SIGPIPE, SIG_IGN); 对比一下测试的两张图, 第一张图到第二张图是增加了两次崩溃次数, 原因是故意设置了 bugtag.option.ignorePIPESignalCrash = NO, 也正好验证了我们的想法. 总结 Xcode 连接真机或者模拟器, 运行出现异常断点, 可能就是隐患点. 学会使用后台日志找到规律, 继而去思考并解决问题. 对 Crash 进行更深入的分析和总结, 不要轻易放弃. 后续研究 是否可以忽略其他的 signal, 来避免不必要的 Crash? 自定义一套关于 signal 捕获的跨平台库, 在开发阶段可以直接看到完整的日志. 推荐 Avoiding Common Networking Mistakes linux die Using Sockets and Socket Streams 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Crash linux signal SIGPIPE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这样学习你愿意吗?]]></title>
    <url>%2F2018%2F04%2F07%2F%E8%BF%99%E6%A0%B7%E5%AD%A6%E4%B9%A0%E4%BD%A0%E6%84%BF%E6%84%8F%E5%90%97%2F</url>
    <content type="text"><![CDATA[不得不承认, 学习确实是个「苦差事」, 这里说的学习不仅仅指伏案学习, 之乎者也等, 而是一种广泛的学习. 如何学习是始终要去探讨的一个话题, 时代在变, 环境在变, 学习当然也不能一成不变. 坚持学习是一辈子的事, 活到老学到老. 既然学习是一个漫长的马拉松, 那我们只有持之以恒的’跑’下去, 才能保持不掉队. 这样一来, 学习方法和学习技巧就是取胜的关键了. 世上没有绝对的学习妙招和学习宝典, 找到适合自己的就是最好的. 下面我结合自己的一些经历给大家分享在学习的道路上遇到的那些事. 不管怎样, 学习一定要带着目标, 结合理论再去实践, 事半功倍. 欢迎大家在评论区交流, 不喜勿喷~ 回忆当天事每晚躺在床上或者沙发上, 发发呆, 把当天做过的事情, 在脑海中统统的过一遍, 像放电影一样, 能有多详细就多详细, 也就是说尽量的回忆细节. 这种做法看似很简单, 其实很难坚持下去. 特别是中间几天, 很多人都会放弃, 再加上现在手机互联网的 “毒害”, 留给自己去真正学习的时间更少了. 但是只要你咬咬牙坚持一下, 把这个习惯养成, 就会终生受用. 我在初中时期已经养成了这个习惯, 直到大学都没有放弃. 大学里面每次期末考试, 看到很多人忙的不可开交, 我都是不慌不忙的, 悠闲自得, 室友问我怎么做到游刃有余, 我说你白天少睡点觉, 平时注意听讲, 晚上回忆一下就可以了, 从他迷茫的眼神中可以看出, 他当时并不完全相信我说的! 每次回忆结束, 有些东西还是比较模糊甚至一知半解, 没事, 你第二天去翻阅相关知识再去整理和理解一下就好了, 这种自我激励比任何鞭策都有用. 有些困难只是暂时的, 想办法 ‘挺’ 过去, 你就赢了. 很多时候不是困难吓到了我们, 而是我们放弃了自己. 多想多问和你身边兴趣相投或者比你有能力的人多交流, 交流的过程也是你练习自我表达能力的过程, 把自己的问题能够清楚的描述给别人听, 也是一种能力. 不知道大家有没有这样一种感觉, 在跟别人交流的过程中, 虽然别人没有直接帮你解决问题, 但是你突然有了解决问题的办法. 为什么会这样呢? 很简单, 因为这个问题你之前思考过, 只是在交流的过程中, 你的大脑专注在此, 聚精会神的在想这件事情. 问问题有一套门道. 在请教别人问题之前, 最好自己先尽力想一想, 不要遇到一点问题就去问东问西, 即使别人给你讲了, 你也只是当时明白了, 下次再遇到此类问题, 你依然懵逼. 还有就是会让你形成一种依赖心理, 反正有人能解决, 我问就可以了, 干嘛还有费时费力的去想?! 久而久之, 就破罐子破摔了. 另外一个要说的就是在请教或者交流问题的时候, 要对对方谦虚. 我很感激高中时代, 班主任很信任我, 让我当了三年班长, 那三年让我学到了很多书本之外的东西, 其中沟通和管理让我在今后的工作中受益匪浅. 阅读和写作 这里说的写作不是指专业的作家级的写作, 泛指任何文字的记录, 日记也算. 每天最幸福的时刻就是在 23:00 点之前坐在电脑前, 可以写自己心中要表达的内容, 任思绪飘摇. 只要有闲暇的时间, 我就会整理和总结这段时间发生的事情, 既有工作上的也有生活上的. 小的时候, 家里比较穷, 交学费都是问题, 更别说是买书了. 我记得初中一年级, 我很想要一本英语书籍, 那种渴望至今难忘! 后来, 我每天从自己的生活费里抠出一点钱(生活费本来就少), 就这样积攒了几个星期, 去新华书店买了一本英语书籍. 高中时期, 有同学不要的或者已经不读的书籍, 我都会借过来看, 沉浸在自己的幸福当中. 参加工作之后, 我也有写博客的习惯, 把自己工作中遇到的问题以及解决问题的思路和方式写出来, 分享给其他人, 快乐无比. 特别是收到文章的评论后, 心理美滋滋的. 在互联网的海洋里, 大家素不相识, 通过键盘上敲击的文字互相交流知识和想法, 彼此成长着, 也别具一番乐趣. 阅读和写作可以培养自己的专注力, 这么好的习惯你千万不要拒绝. 写作可以倒逼着你去阅读, 去关心生活里面的点滴, 阅读和生活中的体验又可以激发你写作的欲望, 两者相辅相成. 推荐给大家一本书: Google 工作整理术 谷歌前CIO（首席信息官）分享风靡谷歌的信息整理术，帮助现代人彻底告别无序工作，学会利用数字工具为大脑减压！信息太多、时间太少，整理信息已成为现代人急需掌握的必备技能。谷歌作为引领全球的信息搜索与整合巨头，拥有能够有序整理信息的独特方式，而谷歌首席信息官便是主导这一“信息工厂”的总工程师。如今，曾担任“总工程师”的道格拉斯梅里尔亲自将风靡谷歌的信息整理方式分享给大众读者，帮助现代人克服无序工作的通病。《Google工作整理术》告诉你：不要花太多时间给信息归档，用的时候学会去搜索；在数字信息文档中加上关键词，方便日后检索；从前，知识就是力量,现在，共享知识才是力量；把工作和生活融为一体，而不是力图在二者之间求平衡。这些实用 Tips 都揭示了：信息整理才是高效工作的关键，信息整理已是现代人的工作必备技能！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 感悟 学习 阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 总结消息转发中用到的知识点]]></title>
    <url>%2F2018%2F04%2F05%2FOC-RunTime-%E6%80%BB%E7%BB%93%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言OC-RunTime: 消息转发之实例方法的转发流程 OC-RunTime: 消息转发之实例方法的转发流程实例讲解 OC-RunTime: 消息转发之类方法的转发流程 在上面的几篇文章中我分享了关于消息转发相关的知识点，里面有很多细节没有阐述。 若在上面的文章中加入很多细节点的话，一是拉长了文章的内容, 二是对于刚接触 Runtime 的朋友来说不一定能接受, 于是就有了这篇文章的诞生. RunTime 的定义及使用场景苹果 开发文档 的这样解释 runtime 的： 1The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work 尽量将决定放到运行的时候，而不是在编译和链接过程中. RunTime 的应用场景: 1.面向切面编程 AOP.2.方法调配 method swizzling. 有些地方称之为”黑魔法”.3.消息转发.4.给分类添加属性(关联对象).5.动态获取 class 和 slector.6.KVO/KVC, 修改私有属性的值. 建议去阅读下面框架的源码，恕我没有加入链接: Aspects（AOP必备，“取缔” baseVC，无侵入埋点） MJExtension（JSON 转 model，一行代码实现 NSCoding 协议的自动归档和解档） JSPatch（动态下发 JS 进行热修复） NullSafe（防止因发 unrecognised messages 给 NSNull 导致的崩溃） UITableView-FDTemplateLayoutCell（自动计算并缓存 table view 的 cell 高度） UINavigationController+FDFullscreenPopGesture（全屏滑动返回） 思考问题在前面的文章中，很多次看到 IMP、SEL、selector 以及 Method 等关键字，相信大家随着对 RunTime 的逐步了解，慢慢会逐渐熟悉它们的，只是时间问题。很多概念上面的东西理解起来没那么简单，需要动手去写写代码。 在看下面内容之前, 先抛出一个问题: runtime 如何通过 selector 找到对应的 IMP 地址? 接下来分别说一下 IMP、SEL、selector 以及 Method. IMPIMP 保存的是 Method 的地址，本质是一个函数指针，由编译器生成。 IMP 在 objc.h 中的定义： 123456/// A pointer to the function of a method implementation. #if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif 向对象发送消息之后，是由这个函数指针 IMP 指定的, 即 IMP 函数指针就指向了方法的实现. IMP 函数指针最少包含 id 和 SEL 类型的两个参数，后面其他的参数是对应方法需要的参数。其中 id 代表执行该方法的 target(对象), SEL 就是对应的方法, 通过 id 和 SEL 参数就能确定唯一的方法实现地址. 那么我们如何获取方法的 IMP 呢？很简单. NSObject 提供了如下两个方法: 12- (IMP)methodForSelector:(SEL)aSelector;+ (IMP)instanceMethodForSelector:(SEL)aSelector; 对应的实现(源码 NSObject.mm), 如下: 1234567891011121314+ (IMP)instanceMethodForSelector:(SEL)sel &#123; if (!sel) [self doesNotRecognizeSelector:sel]; return class_getMethodImplementation(self, sel);&#125;+ (IMP)methodForSelector:(SEL)sel &#123; if (!sel) [self doesNotRecognizeSelector:sel]; return object_getMethodImplementation((id)self, sel);&#125;- (IMP)methodForSelector:(SEL)sel &#123; if (!sel) [self doesNotRecognizeSelector:sel]; return object_getMethodImplementation(self, sel);&#125; 大家可以看到，对应的 methodForSelector 既有实例方法又有类方法，而 instanceMethodForSelector 只有类方法。 在使用 methodForSelector 方法时，向类发送消息，则 SEL 应该是类方法, 若向实例对象发送消息，则 SEL 应该为实例对象方法. 而 instanceMethodForSelector 仅仅允许类发送该消息, 从而获取实例方法的 IMP. 该方法无法获取类方法的 IMP, 如果想获取类方法的 IMP 可以使用 methodForSelector 来获取。 函数文档原文解释如下: 12Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class method, send the methodForSelector: instance method to the class instead. 举个例子，或许更好理解。 下面两个方法, 一个是类方法(testClassMethod), 另一个是实例方法(testInstanceMethod). 12345+ (void)testClassMethod &#123;&#125;- (void)testInstanceMethod &#123;&#125; 分别使用上面提到的方法来获取 IMP 的几个方法. 123456789IMP imp = [[self class] instanceMethodForSelector:@selector(testClassMethod)];IMP imp2 = [[self class] instanceMethodForSelector:@selector(testInstanceMethod)];// 也可以改成 NSObject 调用的方式, 结果一样.// IMP imp = [NSObject instanceMethodForSelector:@selector(testClassMethod)];// IMP imp2 = [NSObject instanceMethodForSelector:@selector(testInstanceMethod)]; IMP imp3 = [[self class] methodForSelector:@selector(testClassMethod)];IMP imp4 = [self methodForSelector:@selector(testInstanceMethod)]; 调试器可以看出, 如下日志: 123456789101112Printing description of imp:(IMP) imp = 0x000000010d8455c0 (libobjc.A.dylib`_objc_msgForward)Printing description of imp2:(IMP) imp2 = 0x000000010cf19b90 (-[ViewController testInstanceMethod] at ViewController.m:94)Printing description of imp3:(IMP) imp3 = 0x000000010cf19b60 (+[ViewController testClassMethod] at ViewController.m:89)Printing description of imp4:(IMP) imp4 = 0x000000010cf19b90 (-[ViewController testInstanceMethod] at ViewController.m:94)(lldb) imp2、imp3、imp4 都是正常的，唯独 imp 不正常，也充分说明了 instanceMethodForSelector 无法获取类方法的 IMP. Method在源码 runtime.h 中, 定义 method, 其本质是一个结构体. 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 方法名 method_name 类型为 SEL. method_types 方法类型, 是一个 char 指针，存储着方法的参数类型和返回值类型。 方法实现 method_imp 的类型为 IMP. 可以看出, 有 SEL 和 IMP, method_types 是对应的方法返回值和参数类型, 如 v@:，是一个字符串。 runtime.h 中有两个方法，可以根据 SEL 直接获取实例方法和类方法的 Method，如下: 123Method class_getInstanceMethod(Class cls, SEL name);Method class_getClassMethod(Class cls, SEL name); SELselector, 称之为方法选择器，SEL 是 selector 的表示类型，也是方法的编号，是类成员方法的指针。 SEL 定义在源码 objc.h 中, 是一个结构体指针, 如下: 12/// An opaque type that represents a method selector.typedef struct objc_selector *SEL; 但是源码中查不到 objc_selector 具体的定义和实现. 获取 SEL 有三个方法: 123SEL sel = @selector(play:);SEL sel = sel_registerName("play:"); SEL sel = NSSelectorFromString(@"play"); SEL 表示一个 selector 的指针，无论什么类里，只要方法名相同，SEL 就相同，SEL 实际是根据方法名 hash 化了的字符串。而对于字符串的比较仅仅需要比较他们的地址就可以了，所以速度上非常快，SEL 的存在加快了查询方法的速度。 思考一个问题：为什么在同一个 OC 类中，不能存在同名的函数，即使参数类型不同也不行，换句话说 OC为什么没有重载？ 答案已经在上面说了，SEL 表示一个 selector 的指针，无论什么类里，只要方法名相同，SEL 就相同，相同的函数名，编译器无法编译通过。 dispatch table 存放 SEL 和 IMP 的对应关系，SEL 最终会通过 dispatch table 寻找到对应的IMP。 总之，Selector、Method 和 IMP 三者之间的关系可以这么解释，在类的(实例和类方法)调度表(dispatch table)中的每一个实体代表一个方法 Method，其名字叫做选择器 SEL，并对应着一种方法实现称之为 IMP，有了 Method 就可以使用 SEL 找到对应的 IMP，SEL 就是为了查找方法的最终实现 IMP。 class_addMethod查看源码 objc-runtime-new.mm 中该函数实现如下: 1234567BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)&#123; if (!cls) return NO; rwlock_writer_t lock(runtimeLock); return ! addMethod(cls, name, imp, types ?: "", NO);&#125; 开发文档中这样描述该函数: 1234Adds a new method to a class with a given name and implementation.class_addMethod will add an override of a superclass's implementation, but will not replace an existing implementation in this class. To change an existing implementation, use method_setImplementation. 解释一下，可以为类根据 SEL 和 IMP 动态添加一个新方法。class_addMethod 仅可以动态添加方法，不会替换。如果想达到方法替换的效果可使用 method_setImplementation 函数。 关于 method_setImplementation 和 method_exchangeImplementations 后面文章再做分析. 其实, method_exchangeImplementations 的内部实现相当于调用了 2 次 method_setImplementation 方法。 class_addMethod 不仅可以动态添加类方法, 也可以添加实例方法。 参数及返回值解释: 123456789返回值: 返回 YES 表示方法添加成功, 否则添加失败。参数 Class cls: 将要给添加方法的类, 即［类名 class］参数 SEL name: 将要添加的方法 SEL, 即 @selector(方法名)，如果已经存在，该方法返回失败，不存在就添加成功。参数 IMP imp：实现这个方法的函数. 有两种写法即 C 和 OC 的写法. 一个 IMP 最少包括两个参数, 上面已经说过。参数 const char *types: 实现方法的函数的返回和参数编码类型. 如 "v@:" 表示返回值为 void, 没有参数的一个函数, 其中 @和:分别代表 IMP 的默认两个参数即 id 和 sel. 关于 types，可以使用 method_getTypeEncoding 来获取。 更多关于 types 的内容可以参考开发者文档 Type Encodings. 解答问题读到这里, 大家对 IMP, SEL 以及 Method 应该有初步的了解了, 那么来解答一下刚才提出的问题: runtime 如何通过 selector 找到对应的 IMP 地址? 回答这个问题的关键是要知道消息调度表(dispatch table)，另外一个要回答的要点是 IMP 的实现和获取以及和 Method 之间的关系。 类对象中有类方法和实例方法的分发表，表中记录着方法的名字、参数和实现，selector 本质就是方法名称，runtime 通过这个方法名称就可以在列表中找到该方法对应的实现. 系统为我们提供了获取 IMP 指针的函数，无论是类方法还是实例方法我们都可以获取对应的 IMP. 而 Method 将 Selector 和 IMP 联系起来，可从源码中看出: 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; IMP 是函数的指针，它是由编译器编译生成的。当发一个消息时，它会找到那段代码执行，IMP 指向了这个方法的具体的实现，得到这个函数的指针可以直接执行。 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址，反之亦然。当发送消息给一个对象时，runTime 会在对象的类对象方法列表里查找，当我们发送一个消息给一个类时，这条消息会在类的 Meta Class 对象的方法列表里查找，直到超找到 NSObject 中为止。 消息传递的过程 1. 当消息被发送给一个对象，messaging function 跟随对象的 isa 指针找到它的 class structure，在 dispatch table 中寻找 method selector. 2. 如果没有找到 selector，objc_msgsend 跟随该类实例的 isa 找到父类，尝试在父类的 dispatch table 中寻找 selector. 3. 重复步骤 2，直到 isa 指向 NSObject Class 为止。 关于分发表和消息相关的知识可以参考开发文档 Messaging，讲得很清楚。 实际例子说了这么多理论知识，是时候举栗子了，方便大家更好的理解上面的内容。 1. 动态添加实例方法Student.m 除 init 外，Student 只有一个实例方法 studentWalkImp. 12345678910111213141516171819202122232425262728@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; SEL proxySelector = NSSelectorFromString(@"studentWalkImp"); IMP impletor = class_getMethodImplementation([self class], proxySelector); // 获取实例方法 Method method = class_getInstanceMethod([self class], proxySelector); const char *types = method_getTypeEncoding(method); SEL origSel = NSSelectorFromString(@"walk"); class_addMethod([self class], origSel, impletor, types); &#125; return self;&#125;- (void)studentWalkImp&#123; NSLog(@"---veryitman--- Student studentWalkImp");&#125;@end 调用测试一下. 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; Student *stud = [[Student alloc] init]; [stud performSelector:NSSelectorFromString(@"walk") withObject:nil];&#125; 这里 Student 并没有 walk 方法，故意为之，运行后控制台会打印: 1---veryitman--- Student studentWalkImp 成功的为 Student 添加了一个实例方法 walk 的实现 studentWalkImp. 上面的例子是使用 OC 的 IMP 方式来实现的，可以改为 C 实现版本的. 123456789101112131415161718@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; SEL origSel = NSSelectorFromString(@"walk"); class_addMethod([self class], origSel, (IMP)studentWalkImp, "v:@"); &#125; return self;&#125;void studentWalkImp()&#123; NSLog(@"---veryitman--- Student studentWalkImp");&#125; 2. 动态添加类方法动态添加类方法，和动态添加实例方法稍微有点不同。下面是改造后的 Student.m. Student.m 123456789101112131415161718192021222324252627282930@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; // 获取 MetaClass, 类方法不可以使用 [self class] Class metaCls = objc_getMetaClass([NSStringFromClass([self class]) UTF8String]); SEL proxySelector = NSSelectorFromString(@"clsImp"); IMP impletor = class_getMethodImplementation(metaCls, proxySelector); // 获取类方法 Method method = class_getClassMethod([self class], proxySelector); const char *types = method_getTypeEncoding(method); SEL origSel = NSSelectorFromString(@"walk"); class_addMethod(metaCls, origSel, impletor, types); &#125; return self;&#125;+ (void)clsImp&#123; NSLog(@"---veryitman--- Student clsImp");&#125; 注意：这里获取 Class 稍微不同的是使用了 objc_getMetaClass，这里关系到 Objective-C 中的类、Class、根类和元类的区别，可以参考 Class、isa、元类 这篇文章。 调用测试一下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; Student *stud = [[Student alloc] init]; [[stud class] performSelector:NSSelectorFromString(@"walk") withObject:nil];&#125; 控制台打印： 1---veryitman--- Student clsImp 成功地为类动态的添加了一个类方法 clsImp. 参考文档1. Objective-C 对象模型及应用 2. Apple RunTime 源码 objc4-723.tar.gz 3. Messaging 4. Objective-C 深入理解中的消息机制和方法调用 完整代码点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 消息转发之类方法的转发流程]]></title>
    <url>%2F2018%2F04%2F03%2FOC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本篇是「消息转发」系列的第三篇, 在 OC-RunTime: 消息转发之实例方法的转发流程 和 OC-RunTime: 消息转发之实例方法的转发流程[实例讲解] 中分享了实例方法的转发流程. 今天分享如何对类方法进行消息的转发. resolveClassMethodNSObject 提供了 resolveClassMethod 来让开发者在里面动态添加一个类方法. 类方法的转发流程和实例方法转发的流程大致一样, 唯独不同的是需要重写的方法(NSObject中)的不一样. 当时我在写 Demo, 以为只需要将 resolveInstanceMethod 改为 resolveClassMethod 就万事大吉了即重写下面几个方法就可以解决问题, 事实证明这样是不行的. +resolveClassMethod -forwardingTargetForSelector -methodSignatureForSelector -forwardInvocation -doesNotRecognizeSelector: 网上很多博文并没有深入的探讨关于类方法转发的流程, 只是在介绍实例方法转发的流程的同时, 一笔带过类方法转发机制和流程. 通过对 NSObject.mm 源码的查看, 可以看到对应上面的几个方法都有类方法. 如下: 123451. +resolveClassMethod2. +forwardingTargetForSelector3. +methodSignatureForSelector4. +forwardInvocation5. +doesNotRecognizeSelector: 重新这几个方法才是解决问题的关键. 现在我们重写 resolveClassMethod, 如下. ViewController.m 123456789101112131415161718192021222324252627282930313233#import &lt;objc/runtime.h&gt;static NSString * const sPerformClassMethodName = @"veryClassMethod";+ (BOOL)resolveClassMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveClassMethod"); NSString *methodName = NSStringFromSelector(sel); if ([sPerformClassMethodName isEqualToString:methodName]) &#123; // 获取 MetaClass Class predicateMetaClass = objc_getMetaClass([NSStringFromClass(self) UTF8String]); // 根据 metaClass 获取方法的实现 IMP impletor = class_getMethodImplementation(predicateMetaClass, @selector(proxyMethod)); // 获取类方法 Method predicateMethod = class_getClassMethod(predicateMetaClass, @selector(proxyMethod)); const char *encoding = method_getTypeEncoding(predicateMethod); // 动态添加类方法 class_addMethod(predicateMetaClass, sel, impletor, encoding); return YES; &#125; return [super resolveClassMethod:sel];&#125;+ (void)proxyMethod&#123; NSLog(@"---veryitman--- +proxyMethod of class's method for OC.");&#125; 模拟调用 12345678910- (void)viewDidLoad&#123; [super viewDidLoad]; // 运行类方法 SEL selector = NSSelectorFromString(sPerformClassMethodName); SuppressPerformSelectorLeakWarning( [[self class] performSelector:selector withObject:nil]; );&#125; 关于 SuppressPerformSelectorLeakWarning 可以参考 OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]. 将动态添加的方法让 proxyMethod 来执行, 显示结果达到预期. 12---veryitman--- 1--- +resolveClassMethod---veryitman--- +proxyMethod of class's method for OC. 创建被转发者MZTempObj.m 123456789@implementation MZTempObj/// 类方法+ (void)veryClassMethod&#123; NSLog(@"---veryitman--- veryClassMethod");&#125;@end 这里有类方法的一个实现 veryClassMethod. 重写转发消息的函数同理将 resolveClassMethod 修改一下, 为了保证流程继续. 示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115+ (BOOL)resolveClassMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveClassMethod. selector: %@", NSStringFromSelector(sel)); NSString *methodName = NSStringFromSelector(sel); // 这里故意将 sPerformClassMethodName 改为 @"", 为了流程往下走 if ([@"" isEqualToString:methodName]) &#123; // 获取 MetaClass Class predicateMetaClass = objc_getMetaClass([NSStringFromClass(self) UTF8String]); // 根据 metaClass 获取方法的实现 IMP impletor = class_getMethodImplementation(predicateMetaClass, @selector(proxyMethod)); // 获取类方法 Method predicateMethod = class_getClassMethod(predicateMetaClass, @selector(proxyMethod)); const char *encoding = method_getTypeEncoding(predicateMethod); // 动态添加类方法 class_addMethod(predicateMetaClass, sel, impletor, encoding); return YES; &#125; return [super resolveClassMethod:sel];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- +forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); if ([sPerformClassMethodName isEqualToString:selectorName]) &#123; // 注意1: 也可在此转发实例方法#if 0 // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject;#endif // 转发类方法对应返回类对象 return [MZTempObj class]; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 3--- +methodSignatureForSelector"); // 找出对应的 aSelector 签名 NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; // 注意2: 也可以在此获取实例方法的签名#if 0 if (nil == signature) &#123; // 是否有 aSelector if ([MZTempObj instancesRespondToSelector:aSelector]) &#123; signature = [MZTempObj instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;#endif if (nil == signature) &#123; // 是否有 aSelector if ([MZTempObj respondsToSelector:aSelector]) &#123; //methodSignatureForSelector 可以获取类方法和实例方法的签名 //instanceMethodSignatureForSelector只能获取实例方法的签名 signature = [MZTempObj methodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@"---veryitman--- 4--- +forwardInvocation"); // 注意3: 也可以调用实例方法#if 0 if ([MZTempObj instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:[[MZTempObj alloc] init]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125; return;#endif if ([MZTempObj respondsToSelector:anInvocation.selector]) &#123; // 这里转发的是 MZTempObj Class, 不是对象 [anInvocation invokeWithTarget:[MZTempObj class]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;+ (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 5--- +doesNotRecognizeSelector: %@", NSStringFromSelector(aSelector));&#125; 执行后, 控制台输出日志: 123---veryitman--- 1--- +resolveClassMethod. selector: veryClassMethod---veryitman--- 2--- +forwardingTargetForSelector---veryitman--- veryClassMethod 这里注意一下 将代码中 注意1 注意2 等部分可以自行打开测试一下, 然后将 MZTempObj.m 中的类方法(+veryClassMethod)改为实例方法(-veryClassMethod), 也是可以的, 这样就达到了将类方法转发给实例方法的效果. 修改一下 forwardingTargetForSelector 中的实现, 可以看到 4, 5也会执行. 123456789101112131415161718192021222324+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- +forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); if ([@"" isEqualToString:selectorName]) &#123; // 注意1: 也可在此转发实例方法#if 0 // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject;#endif // 转发类方法对应返回类对象 return [MZTempObj class]; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125; 123456---veryitman--- 1--- +resolveClassMethod. selector: veryClassMethod---veryitman--- 2--- +forwardingTargetForSelector---veryitman--- 3--- +methodSignatureForSelector---veryitman--- 1--- +resolveClassMethod. selector: _forwardStackInvocation:---veryitman--- 4--- +forwardInvocation---veryitman--- veryClassMethod 同理我们可以得到类方法的消息转发流程图, 如下图所示: 推荐OC-RunTime: 消息转发之实例方法的转发流程 OC-RunTime: 消息转发之实例方法的转发流程实例讲解 OC-RunTime: 总结消息转发中用到的知识点 点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]]]></title>
    <url>%2F2018%2F04%2F01%2FOC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程 分享了消息转发的流程, 本次结合实际例子继续分析一下消息转发流程. 发送不存在的消息在 ViewController 的 viewDidLoad 中运行 veryTestMethod 方法. ViewController.m 12345678910111213static NSString * const sPerformInstanceMethodName = @"veryTestMethod";- (void)viewDidLoad &#123; [super viewDidLoad]; // 运行实例方法 SEL selector = NSSelectorFromString(sPerformInstanceMethodName); SuppressPerformSelectorLeakWarning( [self performSelector:selector withObject:nil]; );&#125; 其中, SuppressPerformSelectorLeakWarning 是定义的一个宏. 1234567#define SuppressPerformSelectorLeakWarning(Stuff) \do &#123; \ _Pragma("clang diagnostic push") \ _Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \ Stuff; \ _Pragma("clang diagnostic pop") \&#125; while (0) 在 ViewController 中我并没有写 veryTestMethod 这个函数, 只是借助 performSelector 动态执行, 如果编译运行直接会 crash. 可以查看 NSObject.mm 源码, 里面关于消息转发的几个重要函数都写着 _objc_fatal, 可谓是招招毙命. 紧接着, 我们可以借助 resolveInstanceMethod 来完成消息转发给 ViewController. resolveInstanceMethod 转发重写 NSObject 中的 resolveInstanceMethod 函数. +resolveInstanceMethod ViewController.m 1234567891011121314151617181920212223242526// 记得导入 RunTime 头文件#import &lt;objc/runtime.h&gt;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveInstanceMethod"); NSString *methodName = NSStringFromSelector(sel); if ([sPerformInstanceMethodName isEqualToString:methodName]) &#123; SEL proxySelector = NSSelectorFromString(@"proxyMethod"); IMP impletor = class_getMethodImplementation(self, proxySelector); // 获取实例方法 Method method = class_getInstanceMethod(self, proxySelector); const char *types = method_getTypeEncoding(method); // 添加 OC 的函数 class_addMethod([self class], sel, impletor, types); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; ViewController 中实现的 proxyMethod 12345// OC 实现- (void)proxyMethod&#123; NSLog(@"---veryitman--- -proxyMethod of instance's method for OC.");&#125; 在 resolveInstanceMethod 中动态添加了 veryTestMethod 方法, 并让 proxyMethod 函数来实现(IMP). 运行可以看到, 程序并没有 crash, 成功的执行了 proxyMethod. 12---veryitman--- 1--- +resolveInstanceMethod---veryitman--- -proxyMethod of instance&apos;s method for OC. 到此为止, 我们已经看到动态添加一个方法的实现并成功运行的完整例子. 接下来, 我们将转发给其他对象 MZTempObj 来执行. 自定义被转发的对象MZTempObj.m 123456@implementation MZTempObj- (void)veryTestMethod&#123; NSLog(@"---veryitman--- veryTestMethod");&#125; veryTestMethod 就是我们要转发对应的消息. 消息转发实践接下来我们把向 ViewController 发送 veryTestMethod 的消息转发给 MZTempObj 的 veryTestMethod 方法. 继续重写下面函数, 不过 resolveInstanceMethod 要稍微改造一下, 才能达到我们实践的目的. +resolveInstanceMethod -forwardingTargetForSelector -methodSignatureForSelector -forwardInvocation -doesNotRecognizeSelector: ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 记得导入 RunTime 头文件#import &lt;objc/runtime.h&gt;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveInstanceMethod: %@", NSStringFromSelector(sel)); NSString *methodName = NSStringFromSelector(sel); // 这里故意为之, 让流程往下走 if ([@"" isEqualToString:methodName]) &#123; SEL proxySelector = NSSelectorFromString(@"proxyMethod"); IMP impletor = class_getMethodImplementation(self, proxySelector); // 获取实例方法 Method method = class_getInstanceMethod(self, proxySelector); const char *types = method_getTypeEncoding(method); // 添加 OC 的函数 class_addMethod([self class], sel, impletor, types); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;/// 转发给对应的某个对象来执行 aSelector- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- -forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); if ([sPerformInstanceMethodName isEqualToString:selectorName]) &#123; // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 3--- -methodSignatureForSelector"); // 找出对应的 aSelector 签名 NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (nil == signature) &#123; // 是否有 aSelector if ([MZTempObj instancesRespondToSelector:aSelector]) &#123; signature = [MZTempObj instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@"---veryitman--- 4--- -forwardInvocation"); if ([MZTempObj instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:[[MZTempObj alloc] init]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;- (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 5--- -doesNotRecognizeSelector: %@", NSStringFromSelector(aSelector));&#125; 运行程序, 控制台打印结果如下: 123---veryitman--- 1--- +resolveInstanceMethod---veryitman--- 2--- -forwardingTargetForSelector---veryitman--- veryTestMethod 这里对照之前的流程图是完全符合的, 那么怎么让其执行 3 和 4 呢? 很简单, 修改一下 forwardingTargetForSelector 里面的实现即可. 12345678910111213141516171819- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- -forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); // 故意为之 if ([@"" isEqualToString:selectorName]) &#123; // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125; 再次执行看结果: 123456---veryitman--- 1--- +resolveInstanceMethod veryTestMethod---veryitman--- 2--- -forwardingTargetForSelector---veryitman--- 3--- -methodSignatureForSelector---veryitman--- 1--- +resolveInstanceMethod: _forwardStackInvocation:---veryitman--- 4--- -forwardInvocation---veryitman--- veryTestMethod 注意: 这里在 3后面会多了一个 1--- resolveInstanceMethod 的打印, 是系统调用的, 此时对应的 sel 是 _forwardStackInvocation. 如果不去重写 methodSignatureForSelector 打印结果如下: 123---veryitman--- 1--- +resolveInstanceMethod---veryitman--- 2--- -forwardingTargetForSelector---veryitman--- 5--- -doesNotRecognizeSelector: veryTestMethod 参考文档1.Apple RunTime 源码 objc4-723.tar.gz 2.Message Forwarding 推荐OC-RunTime: 消息转发之实例方法的转发流程 OC-RunTime: 消息转发之类方法的转发流程 OC-RunTime: 总结消息转发中用到的知识点 点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程]]></title>
    <url>%2F2018%2F03%2F31%2FOC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 本篇只是从系统函数的实现上, 来分析消息转发的流程. 下一篇结合本篇的理论和实际的例子来分析一下消息转发. 需要明确的几个问题在往下看这篇博文之前, 有几个问题需要大家达成共识. 1.Objective-C 的特点按照是否需要编译的原理来说, 编程语言一般可以分为静态编译类型和动态解释类型. 如 Java/C/C++ 是属于编译类型的语言, Php/Python/Ruby 属于解释类型的语言. Objective-C 是基于 C 并具有自身特点的编译型语言, 再加上其 RunTime 机制, Objective-C 既是编译型又是动态的一门编程语言. 所谓的动态指的是在程序编译后运行中可以改变其结构. 2.函数调用在 Objective-C 中调用函数, 被解释为向一个对象发送消息, 该对象可以是类对象也可以是实例对象. 例如: 1[person play]; 意思是向实例对象 person 发送一个 play 的消息. 还有一个比较有意思的是, 向一个空对象(nil) 发送消息不会 crash, 如果在 Java 中这个是不行的.例如: 12person = nil;[person play]; 这个不会导致程序崩溃, 只是调用 play 函数没有任何反应罢了! 3.self在 C++/Java 语言中, 有 this 指针的概念, 在 Objective-C 中, 也有类似的 this 指针即 self. self 既可以是实例对象也可以是类对象. 这里举个例子, 下面两个同名函数, 一个是类方法(+)一个是实例方法(-).跟 Java 中的类似, 实例方法可以直接使用类方法, 但是类方法不可以直接使用实例方法. 123456789101112131415161718192021+ (void)testClassMethod&#123; [self sendMsg];&#125;- (void)testInstanceMethod&#123; [self sendMsg];&#125;// 类方法+ (void)sendMsg&#123; NSLog(@"+ sendMsg. self: %@", self);&#125;// 实例方法- (void)sendMsg&#123; NSLog(@"- sendMsg. self: %@", self);&#125; 在 ViewController 中分别调用两个 test 方法, 输出内容, 如下: 123+ sendMsg. self: ViewController- sendMsg. self: &lt;ViewController: 0x7fc64740a5e0&gt; 从结果可以看出类方法中的 self 代表的是该类, 实例方法中的 self 指的是类的一个实例即对象. 更多 self 的知识点，可以参考 OC: self 这篇文章。 关于 Message ForwardingMessage Forwarding 即消息转发. 关于消息转发, 官方文档 Message Forwarding 是这么解释的: 123Sending a message to an object that does not handle that message is an error. However, before announcing the error, the runtime system gives the receiving object a second chance to handle the message. 大概意思是这样的: 向一个对象发送消息, 该对象如果无法处理该消息, 系统就会报错, 但是在报错之前, 利用 Objective-C 提供的运行时机制可以防止报错的发生. 在 iOS 中类似这样的报错会导致程序直接 crash.这里的对象, 可以是实例对象又可以是类对象. 在开发过程中, 大家一般都会遇到类似的 crash: 123456789101112 *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Controller play]: unrecognized selector sent to instance 0x7ff779f322a0'*** First throw call stack:(CoreFoundation 0x000000010d89712b __exceptionPreprocess + 171libobjc.A.dylib 0x000000010cf2bf41 objc_exception_throw + 48CoreFoundation 0x000000010d918024 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132UIKit 0x000000010df48f51 -[UIResponder doesNotRecognizeSelector:] + 295CoreFoundation 0x000000010d819f78 ___forwarding___ + 1432CoreFoundation 0x000000010d819958 _CF_forwarding_prep_0 + 120) 这个 crash 很明显, Controller 中调用了一个不存在的函数 play. 这里可以看到一个被调用的系统函数 doesNotRecognizeSelector, 今天我们剖析一下消息转发的流程. 实例方法(消息)转发的流程在上面已经说过, OC 可以通过运行时来避免因为找不到方法而导致错误. 其实, 含义就是 OC 给了我们第二次机会来避免类似的错误. 我们重写 NSObject 中的 5 个方法, 分别是: +resolveInstanceMethod -forwardingTargetForSelector -methodSignatureForSelector -forwardInvocation -doesNotRecognizeSelector: 当无法找到对应的方法时, 调用的方法和顺序大致如下: 1234+resolveInstanceMethod-forwardingTargetForSelector-methodSignatureForSelector-doesNotRecognizeSelector: 当找到对应的方法时, 调用方法和顺序大致如下: 1234+resolveInstanceMethod-forwardingTargetForSelector-methodSignatureForSelector-forwardInvocation 根据实践结果, 画流程图如下: 下面分别解释一下这几个方法的作用和意义. + (BOOL)resolveInstanceMethod:(SEL)sel 解析对应的实例方法. 在该方法中允许增加一个方法的实现, 从而实现动态添加方法. 默认返回 NO. 在 NSObject.mm 中可以看到方法的实现: 123+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return NO;&#125; - (id)forwardingTargetForSelector:(SEL)aSelector 将对应的 selector 转发给指定的对象. 换句话说就是将之前没有实现的 selector 转交给另外一个可能实现了该 selector 的对象去处理. 默认返回 nil. - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 该方法返回对 selector 实现的方法签名. 默认实现如下: 1234- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; _objc_fatal("-[NSObject methodSignatureForSelector:] " "not available without CoreFoundation");&#125; - (void)forwardInvocation:(NSInvocation *)anInvocation 该方法是依赖第3个方法的, 如果第三个方法找到了对应的方法签名, 该方法就可以实现转向调用了. - (void)doesNotRecognizeSelector:(SEL)sel 如果前面几个方法都没有处理好, 系统会调用该方法, 直接导致程序 crash, 也称之为终极死亡方法. 源码实现如下: 1234- (void)doesNotRecognizeSelector:(SEL)sel &#123; _objc_fatal("-[%s %s]: unrecognized selector sent to instance %p", object_getClassName(self), sel_getName(sel), self);&#125; 总结, Objective-C 中给一个对象发送消息会经过如下几个步骤： 步骤1. 在类的调度表(dispatch table) 中找要执行的函数(消息), 如果找到了，到相应的函数 IMP 去执行. 每个类的结构体包含着两个必备的元素:[1]. 指向父类的指针[2]. class dispatch table(调度表). 调度表中包含了 method selectors 和特定 class 相应方法实现的地址. 步骤2. 如果没找到，运行时会调用 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试解析这个消息. 在该方法中, 允许动态添加一个方法的实现. 关于 resolveClassMethod 这个放在另一篇博客中讲解. 步骤3. 如果 resolveXX 返回 YES, 直接结束后面的流程, 执行解析得到的方法. 如果 resolveXX 返回 NO，运行时就发送 forwardingTargetForSelector 消息, 允许这个消息转发给另一个可能实现了对应 selector 的对象. 步骤4. 如果没有新的目标对象返回, 运行时就会发送methodSignatureForSelector 消息, 找到对应的方法签名.如果找到了, 会接着调用 forwardInvocation, 如果没有找到即返回 nil, 那么直接调用 doesNotRecognizeSelector. 下一篇结合实际例子分析一下整个实例方法的转发流程. 参考文档1.Apple 开发者文档 Message Forwarding 2.Apple RunTime 源码 objc4-723.tar.gz 推荐OC-RunTime: 消息转发之实例方法的转发流程实例讲解 OC-RunTime: 消息转发之类方法的转发流程 OC-RunTime: 总结消息转发中用到的知识点 点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 文件大小的单位]]></title>
    <url>%2F2018%2F03%2F24%2FMacOS-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[缘由我一直以为文件大小都是按照 1024 为单位来计算的, 但是在 MacOS 上面是按照 1000 为单位计算的, windows 上面是按照 1024 为单位来计算的. 偶然的发现之前写代码, 需要用到获取文件大小的功能, 代码如下: 123456789101112131415// 读取文件大小long getFileSize(char *filename) &#123; FILE *fp = fopen(filename, &quot;r&quot;); if (!fp) &#123; return -1; &#125; fseek(fp, 0, SEEK_END); long size = ftell(fp); fclose(fp); return size;&#125; 文件名是 mm.aac, 一个音频文件, 获取到的文件大小是 76395 字节. 我无聊至极, 使用 du 命令来获取该文件的大小: 1du -sh mm.aac 显示文件大小是 76KB. MacOS 上面查看文件属性, 获取到的大小也是 76KB 二者获取的文件大小一致, 可以看出文件的大小是正确的. 于是我查了一下在 windows 上面的该文件的大小, 如下截图: 可以看出, MacOS 上面文件大小是按照 1000 单位来计算的, 而 windows 上面是按照 1024 单位来计算的. 1276395 / 1000 = 76.39576395 / 1024 = 74.604 按照 GNU 的习惯，单纯的 K M G T 分别指代 KiB MiB GiB TiB 以 1024 进制数据量单位，用 KB MB GB TB 以 1000 进制数据量单位. 所以, 在 windows 上面准确表示 76395bytes 应该是 74.6KiB. 推荐在线计算 单位换算.]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS C 文件大小单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO: 写第一个 GOLang 程序]]></title>
    <url>%2F2018%2F03%2F11%2FGO-%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA-GOLang-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介本文分享在 MacOS 上面通过 pkg 的方式安装 GO 编程环境, 以及编译运行第一个使用 GOLang 编写的程序. 其他关于 GO 的安装方式, 如使用 Homebrew 安装或者使用源码安装的方式, 请自行尝试. 下载安装在 这里 下载 GO 的 pkg 安装包. 但是你需要科(fan)学(qiang)才能下载. 你也可以下载 Stable versions. 下载完成后, 直接双击安装即可. 配置环境变量安装完成后, GO 安装目录在 /usr/local 下面. 安装目录如下图所示: 需要将其设置到环境变量中, 才能在终端使用其相关的命令. 编辑 ~/.bash_profile, 增加下面几行即可. 12345# Golangexport GOROOT=/usr/local/goexport GOPATH=~/goworkexport PATH=$GOROOT/bin:$GOPATH:$PATH 记住, GOROOT 和 GOPATH 必须设置.gowork 是我自己新建的目录. GOPATH 可以理解为工作目录. 关于 GOPATH 可以参考这个文档 SettingGOPATH. 我刚开始没有配置 GOROOT 变量, 执行 go 命令会提示警告, 警告内容如下: 1warning: GOPATH set to GOROOT (/usr/local/go) has no effect 编辑保存, 然后使其立即生效. 1source ~/.bash_profile 检查环境变量是否生效. 1go version 对应输出 1go version go1.9.4 darwin/amd64 也可以使用 go env 来查看更加详细的内容. 编译运行 GOLang 程序1.编写代码 编辑一个 Hello GOLang 的程序. 在任意一个文件夹位置, 新建一个 go_hello.go 的文件. 1touch go_hello.go 写入如下程序: 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, GOLang!&quot;)&#125; 2.编译运行 使用 go build 命令编译. 1go build go_hello.go 编译成功后, 生成可执行文件 go_hello. 执行即可. 1./go_hello 或者直接运行, 执行下面的命令. 1go run go_hello.go 这个不会生成可执行文件. 至此, GO 的编程环境已经搭建完成, 比较简单. 卸载 GO如果你想卸载 GO 环境, 只需要三个步骤. 1.删除安装目录 1sudo rm -fr /usr/local/go 2.删除 go 文件 1sudo rm -f /etc/paths.d/go 3.删除环境变量 编辑 etc, 删除对应添加的 go 环境变量即可. 参考GO: Getting Started GO: DOC SettingGOPATH]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>GOLanguage Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 指针与 OC 对象之间的转换]]></title>
    <url>%2F2018%2F03%2F07%2FC-%E6%8C%87%E9%92%88%E4%B8%8E-OC-%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Core Foundation 框架Core Foundation 框架 (CoreFoundation.framework) 是一组 C 语言接口， 简称 CF. 它们为 iOS 应用程序提供基本数据管理和服务功能. 如 Core Graphics、Core Text，并且我们可能需要将 CF 对象和OC 对象进行相互转化，ARC 下，编译器不会自动管理 CF 对象的内存，我们需要手动管理. 创建一个 CF 对象使用后, 需要使用 CFRelease 将其手动释放, 换句话说, Core Foundation 对象类型不在 ARC 管理范畴内. 如何将 CF 和 OC 对象有效的结合起来, 在 ARC 环境下, 提供了 桥接 的技术, 即 ARC 下 OC 对象和 Core Foundation 对象之间的桥梁. ARC 桥接ARC 下 C 指针与 OC 指针(对象)之间转换, 一般会用到下面的方法. 12345__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;__bridge &lt;#type#&gt;)&lt;#expression#&gt; 也就是所谓的 桥接, 它是 Object-C 在 ARC 环境下开发出来的一种用作转换 C 指针跟 OC (类)指针的一种转换技术, 所以是 ARC 下的称谓, 在 MRC 下没有 桥接. 针对内存管理问题，ARC 可以管理 Objective-C 对象, 但不支持 Core Foundation 对象的管理，所以转换后要注意一个问题：谁来释放使用后的对象. 结合 ARC 和 内存管理, 下面分别介绍一下. Core Foundation 对象必须使用 CFRetain 和 CFRelease 来进行内存管理.当使用 Objective-C 和 Core Foundation 对象相互转换的时候，必须让编译器知道，到底由谁来负责释放对象，是否交给 ARC 处理, 只有正确的处理，才能避免内存泄漏和 double free 导致程序崩溃. __bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;__bridge_retained 等同于 CFBridgingRetain(). 将 Objective-C 对象转换为 Core Foundation 对象，把对象所有权桥接给 Core Foundation 对象，同时剥夺 ARC 的管理权，后续需要开发者使用 CFRelease 或者相关方法手动来释放 CF 对象. 示例: 12345678910void *cPointer;NSObject *objc = [[NSObject alloc] init];//将 OC 对象转换为 C 指针cPointer = (__bridge_retained void*)objc;//use cPointer ...//需要释放资源CFRelease(cPointer); 在 ARC 下, CFBridgingRetain 实现如下: 123NS_INLINE CF_RETURNS_RETAINED CFTypeRef _Nullable CFBridgingRetain(id _Nullable X) &#123; return (__bridge_retained CFTypeRef)X;&#125; 关于 CFTypeRef, 如下: 1typedef const CF_BRIDGED_TYPE(id) void * CFTypeRef; 所以 CFBridgingRetain 返回值是 const void * 类型的. 上面的示例可以改写为: 1234567const void *cPointer;const NSObject *objc = [[NSObject alloc] init];cPointer = CFBridgingRetain(objc); //use cPointer ... CFRelease(cPointer); __bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;__bridge_transfer 等同于 CFBridgingRelease(). 将非 OC 对象转换为 OC 对象，同时将对象的管理权交给 ARC，开发者无需手动管理内存. 示例: 12345678CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);CFStringRef strUUID = CFUUIDCreateString(kCFAllocatorDefault, uuid);NSString *str = (__bridge_transfer NSString *)strUUID;//无需释放 strUUID//CFRelease(strUUID);CFRelease(uuid); CFBridgingRelease 实现如下: 123NS_INLINE id _Nullable CFBridgingRelease(CFTypeRef CF_CONSUMED _Nullable X) &#123; return (__bridge_transfer id)X;&#125; 上面的示例可以改写为: 12345678CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);CFStringRef strUUID = CFUUIDCreateString(kCFAllocatorDefault, uuid);NSString *str = CFBridgingRelease(strUUID); //无需释放 strUUID//CFRelease(strUUID); CFRelease(uuid); __bridge__bridge 不改变对象所有权, 需要我们自己来管理内存, 它也是我们经常使用的方法, 从某种程度上来说, 它是上面两个方法的简化版本. __bridge 可以将 OC 对象 与 C 指针相互转换, 示例: 12345//CFString -&gt; OC 对象CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, "very", kCFStringEncodingUTF8);NSString *nsString = (__bridge NSString *)cfString;NSLog(@"CFString -&gt; NSString: %@", nsString);CFRelease(cfString); 如果将 CFRelease(cfString) 注释掉, Xcode 的静态检测器会告诉你有内存泄露的情况, 如图: 再来另外一个例子, 如下: 12345//OC 对象 -&gt; CFStringNSString *nstr = @"itman";CFStringRef cfStringRef = (__bridge CFStringRef)nstr;NSLog(@"NSString -&gt; CFString: %@", cfStringRef);CFRelease(cfStringRef); 无论是使用 CFRelease(cfStringRef), 还是注释掉 CFRelease(cfStringRef), 静态检测器都不会报错. 说明这种情况下, 当前的内存管理已经被 OC 对象管理. 经典例子NSString 与 CFString 转换1、NSString → CFString 123456789&#123; NSString *string = @"veryitman.com"; // 方法1: 不需要释放 CFStringRef cfStr = (__bridge CFStringRef)string; // 方法2: 需要释放, 这里 retain 了 CFStringRef cfStr2 = (__bridge_retained CFStringRef)string; CFRelease(cfStr2);&#125; 2、CFString → NSString 123456789CFStringRef cfStr = CFStringCreateWithCString(kCFAllocatorDefault, "veryitman", kCFStringEncodingUnicode); // 方法1: 需要释放NSString *string = (__bridge NSString *)cfStr;NSLog(@"OC string: %@", string);CFRelease(cfStr); // 方法2: 不需要释放, __bridge_transfer 自带 releasestring = (__bridge_transfer NSString *)cfStr; 野指针运行下面的示例: 1234567void *p;&#123; NSObject *objc = [[NSObject alloc] init]; p = (__bridge void*)objc;&#125; NSLog(@"mark: %@", (__bridge NSObject*)p); 会直接 crash, 如图: 当 objc 这个对象超出作用域范围，其内存就会被回收，接着在作用域范围外用 void *p 去访问 objc 的内存，就造成了野指针. 结合上面所说的, 我们可以让指针 p 对 objc 进行引用即 retain 操作, 修改如下: 1234567891011void *p;&#123; NSObject *objc = [[NSObject alloc] init]; //p = (__bridge void*)objc; p = (__bridge_retained void*)objc;&#125; NSLog(@"mark: %@", (__bridge NSObject*)p); // 一定要释放CFRelease(p); 可以正常的运行. 还可以修改为另一种方式: 123456789101112void *p;&#123; NSObject *objc = [[NSObject alloc] init]; //p = (__bridge void*)objc; //p = (__bridge_retained void*)objc; p = (void *)CFBridgingRetain(objc);&#125; NSLog(@"mark: %@", (__bridge NSObject*)p); // 一定要释放CFRelease(p); 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C ARC Foundation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: iOS 推流]]></title>
    <url>%2F2018%2F02%2F26%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E6%8E%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[本篇分享是基于 音视频编程: 构建 nginx 推流服务器 这篇文章的, 之前是使用 ffmpeg 命令进行推流并且都是在 macos 上面进行的操作. 现在在 iOS 平台上使用 LFLiveKit 进行推流, 然后使用 VLC 播放器播放流视频. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 音视频编程: iOS 推流 (本篇) 基本概念一般直播过程包括对音视频的采集、处理、编码、封包、推流、传输、转码、分发、解码、播放等. 推流, 指使用推流工具把直播内容传输到服务器的过程. 本篇分享使用 LFLiveKit 工具将 iPhone 摄像头和麦克风采集的数据推流到本地流服务器. 拉流, 指对服务器直播的内容，用指定地址进行拉取(播放)的过程, 本篇分享使用 VLC 充当拉流的角色. 集成 LFLiveKitLFLiveKit 是一个开源的推流 SDK, 支持 H264 and AAC 的硬编码, 支持美颜(集成了 GPUImage). 使用 LFLiveKit 比较简单, 按照其 demo 集成即可. 1.工程配置info.plist 需要访问相机和麦克风权限. 123Privacy - Camera Usage DescriptionPrivacy - Microphone Usage Description 2.请求相机和麦克风权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)requestAccessForVideo &#123; __weak typeof(self) _self = self; AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; switch (status) &#123; case AVAuthorizationStatusNotDetermined: &#123; [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123; if (granted) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_self.session setRunning:YES]; &#125;); &#125; &#125;]; break; &#125; case AVAuthorizationStatusAuthorized: &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_self.session setRunning:YES]; &#125;); break; &#125; case AVAuthorizationStatusDenied: case AVAuthorizationStatusRestricted: // 用户明确地拒绝授权，或者相机设备无法访问 break; default: break; &#125;&#125;- (void)requestAccessForAudio &#123; AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; switch (status) &#123; case AVAuthorizationStatusNotDetermined: &#123; [AVCaptureDevice requestAccessForMediaType:AVMediaTypeAudio completionHandler:^(BOOL granted) &#123; &#125;]; break; &#125; case AVAuthorizationStatusAuthorized: &#123; break; &#125; case AVAuthorizationStatusDenied: case AVAuthorizationStatusRestricted: break; default: break; &#125;&#125; 务必要调用 LFLiveSession 的 setRunning 方法. 完整的工程代码, 后续我会放到 Github 上面. 方便有需要的下载. 推流播放上面的基本配置完成后, 可以开始推流了. 1.启动 nginx 1sudo nginx 2.启动推流 1234567- (void)startLive &#123; LFLiveStreamInfo *streamInfo = [LFLiveStreamInfo new]; streamInfo.url = sRTMPUrl; [self.session startLive:streamInfo]; self.session.beautyFace = YES;&#125; 这里的 sRTMPUrl 是一个常量定义: 1static NSString * const sRTMPUrl = @&quot;rtmp://192.168.1.102:1935/rtmplive/channel&quot;; 192.168.1.102 是我的本机(mac) ip 地址. 如果一切正常的话, 你在手机上面可以看到自己的预览画面. 3.VLC 播放 使用 VLC 播放 rtmp 的流, 打开 VLC 播放器, 选择 File/Open Network, 输入 rtmp://192.168.1.102:1935/rtmplive/channel 这个地址即可实时播放了. 这里注意一定要使用本机的 ip 地址, 不要使用 localhost:1935 类似的地址, 否则无法播放和推流. 后续分享如何在 iOS 上面使用播放器来播放直播流.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 rtmp nginx 推流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: 构建 nginx 推流服务器]]></title>
    <url>%2F2018%2F02%2F25%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本篇分享的主要内容 如何在 macos 中构建本地的推流服务器(nginx + rtmp-nginx-module), 并使用 ffmpeg 命令进行视频推流, 然后使用 VLC 播放器播放视频. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 (本篇) 安装 rtmp-nginx-module之前在测试 php 程序的时候, 我已经安装过 nginx, 但是发现这样在配置 rtmp-nginx-module 的时候, 无法成功. 配置文件修改完成之后, nginx 总是无法识别 rtmp, 报错如下: 1[emerg] 30766#0: unknown directive &quot;rtmp&quot; in /usr/local/etc/nginx/nginx.conf:40 现在需要卸载原来已经安装的 nginx, 命令如下: 1brew uninstall nginx 再次安装: 1brew install nginx-full --with-rtmp-module 耐心等待一会 ~~ nginx 的版本(nginx -v): 1nginx/1.12.2 rtmp-nginx-module 版本: 11.1.7.11-dev_2 配置 rtmp编辑 nginx 的配置文件, 文件位置位于: 1/usr/local/etc/nginx/nginx.conf 在 http {} 后面写入如下内容: 123456789101112131415rtmp &#123; server &#123; #rtmp协议的默认端口号是 1935 listen 1935; #直播流配置, 访问 path 是 rtmplive application rtmplive &#123; #开启实时 live on; #设置 rtmp 引擎的最大连接数. 默认为off max_connections 1024; #不记录数据 record off; &#125; &#125;&#125; 注意: rtmplive 是固定的. 具体的 nginx 配置详见后面的附录内容. 推流1.安装 ffmpeg 即可. 1brew install ffmpeg 这个过程有点久, 如果你没有梯子基本安装不了 [大哭]~ 2.安装 VLC 直接去官网下载 dmg 包, 安装即可. 打开 VLC 然后选择从 File/Open Network 打开文件, 如下图所示: 在弹出的框中, 写入推流地址 rtmp://localhost:1935/rtmplive/channel, 如图所示: 直接点击 Open. 注意: 如果 localhost 无法播放, 请更换为你的本机 ip, 如我的本机 ip 是 192.168.1.122, 对应的播放地址为 rtmp://192.168.1.122:1935/rtmplive/channel.如果还是无法成功, 请关闭 macos 的防火墙. 3.启动 nginx 1sudo nginx 可以在浏览器访问如下地址, 看看 nginx 是否启动成功. 1http://localhost:8080/index.html 4.ffmpeg 推流 推流的命令如下: 1ffmpeg -re -i ~/Desktop/launcher.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmplive/channel 其中 launcher.mp4 是我自己从网络上面下载的一个视频文件, 时长大约是 5 分钟. 在 VLC 中, 就可以看到推流播放的视频了. [开心]~~ 附录nginx 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log debug;pid /usr/local/var/run/nginx.pid; events &#123; worker_connections 256;&#125; http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*; include /usr/local/etc/nginx/conf.d/*; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /Users/me/workspace/projs/phpwork/; #web的根目录 index index.php index.html index.htm; &#125; &#125;&#125;rtmp &#123; server &#123; #rtmp协议的默认端口号是1935 listen 1935; #直播流配置,访问路径是rtmplive application rtmplive &#123; #开启实时 live on; #为rtmp引擎设置最大连接数.默认为off max_connections 1024; #不记录数据 record off; &#125; &#125;&#125; 视频文件使用下载的 mp4 文件, 有些无法播放, 暂时估计应该是码率的问题, 大家在测试过程中, 发现视频无法播放, 最后试试其他视频文件. 另外, 视频文件不要太小, 尽量能让其播放时长在 3-5 分钟. brew install/uninstall 报错报错信息如下: 123456Error: undefined method `patch&apos; for #&lt;Resource:0x000001040877a8&gt;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/gcc@4.9.rb:55:in `block in &lt;class:GccAT49&gt;&apos;/usr/local/Homebrew/Library/Homebrew/resource.rb:49:in `instance_eval&apos;/usr/local/Homebrew/Library/Homebrew/resource.rb:49:in `initialize&apos;/usr/local/Homebrew/Library/Homebrew/software_spec.rb:111:in `new&apos;/usr/local/Homebrew/Library/Homebrew/software_spec.rb:111:in `resource&apos; 最终的解决方案是重新安装 Homebrew, 命令如下: 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 检查本机的 ip1ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 rtmp nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSLog 格式化输出 NSInteger/NSUInteger]]></title>
    <url>%2F2018%2F02%2F22%2FNSLog-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-NSInteger-NSUInteger%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介在 Xcode 中 使用 NSLog 打印 NSInteger/NSUInteger 数据, 经常会遇到类似的警告. 如下图所示: 但是在 iphone 4s(32位)机器上就没有任何警告, 只是在64位的机型上面有这样的警告. 在 NSObjCRuntime.h 里面定义 NSInteger 和 NSUInteger 如下: 1234567#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64typedef long NSInteger;typedef unsigned long NSUInteger;#elsetypedef int NSInteger;typedef unsigned int NSUInteger;#endif 也就是说 64 位下是 long 类型，32 位下是 int 类型. 所以, 上面的代码在 32 位机型上面不会有警告. 按照 Xcode 的提示, Fix it: 12345NSUInteger iun = 3;NSLog(@"iun: %lu", (unsigned long)iun); NSInteger nsi = 6;NSLog(@"nsi: %ld", (long)nsi); 这样无论在 32 位还是在 64 位机型上面, 都没有警告了. Twitter 帖子在 twitter 有个帖子 说了另一种解决办法, 原文如下: 1%zd, %tu, %tx (signed, unsigned, hex) currently format NSInteger and NSUInteger with no warnings. 意思是使用 zd 可以格式化有符号的如 NSInteger, 使用 tu 格式化无符号的如 NSUInteger. 而 tx 可以用来格式化输出 16 进制数据. 按照这个说法, 修改如下: 12345NSUInteger iun = 3;NSLog(@"iun: %zd", iun); NSInteger nsi = 6;NSLog(@"nsi: %td", nsi); 或者这样修改: 12345NSUInteger iun = 3;NSLog(@&quot;iun: %tu&quot;, iun); NSInteger nsi = 6;NSLog(@&quot;nsi: %td&quot;, nsi); 确实没有了警告的问题. 我在实践过程中发现一个问题: 使用 zu 来格式化输出 NSUInteger, 在 32 位机器上面, 仍旧会报警告. 12NSUInteger iun = 3;NSLog(@"iun: %zu", iun); 这就让我开始怀疑 z 和 t 的可靠性了. 下面接着了解一下它们. 关于 z t关于 z t 的说明可以参考 String Format Specifiers 可以说明: 格式化 z 可以用来代表 size_t.格式化 t 可以用来代表 ptrdiff_t. ptrdiff_t 是C/C++标准库中定义的一个与机器相关的数据类型.ptrdiff_t 类型变量通常用来保存两个指针减法操作的结果, 其定义在 C99 标准中. size_t 类型用于指明数组长度, 它必须是一个正数, 而 ptrdiff_t 类型则应保证足以存放同一数组中两个指针之间的差距, 它有可能是负数. 即: size_t 是 unsigned 类型, 而 ptrdiff_t 则是 signed 整型. 12printf("size_t bytes = %d\n" ,sizeof(size_t));printf("ptrdiff_t bytes = %d\n" ,sizeof(ptrdiff_t)); 在 32 位机型中输出结果: 12size_t bytes = 4ptrdiff_t bytes = 4 在 64 位机型中输出结果: 12size_t bytes = 8ptrdiff_t bytes = 8 这说明, sizet_t 和 ptrdiff_t 是和机器类型相关的跨平台的. 系统定义: 12typedef __SIZE_TYPE__ size_t;typedef __PTRDIFF_TYPE__ ptrdiff_t; 32 位机型定义: 12#define __SIZE_TYPE__ long unsigned int#define __PTRDIFF_TYPE__ int 64 位机型定义: 12#define __SIZE_TYPE__ long unsigned int#define __PTRDIFF_TYPE__ long int 终极解决方案既然在 Xcode 里面提示 Fix it 可以使用, 那么为了提高代码的健壮性和可维护性, 可以定义宏定义来解决. 宏定义如下: 1234567#if __LP64__#define MZNSI @"ld"#define MZNSU @"lu"#else#define MZNSI @"d"#define MZNSU @"u"#endif //__LP64__ 使用方法, 如下: 1234NSInteger nsi = 6;NSUInteger iun = 3;NSLog(@"NSInteger nsi = %"MZNSI, nsi);NSLog(@"NSUInteger iun = %"MZNSU, iun); 附录给出常用的格式化打印输出字符串中的格式符, 如下所示: 1）%c：对应参数是一个 int 类型，但实际运行时会将该 int类型对象转换为 unsigned char 类型. 2）%d 或者 %i：对应参数是一个 int 类型. 只不过, %d 一般用于十进制, %i 可以对应各种进制的数据. 二者在打印输出上面没有什么太大的差别. 但是在接收输入(scanf)上, %d 用于十进制, %i 对应各种进制的数据. 可以参考 Difference between %d and %i format specifier in C language 这篇文章. 3）%f：对应参数是一个 double 类型. 4）%ld：对应参数是一个 long int 类型. 5）%s：对应参数是一个 const char* 类型，表示输出一个字符串. 6）%u：对应参数是一个 unsigned int 类型. 7）%zu：对应参数是一个 size_t 类型. 8）%td：对应参数是一个 ptrdiff_t 类型. 9）%x（或 %X）：对应参数是一个 int 类型，不过会以十六进制形式输出，其中大于 9 的数字根据字母 x 大小写进行转换，如果是 %x，则大于 9 的数用 a～f 表示；如果是 %X，则用 A～F 表示. 10）%%：输出一个 % 符号. 推荐Apple：String Format Specifiers 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSLog printf scanf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: iOS 使用 faad2]]></title>
    <url>%2F2018%2F02%2F20%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介本次分享使用 faad2 解码 AAC 音频文件, 将 AAC 文件转换为 WAV 文件并使用 AVAudioPlayer 进行播放。 在博文 音视频编程: 简单分析 WAV 文件 给大家简单的分析了一下 WAV 的数据头协议, 其实也是为了这篇博文来服务的, 所以阅读本文之前, 建议先看上文。 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 (本篇) 音视频编程: 构建 nginx 推流服务器 例子介绍本文以一个实际的例子, 使用 faad2的各个函数来解码 AAC 数据. 主要有以下几个步骤: 获取输入文件 获取 faad 解码器句柄 初始化 faad 解码器 根据文件解析文件帧, 并写入输出文件中 写入文件头将其封装为 WAV 格式的音频文件 关闭 faad 解码器句柄 工程实战引入 faad2将编译好的 faad2 导入工程即可. 其中关键的 API 在 neaacdec.h 中有描述. 工程效果图: 编码实现在 音视频编程: 简单分析 WAV 文件 中已经定义了 WAV 的数据头. 12345678910111213141516struct MZWavAudioFileHeader&#123; char riff[4]; // 字符串 "RIFF" uint32_t totalLength; // 文件总大小, 包括PCM 数据大小和该文件头大小 char wave[4]; // 字符串 "WAVE" char fmt[4]; // 字符串 "fmt " uint32_t format; // WAV 头大小, 固定为值 16 uint16_t pcm; // PCM 编码方式, 固定值为 1 uint16_t channels; // 声道数量, 为 2 uint32_t frequency; // 采样频率 uint32_t bytes_per_second; // 每秒字节数(码率), 其值=采样率x通道数x位深度/8 uint16_t bytes_by_capture; // 采样块大小 uint16_t bits_per_sample; // 采样点大小, 这里是 16 位 char data[4]; // 字符串 "data" uint32_t bytes_in_pcmdata; // pcm 数据长度&#125;; 现在实现写入数据头的方法 mz_write_wav_header 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 写入 wav 头数据. * * @param file wav 文件指针. * @param total_samples_per_channel 每个声道的采样数. * @param samplerate 采样率. * @param channels 声道数. */void mz_write_wav_header(FILE *file, int total_samples_per_channel, int samplerate, int channels) &#123; if (NULL == file) &#123; return; &#125; if (total_samples_per_channel &lt;= 0) &#123; return; &#125; printf("FAAD. total_samples_per_channel: %i, samplerate: %i, channels: %i\n", total_samples_per_channel, samplerate, channels); struct MZWavAudioFileHeader wavHeader; // 写入 RIFF strcpy(wavHeader.riff, "RIFF"); wavHeader.bits_per_sample = 16; wavHeader.totalLength = (total_samples_per_channel * channels * wavHeader.bits_per_sample/8) + sizeof(wavHeader) - 8; // 写入 WAVE 和 fmt strcpy(wavHeader.wave, "WAVE"); strcpy(wavHeader.fmt, "fmt "); wavHeader.format = 16; wavHeader.pcm = 1; wavHeader.channels = channels; wavHeader.frequency = samplerate; // 每秒的字节数(码率)=采样率x通道数x位深度/8 wavHeader.bytes_per_second = wavHeader.channels * wavHeader.frequency * wavHeader.bits_per_sample/8; wavHeader.bytes_by_capture = wavHeader.channels*wavHeader.bits_per_sample/8; wavHeader.bytes_in_pcmdata = total_samples_per_channel * wavHeader.channels * wavHeader.bits_per_sample/8; // 写入 data strcpy(wavHeader.data, "data"); fwrite(&amp;wavHeader, 1, sizeof(wavHeader), file);&#125; 解码主要用到了 FAAD2 中的 NeAACDecDecode 函数. 函数原型如下: 1234void* NEAACDECAPI NeAACDecDecode(NeAACDecHandle hDecoder, NeAACDecFrameInfo *hInfo, unsigned char *buffer, unsigned long buffer_size); 对应帧定义的结构体: NeAACDecFrameInfo, 定义如下: 123456789101112131415161718192021222324252627typedef struct NeAACDecFrameInfo&#123; unsigned long bytesconsumed; unsigned long samples; unsigned char channels; unsigned char error; unsigned long samplerate; /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */ unsigned char sbr; /* MPEG-4 ObjectType */ unsigned char object_type; /* AAC header type; MP4 will be signalled as RAW also */ unsigned char header_type; /* multichannel configuration */ unsigned char num_front_channels; unsigned char num_side_channels; unsigned char num_back_channels; unsigned char num_lfe_channels; unsigned char channel_position[64]; /* PS: 0: off, 1: on */ unsigned char ps;&#125; NeAACDecFrameInfo; 具体的解码实现, 我放到了 Github 上面了, 大家可以去 这里 查看. 麻烦 解码 aac, 解决采样频率和通道数不对的问题 1234//防止采样频率加倍NeAACDecConfigurationPtr conf = NeAACDecGetCurrentConfiguration(decoder);conf-&gt;dontUpSampleImplicitSBR = 1;NeAACDecSetConfiguration(decoder, conf); 123456//从双声道的数据中提取单通道 for(i=0,j=0; i&lt;4096 &amp;&amp; j&lt;2048; i+=4, j+=2) &#123; frame_mono[j]=pcm_data[i]; frame_mono[j+1]=pcm_data[i+1];&#125; 具体可以查阅 FAAD2 的源码. 感谢 使用FAAD库解码AAC实例及 及 faad解码后的通道数不正确的问题 提供.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 wav pcm faad2 aac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: 简单分析 WAV 文件]]></title>
    <url>%2F2018%2F02%2F20%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 这篇分享是下篇 音视频编程: iOS 使用 faad2 的预备知识, 如果要解码 WAV 文件, 首先需要了解一下 WAV 音频文件的格式。 今天说的是 线性 PCM 对应的 WAV 格式的数据。 PCM 的种类 线性化 PCM A律量化的 PCM U律量化的 PCM AD PCM GSM 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件(本篇) 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 WAV 简介WAV 只是该音频文件的后缀名, 其完整名称缩写是 WAVE，WAVE(Waveform Audio File Format), 采用RIFF（Resource Interchange File Format）文件格式结构。 WAV 格式的音频文件通常用来保存 PCM 格式的原始音频数据，通常被称之为无损音频。 WAV 音频文件, 粗略来说是 WAV 数据头 + PCM 数据组成的. 裸数据 PCM 外面包了一层文件头，WAV 实质为一个 RIFF 文件. WAV 数据头关于 WAV 音频文件的数据头定义如下图所示: 最前面的4个字节用来标示是 RIFF 字符串。 可以看出, 一般的 WAV 文件的数据头为 44 个字节, 其后面跟的是 PCM 数据。 分析 WAV 数据头使用 hexdump 来看一下 WAV 文件的数据头。 在当前路径下, 有个 wav 格式的音频文件 m.wav, 使用 hexdump 分析一下. 1hexdump -n 44 m.wav 其中, -n 44 表示查看前 44 个字节. 按字节分组的图, 如下所示: 152 49 46 46 分别是 RIFF 的 ASCII 码. 跟在 RIFF 后面的四个字节是文件的大小信息, 我们先使用 ls 命令看一下该文件的大小。 1ls -al 输出文件大小为(字节数): 1080808 1staff 1080808 Jan 25 15:44 m.wav RIFF 后面的四个字节分别是: e0 7d 10 00, 由于该存储使用了小端序(Little-Endian 存储，也就是说对其中的数据，低位字节在前，高位字节在后), 所以16进制表示为: 0x00107de0, 对应的字节大小是 1080808. 上面说到, 线性 PCM, 其实在该文件头中, 第17到第第22个字节(上图红色的5和6组合)标示了 PCM 的类型, 即: 110 00 00 00 01 00 其他类型的 PCM 类型定义为: A律量化的PCM: 12 00 00 0006 00U律量化的PCM: 12 00 00 00 07 00AD PCM: 32 00 00 00 02 00GSM: 14 00 00 00 31 00 最后4个字节表示真正 PCM 数据的文件大小, 即: 0x00107dbc, 其10进制大小为: 1080764, 用总文件大小减去 1080764, 就是文件头的大小, 如下: 11080808 - 1080764 = 44 其他对应的数据, 大家可以对照表自行分析。 定义数据头 数据类型 char 占用 1 个字节 uint32_t 占用 4 个字节 uint16_t 占用 2 个字节 这里使用结构体定义 WAV 文件头, 其定义如下: 12345678910111213141516struct MZWavAudioFileHeader&#123; char riff[4]; // 字符串 "RIFF" uint32_t totalLength; // 文件总大小, 包括PCM 数据大小和该文件头大小 char wave[4]; // 字符串 "WAVE" char fmt[4]; // 字符串 "fmt " uint32_t format; // WAV 头大小, 固定为值 16 uint16_t pcm; // PCM 编码方式, 固定值为 1 uint16_t channels; // 声道数量, 为 2 uint32_t frequency; // 采样频率 uint32_t bytes_per_second; // 每秒字节数(码率), 其值=采样率x通道数x位深度/8 uint16_t bytes_by_capture; // 采样块大小 uint16_t bits_per_sample; // 采样点大小, 这里是 16 位 char data[4]; // 字符串 "data" uint32_t bytes_in_pcmdata; // pcm 数据长度&#125;; 可以使用下面代码来计算该结构体所占的字节数(结果是44): 1int wav_header_size = sizeof(struct MZWavAudioFileHeader);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 wav pcm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: iOS 使用 faac 编码]]></title>
    <url>%2F2018%2F02%2F16%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[简介本文分享如何将 WAV 格式的音频文件转换(编码)为 AAC 格式的音频文件并使用 AVAudioPlayer 播放编码后的文件. 这里的编码功能使用 faac 这个库来实现. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码(本篇) 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 函数介绍 获取 faac 的版本 1int FAACAPI faacEncGetVersion(char **faac_id_string, char **faac_copyright_string); 示例: 1234char *version;char *copyright;faacEncGetVersion(&amp;version, &amp;copyright);printf(&quot;FAAC version: %s, copyright: %s&quot;, version, copyright); 打印结果: 1234FAAC version: 1.28, copyright: FAAC - Freeware Advanced Audio Coder (http://www.audiocoding.com/)Copyright (C) 1999,2000,2001 Menno BakkerCopyright (C) 2002,2003 Krzysztof NikielThis software is based on the ISO MPEG-4 reference source code. 打开并初始化 faac 编码器 12345678// sampleRate: 采样率// numChannels: 通道数量，1-单声道 2-立体声// inputSamples: 编码后的数据长度// maxOutputBytes: 编码后的信息最大长度faacEncHandle FAACAPI faacEncOpen(unsigned long sampleRate, unsigned int numChannels, unsigned long *inputSamples, unsigned long *maxOutputBytes); 该函数返回一个 faac 编码器句柄. 其很多函数都需要这个句柄. 关闭 faac 编码器 1int FAACAPI faacEncClose(faacEncHandle hEncoder); 将开启 faac 编码器返回的句柄传入即可. 获取配置和设置配置 123456faacEncConfigurationPtr FAACAPI faacEncGetCurrentConfiguration(faacEncHandle hEncoder);int FAACAPI faacEncSetConfiguration(faacEncHandle hEncoder, faacEncConfigurationPtr config); faac 的配置被定义为了一个结构体 faacEncConfiguration, 大家可以看源码. 编码(编码一帧音频数据) 12345678// hEncoder: faacEncOpen 返回的编码器句柄// inputBuffer: 输入信息缓冲区// samplesInput: faacEncOpen编码后的数据长度，即缓冲区长度// outputBuffer: 编码后输出信息缓冲区// bufferSize: 输出信息长度int FAACAPI faacEncEncode(faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput, unsigned char *outputBuffer, unsigned int bufferSize); 实例可以自己新建一个 iOS 工程. 准备好一个 wav 格式的音频文件. 效果如下图所示: 新建一个 C++ 文件, MZCodec. MZCodec.hpp 12345678#ifndef MZCodec_hpp#define MZCodec_hpp#include &lt;stdio.h&gt;int codeWAV(const char *srcFilePath, const char *destPath);#endif /* MZCodec_hpp */ MZCodec.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &quot;MZCodec.hpp&quot;#include &quot;faac.h&quot;#include &lt;stdio.h&gt;int codeWAV(const char *srcFilePath, const char *destPath) &#123; unsigned long nSampleRate = 44100;//采样率 unsigned int nChannels = 2;//声道数 unsigned int nPCMBitSize = 16;//单样本位数 unsigned long nInputSamples = 0; unsigned long nMaxOutputBytes = 0; int nRet; faacEncHandle hEncoder; faacEncConfigurationPtr pConfiguration; size_t nBytesRead; unsigned long nPCMBufferSize; unsigned char *pbPCMBuffer; unsigned char *pbAACBuffer; FILE *fpIn; // WAV file for input FILE *fpOut; // AAC file for output /// 获取 faac 版本信息 &#123; char *version; char *copyright; faacEncGetVersion(&amp;version, &amp;copyright); printf(&quot;FAAC version: %s, copyright: %s&quot;, version, copyright); &#125; fpIn = fopen(srcFilePath, &quot;rb&quot;); if (NULL == fpIn) &#123; return -2; &#125; fpOut = fopen(destPath, &quot;wb&quot;); /// 1. 打开 FAAC hEncoder = faacEncOpen(nSampleRate, nChannels, &amp;nInputSamples, &amp;nMaxOutputBytes); if (NULL == hEncoder) &#123; printf(&quot;[ERROR] Failed to call faacEncOpen()\n&quot;); return -1; &#125; nPCMBufferSize = nInputSamples * nPCMBitSize / 8; pbPCMBuffer = new unsigned char[nPCMBufferSize]; pbAACBuffer = new unsigned char[nMaxOutputBytes]; /// 2.1. 获取当前的编码器配置 pConfiguration = faacEncGetCurrentConfiguration(hEncoder); pConfiguration-&gt;inputFormat = FAAC_INPUT_16BIT; // 对象类型只有为 LOW, iOS 的 AVAudioPlayer 才能播放 pConfiguration-&gt;aacObjectType = LOW; // 0 = Raw; 1 = ADTS pConfiguration-&gt;outputFormat = 1; pConfiguration-&gt;mpegVersion = MPEG4; pConfiguration-&gt;useTns = 1; pConfiguration-&gt;bitRate = 30; /// 2.2. 配置编码器 nRet = faacEncSetConfiguration(hEncoder, pConfiguration); //是wav格式, 先读取前面的 fseek(fpIn, 58, SEEK_SET); do &#123; //读入的实际字节数，最大不会超过 nPCMBufferSize nBytesRead = fread(pbPCMBuffer, 1, nPCMBufferSize, fpIn); //输入样本数，用实际读入字节数计算 //一般只有读到文件尾时才不是 nPCMBufferSize/(nPCMBitSize/8) nInputSamples = nBytesRead / (nPCMBitSize / 8); /// 3. 编码 nRet = faacEncEncode(hEncoder, (int *)pbPCMBuffer, (unsigned int)nInputSamples, pbAACBuffer, (unsigned int)nMaxOutputBytes); fwrite(pbAACBuffer, 1, nRet, fpOut); printf(&quot;FaacEncEncode returns %d\n&quot;, nRet); &#125; while (nBytesRead &gt; 0); /// 4. 关闭 FAAC nRet = faacEncClose(hEncoder); delete[] pbPCMBuffer; delete[] pbAACBuffer; fclose(fpIn); fclose(fpOut); return 0;&#125; 使用 MZCodec 的 Controller 需要命名为 .mm 文件. ViewController.mm 12345678910111213141516NSBundle *bundle = [NSBundle mainBundle];NSString *resPath = [bundle pathForResource:@&quot;m&quot; ofType:@&quot;wav&quot;];NSLog(@&quot;The path of wav file: %@&quot;, resPath); NSArray&lt;NSString *&gt; *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *destPath = [[docPath lastObject] stringByAppendingString:@&quot;/out.aac&quot;];NSLog(@&quot;The path of aac file: %@&quot;, destPath); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; codeWAV([resPath UTF8String], [destPath UTF8String]); dispatch_async(dispatch_get_main_queue(), ^&#123; //转换完成. &#125;);&#125;); 编码过程需要点时间, 如果文件很大, 时间越久. 所以, 新开线程来进行编码. 编码完成后, 可在对应的沙盒目录找到 out.aac 文件. 具体代码在 Github 上面, 感兴趣的可以点击 前往. 注意事项这个 aacObjectType 需要注意, 之前我在这里折腾了很久. 1pConfiguration-&gt;aacObjectType = LOW; 如果设置为其他三种, 编码后的 aac 文件, AVAudioPlayer 播放不了, 初始化 AVAudioPlayer 就会报错, 报错信息如下:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 faac faad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: 编译 faac/faad2]]></title>
    <url>%2F2018%2F02%2F14%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2%2F</url>
    <content type="text"><![CDATA[本文分享如何在 MacOS 上面编译 faac 和 faad2, 编译后的库文件可以直接在 iOS 上面使用. 后续会分享如何编译给 Android 使用的库文件的方法以及实战. 该系列博文: 音视频编程: 编译 faac/faad2(本篇) 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 简介faad 是 AAC 格式文件的音频解码库. 相对于 FFmpeg 来说比较轻量和简单. 编译出来全平台静态库文件较小, API 也比较简单, 缺点是功能单一, 只能处理 AAC 格式的音频文件。 faac 是与之对应的 AAC 音频编码库. 支持 MPEG-4 和 MPEG-2 的AAC 编码，其特性包括：可移植性好，快速，支持LC/Main/LTP，通过 Dream 支持 DRM. 这两个库虽然很久没有更新了, 但是其功能已经满足很多业务场景了, 并且很好用。 下载源码点击 源码链接 即可下载源码 自从 2020.08 后该网站已经无法访问了，可以从 What Happened to Audiocoding.com (FAAC &amp; FAAD2) 了解一下。 可以从 Sourceforge.net 下载。 编译 faac下载完成后, 解压, 将 faac-1.28 放到新建目录 src 下面即可, 目录结构如下: 修改 build_faac.sh 权限: 1chmod +x build_faac.sh 编辑 build_faac.sh 内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/bin/sh # http://www.linuxfromscratch.org/blfs/view/svn/multimedia/faac.html # ftp://mirror.ovh.net/gentoo-distfiles/distfiles/ major=1 minor=28 micro= XCD_ROOT=&quot;/Applications/Xcode.app/Contents/Developer&quot; TOL_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain&quot; #修改为最新的 sdk 版本SDK_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.2.sdk&quot; SDK_SML_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk&quot; export PATH=$TOL_ROOT/usr/bin:$PATH work=`pwd` srcs=$work/src buid=$work/build insl=$buid/install name=faac-$&#123;major&#125;.$&#123;minor&#125; pakt=$&#123;name&#125;.tar.gz dest=$work/faac-iOS-$&#123;major&#125;.$&#123;minor&#125;.$&#123;micro&#125;.tgz rm -rf $srcs $buid $dest &amp;&amp; mkdir -p $srcs $buid archs=&quot;i386 x86_64 armv7 armv7s arm64&quot; for a in $archs; do case $a in arm*) sys_root=$&#123;SDK_ROOT&#125; host=arm-apple-darwin ;; i386|x86_64) sys_root=$&#123;SDK_SML_ROOT&#125; host=$a-apple-darwin ;; esac prefix=$insl/$a &amp;&amp; rm -rf $prefix &amp;&amp; mkdir -p $prefix rm -rf $srcs &amp;&amp; mkdir -p $srcs &amp;&amp; cd $work &amp;&amp; tar xvzf $pakt -C $srcs &amp;&amp; cd $srcs/$name export CC=&quot;$TOL_ROOT/usr/bin/clang -arch $a -isysroot $sys_root&quot; export CXX=&quot;$TOL_ROOT/usr/bin/clang++ -arch $a -isysroot $sys_root&quot; export CXXFLAGS=&quot;-arch $a -isysroot $sys_root&quot; export CFLAGS=&quot;-arch $a -isysroot $sys_root&quot; export LDFLAGS=&quot;-isysroot $sys_root&quot; export LIBS=&quot;-L$&#123;sys_root&#125;/usr/lib&quot; chmod +x bootstrap ./bootstrap \ &amp;&amp;./configure \ --host=$host \ --with-sysroot=$sys_root \ --prefix=$prefix \ --disable-shared \ --enable-static \ --disable-faac \ --with-mp4v2 \ &amp;&amp;make &amp;&amp; make install lipo_archs=&quot;$lipo_archs $prefix/lib/libfaac.a&quot; echo &apos;continue any key pressed..&apos; read -n 1done univ=$insl/universal &amp;&amp; mkdir -p $univ/lib cp -r $prefix/include $univ/ lipo $lipo_archs -create -output $univ/lib/libfaac.a ranlib $univ/lib/libfaac.a strip -S $univ/lib/libfaac.a cd $univ &amp;&amp; tar cvzf $dest * 执行 ./build_faac.sh, 开始编译。 编译成功后, 生成 build 目录。 其中, universal 生成的库是通用库。 编译 faad2解压后, 将 faad2-2.7 改名为 faad. 编写编译的脚本文件, 这里取名为 build_fadd2.sh 1touch build_fadd2.sh 编辑 build_fadd2.sh 文件。 写入如下内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/bin/shCONFIGURE_FLAGS=&quot;--enable-static --with-pic&quot;ARCHS=&quot;arm64 armv7s armv7 x86_64 i386&quot;# directoriesSOURCE=&quot;faad&quot;FAT=&quot;fat-faad&quot;SCRATCH=&quot;scratch-faad&quot;# must be an absolute pathTHIN=`pwd`/&quot;thin-faad&quot;COMPILE=&quot;y&quot;LIPO=&quot;y&quot;if [ &quot;$*&quot; ]thenif [ &quot;$*&quot; = &quot;lipo&quot; ]then# skip compileCOMPILE=elseARCHS=&quot;$*&quot;if [ $# -eq 1 ]then# skip lipoLIPO=fififiif [ &quot;$COMPILE&quot; ]thenCWD=`pwd`for ARCH in $ARCHSdoecho &quot;building $ARCH...&quot;mkdir -p &quot;$SCRATCH/$ARCH&quot;cd &quot;$SCRATCH/$ARCH&quot;if [ &quot;$ARCH&quot; = &quot;i386&quot; -o &quot;$ARCH&quot; = &quot;x86_64&quot; ]thenPLATFORM=&quot;iPhoneSimulator&quot;CPU=if [ &quot;$ARCH&quot; = &quot;x86_64&quot; ]thenSIMULATOR=&quot;-mios-simulator-version-min=7.0&quot;HOST=&quot;--host=x86_64-apple-darwin&quot;elseSIMULATOR=&quot;-mios-simulator-version-min=5.0&quot;HOST=&quot;--host=i386-apple-darwin&quot;fielsePLATFORM=&quot;iPhoneOS&quot;if [ $ARCH = &quot;armv7s&quot; ]thenCPU=&quot;--cpu=swift&quot;elseCPU=fiSIMULATOR=HOST=&quot;--host=arm-apple-darwin&quot;fiXCRUN_SDK=`echo $PLATFORM | tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;`CC=&quot;xcrun -sdk $XCRUN_SDK clang -Wno-error=unused-command-line-argument-hard-error-in-future&quot;AS=&quot;$CWD/$SOURCE/extras/gas-preprocessor.pl $CC&quot;CFLAGS=&quot;-arch $ARCH $SIMULATOR&quot;CXXFLAGS=&quot;$CFLAGS&quot;LDFLAGS=&quot;$CFLAGS&quot;CC=$CC CFLAGS=$CXXFLAGS LDFLAGS=$LDFLAGS CPPFLAGS=$CXXFLAGS CXX=$CC CXXFLAGS=$CXXFLAGS $CWD/$SOURCE/configure \$CONFIGURE_FLAGS \$HOST \--prefix=&quot;$THIN/$ARCH&quot; \--disable-shared \--without-mp4v2make clean &amp;&amp; make &amp;&amp; make install-stripcd $CWDdonefiif [ &quot;$LIPO&quot; ]thenecho &quot;building fat binaries...&quot;mkdir -p $FAT/libset - $ARCHSCWD=`pwd`cd $THIN/$1/libfor LIB in *.adocd $CWDlipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIBdonecd $CWDcp -rf $THIN/$1/include $FATfi 给予执行权限: 1chmod +x build_fadd2.sh 此时目录结构如下: 执行编译脚本, 在当前目录生成 scratch-faad 和 fat-faad 以及 thin-faad 目录, 如下: 使用 fat-faad 里面的库和文件即可。 可以使用下面的命令查看对应的 .a 文件所支持的架构: 1lipo -info libfaad.a 会得到对应的输出: 1Architectures in the fat file: libfaad.a are: i386 armv7 armv7s arm64 同样可以查看 libfaac.a. 后记编译好的文件, 已经放到 github 上面了, 有需要的可以下载使用, 点击 下载链接 进入。 感谢 fflydev/faac-ios-build 提供编译 faac 的 shell, 只需要将里面对应的 SDK 改为本机最新的 SDK 即可。 参考文章 faac 1.28的交叉编译与问题解决 使用FAAD库解码AAC实例 在Linux上使用FDK AAC將音樂轉成M4A(AAC、HE-AAC、HE-AACv2)格式 aac文件转码为wav文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 faac faad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程: 初步认识]]></title>
    <url>%2F2018%2F02%2F12%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[几乎每个编程语言或者平台都会遇到多线程的问题, 说明多线程是一个非常重要且开发者必须了解和掌握的. 多线程也是面试官比较喜欢问的问题, 例如: 进程和线程的区别, Android 是否支持多进程? 线程池如何实现的? 锁机制? 多线程之间如何通信? 谈及 iOS 中的多线程，一般说的是 pthread，NSthread，GCD，NSOperation 这四种, 用的最多也最方便的就是 GCD 了. 关于这四者, 后续会为大家一一分享. phtread 是跨平台的, C/C++ 中都有它的声影, GCD 和 NSOperation 都是常用的，NSOperation 是基于 GCD 的. GCD 的核心概念是将一个任务添加到队列，指定任务执行的方法，然后执行, NSOperation 则是直接将一个操作添加到队列中. 该系列文章来跟大家分享关于 iOS 中的多线程. iOS 多线程: 初步认识(本篇) 进程和线程进程和线程的定义, 大家可以自行到维基百科上面去查. 这里只说二者的区别. 一个程序至少有一个进程, 一个进程至少有一个线程如主线程. 多线程程序的并发性高. 进程在执行过程中拥有独立的内存单元，而多线程是共享内存的，从而极大地提高了程序的运行效率. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口. 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制. 操作系统并没有将多个线程看做多个独立的应用, 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行, 从而实现了进程的调度和管理以及资源分配. 队列iOS 中, 队列主要分为: 全局队列 主队列. 串行队列. 并发队列. Concurrent:tasks are dequeued in FIFO order, but run concurrently and can finish in any order. Serial: .tasks execute one at a time in FIFO order 并发: 任务以 FIFO 从序列中移除，然后并发运行，可以按照任何顺序完成. 串行: 任务以FIFO从序列中一个一个执行. 一次只调度一个任务. 在 iOS 中, 并发不一定会开启多个线程, 串行也不一定只开启一个线程. 因为这里会牵扯到是异步还是同步执行. 主队列, 即 mainQueue. Returns the default queue that is bound to the main thread. 会关联主线程. 全局队列, 即 globalQueue. The well-known global concurrent queues may not be modified. 全局队列中执行不一定会开启新线程. 同步和异步在 iOS 的 GCD 中, 还有同步和异步执行的区别. 同步 同步执行代码块, 诸如 dispatch_async 中执行的. 异步 异步执行代码块, 诸如 dispatch_sync 中执行的. 创建队列的方法创建主队列 1dispatch_queue_t dispatch_get_main_queue(void); 创建全局队列 1dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags); 参数 identifier 用来表示优先级. 对应的优先级为: DISPATCH_QUEUE_PRIORITY_HIG DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW DISPATCH_QUEUE_PRIORITY_BACKGROUND 如果传入 0 标示 DISPATCH_QUEUE_PRIORITY_DEFAULT. 参数 flags 是一个保留参数, API 文档要求传入 0, 非0值可能会导致返回结果为 NULL. 自定义队列 dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr); 参数 label 是一个字符串. 参数 attr 用来标示是串行还是并行队列. 可以从 DISPATCH_QUEUE_SERIAL, DISPATCH_QUEUE_CONCURRENT 二者中取值. 如果该参数传入 NULL, 默认是 DISPATCH_QUEUE_SERIAL 串行队列. 串行队列中的线程串行队列到底是开了一个线程, 还是开了多个线程, 我们一探究竟. 先看例子1 12345678dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL); for (int i=0; i&lt;10; i++) &#123; dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]); &#125;);&#125; 可以看出, 只开启一个新线程. 再看例子2 12345678910dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]); sleep(2);&#125;);dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);&#125;); 可以看出, 也只开启一个新线程. 改造一下例子2, 将其中的一个异步改为同步 12345678910dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]); sleep(2);&#125;);dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);&#125;); 可以看出, 同步的执行在主线程, 二者并不是在一个线程中执行. 所以, 串行队列中执行的代码, 不一定都在子线程中, 如果是异步都是同一个线程中执行.如果是同步的话, 会在主线程中执行. 同理, 并行队列中的异步执行会开启多个线程来执行. 执行方式和队列这里的执行方式指的是同步或者异步执行. 先看异步执行 12345678910111213141516171819202122232425/// 异步全局队列和主队列 &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 1 NSLog(@&quot;dispatch_async. mainQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 0 NSLog(@&quot;dispatch_async. globalQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; /// 异步串行和并行队列 &#123; dispatch_async(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; // 0 NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); dispatch_async(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123; // 0 NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_CONCURRENT. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; 再看同步执行 12345678910111213141516171819202122232425262728/// 同步全局队列和主队列 &#123; #if 0 // 会死锁 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;dispatch_sync. mainQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); #endif dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; // 1 NSLog(@&quot;dispatch_sync. globalQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; /// 同步串行和并行队列 &#123; dispatch_sync(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; // 1 NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); dispatch_sync(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123; // 1 NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_CONCURRENT. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; 得出结论 任何队列的同步执行, 都没有开启新线程, 在主线程中执行. 主队列的同步执行会造成死锁. 主队列的异步执行, 没有开启新线程. 在主线程中执行. 串行和并行以及全局队列的异步执行, 都会开启新线程. 参考 进程和线程的区别 进程与线程的一个简单解释]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 多线程 进程 GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++: 如何相互调用]]></title>
    <url>%2F2018%2F02%2F12%2FC-C-%E5%A6%82%E4%BD%95%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 简介C++ 中调用 C 比较简单. 但是 C 调用 C++ 稍微复杂一些. C 调用 C++ 分为可以调用 C++ 类中的函数和普通 cpp 中的函数. 无论是哪种函数, 我们都可以使用封装了 C++ 的文件作为适配供给 C 来使用. 下面看具体的例子. C++ 调用 C首先创建 CFile.h 和 CFile.c 文件. CFile.h 12345678#ifndef CFile_h#define CFile_h#include &lt;stdio.h&gt;extern void start_c(int cmd);#endif /* CFile_h */ CFile.c 123456#include &quot;CFile.h&quot;void start_c(int cmd) &#123; printf(&quot;start_c by cmd: %i\n&quot;, cmd);&#125; 在 C++ 文件中调用 C 代码, 示例如下: main.cpp 12345678910extern &quot;C&quot; &#123;#include &quot;CFile.h&quot;&#125;int main(int argc, const char * argv[]) &#123; start_c(1); return 0;&#125; 这里可以看到导入 C 文件的方式: 123extern &quot;C&quot; &#123;#include &quot;CFile.h&quot;&#125; 如果直接导入, 如: 12345678#include &quot;CFile.h&quot;int main(int argc, const char * argv[]) &#123; start_c(1); return 0;&#125; 编译报错: 1234Undefined symbols for architecture x86_64: &quot;start_c(int)&quot;, referenced from: _main in main.old: symbol(s) not found for architecture x86_64 这里的 extern &quot;C&quot; 告诉编译器, 要按照 C 的链接约定，而不是 C++ 的链接约定. C 编译器不支持 extern &quot;C&quot;. C 调用普通 C++ 的函数C 调用 C++ 有点曲折. CPPFile.hpp 123456#ifndef CPPFile_hpp#define CPPFile_hppvoid start_cpp(int cmd);#endif /* CPPFile_hpp */ CPPFile.cpp 123456789#include &quot;CPPFile.hpp&quot;#include &lt;iostream&gt;using namespace std;void start_cpp(int cmd) &#123; cout &lt;&lt; &quot;start_cpp by cmd: &quot; &lt;&lt; cmd &lt;&lt; endl;&#125; 这里需要写一个中间的 cpp(CPPAdapter.cpp)文件, 提供方法给 C 来使用. 注意: 这里没有 CPPAdapter.hpp 头文件. CPPAdapter.cpp 123456789101112131415#include &quot;CPPFile.hpp&quot;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif void adapter_start_cpp(int cmd) &#123; //调用 CPPFile 中的方法 start_cpp(cmd); &#125; #ifdef __cplusplus&#125;#endif 然后在 C 中调用 C++ 的代码: CFile.c 12345678910#include &quot;CFile.h&quot;//声明函数extern void adapter_start_cpp(int cmd);void start_c(int cmd) &#123; //调用 c++ 代码 adapter_start_cpp(5);&#125; C 调用 C++ 类中的方法和上面例子的原理一样的. CPPClassFile.hpp 1234567891011121314151617181920#ifndef CPPClassFile_hpp#define CPPClassFile_hpp#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;private: string name; public: Person(); ~Person(); int setName(string name);&#125;;#endif /* CPPClassFile_hpp */ CPPClassFile.cpp 1234567891011121314151617181920#include &quot;CPPClassFile.hpp&quot;Person::Person() &#123; cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;&#125;Person::~Person() &#123; cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;&#125;int Person::setName(string name) &#123; this-&gt;name = name; cout &lt;&lt; &quot;Set name: &quot; &lt;&lt; name &lt;&lt; endl; return 0;&#125; CPPAdapter.cpp 12345678910111213141516171819202122232425#include &quot;CPPFile.hpp&quot;#include &quot;CPPClassFile.hpp&quot;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif void adapter_start_cpp(int cmd) &#123; //调用 CPPFile 中的方法 start_cpp(cmd); &#125; int adapter_set_name(const char *cName) &#123; Person *person = new Person(); int ret = person-&gt;setName(cName); delete person; return ret; &#125; #ifdef __cplusplus&#125;#endif 在 C 中可以调用了, 如下代码: CFile.c 123456789101112131415161718#include &quot;CFile.h&quot;///声明 CPPFile 中的方法extern void adapter_start_cpp(int cmd);///声明 CPPClassFile 中的方法extern int adapter_set_name(const char *cName);void start_c(int cmd) &#123; printf(&quot;start_c by cmd: %i\n&quot;, cmd); //调用 CPPFile 中的方法 adapter_start_cpp(5); //调用 CPPClassFile 中的方法 adapter_set_name(&quot;www.veryitman.com&quot;);&#125; extern “C”extern &quot;C&quot; 中的 “C” 并不表示 C 语言，”C” 表示的是一种链接约定. extern &quot;C&quot; 指令描述的是一种链接约定，它并不影响调用函数的定义，即使做了该声明，对函数类型的检查和参数转换仍要遵循 C++ 的标准，而不是 C 的标准. 不同的编程语言(编译型)链接特性是不同的，这也决定了它们编译后的链接符号的不同. 如函数 void function(int d)，C 语言会把它编译成类似 _function 这样的符号，C 链接器只要找到该函数符号就可以链接成功. C++ 会把这个函数编译成类似 _function_int 或 _xxx_functionIntxxx 这样的符号，即在符号上增加了类型信息，这也解释了为什么 C++ 可以实现函数重载了. 那么，对于用 C 编译器编译成的库，用 C++ 直接链接势必会出现不能识别符号的问题，用 extern &quot;C&quot; 就可以解决, 正如上面的例子. 简单来说, extern &quot;C&quot; 的作用就是让编译器知道要以 C 语言的方式编译和链接函数. __cplusplus 宏__cplusplus 宏是 C++ 编译器默认定义的. 类似如下的代码: 123456789#ifdef __cplusplusextern &quot;C&quot;&#123;#endifvoid fun(int, size_t);#ifdef __cplusplus&#125;#endif 在 C++ 中, 编译器将 fun 按照 C 的链接约定来编译, 而如果是 C 编译器, 直接按照 C 的链接约定来编译即可. __cplusplus 是在 C++ 编译器中默认定义的,Ｃ语言不支持 extern &quot;Ｃ&quot;. 上面的代码很实用, 也是一种编程技巧.]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C C++ 编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: Background Fetch]]></title>
    <url>%2F2018%2F02%2F08%2FiOS-APNs-Background-Fetch%2F</url>
    <content type="text"><![CDATA[在前面的几篇文章中, 给大家介绍了跟推送相关的内容. 今天跟大家聊一聊 iOS7 新加入的 Background Fetch 功能. 该系列博客: iOS APNs: 远程推送iOS APNs: 本地推送iOS APNs: 处理数据iOS APNs: 静默推送iOS APNs: Background Fetch(本篇) 简介从 Background Fetch 字面上来看, 大致意思是可在后台获取数据. 在 iOS7 中，Apple 为开发者提供了可以在后台更新应用程序界面和内容的 API, 即 Background Fetch. 该特性允许开发者在一个周期间隔后进行特定的动作，如获取网络内容, 更新 UI 操作等. 同时在 iOS7 中, 也加入了另一个特性, 就是博文 iOS APNs: 静默推送 里面说的静默推送. 这些都是对 iOS 后台多任务的补充和完善, Apple 一直在优化系统从而增强用户体验. 开启 Background Fetch1.需要 APP 支持 如下图所示, 勾选即可. 2.设置 fetch 时间间隔 在 AppDelegate 中设置. 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 设置 fetch 时间间隔 [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];&#125; UIApplicationBackgroundFetchIntervalMinimum 是系统自定义的时间. 如果不设置, 默认是 UIApplicationBackgroundFetchIntervalNever, 这样就不会让 Background Fetch 生效了. 可以查看对 UIApplicationBackgroundFetchIntervalNever 的官方解释. 123UIApplicationBackgroundFetchIntervalNeverA fetch interval large enough to prevent fetch operations from occurring. 当然, 你也可以设置自己定义的时间的间隔, 但是基本没有什么作用, 因为这个时间间隔完全由系统来决定, 系统会根据你的电量以及使用频率来决定. 所以, 可以理解为 setMinimumBackgroundFetchInterval 方法只是开启了 Background Fetch 功能. 3.开启了系统后台更新功能 在 iOS 系统中, 设置/通用/后台应用刷新中一定要开启对应 APP 的功能. 判断是否已经开启该功能的示例代码: 1234if ([[UIApplication sharedApplication] backgroundRefreshStatus] != UIBackgroundRefreshStatusAvailable) &#123; //不可用提示用户&#125; 处理回调在实际的应用环中，Background Fetch 事件是由系统管理的，我们开发者是无法预先知道 Fetch 事件达到的时机的. 网上很多说可以使用 Xcode 模拟这个事件, 估计也是之前的系统和 Xcode 版本, 现在的 Xcode9 貌似不行了. 但是, 你的手机在后台等几分钟, 有时候会被系统触发该事件, 触发后, 对应的系统回调(在 AppDelegate 中)会被调用. 12345678910// Background fetch 回调- (void)application:(UIApplication *)applicationperformFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler &#123; MZLOG(@&quot;AppDelegate. Background fetch.&quot;); //可进行对应的耗时操作, 如下载等. completionHandler(UIBackgroundFetchResultNoData);&#125; Background Fetch 会为我们的 App 争取更多的后台时间, 但是一般是几十秒左右, 不会太多. 所以, 不要在回调中做太多耗时的操作.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 远程推送 BackgroundFetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 静默推送]]></title>
    <url>%2F2018%2F02%2F06%2FiOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[最近在看人工智能相关的知识，无意中发现了一个巨牛的 人工智能教程，分享一下给大家。 教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点 这里 可以直接看教程。 今天跟大家介绍一下 ios 的静默推送功能。 静默推送，简单来说就是通过推送实现用户无感知的消息通知。 该系列博文: iOS APNs: 远程推送iOS APNs: 本地推送iOS APNs: 处理数据iOS APNs: 静默推送(本篇) 普通推送例如微信，好友给你发送了一条消息，你的微信APP 在后台, 此时会收到带声音的一个消息提示。 这条推送机油有文字又有声音，点开这个推送可以直接打开 APP. 从程序的角度来讲，进入 App 后会调用下面的方法: iOS10.0.x 和其之前的系统调用下面的方法: 1- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo iOS10.0.x 之后的系统，会调用如下的方法: 123- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler 静默推送的异同1.没有弹出框 没有推送的弹框出现，用户毫无感知的接收到了这个推送消息. 有 润物细无声 的感觉。 该推送既没有文字又没有声音。 2.需要用户授权允许推送 这个跟普通推送一样，都需要用户授权才可以推送。 3.会执行代理方法 静默推送来的时候，也能执行上面的回调方法。执行上面方法的场景如下: 1.App 在前台.2.App 在后台, 但是没有被 kill 掉. 4.iOS7 以后才有的 对于 iOS 之前是没有静默推送的。 5.可以延长后台时间 收到静默推送后，在应用程序挂起之前有 30 秒左右可以执行相关的操作。 6.推送频率的控制 静默的推送是苹果推送服务器控制推送频率的。 苹果推送服务根据后台推送任务的能耗(用电量,接收情况)来控制后台推送的推送频率和延迟时间。 总之, 静默推送是普通推送的一种变种而已。 无论是静默推送还是普通推送，开发者证书里面必须开通 push 相关的功能，并且也需要用户开启允许推送的授权。 这个在 iOS APNs: 远程推送 里面已经介绍过，不在这里赘述。 推送的格式普通推送的格式，大致是这个样子: 12345678&#123; &quot;aps&quot;: &#123; &quot;alert&quot;:&quot;Testing.. (15), &quot;badge&quot;:1, &quot;sound&quot;:&quot;default&quot; &#125;&#125; 静默推送是不允许带 alert badge sound 等字段的，但是必须包含 &quot;content-available&quot;:1. 例如下面的形式都可以: 形式1 123456&#123; &quot;aps&quot;: &#123; &quot;content-available&quot;:1 &#125;&#125; 形式2 1234567&#123; &quot;aps&quot;: &#123; &quot;custom&quot;:&quot;open_profile_page&quot; &quot;content-available&quot;:1 &#125;&#125; 其中 custom 是自己定义的，大家根据需求自行扩展即可。 形式3 1234567&#123; &quot;aps&quot; : &#123; &quot;content-available&quot; : 1 &#125;, &quot;acme1&quot; : &quot;bar&quot;, &quot;acme2&quot; : 42&#125; 这个来自苹果开发者 文档 。 使用场景具体的使用场景, 需要结合本身的业务和功能特点来说。 静默推送的前提是 APP 没有被杀死，可以通过回调函数来执行相关的代码。 另外静默推送不会打扰用户，比如用户正在游戏中战斗，你频繁的使用普通推送给他，估计他都要疯了.。 我个人使用静默推送的场景大致是这样的，APP 将要挂起的时候, 请求服务器去发一条静默推送，然后使用本地通知的方式唤起用户来打开 APP，从而保证 APP 处于保活的状态，至少静默推送可以增加被后台挂起的时间。 关于本地通知的内容，可以参考之前的文章 iOS APNs: 本地推送. 更多的使用场景等大家在业务中去挖掘。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hi 2018, 我又来了]]></title>
    <url>%2F2018%2F02%2F02%2FHi-2018-%E6%88%91%E5%8F%88%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[好久没有更新自己的博客了, 以前坚持一周至少两三篇博文的我, 从 2017 年 10 月份到现在居然停止了. 其实, 这是有原因的… 数据丢了2017 年 10 月 15 日晚, 我亲手把自己的之前写的文章(原数据)给弄丢了. 我自己搭建的博客系统是使用 GitHub + Hexo 部署和发布的. 事情大致经过是这样的… Mac 操作系统提示, 有更新的系统可以使用了, 问是否立即安装, 在公司的时候, 我心想, 更新后, 自己安装的一些库, 估计也要重新安装, 嫌麻烦就直接跳过了. 过了几天, 我晚上下班回家, 系统又提示我更新. 当时, 我就没有忍住, 直接更新了, 毕竟早晚都要更新的, 再说了 MacOS 还是比较让人放心的. 趁电脑更新系统的时候, 我就去洗了澡, 回来发现系统更新已经完成了. 心中想正好可以把之前没有完成的博客去完善一下, 谁知道…天不遂我愿呀! 再去使用 Hexo 的时候, 提示我失败, 居然无法使用了. 这可把我急的够呛, 一气之下(脑子估计当时进水了), 直接删了 Hexo 目录, 是那种程序员式的毫不留情的删除. rm -fr ./hexo 潇洒的操作后, 重新安装 Hexo, 又折腾了两个晚上, 最终也是安装好了, 可以写东东了. 但是发现从 Github 上面 clone 后的文件, 无法还原成自己当初的 MarkDown 文件了. 雪花那个飘啊飘, 北风那个萧呀萧… 一切都晚了! ^^ 唯一值得庆幸的是, 原来自己的网站博文还在那里. 还原数据从哪里跌倒, 就从哪里爬起来, 我决定把之前的数据使用 人工智能 的方式还原回来. 😆我就是那个 人工, 手动的将 HTML 转换为 MarkDown 文档, 压根没有什么 智能. 好歹那也是自己熬过多少个日夜的成果呀, 没有功劳也有苦劳, 我不忍心就这样让它丢掉, 含着泪也要把它们给找回来! 自己下半年也比较忙, 周末都在加班, 只能每天晚上回家抽些时间还原一点, 有时候太困, 就推迟到下个晚上. 大概用了 3 个月左右的时间, 基本还原回来了. 每篇文章基本都有配图, 都有跳转链接, 恢复起来, 还是需要一点时间和毅力的, 中途我也放弃过, 但是想想它们就要这样的被我抹杀了, 实在太可怜了, 就坚持下来了. 反思和总结还原之前的数据, 比写新文章还累, 主要是心累. 刚开始的时候, 我每篇都想一步到位的还原, 发现坚持几个晚上, 效率很低, 很容易放弃. 最后, 我调节了一下心态, 分 迭代 去做. 第一个阶段, 把 HTML 文章拷贝到 MarkDown 工具中, 不做任何的修饰和修改. 第二个阶段, 梳理 MarkDown 文档, 把缺失的图片补上去. 第三个阶段, 把文章中的链接尽量补全. 经过这三个阶段后, 文章基本已经复原了, 只是格式上看起来有点糟糕. 第四个阶段, 整理文章的排版, 对比已经发布的文章, 查漏补缺. 第四个阶段结束后, 文章基本都复活了, 接下来就是部署和发布了. 第五个阶段, 整理 Hexo, 配置相关的主题. 第六个阶段, 本地预览和再次校验文章, 统一发布. 每个阶段, 我都给自己一个小目标, 不断的去完善, 最后将各个阶段的成果串联起来, 就完成了. 当自己遇到困难的时候, 不妨分解一下任务, 不断的去完成每个小任务, 每个完成的小任务都是对自己最大的奖励. 整个还原的过程, 又让我重新梳理了一下之前的文章, 包括目录规划和文章中的措辞, 也对图片进行了压缩和处理. 收获颇多. 如果当初自己不那么冲动, 如果当初自己备份了文件, 应该就不会有这么一个艰辛的历程了. 数据备份很重要, 冲动是要付出代价的. 现在我把原数据保存在云盘中, 本地也保留一份, 定期更新到云盘中. 这样就可以防止数据丢失了. 祝大家在 2018 发发发, 身体健康, 幸福安康! 推荐推荐给 Mac 用户一个图片压缩工具 imageoptim.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学习 生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: 静态库]]></title>
    <url>%2F2017%2F10%2F08%2FGCC-%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[概要如果你对 GCC 的编译 C语言的流程不清楚, 建议在阅读本文之前先去看一下 GCC: 编译C语言的流程 这篇文章, 篇幅短小精悍, 阅读后, 至少可以扫扫盲😜. 本篇博文用到的一些基础知识点: 1.GCC gcc -c 选项含义: 1Only run preprocess, compile, and assemble steps 是 -c 选项只是进行了预处理, 编译, 汇编的阶段, 不会进行链接的操作. 2.静态库 Linux 上的静态库，本质是一些目标文件的归档文件. 3.静态库和共享库区别 [1].使用共享库可以节省内存. 比如 libc，系统中几乎所有的进程都映射 libc 到自己的进程地址空间，而 libc 的只读部分在物理内存中只需要存在一份，就可以被所有进程共享，这就是“共享库”这个名称的由来了. [2].使用共享库可以很方便地升级库文件而不需要重新编译应用程序. [3].共享库占用更少的体积. 在运行时做动态链接.而在链接静态库时, 链接器会把静态库中的目标文件取出来和可执行文件真正链接在一起. 创建步骤创建静态库的步骤如下: [1]. 写源文件.[2]. 通过 gcc -c x.c 生成目标文件.[2]. 归档. 用 ar 归档目标文件，生成静态库.[3]. 写头文件, 便于使用者知道怎么使用该静态库. 使用静态库时，在源码中包含对应的头文件，链接时记得链接自己的库. 下面结合具体例子, 展开讲. 写源文件目录结构 示例文件都是很简单的代码, 附录可以查看完整示例. 生成目标文件将 libs 目录下面的(c)源文件进行预处理, 编译和汇编.注意这里没有进行链接. 1gcc -c libs/person.c libs/eat.c libs/play.c libs/sleep.c 执行城后, 会生成对应的 .o 文件. 归档libperson.a 是要生成的库文件. 库文件都以 lib 开头, 静态库以. a 为后缀. 所以一般是 lib+ 名字.a 1ar rs libperson.a person.o sleep.o play.o eat.o ar: 类似于 tar, 用来对文件进行库打包. r 选项: 将其后面的文件列表添加到文件包(libperson.a)中, 如果 libperson.a 不存在就创建它, 如果 libperson.a 已经存在且里面有同名的目标文件就进行替换操作. s 选项: 为静态库创建索引.这个索引会被链接器使用. ranlib 命令也可以为静态库创建索引. 所以上面的命令可以等效为下面的两个命令. 12ar r libperson.a person.o sleep.o play.o eat.oranlib libperson.a 写头文件写一个 person.h 文件, 便于调用者查看库如何使用. person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif 使用静态库 1gcc main.c -L. -lperson -Ilibs -o main -L 选项: 告诉编译器去哪里找库文件, 这里的 _L. 表示在当前目录.如果不用 -L 选项, 即使库文件在当前目录, 编译器也不会去找, 所以该选项不能少. 报错信息如下: 12ld: library not found for -lpersonclang: error: linker command failed with exit code 1 (use -v to see invocation) -lperson: 告诉编译器要链接 libperson.a 库. -I: 告诉编译器到哪里找头文件.如果不指定头文件的查找目录, 也会报错: 1234main.c:2:10: fatal error: &apos;person.h&apos; file not found#include &quot;person.h&quot; ^~~~~~~~~~1 error generated. 此时的目录结构: 链接成功后, 可以执行生成的 main (可执行)文件. 1./main 123uid: 101 eatinguid: 101 playinguid: 101 has sleep 有趣的实验猜想一下如果有两个库一个是共享库, 一个是静态库, 而且二者除了后缀不一样, 名字都一样如 libperson.a 和 libperson.so, 那么调用方如何来选择对应的库文件呢? 我们把 GCC: 共享库 里面生成的共享库 libperson.so 放到当前的目录, 重新编译链接 main.c 文件. 1gcc main.c -L. -lperson -Ilibs -o main 再次执行 ./main, 得到结果是这样的: 123From sharedlib.uid: 101 eatingFrom sharedlib.uid: 101 playingFrom sharedlib.uid: 101 has sleep 以上的结果, 说明链接器会优先选择共享库其次才是静态库. Linux(MacOS 也一样) 的 GCC 默认链接动态库，只有当动态库不存在时，才去链接静态库.若是需要强制指定静态库需要指定选项 -static.但是在 MacOS 上面不支持该选项. 1gcc -static main.c -L. -lperson -Ilibs -o main 附录示例完整代码 main.c 12345678#include &lt;stdio.h&gt;#include &quot;person.h&quot;int main() &#123; init(101); eat(); play(); sleep();&#125; person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif person.c 1234int uid;void init(int pUid) &#123; uid = pUid;&#125; eat.c 12345#include &lt;stdio.h&gt;extern int uid;void eat() &#123; printf(&quot;uid: %i eating\n&quot;, uid);&#125; play.c 12345#include &lt;stdio.h&gt;extern int uid;void play() &#123; printf(&quot;uid: %i playing\n&quot;, uid);&#125; sleep.c 12345#include &lt;stdio.h&gt;extern int uid;void sleep() &#123; printf(&quot;uid: %i has sleep\n&quot;, uid);&#125; GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>GCC 编译器 静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: 共享库]]></title>
    <url>%2F2017%2F10%2F07%2FGCC-%E5%85%B1%E4%BA%AB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[基本概念共享库: 在程序执行期间需要调用到共享库的时候才加载到内存里面，可以被多个程序共享使用. 在 MacOS 上面创建和使用共享库要比在 Linux 上面简单.在 Linux 上面还会牵扯到共享库路径问题, 在 Mac 上面就没有这样的问题. 在 MacOS 上面使用的 GCC 其本质是 LLVM. 你可以在命令行: 1gcc -v 可以看到对应的输出结果: 12345Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1Apple LLVM version 9.0.0 (clang-900.0.37)Target: x86_64-apple-darwin16.7.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 创建共享库步骤[1].写源文件.这里以 C文件为基础.[2].将源文件生成目标文件.[3].创建共享库.[4].写头文件, 供调用方使用. 下面结合实例来分享一下如何在 Mac 上面创建共享库. 写源文件目录结构: 对应的完整代码可以看文末的附录. 生成目标文件执行如下命令: 1gcc -Wall -c -fPIC libs/eat.c libs/play.c libs/sleep.c libs/person.c 注意: -fPIC 选项一定要加. PIC(position independent code), 产生位置无关码 生成共享库这里把共享库暂且称之为 libperson.so. 执行下面命令创建: 1gcc -shared -fPIC eat.o play.o sleep.o person.o -o libperson.so 写头文件这里头文件主要是 person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif 使用共享库main.c 是使用方, 编译链接即可. 1gcc main.c -L. -lperson -Ilibs -o main 生成可执行文件 main, 执行结果: 123From sharedlib.uid: 101 eatingFrom sharedlib.uid: 101 playingFrom sharedlib.uid: 101 has sleep 注意:-L 选项, 告诉编译器去哪里找库文件, 这里的 _L. 表示在当前目录. -lperson, 表示 libperson.so 库. -Ilibs 告诉编译器头文件所在的目录. 附录示例完整代码 main.c 12345678#include &lt;stdio.h&gt;#include &quot;person.h&quot;int main() &#123; init(101); eat(); play(); sleep();&#125; person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif person.c 1234int uid;void init(int pUid) &#123; uid = pUid;&#125; eat.c 12345#include &lt;stdio.h&gt;extern int uid;void eat() &#123; printf(&quot;From sharedlib.uid: %i eating\n&quot;, uid);&#125; play.c 12345#include &lt;stdio.h&gt;extern int uid;void play() &#123; printf(&quot;From sharedlib.uid: %i playing\n&quot;, uid);&#125; sleep.c 12345#include &lt;stdio.h&gt;extern int uid;void sleep() &#123; printf(&quot;From sharedlib.uid: %i has sleep\n&quot;, uid);&#125; GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>GCC 编译器 共享库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: Homebrew 安装 GCC 和 Binutils]]></title>
    <url>%2F2017%2F10%2F07%2FGCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils%2F</url>
    <content type="text"><![CDATA[文章背景前段时间，有个博客上面的小伙伴给我发来邮件，问我关于 GCC 相关的知识，对于 GCC 我也只是凭着之前的了解，回复他了。书到用时方恨少呀！ 这位小伙伴还在读大学，自学能力比较强，自己出了完成课时之外，还会在网上找资料自学。 我记得自己在大学的时候，对 GCC 一窍不通，只知道 Turbo-C 和那些被强制记住的关键字。 最后告诉他, 我会坚持把自己以前学习过相关 GCC 的知识，以博客的形式输出。于是。就有了 GCC 系列 的文章，希望能够帮到大家。 概要这篇博客主要分享 macOS 下安装 GCC 和 Binutils 工具。 macOS 终端下输入 gcc -v, 其实是链接指向了 LLVM 编译器, 不是 GNU 的 GCC. 12345Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1Apple LLVM version 9.0.0 (clang-900.0.37)Target: x86_64-apple-darwin16.7.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 安装 GCC关于 GCC, 可以参考 维基百科. 执行下面命令, 即可开始安装: 1brew tap homebrew/versions 然后搜索 gcc 1brew search gcc 搜索结果中会显示 gcc 的版本，可以选择安装一个，建议安装最新版。 这里以安装 gcc49 为例。 1brew install gcc49 brew 会自动为你安装相关依赖，如 gmp4、mpfr2、libmpc08、isl011、cloog018. 这里安装需要等待一段时间… 看到下面的内容, 表示安装完毕. 123Pouring gcc49-4.9.2_1.yosemite.bottle.1.tar.gz/usr/local/Cellar/gcc49/4.9.2_1: 1138 files, 164M 安装成功后, 安装目录在: 1/usr/local/Cellar/gcc49/4.9.2_1 你在终端直接输入 gcc -v，其实还是 LLVM，那么如何使用我们 刚安装的 gcc? 123cd /usr/local/Cellar/gcc49/4.9.2_1/binls -l 可以看到: 123456789101112131415c++-4.9cpp-4.9g++-4.9gcc-4.9gcc-ar-4.9gcc-nm-4.9gcc-ranlib-4.9gcov-4.9x86_64-apple-darwin14.3.0-c++-4.9x86_64-apple-darwin14.3.0-g++-4.9x86_64-apple-darwin14.3.0-gcc-4.9x86_64-apple-darwin14.3.0-gcc-4.9.2x86_64-apple-darwin14.3.0-gcc-ar-4.9x86_64-apple-darwin14.3.0-gcc-nm-4.9x86_64-apple-darwin14.3.0-gcc-ranlib-4.9 Ok，你应该明白了, 在命令行输入 gcc-4.9 -v 就可以使用我们刚安装的 GCC 了，包括 g++ 等工具. 以后使用 GNU 的 GCC 输入 gcc-4.9 就好了。 安装 Binutils关于 Binutils 可以参考 维基百科. 执行下面命令, 直接安装: 1brew install binutils 同理: 1cd /usr/local/Cellar/binutils/2.25/bin 可以看到你需要的工具: 1234567891011121314151617181920gaddr2linegargc++filtgcoffdumpgdlltoolgdllwrapgelfeditgnlmconvgnmgobjcopygobjdumpgranlibgreadelfgsizegsrconvgstringsgstripgsysdumpgwindmcgwindres 个人感受在 macOS 上面，即使安装了 GNU 的 GCC，也没有在 Linux 上面用的那么爽，很多 GCC 的命令选项在 macOS 上面无法使用，但不得不承认 LLVM 是比较优秀的编译器。 遇到问题gcc-4.9 编译代码报错，报错内容如下： 1234main.c:9:19: fatal error: stdio.h: No such file or directory #include &lt;stdio.h&gt; ^compilation terminated. 卸载 gcc 重新安装最新版本的 gcc 即可，如果你不知道最新的 gcc 版本是哪个，可以 search 一下。 1brew search gcc 显示结果大致如下： 123456gcc gcc@5 gcc@7gcc@4.9 gcc@6 i386-elf-gcc 这里以安装 gcc@7 为例，命令如下： 12345// 卸载原来的brew uninstall gcc// 安装最新版本brew install gcc@7 GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>brew GCC C 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: 编译C语言的流程]]></title>
    <url>%2F2017%2F10%2F03%2FGCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[再看下文之前，先普及一下 Linux 和 gcc 的历史，下面的这段内容来自于网络。 早在 20 世纪 70 年代，UNIX 系统是开源而且免费的。但是在 1979 年时，AT&amp;T 公司宣布了对 UNIX 系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。 于是在 1984 年，Richard Stallman 面对于如此封闭的软件创作环境，发起了 GNU 源代码开放计划并制定了著名的 GPL 许可协议。 1987 年时，GNU 计划获得了一项重大突破—gcc编译器发布，这使得程序员可以基于该编译器编写出属于自己的开源软件。 随之，在 1991 年10 月，芬兰赫尔辛基大学的在校生 Linus Torvalds 编写了一款名为 Linux 的操作系统。该系统因其较高的代码质量且基于 GNU GPL 许可协议的开放源代码特性，迅速得到了 GNU 计划和一大批黑客程序员的支持。 随后 Linux 系统便进入了如火如荼的发展阶段。 1994 年 1 月，Bob Young 在 Linux 系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了 Linux 系统的普及。 1998 年以后，随着 GNU 源代码开放计划和 Linux 系统的继续火热，以 IBM 和 Intel 为首的多家 IT 企业巨头开始大力推动开放源代码软件的发展。 到了 2017 年年底，Linux 内核已经发展到了 4.13 版本，并且 Linux 系统版本也有数百个之多，但它们依然都使用 Linus Torvalds 开发、维护的Linux 系统内核。RedHat 公司也成为了开源行业及 Linux 系统的带头公司。 声明这篇博文 makefile: gcc 工作流程 早期被我放在 CSDN 上面过.时隔多年, 仍不能忘怀, 现乔迁至此. 本文比较简单, 比较适合初学者.我只是试图以实例的方式给大家讲解一下 GCC 编译链接 C语言程序的流程, 并没有高深的知识. 编译流程C 语言经过预处理、编译、连接最后生成可执行文件. 在 Linux 的 GCC 下面，看看其工作流程. 流程图如下： 预处理，将包含的 .h 文件或者一些预处理语句（如 #define）处理一下，然后将 .c 文件生成 *.i 的中间文件. 注意了 GCC 不会自动生成这样一个文件，如果需要，自己加 -E 参数即可. 编译、汇编阶段生成 *.o 目标文件，最后经过链接生成可执行文件. 注意：可执行文件不一定是 exe 文件. 实例下面以一个实例 hello.c，说明这个过程. 源文件很简单，这里只是为了说明问题. 在命令行，执行下面命令完成预处理： 1gcc -E hello.c -o hello.i 执行之后，你可以打开 hello.i 文件，可以看到很多 extern 以及将 MAX 解释为 20： 在命令行，执行下面命令, 完成编译阶段: 1gcc -S hello.i -o hello.s 这时可以生成 *.s 文件，其实就是一些汇编语句，如下所示： 那麽，我们就可以进入汇编阶段了，执行： 1gcc -c hello.s -o hello.o 打开这个 hello.o 文件，都是一些机器码. 最后一个连接生成可执行文件： 1gcc hello.o -o hello 在当前目录就可以生成 hello 这个可执行文件. 执行 ./hello，就会输出： 到此，GCC 编译连接生成可执行文件完毕！ 当前目录下面的文件： 以上的步骤，其实一句命令即可： 1gcc hello.c -o hello 此时目录内容如下： 自己动手感受一下，你会收获更多！ GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>GCC C 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 处理数据]]></title>
    <url>%2F2017%2F08%2F07%2FiOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[简介博文: iOS 细说推送: 远程推送 和 iOS 细说推送: 本地推送分别介绍了 iOS 的两种典型推送, iOS 还有很多类型的推送, 如静默推送, VOIP 推送(iOS8)等, 后面会慢慢介绍给大家. 今天跟大家聊聊关于如何处理推送的数据(payload). 该系列博客: iOS APNs: 远程推送iOS APNs: 本地推送iOS APNs: 处理数据(本篇)iOS APNs: 静默推送iOS APNs: Background Fetch 推送的代理回调时机还记得 AppDelegate 里面关于推送的几个代理方法吧.~ 估计你也忘记了, 没关系, 我们再一起整理一下. 123456- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123; MZLOG(@&quot;markApp push. RemotePush userInfo: %@&quot;, userInfo); // 可以根据推送内容决定下一步的行为&#125; 该方法在接收到 RemotePush 的时候, 调用时机: 1.APP 在前台运行的, RemotePush 被推送过来了.2.APP 在后台运行, 无论是否被挂起只要没有被杀死, 点击推送内容. 以上两种情况均可以进入 didReceiveRemoteNotification 方法. 123456- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123; MZLOG(@&quot;App push. LocalPush notification: %@&quot;, notification); // 可以根据推送内容决定下一步的行为&#125; 该方法接收到 LocalPush 的时候, 调用时机: 1.APP 在前台运行的, LocalPush 被推送过来了.2.APP 在后台运行, 无论是否被挂起只要没有被杀死, 点击推送内容. 以上两种情况均可以进入 didReceiveLocalNotification 方法. 这两个回调方法, 分别接收 RemotePush 和 LocalPush 的推送消息. 有些人会问了, 假如这个时候我的应用在后台, 被系统杀死了或者被用户双击 Home 键杀死了, 此时远程推送过来了, 或者状态栏里面有本地推送的消息, 我点击推送消息, 这两个方法会被调用吗? 类似这种效果, 上面是 RemotePush, 下面是 LocalPush. 我肯定的告诉大家, 应用被杀死的情况下, 点击推送内容, didReceiveRemoteNotification 和 didReceiveLocalNotification 都不会被调用. 这个时候, AppDelegate 中的另一个方法上场了. 12- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 看一下 didFinishLaunchingWithOptions 的具体实现, 示例代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; /// 将应用图标的 badge 清零 &#123; [[UIApplication sharedApplication] setApplicationIconBadgeNumber:1]; [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0]; [[UIApplication sharedApplication] cancelAllLocalNotifications]; &#125; if (nil != launchOptions) &#123; /// 处理 LocalPush &#123; // 这里可以得到 UILocalNotification 对象 id localPushNotify = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey]; MZLOG(@&quot;AppDelegate localPush: %@&quot;, localPushNotify); if (nil != localPushNotify) &#123; if ([localPushNotify isKindOfClass:[UILocalNotification class]]) &#123; // 获取 userinfo 数据 NSDictionary *userInfo = [(UILocalNotification *)localPushNotify userInfo]; MZLOG(@&quot;AppDelegate localPush of UILocalNotification: %@&quot;, userInfo); // 根据 userInfo 的内容处理如页面跳转等 &#125; &#125; &#125; /// 处理 RemotePush &#123; NSDictionary *remotePushNotify = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; MZLOG(@&quot;AppDelegate remotePush: %@&quot;, remotePushNotify); if (nil != remotePushNotify) &#123; NSDictionary *remoteAps = [remotePushNotify objectForKey:@&quot;aps&quot;]; MZLOG(@&quot;AppDelegate remotePush. The aps&apos; info, alert: %@, badge: %@, sound: %@&quot;, [remoteAps objectForKey:@&quot;alert&quot;], [remoteAps objectForKey:@&quot;badge&quot;], [remoteAps objectForKey:@&quot;sound&quot;]); // 根据推送的内容处理如页面跳转等 &#125; &#125; &#125; MZLOG(@&quot;AppDelegate. launchOptions: %@&quot;, launchOptions); return YES;&#125; 对应的打印输出内容, 如下 本地推送的内容: 123 AppDelegate localPush of UILocalNotification: &#123; &quot;user_info_key&quot; = &quot;user_info_value_json_str&quot;;&#125; 远程推送的内容: 1234567aps = &#123; alert = &quot;Testing.. (2)&quot;; badge = 1; sound = default; &#125;; The aps&apos; info, alert: Testing.. (19), badge: 1, sound: default 自定义推送内容 对于推送的数据格式, 是苹果规定的格式, 我们可以在其基础上添加我们需要的数据. 在介绍下面内容之前, 先了解一下什么是 payload. payload 是推送通知的一部分，每一条推送通知都包含一个 Payload.它包含了系统提醒用户通知到达的方式，还可以添加自定义的数据, 即通知主要传递的数据为 payload. Payload 本身为 JSON 格式的字符串，它内部必须要包含一个键为 aps 的字典.也就是说 payload 是整个字符串. 关于 payload 的限制 在早期的推送中, payload 不能超过 256bytes, 中间还经历过推送的 payload 最大为 2KB.现在苹果支持最大为5KB(VOIP 推送), 官方文档有说, 如下: 1234For regular remote notifications, the maximum size is 4KB (4096 bytes)For Voice over Internet Protocol (VoIP) notifications, the maximum size is 5KB (5120 bytes)NOTEIf you are using the legacy APNs binary interface to send notifications instead of an HTTP/2 request, the maximum payload size is 2KB (2048 bytes) 上面是 官方文档 的原文, 大概意思是: 现在 APNs 支持 payload 为 4KB, 如果是 VoIP 推送的话, 支持 5KB. 但是, 如果你使用传统的 APNs 而不是使用 HTTP/2 的话, 最大支持 2KB. 也就是说, 推送的 payload 大小和 iOS 系统无关, 而是和协议有关. 可以使用下面代码, 查看 payload 长度 1payload.getBytes().length 我们正常的推送内容是这样的, 正常格式: 1&#123;&quot;aps&quot;:&#123;&quot;alert&quot;:&quot;Testing.. (21)&quot;,&quot;badge&quot;:1,&quot;sound&quot;:&quot;default&quot;&#125;&#125; 如果想对推送内容做自定义, 可以自己添加额外的数据, 如: 1&#123;&quot;aps&quot;:&#123;&quot;alert&quot;:&quot;Testing.. (21)&quot;,&quot;badge&quot;:1,&quot;sound&quot;:&quot;default&quot;&#125;, &quot;ext&quot;:&#123;&quot;key&quot;:&quot;value&quot;&#125;&#125; 其中, ext 就是额外添加的数据模型. 在 APP 收到这样的数据模型时, 可以对应不同的行为. 大家可以根据自己的业务需求, 自行定义数据格式. 自定义的数据格式, 注意内容的长度, 在不同的 iOS 系统上面, 对于推送的内容是有长度限制的. 再唠叨几句关于 iOS7 以后添加的方法 123- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler 这个方法也是在 AppDelegate 中实现的. 12- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo 这个方法在 iOS3 就已经有了, 可谓是历史悠久.我姑且称之为该方法为 FatherMethod, 上面那个新加入的称之为 SonMethod. 注意事项: [1]. 实现了 FatherMethod, 即使你实现了 SonMethod, SonMethod 也不会被调用.[2]. SonMethod 比 FatherMethod 多了一个参数 completionHandler, 这个在后面会说到.主要用于 Background Mode 中的 Background Fetch.[3]. 推送被调用的时机, 除了 FatherMethod 的时机外, 还多了一种时机, 就是在 APP 被杀死后, 点击推送内容打开 APP, 此时 APP 再次回到前台的时候, 该方法也会被调用(didFinishLaunchingWithOptions也会调用), 所以在处理远程推送内容的时候, 要注意这一点. 针对注意事项[3], 目前我能给出的有两种解决方案: 第一, 判断是否是第一次启动 APP, 如果是第一次启动 APP, 统一在didFinishLaunchingWithOptions 中处理, 不在 SonMethod 中处理. 第二, 远程推送统一在 SonMethod 中处理, didFinishLaunchingWithOptions 中只处理在 APP 被杀死的情况下, 用户点击推送本地的内容. 我个人采用的是第二中方案. 感谢在推送工具 NWPusher 和 Xcode 的 Window/Devices/Console 帮助下, 才得以完善博文. NWPusher 用来发送推送内容. Window/Devices/Console 用于查看输出日志. 必看文档Creating the Remote Notification Payload Payload Key Reference]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 本地推送]]></title>
    <url>%2F2017%2F08%2F06%2FiOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[概括iOS APNs: 远程推送 说过远程推送(RemotePush). 今天说说本地推送, 本地推送也就是平时所说的 LocalPush. 该系列博客: iOS APNs: 远程推送 iOS APNs: 本地推送(本篇) iOS APNs: 处理数据 iOS APNs: 静默推送 iOS APNs: Background Fetch 业务场景在具体实现之前, 先说一下业务场景. 假如你的 APP 具有 IM(即时通讯) 功能, 这个时候, 你可以根据连接来判断用户是否在线, 如果不在线, 可以使用远程推送将推送内容告知用户.如果在线, 可以通过 IM 把内容告诉 APP, APP 收到这个消息后, 可以使用本地推送告知给用户. 据说 APNs 每天要处理的推送在亿级别, 所以如果可以使用 LocalPush 完成的业务, 我建议大家还是不要使用远程推送, 况且苹果并不一定保证远程推送一定成功, 如果网络或者 APNs 压力大, 推送也会延时. 给苹果减少点压力吧, 哈哈! 再说一个业务场景, 你的 APP 在后台运行时间快到要被系统挂起的时候了, 你可以发送一个 LocalPush 来提示用户或者刺激用户, 再次将 APP 拉回前台运行. 这样可以保证 APP 可以正常运行了. 上面说的第二个业务场景, 是今天例子的基础, 你也可以根据自己的实际业务场景来使用 LocalPush 功能. LocalPush 简介LocalPush 允许 APP 向用户发送通知, 对于用户来说, 就跟远程推送是一样的, 基本没有感知, 开发者也不希望用户有感知. 推送效果图: 注意: 如果你的 APP 在前台, 发送 LocalPush 是不会要上述效果的.如果在前台, 可以使用自定义的弹框来提示用户. LocalPush 同样需要用户授权推送的权限, 否则也无法发送成功.这个跟远程推送是一样的. 另外, LocalPush 需要 APP 在后台没有被挂起的情况下, 才能发送, 否则无法启用. 发送 LocalPush 的一个好处是不需要用户连接网络, 这个是区别于远程推送的, 因为远程推送必须要求用户连接网络的.很多单机游戏或者弱联网的游戏, 发送的推送都是 LocalPush, 而非远程推送. 在阅读下面内容之前, 建议大家先看看 iOS 后台模式 这篇文章.本篇也是基于这个为基础的. 实现这个示例, 实现的场景如下: 用户打开 APP, 授权了推送的权限, 用户试玩一会之后, 将 APP 退到了后台, APP 监听退到后台之后, 延时一定时间发送 LocalPush 给用户. AppDelegate.m 中使用后台模式 关于 MZBackgroundTask 的实现, 附录给出. 1234- (void)applicationDidEnterBackground:(UIApplication *)application &#123; [[MZBackgroundTask sharedTask] startTask];&#125; ViewController.m 1234567891011121314151617181920212223242526272829303132333435- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil];&#125;- (void)onDidEnterBackground:(NSNotification *)notification &#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;); // 等待 6s 后, 这个时间可以根据具体情况去修改, 这里只是模拟 int delta = 6; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;); if (UIApplicationStateBackground == [UIApplication sharedApplication].applicationState) &#123; UILocalNotification *notification = [UILocalNotification new]; notification.alertBody = @&quot;走, 去high吧!&quot;; notification.soundName = UILocalNotificationDefaultSoundName; // 应用图标上面显示的数字 notification.applicationIconBadgeNumber = notification.applicationIconBadgeNumber + 1; // 可以自定义数据 notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;; [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125; else &#123; // 显示自定义弹框等 &#125; &#125;);&#125; 将 APP 点击 Home 键退到后台, 6s 后可以看到推送的效果. 点击推送的提示框, 再次打开了 APP, 会执行 AppDelegate 中的方法, 如下: 1234- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123; MZLOG(@&quot;App push. notification: %@&quot;, notification);&#125; 打印出来的 notification, 如下图所示: 其中, user_info 是我们自定义的数据部分. 附录 MZBackgroundTask 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#import &quot;MZBackgroundTask.h&quot;@implementation MZBackgroundTask+ (instancetype)sharedTask &#123; static MZBackgroundTask *_task; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _task = [[self alloc] init]; &#125;); return _task;&#125;- (void)startTask &#123; if (![self _checkSupportBackgroundTask]) &#123; MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;); return; &#125; UIApplication *application = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier taskId; /// 申请后台执行 /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟 &#123; taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123; MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining); [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;]; &#125; if (UIBackgroundTaskInvalid == taskId) &#123; MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;); return; &#125; /// 可以监控后台任务剩余的时间, 针对业务可以去处理 &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (true) &#123; // 剩余可以后台执行的时间 NSTimeInterval remainedTime = application.backgroundTimeRemaining; MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime); if (remainedTime &lt; 2) &#123; // 可以告诉其他业务, 后台任务即将结束了 break; &#125; // 睡眠(延时)1s [NSThread sleepForTimeInterval:1.f]; &#125; /// 这里可以做一些清除工作 &#123; // clean up &#125; [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;); &#125;&#125;#pragma mark - Private./** * 当前设备是否支持后台任务. * * @return YES, 支持后台任务. 否则, 不支持后台任务. */- (BOOL)_checkSupportBackgroundTask &#123; SEL sel = @selector(isMultitaskingSupported); BOOL supportBTask = [[UIDevice currentDevice] respondsToSelector:sel]; return supportBTask;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 远程推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 远程推送]]></title>
    <url>%2F2017%2F08%2F06%2FiOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[概要本篇博文, 你首先需要知道的内容: 1.了解过 Push.2.阅读过 [iOS 后台模式] 这篇文章.3.申请过苹果证书或者知道如何申请和制作证书.4.iOS 开发基本知识. 你在这篇博文将会学到: 1.Push 的发展历程.2.开源推送工具 NWPusher 的使用.3.Push 的基本原理. 简介APNs, 苹果推送通知服务. 全称是: Apple Push Notification Service. 推送指的是由 APNs 服务器、ProviderService、iOS 系统、App 构成的通讯系统，也是移动互联网与传统的 Web 最明显不同的. 官方有比较详细的文档介绍, 可以戳这里 官方文档 查看. 苹果的文档写的确实好, 但是作为程序员, 最重要的还是要结合理论去实践. 本篇结合自己的实践和对推送的理解, 跟大家分享一下推送相关的知识. Push 发展历程iOS 历经很多版本, 一直在优化或者说是进化推送相关的内容, 无论是从实用性和技术上来看, 推送是至关重要的. 看一下 push 发展历程 iOS 3 - 引入推送通知 UIApplication 的 registerForRemoteNotificationTypes 与 UIApplicationDelegate 的 application(:didRegisterForRemoteNotificationsWithDeviceToken:)，application(:didReceiveRemoteNotification:) iOS 4 - 引入本地通知 scheduleLocalNotification，presentLocalNotificationNow:， application(_:didReceive:) iOS 5 - 加入通知中心页面 iOS 6 - 通知中心页面与 iCloud 同步 iOS 7 - 后台静默推送 application(_:didReceiveRemoteNotification:fetchCompletionHandle:) iOS 8 - 重新设计 notification 权限请求，Actionable 通知 registerUserNotificationSettings(:)，UIUserNotificationAction 与 UIUserNotificationCategory，application(:handleActionWithIdentifier:forRemoteNotification:completionHandler:) 等 iOS 9 - Text Input action，基于 HTTP/2 的推送请求 UIUserNotificationActionBehavior，全新的 Provider API 等 iOS 10- 支持Images, GIFs, Audio and Video类型, 并且有 Notification Service Extension 与 Notification Content Extension，可以实现推送数据在展示前进行下载更新、定制通知 UI, 并且统一了通知类型，具有时间间隔通知、地理位置通知和日历通知. 该系列博客共分为几个部分: iOS APNs: 远程推送(本篇) iOS APNs: 本地推送 iOS APNs: 处理数据 iOS APNs: 静默推送 iOS APNs: Background Fetch 如果需要完整源码的, 可以通过邮件联系我(veritman@126.com), 后续完成后会上传到 github. 原理先看官方的流程图, 如下所示: 该流程图, 主要说明的是自己 业务服务器(Provider) 推送消息到用户(Client APP) 的流程. 注意: 这里说的以及本文后面说的 业务服务器, 统一指的是可以向 APNs 发送推送消息的服务器. 下面这张图是比较完整的一张流程图, 自己画的, 凑合看吧! 大概流程, 我详细说一下. 1.iOS 设备启动后连接网络, 会与苹果服务器建立一个安全的长连接.这个是系统维护的, 这也是推送的关键.2.用户打开 app, 授权了推送通知的权限.3.授权成功后, APNs 会将 deviceToken 返回给 iOS 终端.4.终端将该 deviceToken 返回给指定的 APP.5.APP 拿到 deviceToken 上传给我们自己的业务服务器.6.业务服务器向 APNs 发送推送请求, 带上 deviceToken.7.APNs 推送内容到指定的 iOS 终端.8.iOS 终端将内容推送给用户. 关于 deviceToken 后面会讲. 关于 deviceToken这里简单介绍一下 deviceToken. deviceToken 是 NSData 类型的数据, 是苹果服务器根据 设备,证书等信息和一定算法生成的.需要将这个 deviceToken 传送给我们的服务器端, 这样一个用户对象就绑定了一个 deviceToken.当需要给用户推送消息, 通过自己的业务服务器, 找用户对应的 deviceToken 和要发送的推送内容, 发送到苹果的 APNs, 然后 APNs 将消息推送到该 deviceToken 对应的手机上. 关于 deviceToken 是否可变的问题 网上有些人说, deviceToken 是可变的, 有些人说, deviceToken 是不可变的, 我也不知道他们到底有没有实践过, 今天我要告诉大家的是, deviceToken 是可变的. 如卸载重装 app, deviceToken 会变. 我的设备 iphone6, iOS10.3. 下面是我实验的数据: 1234第一次安装运行得到的 deviceToken&lt;4e0f2928 5be0700c=&quot;&quot; 296bf7f1=&quot;&quot; 3b0837e4=&quot;&quot; bc9da6d1=&quot;&quot; 9fdb672e=&quot;&quot; f87446be=&quot;&quot; 1c098431=&quot;&quot;&gt;卸载后, 第一次安装运行得到的 deviceToken 这说明, deviceToken 是可变的. 代码实现上面基本都是一些理论知识, 下面结合代码, 具体实现. 工程配置在写代码之前, 需要配置一下工程.关于如何创建带有 push 功能的苹果证书的操作, 大家自行去网上学习, 这里不赘述. 不过这里要提醒一点, 创建的证书一定要和自己项目的 appid 保持一致, 否则无法推送. 这个 Demo 工程的名字是 MZPush. 安装好证书, 打开工程, 并能让工程识别到. 切换到 Target, 点击 Capabilities 选项. 步骤1: 配置 Push, 打开开关即可. 配置后台模式, 打开开关, 选中Remote notifications. 不过这一步, 不是必须的, 如果你不配置, 工程会有警告.我建议是选上, 在后面的博文中, 再仔细说说这个东西的好处. 警告信息如下: 12You&apos;ve implemented -[&lt;UIApplicationDelegate&gt; application:didReceiveRemoteNotification:fetchCompletionHandler:], but you still need to add &quot;remote-notification&quot; to the list of your supported UIBackgroundModes in your Info.plist. 步骤2: 配置完这一步后,在 Info.plist 中可以看到多了一项内容: 步骤3: 配置工程最小兼容版本 因为我要兼容 iOS7, 所以在 Xcode8 中, 自己手动改为了 7.0. 步骤4: 关闭 Bitcode(可选操作) 步骤5: 配置支持 HTTP(可选操作) 在 Info.plist 中, 添加如下: 用户授权询问用户授权的实现 该实现兼容了 iOS7. 1234567891011121314+ (void)applyPushPermission &#123; UIApplication *application = [UIApplication sharedApplication]; if (MZSysVersion &lt;= 7.0) &#123; UIRemoteNotificationType nType = UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound; [application registerForRemoteNotificationTypes:nType]; &#125; else &#123; UIUserNotificationType nType = UIUserNotificationTypeBadge|UIUserNotificationTypeSound|UIUserNotificationTypeAlert; UIUserNotificationSettings *nSettings = [UIUserNotificationSettings settingsForTypes:nType categories:nil]; [application registerUserNotificationSettings:nSettings]; &#125;&#125; 关于用户授权, 分几种情况来看待. 情景一. 用户不允许 APP 推送, 即不授权. Appdelegate 代理调用 123456- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123; MZLOG(@&quot;App push. notificationSettings: %@&quot;, notificationSettings); [application registerForRemoteNotifications];&#125; 1- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error error 信息大概如下: 12Error Domain=NSCocoaErrorDomain Code=3000 &quot;未找到应用程序的“aps-environment”的授权字符串&quot;UserInfo=&#123;NSLocalizedDescription=未找到应用程序的“aps-environment”的授权字符串&#125; 情景二. 用户允许授权了, 又分为两种情况 1.使用具有 push 功能的证书 一定要有带有 push 功能的证书. 代理调用 123456- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123; MZLOG(@&quot;App push. notificationSettings: %@&quot;, notificationSettings); [application registerForRemoteNotifications];&#125; 这个方法大概在上面回调 1s 后才会调用. 12345678910111213- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123; MZLOG(@&quot;App push. deviceToken: %@&quot;, deviceToken); // 格式化该数据 NSString *deviceTokenStr = [NSString stringWithFormat:@&quot;%@&quot;, deviceToken]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; MZLOG(@&quot;App push. deviceToken string: %@&quot;, deviceTokenStr); // 可以上传该 token 到自己的业务服务器&#125; 在 didRegisterForRemoteNotificationsWithDeviceToken 方法中可以得到 deviceToken 信息: 注意: 代码中将 NSData 的 deviceToken 转换为了 NSString 类型的数据类型. 2.使用一般的证书, 没有 push 功能的证书 这种情况和 情景一 一样. 推送万事俱备, 只欠东风了. 今天没有准备搭建一个自己的业务服务器去推送, 可以使用推送工具来替代. 安装 NWPusher 这个工具, 可以进行推送测试. 安装成功后, 打开这个 Mac APP, 填写相关信息. 点击 push 即可推送. 在 Appdelegate 中的代理回调中, 可以打印推送内容. 1234- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123; MZLOG(@&quot;App push. userInfo: %@&quot;, userInfo);&#125; 推送的内容, 如下图所示. 1234567&#123; aps = &#123; alert = &quot;Testing.. (6)&quot;; badge = 1; sound = default; &#125;;&#125; 推荐1.活久见的重构 - iOS 10 UserNotifications 框架解析 2.国内 90%以上的 iOS 开发者，对 APNs 的认识都是错的]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>推送 APNs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 后台模式]]></title>
    <url>%2F2017%2F07%2F30%2FiOS-%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[应用状态来自苹果开发者文档 The App Life Cycle 的图. 下面这张图说明了应用程序的状态, 如下所示: 具体的说一下这5中状态: 1.Not running 未运行, 程序没启动或者被系统被用户杀死 2.Inactive 未激活, 程序在前台运行，不过没有接收到事件.在没有事件处理情况下程序通常停留在这个状态. 3.Active 激活, 程序在前台运行而且接收到了事件.这也是前台的一个正常的模式 4.Backgroud 后台, 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会.时间到之后会进入挂起状态(Suspended). 有的程序经过特殊的请求后可以长期处于 Backgroud 状态. 5.Suspended 挂起, 程序在后台不能执行代码.系统会自动把程序变成这个状态而且不会发出通知.当挂起时, 程序还是停留在内存中的, 当系统内存低时, 系统就把挂起的程序清除掉, 为前台程序提供更多的内存. 关于 Backgroud 状态, 是我们今天要说的重点部分. 多任务介绍iOS 的多任务是在 iOS4 的时候被引入的，在此之前 iOS 的 APP 都是按下 Home 键就被干掉了.iOS4 虽然引入了后台和多任务，但是实际上是伪多任务，一般的 APP 后台并不能执行自己的代码，只有少数几类服务在通过注册后可以真正在后台运行，并且在提交到 AppStore 的时候也会被严格审核是否有越权行为，这种限制主要是出于对于设备的续航和安全两方面进行的考虑.之后经过iOS5 和 iOS6 的逐渐发展，后台能运行的服务的种类虽然出现了增加，但是 iOS 后台的本质并没有变化.在iOS7之前，系统所接受的应用多任务可以大致分为几种： 后台完成某些花费时间的特定任务. 后台播放音乐等. 位置服务. IP电话(VOIP). Newsstand. iOS7 后台任务申请的最长时间 10分钟.iOS8+ 后台任务申请最长时间 3分钟. 示例: APP 退到后台会被挂起今天跟大家分享的是一般应用如何在后台延长生命周期的知识, 关于其他特殊的 App 如上面提到的5中情况, 不是今天讨论的重点. 我们先看一个例子, 例子很简单. 这里要说明一下概念, 直接锁屏和点击 Home 键, 都会导致应用处于后台模式, 这里为了说明问题, 统一点击 Home 作为代名词. 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil];&#125;- (void)onDidEnterBackground:(NSNotification *)notification &#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;); int delta = 1; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;); UILocalNotification *notification = [UILocalNotification new]; notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3]; notification.alertBody = @&quot;走, 去high吧!&quot;; notification.soundName = UILocalNotificationDefaultSoundName; // 可以自定义数据 notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;; [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125;);&#125; UIApplicationDidEnterBackgroundNotification 可以监听到用户将 APP 退到后台. 当 APP 退到后台, 会调用 onDidEnterBackground 这个方法. 在 onDidEnterBackground 这个方法中, 我故意延时执行代码, 这里使用的是 dispatch_after. 编译运行这个工程, 运行成功后, 可以点击 Home 键将应用退到后台. 可以在 Xcode 的控制台看到 App Background. Enter onDidEnterBackground. 的打印信息, 但是迟迟不见 dispatch_after 里面的代码执行. 这里说明, APP 退到后台后被系统挂起了. 另外一个例子就是使用 NSTimer, 在 APP 退到后台后, 也会被终止. 完整例子, 一会在文章后台附录给出. 通过后台模式延长 APP 运行上面的例子充分说明了, 在我们没有做任何处理的情况下, iOS 系统在 APP 退到后台的情况下, 会被系统挂起, 从而终止 APP 的代码行为. 下面通过实例, 来开启后台任务, 让 APP 尽可能的延长声明周期. 在工程的基础上, 新建一个文件 MZBackgroundTask 1234@interface MZBackgroundTask : NSObject+ (instancetype)sharedTask;- (void)startTask;@end 具体实现, 只给出关键代码. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677- (void)startTask &#123; if (![self _checkSupportBackgroundTask]) &#123; MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;); return; &#125; UIApplication *application = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier taskId; /// 申请后台执行 /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟 &#123; taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123; MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining); [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;]; &#125; if (UIBackgroundTaskInvalid == taskId) &#123; MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;); return; &#125; /// 可以监控后台任务剩余的时间, 针对业务可以去处理 &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __block NSTimeInterval remainedTime; while (true) &#123; // 剩余可以后台执行的时间 dispatch_async(dispatch_get_main_queue(), ^&#123; // application.backgroundTimeRemaining 必须在主线程获取 remainedTime = application.backgroundTimeRemaining; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime); if (remainedTime &lt; 10) &#123; // 可以告诉其他业务, 后台申请的时间即将结束了 &#125; if (remainedTime &lt; 2) &#123; /// 这里可以做一些清除工作 &#123; // clean up &#125; [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; return; &#125; // 睡眠(延时)1s [NSThread sleepForTimeInterval:1.f]; &#125;); &#125;); &#125; &#125;); &#125;&#125; startTask 开启后台任务. 在 AppDelegate 中, 调用这个方法. 1234- (void)applicationDidEnterBackground:(UIApplication *)application &#123; [[MZBackgroundTask sharedTask] startTask];&#125; 再次运行工程, 可以根据日志看出, 之前的 dispatch_after 和 timer 可以运行了, 并且可以运行3分钟(180s). 根据 backgroundTimeRemaining 这个属性, 可以看出具体的后台可执行的剩余时间. 注意: 我测试的时候使用的是 iOS10 设备. 后记除了苹果规定的几种类型(如定位, 录音, VOIP 等)的应用外, 其他 APP 想申请更多的后台驻留时间, 就需要一些 旁门左道 的方法了. 苹果对后台操作做了这么多限制, 也是从用户的角度出发, 如安全, 省电, 省流量等. 比如, 在后台播放没有声音的音乐. 再比如, 申请定位服务的权限, 这样也可以保持 APP 在后台不被挂起.但是, 依照苹果一贯的审核做法来看，如果声明了需要某项后台权限，你却没有相关实现的话，会直接被拒掉的. 这些是技术上的实现, 我没有推荐大家这么干, 现在苹果审核比以前还要严格, 大家还是悠着点干吧.如果你的 APP 不需要上架到 AppStore 的话, 就尽情的放纵吧… 推荐博文1.iOS实现无限后台background的方法 2.WWDC 2013 Session笔记 - iOS7中的多任务 iOS 在后台的时候如果不使用后台模式, socket 也会被系统关闭连接, 比如我们使用的 IM 功能.使用后台模式后, 向系统申请的时间(3分钟内), socket 还是没有被关闭的, 除非断网或者被路由器给断开了, 在申请的这段时间内, socekt 还是可以使用的, 如果想持续的保持 socket 连接, 就需要去了解一下 VOIP Socket 相关的知识了, 实践过后, 分享给大家. 附录下面是具体的实现代码. ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@interface ViewController ()@property (nonatomic, strong) NSTimer *timer;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil]; // 每隔一秒执行一次 _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(onTimerDidRun:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;#pragma mark - Callback.- (void)onTimerDidRun:(id)sender &#123; MZLOG(@&quot;App Background. Timer Running.&quot;);&#125;- (void)onDidEnterBackground:(NSNotification *)notification &#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;); int delta = 1; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;); UILocalNotification *notification = [UILocalNotification new]; notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3]; notification.alertBody = @&quot;走, 去high吧!&quot;; notification.soundName = UILocalNotificationDefaultSoundName; // 可以自定义数据 notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;; [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125;);&#125;#pragma mark - SetupViews.- (void)_setupViews &#123; self.view.backgroundColor = [UIColor purpleColor]; &#125; MZBackgroundTask.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#import &quot;MZBackgroundTask.h&quot;@implementation MZBackgroundTask+ (instancetype)sharedTask &#123; static MZBackgroundTask *_task; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _task = [[self alloc] init]; &#125;); return _task;&#125;- (void)startTask &#123; if (![self _checkSupportBackgroundTask]) &#123; MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;); return; &#125; UIApplication *application = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier taskId; /// 申请后台执行 /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟 &#123; taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123; MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining); [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;]; &#125; if (UIBackgroundTaskInvalid == taskId) &#123; MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;); return; &#125; /// 可以监控后台任务剩余的时间, 针对业务可以去处理 &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __block NSTimeInterval remainedTime; while (true) &#123; // 剩余可以后台执行的时间 dispatch_async(dispatch_get_main_queue(), ^&#123; // application.backgroundTimeRemaining 必须在主线程获取 remainedTime = application.backgroundTimeRemaining; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime); if (remainedTime &lt; 10) &#123; // 可以告诉其他业务, 后台申请的时间即将结束了 &#125; if (remainedTime &lt; 2) &#123; /// 这里可以做一些清除工作 &#123; // clean up &#125; [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; return; &#125; // 睡眠(延时)1s [NSThread sleepForTimeInterval:1.f]; &#125;); &#125;); &#125; &#125;); &#125;&#125;#pragma mark - Private./** * 当前设备是否支持后台任务. * * @return YES, 支持后台任务. 否则, 不支持后台任务. */- (BOOL)_checkSupportBackgroundTask &#123; SEL sel = @selector(isMultitaskingSupported); BOOL supportBTask = [[UIDevice currentDevice] respondsToSelector:sel]; return supportBTask;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>后台模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Charles]]></title>
    <url>%2F2017%2F07%2F23%2F%E4%BD%BF%E7%94%A8-Charles%2F</url>
    <content type="text"><![CDATA[概要Charles 是 Mac 上面比较好用的抓包工具. 在使用微信登录 SDK 的时候, 我想看看微信请求的内容, 以及其授权过程, 发现只要连接 Charles, 跳转到微信之后无法打开微信的授权登录页面, 提示网络不可用. 经过研究, 是需要使用 Charles 配置 HTTPS, 配置完成后, 就可以随心所欲了. 所以, 今天跟大家分享一下 Charles 使用的两个点: Charles 的 HTTPS 配置. 使用 Charles 模拟(慢)网络. 工具和系统 iPhone: iOS 10.3. Mac OS: 10.12.5. Charles: 4.0.2. 抓取 HTTPS 请求1.Mac 安装证书 打开 Charles, 在 Help 选项中选择 SSL Proxying, 如下图所示: 2.Mac 信任证书 打开 Keychain Access (钥匙串), 找到刚才安装的证书, 信任证书, 如图: 3.给 iPhone 安装证书 打开 Charles, 在 Help 选项中选择 SSL Proxying, 操作如图: 在弹出的对话框中, 可以看到 chls.pro/ssl 手机设置代理, 连接 Charles 一定要记住: 手机一定要设置代理, 否则安装证书会失败. 打开手机的 Safari 浏览器, 输入 chls.pro/ssl 这个地址. 设置信任证书, 如下图: 模拟任意网络Charles 给我们提供了可以模拟任何网速的网络环境的条件. 打开 Throttle Settings, 然后 Enable Throttling 可以看到很多类型的网络供你选择. Add Preset 可以自己自定义一个网络环境. 这个功能非常实用, 可以让我们模拟慢网络环境, 更好地调试自己的程序. 遇到麻烦1.抓取 HTTPS 的请求出现错误 错误日志如下: 123SSLHandshake: Received fatal alert: unknown_caCharles Proxy will even offer a helpful suggestion:You may need to configure your browser or application to trust the Charles Root Certificate. See SSL Proxying in the Help menu. 这种错误一般是出现在 iOS10 上面. 请在关于本机里面再设置一次 证书信任设置, 即可. 2.系统升级后, 设置的 HTTPS 抓包失效 按照上述方法, 重新设置一次即可.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Charles MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2d-js: 在 iOS 上运行]]></title>
    <url>%2F2017%2F07%2F23%2FCocos2d-js-%E5%9C%A8-iOS-%E4%B8%8A%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在我的博文 Cocos2d-js: 首次在 Mac 上面运行 这篇文章中, 介绍了 Cocos2d 相关的知识, 并且使用Cocos2dx 创建了一个 JS 的简单游戏项目. 今天跟大家分享一下, 如何在 ios 设备上面运行一个 JS 游戏项目. 该游戏项目(贪吃蛇)来自网络资源, 只供演示使用, 不提供任何关于游戏的资源. 当初的想当然在 Mac 上面 so easy 的编译并运行了 JS 游戏, 我想在 iOS 设备上应该也很简单的就可以运行起来, 但是我发现我简单不加思考的想法, 是行不通的. 博文 Cocos2d-js: 首次在 Mac 上面运行 在 FireFox 浏览器上面可以直接运行 index.html, 但是在 Chrome 浏览器上面就没那么顺利. 想到这里, 我就受到了启发, 莫非 iOS 设备上面需要自己搭建一套 Web Server? 搭建 Web Server既然想到了这一步, 接下来就是找方案实施了. CocoaHTTPServer 这个可以满足我的需求, 于是, 我就直接拿来使用了. 项目中, 我使用了 Cocoapods 来管理第三方库.在 podfile 中直接添加下面的代码: 1pod &apos;CocoaHTTPServer&apos;, &apos;~&gt; 2.3&apos; 然后 pod install 即可. 1.在 ViewController 中导入头文件 1234567891011#import &lt;HTTPServer.h&gt;ViewController 声明部分@interface ViewController () &lt;WKNavigationDelegate&gt;@property (nonatomic, strong) WKWebView *webView;@property (nonatomic, strong) HTTPServer *localHttpServer;@property (nonatomic, strong) WKWebViewConfiguration *wbConfig;//用于调试的 UILabel@property (nonatomic, strong) IBOutlet UILabel *loadingLb;@property (nonatomic, assign) BOOL startServerSuccess;@end 2.配置 Web Server 核心实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940 - (void)_configLocalHttpServer&#123; NSString *webPath = [[NSBundle mainBundle] pathForResource:@&quot;crazySnake&quot; ofType:nil]; _localHttpServer = [[HTTPServer alloc] init]; [_localHttpServer setType:@&quot;_http.tcp&quot;]; NSFileManager *fileManager = [[NSFileManager alloc] init]; NSLog(@&quot;%@&quot;, webPath); if (![fileManager fileExistsAtPath:webPath]) &#123; NSLog(@&quot;File path error!&quot;); &#125; else &#123; NSString *webLocalPath = webPath; [_localHttpServer setDocumentRoot:webLocalPath]; NSLog(@&quot;webLocalPath:%@&quot;, webLocalPath); [self _startWebServer]; &#125;&#125;- (void)_startWebServer&#123; self.loadingLb.hidden = NO; NSError *error; if ([_localHttpServer start:&amp;error]) &#123; NSLog(@&quot;Started HTTP Server on port %hu&quot;, [_localHttpServer listeningPort]); self.port = [NSString stringWithFormat:@&quot;%d&quot;, [_localHttpServer listeningPort]]; self.loadingLb.text = @&quot;Start Server Successfully.&quot;; _startServerSuccess = YES; &#125; else &#123; NSLog(@&quot;Error starting HTTP Server: %@&quot;, error); self.loadingLb.text = @&quot;Start Server failed.&quot;; _startServerSuccess = NO; &#125;&#125; _configLocalHttpServer 是配置 HTTPServer 的方法, _startWebServer 是开启 Web Server 的方法. 这样调用 _configLocalHttpServer 就可以开启在设备上面开启一个 Web Server 了. Xcode 导入 JS 游戏项目首先看一下我的工程和资源目录结构, 如图: 仔细看一下, crazySnake 这个文件夹是蓝色的, 不是黄色的. 这里特别注意, 导入这个 crazySnake 文件夹的时候, Options 一定要选择 Create folder reference. 为什么要这么做? 细心的朋友可以发现, 使用 Create folder reference导入的文件夹, 在项目打包生成的 archive 的文件中(自己可以解压看)是可以看到 crazySnake 这个文件夹的, 如果不是这种方式, 而是使用 Create groups 方式(在 Xcode 中显示黄色), 在 archive 中是看不到 crazySnake 这个文件夹的, 而是将里面的文件打散放在 archive 的根目录下面了. 总之, 一句话, Create folder reference 方式导入的文件夹在打包后还是原来的文件夹, 不会将文件夹里面的文件打散. 试想一下, 如果多加入几个这样的目录, 都打散在根目录下面, 我们就不好管理这个文件夹里面的文件了. 配置 WKWebView 这里我使用了 WKWebView 而不是 UIWebView 作为加载 HTML 的容器.当然, 你也可以使用 UIWebView. 主要的核心代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (void)viewDidLoad&#123; [super viewDidLoad]; self.navigationController.navigationBarHidden = YES; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.loadingLb.text = @&quot;Config server...&quot;; [self _configLocalHttpServer]; &#125;); /// 增加的调式方法: 可以重新启动 web server. &#123; SEL sel = @selector(_configLocalHttpServer); UITapGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:sel]; [self.loadingLb addGestureRecognizer:gesture]; self.loadingLb.userInteractionEnabled = YES; &#125;&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; // 配置 WKWebView dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; _wbConfig = [[WKWebViewConfiguration alloc] init]; self.wbConfig.userContentController = [[WKUserContentController alloc] init]; _webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:self.wbConfig]; _webView.frame = self.view.bounds; _webView.scrollView.showsHorizontalScrollIndicator = NO; _webView.scrollView.showsVerticalScrollIndicator = NO; [self.view addSubview:self.webView]; self.webView.frame = self.view.bounds; self.webView.navigationDelegate = self; if (self.startServerSuccess) &#123; self.loadingLb.hidden = YES; NSString *gameUrl = [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot; inDirectory:@&quot;crazySnake&quot;]; NSURL *url = [NSURL fileURLWithPath:gameUrl]; url = [NSURL URLWithString:[NSString stringWithFormat:@&quot;http://127.0.0.1:%@/index.html&quot;, self.port]]; [self.webView loadRequest:[NSURLRequest requestWithURL:url]]; &#125; &#125;);&#125; 代码很简单, 就是使用 WKWebView 加载一个 HTML 文件并启动 Web Server. 运行项目接下来, 就是见证奇迹的时刻了… 上面配置了 Web Server 和 加载 html 的 WKWebView, 现在可以直接运行项目看效果了. 无论你是在模拟器还是在真机上面都可以运行这个 JS 游戏项目了. 写在最后上面的例子本人亲自实践过的, 给大家提供了一个实现思路, 算是抛砖引玉. 如果想做好这个模式, 还需要很多工作要做, 这里列出来给大家分享一下. 1.游戏资源包管理和下载.2.游戏中需要和 Native 的交互逻辑.3.数据加密.4.移动端游戏本身的加载优化. 如果你有更好的方案和想法, 我很乐意邮件 (veryitman@126.com) 与你沟通, 非常感谢! 代码示例我放在了 GitHub, 点击 MZMWPlay 前往下载体验.]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>cocos Cocos2d-js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: Chrome 调试 WEB 页面]]></title>
    <url>%2F2017%2F06%2F01%2FAndroid-Chrome-%E8%B0%83%E8%AF%95-WEB-%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[引言在 Mac OS 上面通过 Safari 调试 iOS 设备或者模拟器的 WEB 页面, 比较方便. 关于具体如何使用 Safari 来调试 iOS 设备, 可以参考 [Safari 的开发者模式] 这篇文章. 自从踏上开发的道路, 电脑上就安装了 Chrome 浏览器, 并且一直保持着更新, Chrome 以其简单设计和高效的用法吸引了大批开发者. 使用 Chrome 调试 Android 设备的 WEB 页面, 易如反掌. Chrome 调试条件使用这项技能的条件如下: 1.Android 设备系统最低为4.4, 也就是 android-19 2.Chrome 最好使用最新版本的, 以前的版本不支持, 最低兼容版本目前尚不清楚. 3.配置 Android WebView, 使其支持 Debug 和使能 JavaScript 功能. 4.设备和 PC 通过 USB 连接正常, 且支持 USB 调试的. 我目前使用的设备和 Chrome 版本信息如下: Android 设备: 5.1.1版本Chrome: Version 58.0.3029.110 (64-bit) 我们在地址栏中输入: 1chrome://inspect 就可以打开设备列表界面. 可以看到我的 Android 设备已经显示出来了. 下面举个例子说明该调试工具的使用. 简单的 Android 工程示例该工程只有一个 Activity, 使用 WebView 加载本地 HTML 文件. 1. 创建 assets 目录工程切换到 Project Files 视图 这样就可以在 src/main 目录下新建了 assets 文件夹了. 2. 创建 HTML 文件 该 HTML 文件, 命名为 local.html, 放在 assets 目录下面. local.html 源文件: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;p&gt;A function is triggered when the button is clicked.&lt;/p&gt;&lt;script&gt; function myFunction() &#123; console.log(&apos;js console.&apos;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.在 Activity 中配置 WebView.Activity.java 源文件 12345678910111213141516171819202122232425262728public class MZWebPage extends AppCompatActivity &#123; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_mzweb_page); webView = (WebView) this.findViewById(R.id.ui_web_view); // 设置 WebView 的 Debug 为可用状态 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; WebSettings settings = webView.getSettings(); // 设置 JavaScript 可以使用, 否则在 HTML 中无法调用 JavaScript 代码 settings.setJavaScriptEnabled(true); // 本地文件 String url = &quot;file:///android_asset/local.html&quot;; webView.loadUrl(url); webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; return super.shouldOverrideUrlLoading(view, request); &#125; &#125;); // 设置渲染视图 webView.setWebChromeClient(new WebChromeClient()); &#125;&#125; 对应的 xml 布局文件: 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;demo.droidsdk.near.idreamsky.com.nearsdk.MZWebPage&quot;&gt; &lt;WebView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/ui_web_view&quot;&gt; &lt;/WebView&gt;&lt;/LinearLayout&gt; 4. 运行程序在 Chrome 中输入 chrome://inspect 打开, 可以看到正在运行的 local.html. 点击 inspect, 进入调试界面. 在调试界面, 点击页面的 Click me, 按钮, 对应的会有 log 输出. 5.调试出错的 HTML修改一下 local.html 文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;p&gt;A function is triggered when the button is clicked.&lt;/p&gt;&lt;script&gt; function myFunction() &#123; console.log(&apos;js console.&apos; + var_error); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里可以看出 var_error 是一个不存在的变量. 重新运行, 点击 Click me, 可以看到右侧的 error: 关于 Chrome 开发者工具的更多使用, 可以参考官方文档 Chrome 开发者工具.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Chrome Web Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持你的好习惯]]></title>
    <url>%2F2017%2F05%2F29%2F%E4%BF%9D%E6%8C%81%E4%BD%A0%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[明天就是传统的端午节了, 提前祝大家端午安康! 今天老婆让我帮忙把粽叶子洗洗, 说要包粽子, 我听话地把刚买来的粽叶子洗了个干净, 那都是带有绿色的叶子, 生机勃勃, 让我从指尖中感到无比的温馨和无尽的希望. 小的时候, 我很享受妈妈为我们包粽子的过程, 说实话, 我不是很喜欢吃粽子, 但是特别喜欢粽子锅里面的煮鸡蛋, 特别美味. 老家的粽子没有什么特色, 就是简简单单的糯米被包在叶子中, 然后放在锅里慢慢的煮, 熟了之后, 蘸点白糖就可以吃了. 到了南方之后, 我才发现世界上原来有各种各样的粽子, 红枣的, 绿豆的, 猪肉馅的, 鸡肉馅的…等等! 这些都是偶发的回忆, 和今天的推文没有关系, 不信, 你接着往下看. 养成阅读的习惯我不是一个聪明的孩子, 直到小学三年级, 我才真正的开始明白学习到底是怎么一回事, 用老家人的话说算是开窍了. 后来我很顺利的上了初中, 家里的大部分收入要靠庄家, 一年四季能够风调雨顺的话, 也能过个不错的年, 至少能把学费给交上. 初中二年级的时候, 我辍学了, 也许是命运的安排吧, 当时自己也没有多想, 毅然决定下学去寻找另一种人生. 于是, 我选择了理发这个行业. 和师傅在风风雨雨中度过了一年多的时间, 在当时的农村, 不上学有门手艺也算是对自己和父母有个交代. 我的内心仍然渴望去上学, 虽然不知道为什么要去上学也不知道上学后能干什么, 但是心里面总是觉得自己不能放弃学业.在理发的一年多时间里, 我没有放弃过学习.冥冥之中自有安排, 妈妈有次问我: “还想去上学不?”, 我想都没想就情不自禁的点头了, 妈妈又说:”我就知道你没有放弃, 去继续上学吧, 不要留下遗憾!”.当时的我甭提有多高兴了. 再次回到校园的我比以前更加努力和拼命了, 更加懂得如何珍惜这来之不易的学习机会了. 直到大学毕业, 参加工作以及有了孩子后, 我也能保持自我学习和自我激励的状态, 保持好的阅读习惯, 让我受益终身. 有次孩子早晨起床忙完后, 就开始坐在那里看书, 有好几次晚上, 我也发现他洗完澡后, 坐在那里看书, 或者是做手工, 或是画画. 我感到很好奇, 决定找个机会问问他. 有一个周末的上午, 早餐过后, 我就把他拉到身边, 和他一起看儿童读物, 问他:”宝贝, 你为什么喜欢看书呢?”, 他说:”爸爸, 是你影响了我, 你喜欢看书, 我也喜欢看书.”, 看着他一副天真的样子, 我真的不敢相信几岁的孩子能说出这样的话, 但我内心感到无比的欣慰.原来好的习惯会传染给自己身边的人, 并且能让你感到自豪. 坚持写博客写博客或者是生活日记, 确实很”浪费”时间, 甚至会占用你任何休息的时间, 写博客偶尔也会让你抓耳挠腮, 感叹:”书到用时方恨少”! 所以, 读, 写不能分家, 更应该是将二者紧密的联合在一起.多阅读多写, 才会让你更加的通透, 当然了, 我只是喜欢写, 写的质量也很一般, 只是为了满足内心的那一点点对知识的渴望. 写的多了, 你就更加愿意去思考了, 思考多了, 很多事情你就看开了, 对你的生活和工作都有好处. 从09年到现在我一直坚持写博客, 刚开始也是无从下笔, 不知道自己到底该写一写什么东西, 写了之后, 是不是别人看了会嘲笑我, 诸如此类的担心太多太多, 后来我也想明白了, 你写的再好也有人比你写得好, 也会有人说你写的不好.那我何必去计较这么些个事儿了, 只管动手写吧! 然后, 就在博客网站上面耕耘, 技术的, 吐槽的, 生活的我都喜欢写, 不管你喜不喜欢看, 它都在那里, 哈哈! 我把博客当做自己的朋友, 心情好亦或是不好的时候, 我都会向他倾诉, 希望自己写下的东西或多或少能帮助一些人, 这也许是我坚持写博客的最大动力了. 如果你也喜欢写博客或者是准备写博客, 就开始动手写吧, 不要再犹豫了. 最后这个世界上, 没多少人喜欢听别人啰嗦, 即使听了你的啰嗦, 也不一定会付出实践, 即使你是长者或者是智者, 况且我只是一介平民. 但是我还是要啰嗦一句:”保持持续学习的习惯, 会消耗你的勤奋, 但会让你受益终生”, 信不信由你!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考 生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Safari 的开发者模式]]></title>
    <url>%2F2017%2F05%2F15%2FSafari-%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设置 Safari1.打开 Safari 的 Preference 2.切换到 Advanced 选项 将 Show Develop menu in menu bar 选中. 可以看到 Safari 多了 Develop 选项 设置设备或者模拟器在 iphone或者模拟器 中设置 Safari打开 Safari 的高级选项 打开 Web 检查器 上面设置完毕后, 运行你的程序, 在 Safari 的 Develop 中可以看到对应设备, 从而可以调试 HTML 页面了. 在调试窗口中，可以看到当前正在加载网页的各种信息，如源码、请求头、图片、加载的资源与脚本、控制台输出等. 也可以直接修改网页的 CSS 样式和布局等进行修改，而不用重新运行 App. 使用 Safari 的开发者模式, 可以帮助我们调试前端页面, 解决一些问题, 比较方便.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS Safari</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 自定义 UIWebView 和 WKWebView 的 UserAgent]]></title>
    <url>%2F2017%2F05%2F14%2FiOS-%E8%87%AA%E5%AE%9A%E4%B9%89-UIWebView-%E5%92%8C-WKWebView-%E7%9A%84-UserAgent%2F</url>
    <content type="text"><![CDATA[导言在 iOS8, 苹果推出了 WKWebView, 目的很明显: 取代 UIWebView. 随着时间的推移, 越来越多的应用开始最低版本支持为 iOS8, 大家也纷纷的开始使用 WKWebView 组件. 在 iOS10.x 版本上, UIWebView 的表现不尽如人意, 在我们的后台日志和用户反馈, 存在很多莫名其妙的 crash 以及卡顿现象, 内存飙升等问题. 针对不同的 JS 游戏引擎, UIWebView 表现也不够好, 所以是时候使用 WKWebView 了. 但是话又说回来, 如果你最低版本支持 iOS8, 也不能完全放弃 UIWebView, WKWebView 有一部分 API 只有 iOS9+ 才有, 如果你的应用在 iOS8 运行而使用 iOS9 的 API, 肯定会 crash. 例如: 1.清除缓存.2.设置 user-agent. 今天要说的是关于设置自定义 UIWebView 和 WKWebView 的 UserAgent 问题. WKWebView UserAgent默认的 UserAgent使用下面的代码, 可以输出 WKWebView 的默认 UserAgent. 12345678910- (void)viewDidload &#123; [self.wkWebView evaluateJavaScript:@&quot;navigator.appName&quot; completionHandler:^(id __nullable appName, NSError * __nullable error) &#123; NSLog(@&quot;navigator.appName: %@&quot;, appName); &#125;]; [self.wkWebView evaluateJavaScript:@&quot;navigator.userAgent&quot; completionHandler:^(id __nullable userAgent, NSError * __nullable error) &#123; NSLog(@&quot;navigator.userAgent: %@&quot;, userAgent); &#125;];&#125; navigator.appName 无论在 iOS8, iOS9 还是 iOS10, 输出结果都是一致的. navigator.userAgent 在不同的 iOS 系统上面输出结果略有不同. 123456// iOS 8.3// Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12F70// iOS 9.0// Mozilla/5.0 (iPhone; CPU iPhone OS 9_0 like Mac OS X) AppleWebKit/601.1.32 (KHTML, like Gecko) Mobile/13A4254v// iOS 10.x//Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E269 自定义 UserAgent修改默认的 UserAgent, 需要使用下面的方法. 1self.wkWebView.customUserAgent = @&quot;CustomUserAgent&quot; 这样, 就改变了其默认的 UserAgent 值了. 特别需要注意: customUserAgent 是 iOS9 之后才有的字段. 123/*! @abstract The custom user agent string or nil if no custom user agent string has been set.*/@property (nullable, nonatomic, copy) NSString *customUserAgent API_AVAILABLE(macosx(10.11), ios(9.0)); 所以在 iOS8.x, 如果你想改变 UserAgent, 还是要使用 UIWebView. HTML 使用 UserAgentHTML 中可以根据自定义的 UserAgent, 做出不同的行为, 如自定的 UserAgent 可以包括应用的版本号, HTML 可以根据不同的版本来做版本区分等逻辑. 在 HTML 中, 可以使用 JS 来获取 UserAgent 的值. Demo.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;user-agent&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function getUserAgent() &#123; var ug = navigator.userAgent; document.getElementById(&quot;mySpan&quot;).innerHTML = ug; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示 user-agent&lt;/h1&gt; &lt;p&gt;&lt;span style=&quot;font-size:30px&quot; id=&quot;mySpan&quot;&gt;..&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;点击显示 user-agent&quot; onclick=&quot;getUserAgent()&quot; class=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/body&gt; &lt;style&gt; .button &#123; background-color: #4C0950; border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 40px; margin: 20px 200px 100px 300px; cursor: pointer; border-radius: 15; &#125; &lt;/style&gt;&lt;/html&gt; 使用 WKWebView 加载该 Demo.html 文件, 效果图如下: UIWebView UserAgent默认的 UserAgent使用下面的代码, 可以输出 UIWebView 的默认 UserAgent. 12345NSString *appName = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.appName&quot;];NSLog(@&quot;navigator.appName: %@&quot;, appName); NSString *userAgent = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];NSLog(@&quot;navigator.userAgent %@&quot;, userAgent); 打印输出结果和 WKWebView 的结果一致. 设置自定的 UserAgent设置一个 key 为 @”UserAgent” 的本地存储即可. 1234567[[NSUserDefaults standardUserDefaults] registerDefaults:@&#123;@&quot;UserAgent&quot;:@&quot;CustomUserAgent-UIWebView&quot;&#125;]; NSString *appName = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.appName&quot;];NSLog(@&quot;navigator.appName: %@&quot;, appName); NSString *userAgent = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];NSLog(@&quot;navigator.userAgent %@&quot;, userAgent); 这样就改变了 UIWebView 的默认 UserAgent 了. 小结应用最低版本支持 iOS7/8 的开发者们, 可以考虑 UIWebView 和 WKWebView 并存的开发模式. iOS9及以上的开发者你们, 可以完全放弃 UIWebView, 大胆的拥抱 WKWebView 了. 移植 UIWebView 到 WKWebView 的成本不算大.如果你现在有时间, 可以开始着手做这些事了.前端和客户端需要考虑之前交互那部分的逻辑, 即 JS 调用 Native 或者 Native 调用 JS 的需要做些调整, 因为 WKWebView 的调用方式和 UIWebView 不一样了, 前端页面要考虑版本兼容性. 新的 WKWebView 虽然存在一些坑, 但是使用它亦是大势所趋, 正所谓 存在即合理, 你没有理由拒绝它. 后续, 我会写一写在 WKWebView 上面遇到的一些问题, 分享给大家. 之前我也写过一篇文章, 是关于 UIWebView 缓存的, 不妨, 你也瞅瞅 [iOS: 聊聊 UIWebView 缓存].]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIWebView WKWebView UserAgent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2d-js: 首次在 Mac 上面运行]]></title>
    <url>%2F2017%2F05%2F14%2FCocos2d-js-%E9%A6%96%E6%AC%A1%E5%9C%A8-Mac-%E4%B8%8A%E9%9D%A2%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Cocos2d-js 介绍如果你是刚接触 Cocos2d-js 开发的人, 一定会被 Cocos2d-js 和 Cocos2d-HTML5 以及 Cocos2d-x 搞得晕头转向. 下面简单介绍一下 Cocos2d-js 的前世今生. 目前 Cocos2d-x 支持使用 C++、Lua、Javascript 语言来进行开发，且内置 JavaScript 引擎，通过 C++ 解析 Javascript 去执行. Cocos2d-HTML5 是使用 JavaScript 进行开发，最终运行在浏览器里的. v3.0 后，Cocos2d-HTML5 和 Cocos2d-x JSBinding 被合到了一起，称作 Cocos2d-JS. 与 Cocos2d-HTML5 不同的是，Cocos2d-js 开发的程序不仅能运行在浏览器里，还能编译运行在 Mac OSX, Windows, iOS, Android 平台上. 从 Cocos2d-x v3.7 版本之后, js 版本被合并到 Cocos2d-x 中了. 具体可以看 Release Note 这个说明. 这个版本的发布日期是在2015年7月21. 原来的 Cocos2d-js 版本在 [GitHub] 上面已经停止更新了. 说明如下: 2/27/2016 - This repository is no longer active.Cocos2d-JS was merged with Cocos2d-x starting at version 3.7. 可以看出, Cocos2d-js 原来独立的项目被合并到了 Cocos2d-x 中了. 现在使用 Cocos2d-x 不仅可以创建 cpp 项目和 lua 项目, 也可以创建 js 项目了. 官方有说明的: Cocos2d-JS is Cocos2d-x engine’s JavaScript version that includes Cocos2d-html5 and Cocos2d-x JavaScript Bindings. 至于什么是 Cocos2d-x JavaScript Bindings, 大家自行 google, 这里不赘述. 关系图大概如下: Cocos2d-x 框架图 搭建 Cocos2d-js 开发环境1.下载 Cocos2d-x可以在官网下载最新的 Release 包, 点击 下载地址, 我下载的最新包是 cocos2d-x-3.15. 下载解压即可, 这里我把 cocos2d-x-3.15 修改为 cocos2d-x. 设置环境变量在 cocos2d-x 目录, 执行 1python setup.py 执行完毕后, 可以看到 ‘~/.bash_profile` 的内容 123456# Add environment variable COCOS_CONSOLE_ROOT for cocos2d-xexport COCOS_CONSOLE_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/tools/cocos2d-console/binexport PATH=$COCOS_CONSOLE_ROOT:$PATH# Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-xexport COCOS_TEMPLATES_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/templatesexport PATH=$COCOS_TEMPLATES_ROOT:$PATH 这里, 没有看到我的 ANT_ROOT 路径, 其实该脚本智能的找到 /usr/local/Cellar/ant/1.9.7/bin, 但是我不想使用这个 ant, 想使用自己下载的 ant, 修改该文件如下: 123456789# Add environment variable COCOS_CONSOLE_ROOT for cocos2d-xexport COCOS_CONSOLE_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/tools/cocos2d-console/binexport PATH=$COCOS_CONSOLE_ROOT:$PATH# Add environment variable ANT_ROOT for cocos2d-xexport ANT_ROOT=/Users/mark/developer/apache/apache-ant-1.10.1/binexport PATH=$ANT_ROOT:$PATH# Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-xexport COCOS_TEMPLATES_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/templatesexport PATH=$COCOS_TEMPLATES_ROOT:$PATH 最后执行: 1source ~/.bash_profile 使环境变量立即生效. 创建 js 工程cd 到任意目录, 执行: 1cocos new HelloJs -l js -d . new HelloJs 表示工程名字为 HelloJs-l js 表示创建 js 工程.-d . 表示在当前路径创建该工程 可以看到下面创建工程的过程: 123456789Copy template into /Users/mark/workspace/mzProjs/c2dx/works/HelloJsCopying directory from cocos root directory...Copying files from template directory...Copying Cocos2d-x files...Rename project name from &apos;HelloJavascript&apos; to &apos;HelloJs&apos;Replace the project name from &apos;HelloJavascript&apos; to &apos;HelloJs&apos;Replace the project package name from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;Replace the Mac bundle id from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;Replace the iOS bundle id from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos; 工程目录: 工程发布将上面的工程编译发布. 编译发布: 1cocos compile -p web -m release -p web 表示编译 web 平台.-m release 表示编译为 release 模式. 编译输出: 12345678Building mode: releaserunning: &apos;/Users/mark/developer/apache/apache-ant-1.10.1/bin/ant -f /Users/mark/workspace/mzProjs/c2dx/works/HelloJs/publish/html5/build.xml&apos;Buildfile: /Users/mark/workspace/mzProjs/c2dx/works/HelloJs/publish/html5/build.xmlcompile: [jscomp] Compiling 156 file(s) with 42 extern(s) [jscomp] 0 error(s), 0 warning(s)BUILD SUCCESSFULTotal time: 8 seconds 如果你在这一步编译报错, 或者执行不下去, 一般都是没有在环境变量中配置好 ant. 编程成功后, 会多出 publish 目录: 运行执行 cocos run 命令来在系统默认的浏览器上面运行. cd 到工程目录, 执行: 1cocos run -p web -s . --port 9009 这样会帮我们在本地启动一个 webServer 来运行示例, 直接打开了默认使用的浏览器. -s: 表示当前需要执行的源码路径–port: 指定端口, 如果不指定端口, 默认在 8000 端口执行. 更多 cocos run 命令可以, 使用下面的命令来查看帮助: 1cocos run --help 本地运行 index.html 的问题你可以用火狐浏览器(FireFox)打开本地工程目录中的 index.html, 即可看到运行效果了.FireFox 应该是在本地启动了一个 WebServer 来运行. 在 chrome 中直接运行 index.html, 无法看到最终效果, 一直卡在 loading 界面. 打开 inspect, 可以看到报错信息: 12XMLHttpRequest cannot load file:/xx/publish/html5/project.json.Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 网上有人讨论过过问题, 说是 chrome 跨域不支持 file 协议，那么即使你允许 chrome 跨域支持, 直接运行本地的 index.html 还是报错: 1game.min.js:54 Uncaught TypeError: Cannot read property &apos;modules&apos; of null 在 MacOS 上面允许 chrome 跨域访问文件的方法: 1open /Applications/Google\ Chrome.app --args --allow-file-access-from-files 可以看出, 在这方面, FireFox 做的比 chrome 好. 更新 更新时间 2017-10-15 在微信公众号上面看到 一招教你辨别 Cocos、Cocos2d、Cocos2d-x 这篇文章, 大家可以看看, 对 cocos 会有更加深入的了解.]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>cocos cocos2d-js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小篮球队]]></title>
    <url>%2F2017%2F04%2F29%2F%E5%B0%8F%E5%B0%8F%E7%AF%AE%E7%90%83%E9%98%9F%2F</url>
    <content type="text"><![CDATA[篮球, 我最喜欢的一项体育运动, 大学的业余时间基本都”泡”在球场, 压根不知道什么是累. 毕业后的第一份工作, 做的比较开心, 大家年龄相仿, 兴趣相投. 小小的团队, 没有任何纷争, 大家互相学习, 氛围及其融洽. 每个周五我们几个人都会提前下班去打一场篮球, 完事后, 一起喝点小酒, 那日子甭提有多他NND的惬意. 公司解散后, 大家各奔东西, 事过境迁, 各有各的工作和生活, 聚在一起的日子也是少之又少, 以前的日子只能怀念了. 人总需要一些非工作之外的兴趣, 整天围绕着工作, 早晚都会疯掉. 有些人喜欢泡泡图书馆, 有些人喜欢打打游戏, 有些人喜欢跑跑步, 有些人喜欢唱唱歌… 不管怎么样, 你需要某种爱好, 来润色一下你的生活, 我选择了篮球运动. 下面, 来说说篮球队中典型的几种人, 大家结合自己的工作和生活, 思考一下吧~ 单打独斗篮球运动是一项集体运动, 需要每个人发挥自己应有的水平, 才能发挥团队的力量. 有些人喜欢单打独斗, 完全不考虑团队中其他成员的感受, 只要球到了他手中, 其他人只能看他的表演, 任凭你喊破嗓子, 他也不会理你. 这种人, 其实是有一定能力的人, 不然也不会也不可能这么做, 只是他们觉得凭一己之力就可以让大家高正无忧了, 自己没有思考过这样做是不是最合适的. 久而久之, 大家看着他的”表演”, 再也不想发挥了, 单打独斗的人慢慢的也累了, 最后大家都身心疲惫, 球队被对方轻而易举地打败. “指挥官”球队中有一种人, 自己不努力, 总是喜欢颐指气使, 经常听到他们说这样的话: 你快点跑呀, 积极点…死死地防着他, 不要让他进攻, 快…你传球给我呀, 让你别着急, 好了吧, 输了吧…输了, 都怪你… 听到这些话, 再好脾气的人估计都难以接受, 脾气不好的直接开始打他了吧! 这种人最不受待见, 也最遭人唾骂, 这种人在实际工作中, 可能是你的领导. 偷懒的篮球运动的确很消耗体力, 如果在万箭齐发的时刻, 有人故意掉链子, 那将是功亏一篑. 大家在打球的时候, 都在为”荣誉”而战, 但是偏偏有人会使点小心眼, 能少跑一步就少跑一步, 能放对方走就放对方走, 绝对不伤害对方一毛一线. 明明可以稍微努力一下, 就可以拿到篮板, 偏偏让对方比自己还矮小的轻而易举的拿走了篮板. 要知道比自己矮小的那个人, 只是努力的跳了一下. 球场上虽然不是让你拼个你死我活, 不要求你全力以赴, 但是尽力而为总是要有的, 这是一种态度. 在实际工作中, 这种”队友”比比皆是, 但是不一定遭人恨, 有些还是很招人喜欢的, 毕竟他们没有抢你的功劳, 处处让着你, 没有他们的这些所谓的付出, 哪能衬托出你的光芒. 鼓励你的上面说的都是一些”负能量”, 大家一笑而过吧.下面说点正能量的. 在球队中, 还有一种这样的人, 他会察言观色, 觉得你累了, 就告诉大家: “我们应该节奏慢一点, 缓冲一下.”, 当你手感不好的时候, 他会告诉你, 没事, 多来几次就好了, 不要有压力. 当你防守遇到困难时, 他会默默的给你补防, 给你接力, 最大程度的给你信心. 当大家士气不高的时候, 他会站出来投几个漂亮的球, 抑或给对方一个完美的盖帽, 并且鼓励大家不要放弃, 给大家信心, 做大家坚固的后盾. 这种人除了自己有一定的能力外, 还能顾全大局, 并且可以帮助队友, 帮助团队渡过难关, 确实难得. 渴望进步的球队中, 存在一些新人, 或者是渴望自己能投出漂亮弧线球的人, 他们比不上那些资历老且经验丰富的前辈, 但是他们内心有一份信念: “我要变强!”. 这种人, 跟你讨论球技, 虚心向你学习一切可以提高球技的方法, 即使在观众席上, 他们也能聚精会神的观看, 自己领悟其中的奥妙. 只要你约他出来打球, 他都在第一时间出现在球场, 因为他不想放弃学习的机会. 久而久之, 这些人会变得越来越厉害, 通过不断的学习和摸索, 有了一套自己的打法, 步伐稳健, 再也不是那种接球不稳, 传球频频失误的”毛头小子”了. 这种人, 值得我们去挖掘和鼓励, 如果你正好是那个资历老且经验丰富的前辈, 就传授”真经”给他们吧.对于你来说, 有人愿意跟你学习, 跟你分享, 也是美事一桩. 何乐而不为呢? 最后不管你遇到什么样的队友, 如果你愿意, 请胸怀宇宙(当然不是 孙连城 那种啊). 万事万物皆有联系, 愿你能偶尔放下手中的工作, 去选择和爱上另一种乐趣. 五一放假了, 祝大家节日快乐!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 应用内打开 AppStore]]></title>
    <url>%2F2017%2F04%2F15%2FiOS-%E5%BA%94%E7%94%A8%E5%86%85%E6%89%93%E5%BC%80-AppStore%2F</url>
    <content type="text"><![CDATA[应用场景我们的 App 需要在 AppStore 上面打开某个 App 或者游戏, 目的最常见的有: 1.评分评论.2.推荐下载(App 或者游戏). 很多开发者知道打开 AppStore 只需要一句代码: 1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itunes app url&quot;]]; 这样就很简单的打开 AppStore 了, 但是产品经理问了, 能在我们应用内打开 AppStore 吗? 你当时懵逼了吗? 不要懵逼, 以后只要遇到类似这种问题, 你就问产品经理哪个 APP 这样做了?然后, 他就给你看别人家的效果, 你就理直气壮地说: “别人可以做到的, 我们也可以做到!”. 应用内打开 AppStore 也很简单.在 iOS6之后, 苹果已经给我们提供了 SKStoreProductViewController, 大家看一下文档, 你就笑了. 12SKStoreProductViewController/* View controller to display iTunes Store product information */ 应用内打开 AppStore这里我以在应用内打开 微信 为例子. 效果图如下: 从效果图可以看出, 用户在自己的应用内打开 AppStore 后, 不仅可以下载或者打开微信, 还可以直接评论评分, 简直爽(也难怪产品经理这么干). 那我们说一下如何实现上面的效果. 实现方案和步骤 1.包含头文件 #import &lt;StoreKit/StoreKit.h&gt; 2.实现 SKStoreProductViewControllerDelegate 具体代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)openAppFromAppStore:(NSString *)appid&#123; if (nil == appid || appid.length &lt;= 0) &#123; return; &#125; // 加个 loading SKStoreProductViewController *store = [[SKStoreProductViewController alloc] init]; store.delegate = self; NSDictionary&lt;NSString *, id&gt; *parameters = @&#123;SKStoreProductParameterITunesItemIdentifier: appid&#125;; [store loadProductWithParameters:parameters completionBlock:^(BOOL result, NSError *error) &#123; // 结束 loading if (error) &#123; NSLog(@&quot;error %@ with userInfo %@&quot;, error, [error userInfo]); // 提示用户发生了错误 // 或者通过 URL 打开 AppStore App. // NSString *url = @&quot;https://itunes.apple.com/in/app/wechat/id414478124?mt=8&quot;; //[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; &#125; else &#123; [self presentViewController:store animated:YES completion:^&#123; &#125;]; &#125; &#125;];&#125;/// 用户点击取消会执行该方法- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController&#123; [viewController dismissViewControllerAnimated:YES completion:^&#123; &#125;];&#125; 调用(@”414478124” 是 微信 的)方式: 1[self openAppFromAppStore:@&quot;414478124&quot;]; 修改 AppStore 的导航栏产品经理说, 既然你已经实现了上面的功能, 看看能不能把 AppStore 的导航栏改一个牛逼的颜色, 就像上面的大红色. ~ 可以, 干! 直接上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)openAppFromAppStore:(NSString *)appid&#123; if (nil == appid || appid.length &lt;= 0) &#123; return; &#125; // 加个 loading // 导航栏上面的文字和图片颜色变了 [[UINavigationBar appearance] setTintColor:[UIColor greenColor]]; // 导航栏的大红色出来了 [[UINavigationBar appearance] setBarTintColor:[UIColor redColor]]; [UINavigationBar appearanceWhenContainedIn:[SKStoreProductViewController class], nil]; SKStoreProductViewController *store = [[SKStoreProductViewController alloc] init]; store.delegate = self; NSDictionary&lt;NSString *, id&gt; *parameters = @&#123;SKStoreProductParameterITunesItemIdentifier: appid&#125;; [store loadProductWithParameters:parameters completionBlock:^(BOOL result, NSError *error) &#123; // 结束 loading if (error) &#123; NSLog(@&quot;error %@ with userInfo %@&quot;, error, [error userInfo]); // 提示用户发生了错误 // 或者通过 URL 打开 AppStore App. &#125; else &#123; [self presentViewController:store animated:YES completion:^&#123; &#125;]; &#125; &#125;];&#125; 注意事项1.打开 SKStoreProductViewController 目前只能使用 present 方式, 不可以使用 push 的方式. 否则会报错: 12//Terminating app due to uncaught exception &apos;SKUnsupportedPresentationException&apos;,//reason: &apos;SKStoreProductViewController must be used in a modal view controller&apos; 2.加入 loading 在应用内打开 AppStore, 为了不让用户傻等(网络不好的时候, 打开很慢), 可以加入 loading, 缓解一下用户急躁的心情.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找合伙人, 不易]]></title>
    <url>%2F2017%2F03%2F26%2F%E6%89%BE%E5%90%88%E4%BC%99%E4%BA%BA-%E4%B8%8D%E6%98%93%2F</url>
    <content type="text"><![CDATA[早在高中时期, 读过 &lt;三言&gt; 中的 &lt;警世通言&gt;, 第一章写的是 俞伯牙摔琴谢知音, 讲的是钟子期和俞伯牙的故事. 读完之后, 整个人都觉得难受, 心理有说不出的滋味, 眼泪竟夺眶而出. 流传的这首诗, 可以感受下. 摔碎瑶琴凤尾寒，子期不在对谁弹！春风满面皆朋友，欲觅知音难上难。势利交怀势利心，斯文谁复念知音！伯牙不作钟期逝，千古令人说破琴。 自己工作之后, 对 欲觅知音难上难 这句话尤为赞同. 年少轻狂的你, 藏着要改变世界的心, 残酷的现实会抹去你凸起的棱角, 岁月和环境会让你变得越发不安. 不安的世界, 让你茫然. 于是, 点上一支烟, 回顾折腾的人生, 笑叹: 别人笑我太疯癫, 我笑他人看不穿. 可惜, 我们不是唐寅, 没有这份洒脱和奔放, 毕竟时代也大相径庭. ~ 好了, 回到现实中来. 刚毕业, 你会把主要精力放在如何把工作做好, 维持自己的生计上面, 如果能跟身边的大牛学到一些专业知识, 再苦再累, 你都是开心的. 渐渐地, 你发现知识(专业的和非专业的知识)真是要活到老学到老, 永无止境, 无法像武侠片里面演得那样移花接木, 斗转星移. 呜呼, 脚踏实地的做好本职工作, 顺便能拓展一下自己的交际圈, 扩大自己的知识面, 还是很有必要的. 各行各业都有非常突出的人才, 很多时候, 我们只能望洋兴叹. 如果你能遇到一个肯与你分享和交流, 或者是愿意将自己的实践分享给你的人, 那你算是上辈子积了大德了. 阿弥陀佛! 我把这样的人称之为 恩人, 也算是 知音. 以前, 很多朋友会问如果将来自己开公司, 是否愿意接受现在的自己, 我的回答是一定接受. 如果还有人问这个问题, 我会另外再追加一个问题: 如果你开公司, 你是否愿意接受和你现在一起工作的同事?或者说你是否愿意让他成为你的合伙人? 这些问题, 看似玩笑, 实则很现实很残酷, 一旦你决定要去做成某件事情, 立志要实现自己的抱负和理想的时候, 你的立场会和其他人千差外别.首先要考虑的是要和谁一起共谋事, 才能真正的帮到自己, 并且也能帮到别人.因为选择是双向的, 能找到和你一拍即合的人, 也确实不易.但愿任何一个渴望成功并付出行动的人, 能找到自己的合伙人, 找到自己的知音. 真正的成功者, 不是沉浸在多少人让你成功的喜悦中, 而是你让多少人和你一起分享了成功的喜悦的人. 说到这里, 本人只是想说明白一个道理, 送给即将或者已经在职场奋斗的人: 踏踏实实的做事并没有错, 但是找到值得 “托付终身” 的人确实不易, 你现在能做的只有用知识来武装自己, 让自己变强. 在职场中, 你会遇到很多让你不爽的人或者事. 记住, 要做到 对事不对人, 不要太委屈自己, 大丈夫能屈能伸, 该出手时就出手, 没有什么大不了. 如果真的觉得有些人或者有些事不值得你浪费时间, 就离它们远点. 惹不起但可以躲得起, 你说呢? 酌一壶小酒, 老夫聊发少年狂!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考 生活 合伙人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让自己变强]]></title>
    <url>%2F2017%2F03%2F10%2F%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%8F%98%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[当你读到这篇文章的时候, 我其实还不知道『怎么让自己变强』.具体说, 就是没有一套让你或者让他变强的武林秘籍. 只能结合自己经历的事, 分享给大家, 希望能感同身受! 这几天加班加地有点猛, 浑然不知周末轮回了.心理总是在念叨, 好久没有在公众号涂鸦了, 手痒痒了.趁今晚回来早(22:30回到家), 就动笔了. 『让自己变强』, 这句话说着很简单, 但不是任何人都能意识到这几个字带来的力量. 在「明朝那些事儿」中有这么一段: 我们经常会产生一个疑问，那就是怎样才能获得其他国家及其人民的尊重，在世界上风光自豪一把，其实答案很简单——国家强大。 看到这里, 感触颇深. 在团队中成长团队成长的主观条件是团队的成员要成长, 不然团队哪里来的成长. 如果你是作为一个团队或者小组的负责人, 会面临各种各样的问题, 比如需要跟团队以外的部门谈合作, 需要跟老板汇报工作, 还要处理内部的问题等等诸如此类! 我觉得安邦需安内, 也就是说要先搞定团队内部的各种事物, 人是比较复杂的感情动物, 你不好也不能控制别人的情绪. 所以, 需要对事不对人!你不能说, 你看他长得不好看, 就知道工作做不好类似的话. 这样一说, 基本两个人就结下了梁子.迟早会爆发. 首先, 要给团队成员希望, 让大家都认识到有统一的目标. 其次, 让每个人给出工作和实行计划, 制定自己的考核目标.对做出突出贡献的成员奖励, 每个人都需要得到尊重, 而奖励是最大的尊重. 最后, 加强与团队成员之间的沟通, 互相帮助, 让大家能够相互信任和鼓励, 良好有效的沟通, 事半功倍. 作为团队负责人, 肯定希望手下的人各个骁勇善战, 百战百胜, 但是现实中很难做到, 其实也没有必要.西游记告诉我们, 唐僧带领的团队才是最好的团队. 少埋怨多给予帮助每个人生活和工作的环境不一样, 在不同的地点不同的时间面对不同的事情, 都会有不同的看法. 世界上任何一种选择, 都是命中注定的, 没有人能强迫你去做出任何错误的选择, 除了你自己. 在自己所处的环境中, 要么你能改变环境使其来适应自己, 要么就离开这个自己不适应的环境, 不要去抱怨. 唉声叹气, 不仅仅影响自己的工作效率和生活质量, 还会影响到别人.成天在抱怨, 觉得谁谁都不行, 自己才是最牛逼的, 日行见久, 你就是那个充满负能量的人, 当别人觉悟到的时候, 就会离你而去, 岂不咎由自取?!我想这也是微信朋友圈只有点赞没有非点赞的原因吧! 如果觉得自己的同事或者朋友有所欠缺, 就想办法去帮助他, 鼓励他, 把你认为一些好的方式和方法传授给他. 说不定哪天因为你的一句话或者一个方法, 他就走上人生巅峰了, 哈哈! 从现在开始, 忘记埋怨, 给予别人更多的帮助和鼓励. 培养自己的专注力专注力, 是一个很神奇的东西. 如果一个人没有专注力, 很难再有所突破, 据说牛顿是在做梦的时候, 发明了很多折磨广大青少年的牛顿定律的. 每个人在自己的行业上, 多少都有短板. 有短板是情有可原的, 但是首先你得认识到自己的短板, 然后再指定计划去突破他. 要想进步, 必须面对自己的不足. 比如, 工作上需要你学会某种技术, 如果在某个时间点, 你没有学会, 可能就会丢掉饭碗, 你就会不顾一切的去学习, 直到学会会用为止. 这个过程, 你就是在专注这件事情, 回头想想咬咬牙, 还是可以办到的, 没有什么大不了的. 每天给自己一点时间, 专注去做一件事情, 坚持下来, 你会发现, 学习和进步就是 feel feel 倍儿爽. 最后分享给大家一句话: 不能改变别人的时候, 试着改变一下自己或许就能把事情变通了.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔 生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat8 配置 HTTPS]]></title>
    <url>%2F2017%2F02%2F15%2FTomcat8-%E9%85%8D%E7%BD%AE-HTTPS%2F</url>
    <content type="text"><![CDATA[博客 [Tomcat8 域名配置] 介绍了如何在本地配置 Tomcat8 的域名以及通过域名来访问对应的资源. 今天继续跟大家分享如何配置 Tomcat8 的 HTTPS (单向认证), 本篇博客的主要内容如下: 1.配置 Tomcat 的 HTTPS.2.通过 HTTPS + ip 的方式来访问资源.3.通过 HTTPS + 域名 的方式来访问资源. 配置要求1.安装了 JDK, 并配置了其相关的环境变量.可参考 Mac 配置 JDK1.8. 2.安装了 Tomcat8, 并配置了其相关的环境变量.可参考 Mac 配置 Tomcat8. 生成证书 获取证书可以去购买, 这里是在本地机器搭建, 使用 JDK 自带的工具 keytool 生成即可. 打开 mac 终端, 执行: 1keytool -v -genkey -alias tomcat -keyalg RSA -keystore ~/Desktop/tomcat.keystore 紧接着, 会出现一些让你输入信息的交互信息, 第一个是让你输入 密钥库密码(口令), 我输入的是 1234567, 其他信息可以任意输入内容, 在最后一步, 问你生成的 密钥口令 和 密钥库的口令 是否相同, 如果相同就直接回车, 我这里是直接回车的, 即密码相同, 都是 1234567. 这样就生成了所谓的证书. 配置 HTTPS 通过修改 server.xml 来配置. 将 tomcat.keystore 文件复制到 Tomcat 的 conf 目录. 修改 server.xml 文件, 增加一个 Connector, 内容如下: 123&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;conf/tomcat.keystore&quot; keystorePass=&quot;1234567&quot;/&gt; 注意, keystoreFile 是证书文件, keystorePass 是密码, 这里配置一定要正确. 配置 HTTPS + IP配置一个虚拟主机, 修改 server.xml 文件, 增加 Host: 1234&lt;Host name=&quot;192.168.1.103&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 配置 name=”192.168.1.103” 是你本机的 ip 地址. 这个在博客 [iOS: 聊聊 UIWebView 缓存] 中有详细的介绍, 这里不再赘述. 启动 Tomcat, 进行测试. 这里需要到 Tomcat 的 bin 目录下, 执行: 1sudo startup.sh 启动成功后, 打开浏览器, 输入: https://192.168.1.103:8443/test.html, 这个时候, 会弹出如下的警告(提示不安全): 直接点击 Advanced 后再点击 Proceed to 192.168.1.103:8443(unsafe) 处理即可看到页面内容. 配置 HTTPS + 域名修改 server.xml, 增加 Connector: 123&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;conf/tomcat.keystore&quot; keystorePass=&quot;1234567&quot;/&gt; 修改 server.xml, 增加 Host: 1234&lt;Host name=&quot;www.mark.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 修改 /etc/host 文件, 增加: 1127.0.0.1 www.mark.com 启动 Tomcat, 在 bin 目录, 执行: 12shutdown.shsudo startup.sh 启动成功后, 打开浏览器, 输入 https://www.mark.com:8443/test.html, 如果弹出警告, 可以像如上处理来显示页面内容. 如果你这里配置失败了, 请修改一下端口号, 如将 8443 改为 8433.重启 Tomcat 在试一下. 参考Apache 官方文档: ssl-howto]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tomcat Java Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat8 域名配置]]></title>
    <url>%2F2017%2F02%2F13%2FTomcat8-%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[博客 [Mac 配置 Tomcat8] 介绍了在 Mac 下安装和启动 Tomcat. 接下来介绍, 如何在本地配置 Tomcat8 的域名. 网上有很多关于 Tomcat 如何配置单域名或者多域名的文章, 很多都是翻译或者复制别人的, 根本没有实践过, 害人不浅! 结合自己的实践, 把配置的整个过程分享给大家, 希望能帮到你. 下面进入正题. 修改端口在 Tomcat 的安装(其实是解压的)目录 /conf 下有 server.xml 文件. 将下面内容: 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改为: 123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 添加 web 项目 这一步主要是为了后面测试. 很简单, 在 Tomcat 的安装目录 webapps 下面新建 test 文件夹, 里面创建一个 html 文件即可.这里将其命名为 test.html. test.html 内容见后面的附录即可. 配置域名 增加虚拟主机配置.还需要修改 server.xml 文件. 在 server.xml 文件中, 在标签 和 之间增加下面的内容: 1234&lt;Host name=&quot;www.mark.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 其中, www.mark.com 是我自己任意取的一个域名, docBase=”test” 是指向上面新建的 test 目录. 配置域名解析由于部署在本地, 需要修改 host. 修改 /etc/host 文件, 需要 sudo 权限: 1sudo vim /etc/host 增加如下内容: 1127.0.0.1 www.mark.com 验证配置 这一步, 验证配置是否生效. 启动 Tomcat, 这里的操作比较特殊, 需要 sudo 权限来启动 Tomcat, 否则会报下面的错误: 12org.apache.coyote.AbstractProtocol.init Failed to initialize end point associated with ProtocolHandler [&quot;http-nio-80&quot;] java.net.SocketException: Permission denied 因为, 只有 root 用户才可以使用 1024 以下的端口号. 正确姿势: cd 进入 Tomcat 的 bin 目录 1cd ~/Tomcat/bin 执行: 1sudo startup.sh 成功后, 打开浏览器, 输入 http://www.mark.com/test.html, 即可看到页面内容. 配置另一个域名可以配置另外的一个域名, 比如 www.ithome.com, 即多增加一个虚拟主机配置. 在 server.xml 增加: 1234&lt;Host name=&quot;www.ithome.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 配置 DNS, 同理修改 etc/host 文件: 1127.0.0.1 www.ithome.com 可以看出, 在浏览器输入 http://www.ithome.com/test.html 和 http://www.mark.com/test.html 效果是一样的. 附录test.html 文件内容 123456789101112131415161718192021222324252627282930313233343536&lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy&lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy &lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt; mark.zhang is an itman.&lt;/p&gt;&lt;style&gt;.button &#123; background-color: #4CAF50; border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 86px; margin: 50px 200px 100px 300px; cursor: pointer; border-radius: 15;&#125;&lt;/style&gt;&lt;p&gt; &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot; class=&quot;button&quot;&gt;Try it&lt;/button&gt;&lt;/p&gt;&lt;script&gt; function myFunction() &#123; alert(&quot;Blog: www.veryitman.com&quot;); &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tomcat Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATS: HTTPS 认证]]></title>
    <url>%2F2017%2F02%2F08%2FATS-HTTPS-%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[简介在 ATS: HTTP/HTTPS 协议介绍 中介绍了一些关于 HTTP/HTTPS 的概念以及相关的基本知识。 今天来聊聊关于 HTTPS 的认证方式和过程。 说 HTTPS 认证前，我们先了解一下几个相关概念。 关于加密的几个概念1. SSL 协议加密方式 SSL 既用了对称加密，也用了非对称加密。 在建立传输链路时, SSL 首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL 对传输内容使用对称加密。 下面是两种加密方式的对比： 1.1、对称加密 对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，这种方法在密码学中叫做 对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，而且对计算机功能要求也没有那么高。IDEA 加密标准由 PGP（Pretty Good Privacy）系统使用。 该加密方式，速度快，可加密内容较大，用来加密会话过程中的消息。 1.2、非对称加密 1976年，美国学者 Dime 和 Henman 为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于 对称加密算法 这种方法也叫做 非对称加密算法。与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）. 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 该加密方式，速度较慢，能提供更好的身份认证技术，用来加密对称加密的密钥。 2. 数字证书一种文件的名称，好比一个机构或人的签名就好比一个公司的公章一样，能够证明这个机构或人的真实性，其中包含的信息，用于实现上述功能。 CA 证书（即数字证书）是由 CA（Certification Authority，证书颁发机构）机构发布的数字证书。其内容包含电子签证机关的信息、公钥用户信息、公钥、签名和有效期。这里的公钥是服务端的公钥、签名是指用 hash 散列函数计算公开的明文信息的信息摘要，然后采用 CA 的私钥对信息摘要进行加密，加密完的密文就是签名。 即 证书 = 公钥 + 签名 +申请者和颁发者的信息。 客户端中因为在操作系统中就预置了 CA 的公钥，所以支持解密签名（因为签名使用 CA 的私钥加密的）。 我们为什么需要 CA 认证机构颁发证书？ HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造通信方以及窃取网络通信内容，而 HTTPS 协议主要解决的便是网络传输的安全性问题。 我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的 中间人攻击（Man-in-the-MiddleAttack，简称 “MITM攻击”）问题。 推荐大家看看 网络世界背后的“功臣”——CA 认证 这篇文章。 3. 加密和认证加密是指通信双方为了防止敏感信息在信道上被第三方窃听而泄漏，将明文通过加密变成密文，如果第三方无法解密的话，就算获得密文也无能为力。 认证是指通信双方为了确认对方是值得信任的消息发送或接受方，而不是使用假身份的非法者，采取的确认身份的方式。 只有同时进行了加密和认证才能保证通信的安全，因此在 SSL 通信协议中这两者(加密和认证)都被使用。 加密一般使用 对称加密算法 和 不对称加密算法，最常见的算法非对称加密就是 RSA 加密算法。 4. 消息摘要这个技术主要是为了避免消息被篡改，消息摘要也称之为数字摘要。 消息摘要是把一段信息通过某种不可逆的算法，得出一串字符串。这个字符串就是消息的摘要，如果消息被篡改(发生了变化)，那么摘要也一定会发生变化，当然了如果两个不同的消息生成的摘要是一样的，那么这就叫发生了 碰撞。好的摘要算法是没有人能从中找到 碰撞 或者说极度难找到。 消息摘要的算法主要有 MD2、MD4、MD5、SHA-1、SHA-256、RIPEMD128、RIPEMD160 等，在证书领域，一般都是用 SHA(安全哈希算法)。消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。 数字证书、加密和认证、消息摘要三个技术结合起来，就是在 HTTPS 中广泛应用的证书（certificate），证书本身携带了加密/解密的信息，并且可以标识自己的身份，也自带消息摘要。 HTTPS 认证方式分为单向和双向认证。 单向认证 单向认证较简单，只需要客户端校验服务端的证书的合法性即可。换句话说，只需要客户端验证 SSL 服务器身份，不需要服务端验证 SSL 客户端身份。 也就是说单向认证不需要客户端保存 CA 证书即单向认证 SSL 协议不需要客户拥有 CA 证书。 该认证过程使用下面的流程图来表示: 双向认证 双向认证和单向认证原理基本一致，但是需要双方都校验对方的证书的合法性。换句话说， 要求服务器和客户端双方都有证书，客户端需要校验服务端，服务端也需要校验客户端。 也就是说双向认证需要客户端、服务端都要保存证书。 该认证过程使用下面的流程图来表示： 这里总结一下双向通信的流程🤦‍。 第1步：客户端向服务端发起请求 这个过程主要做了下面两件事情： ①、客户端生成随机数 R1 发送给服务端； ②、告诉服务端自己支持哪些加密算法； 第2步：服务器向客户端发送数字证书 ①、服务端生成随机数 R2； ②、从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成）; ③、服务端把证书、随机数 R2 和会话密钥生成算法，一起发给客户端； 第3步：客户端验证数字证书 ①、验证证书的可靠性，先用 CA 的公钥解密被加密过后的证书，能解密则说明证书没有问题，然后通过证书里提供的摘要算法对数据进行摘要计算，然后通过自己生成的摘要与服务端发送的摘要比对，比对如果一致表示通信内容没有被修改； ②、验证证书合法性，包括证书是否吊销、是否到期、域名是否匹配，通过后则进行后面的流程； ③、获得证书的公钥、会话密钥生成算法、随机数 R2（服务端生成的）； ④、客户端生成第三个随机数 R3； ⑤、根据会话秘钥算法使用 R1、R2、R3 生成会话秘钥； ⑥、用服务端证书的公钥加密随机数 R3 并发送给服务端； 第4步：服务器得到会话密钥 ①、服务器用私钥解密客户端发过来的随机数 R3； ②、根据会话秘钥算法使用 R1、R2、R3 生成会话秘钥； 第5步：客户端与服务端进行加密会话 ①、客户端发送加密数据给服务端，客户端加密数据后发送给服务端。 ②、服务端响应客户端，服务端用会话密钥解密客户端发送的数据，然后用会话密钥把响应的数据加密发送给客户端； ③、客户端用会话密钥解密服务端响应的数据； 从上面可以看出，前4步属于双方的通信握手过程，第5步才进行真正的通信。在握手的过程中使用了 非对称加密 主要用于生成后续通信的密钥，在后续的数据通信中使用了 对称加密。 随机数的产生不管是单向认证，还是双向认证，都有随机数的产生和发送，其中 R1、R2 都是明文传输，只有 R3 是加密传输的。 R1：Client Random，是由客户端产生的随机数； R2：Server Random，是由服务端产生的随机数； R3：是客户端产生的且使用密钥加密的随机数，也称之为 Premaster secret； 主密钥（Master Secret）是由预备主密钥 Premaster secret 即 R3、R1 和 R2 通过 PRF（PredoRandomFunction，伪随机数函数） 函数生成的（不过在 TLS 1.3 中，不再使用 PRF 这种算法了，而是采用更标准的 HKDF 算法来进行密钥的推导），后续客户端、服务端使用的 会话密钥 则是由主密钥根据一定的算法生成的。另外要注意的是，会话密钥也会变的，只是在当前某个会话中它是不变的另外建立会话后它又改变了。 随机数的产生流程图: 无论是单向认证还是双向认证都会生成三个随机数即上述流程中的 R1、R2、R3，根据三个随机数创建一个对称加密的秘钥。前两个随机数可以被抓包拿到，但第三个随机数已经使用非对称加密算法加密过，所以最终生成的秘钥是保密的。对称秘钥的安全靠第三个随机数的不可破解来保证。理论上来说，只要服务器的公钥足够长，那么 R3（也被称之为 Premaster secret） 可以保证不被破解。但是为了足够安全，可以考虑把握手阶段的算法从默认的 RSA 算法改为 Diffie-Hellman 算法（简称 DH 算法）。 我们思考一个问题：为何需要生成3个随机数，1个不行吗？ 1、并不是每个主机都能产生完全的随机数，有很多产生的随机数只是弱随机数而已如范围小可能被猜测，这样就不安全了； 2、用 3 个随机数一起生成密钥能使得伪随机数更接近随机； 大家可以看看 TLS 中的密钥计算 这篇文章，里面详细的讲解了随机数生成的原理以及不同 TLS 版本生成会话密钥的差异。 推荐推荐在线流程图工具: ProcessOn. 推荐博文: 1、图解SSL/TLS协议 2、HTTPS的七个误解(译文) 3、对称加密和非对称加密介绍和区别 4、你连HTTPS 原理没搞懂，还给我讲“中间人攻击” 本文中参考了上面文章的部分内容，感谢以上文章作者们。]]></content>
      <categories>
        <category>iOS</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP HTTPS TLS SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATS: HTTP/HTTPS 协议介绍]]></title>
    <url>%2F2017%2F02%2F06%2FATS-HTTP-HTTPS-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[苹果在2017年要求 App 必须支持 HTTPS，不过, 这个要求,，最后又被苹果自己延期了。我只能说，苹果的开发哥哥们真会玩…但是不管怎么说，作为一名合格的程序员还是有义务和责任了解并理解 HTTPS 整个通信过程以及原理的。 该系列博客介绍 iOS 上面的 ATS 以及相关的 HTTPS 知识，分为两篇来分享。 本篇是第一篇，第二篇：ATS: HTTPS 认证 。 今天先简单了解一下 HTTPS 以及相关的知识。 相关名词先了解一下相关的常用名词。 1.HTTPHyperText Transfer Protocol，超文本传输协议。 2.HTTPSHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议。 3.SSLSecure Socket Layer，安全套接字层。 4.TLSTransport Layer Security，传输层安全.其前身就是 SSL. 5.ATSApp Transport Security，应用传输安全。 协议介绍HTTPHTTP 全称是 HyperText Transfer Protocol，即超文本传输协议，是互联网上使用最广泛的一种协议，所有 WWW 文件必须遵循的标准。 HTTP 协议传输的数据都是未加密的, 也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。默认使用 TCP 端口 80. HTTPS安全的超文本传输协议，Hyper Text Transfer Protocol over Secure Socket Layer，网景公式设计了 SSL(Secure Socket Layer) 协议用于对 HTTP 协议传输的数据进行加密，保证会话过程中的安全性。 HTTPS 协议默认使用 TCP 的 443 端口。 拆分 HTTPSSSL 协议加密方式SSL 协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密（主要用于证书校验，这里指的证书是CA认证机构颁发的证书也就是常说的数字证书），链路建立好之后，SSL 对传输内容使用对称加密。 1、对称加密（通信双方使用同一个密钥解密）速度高，可加密内容较大，用来加密会话过程中的消息。 2、非对称加密（通信双方使用不同密钥解密或者解密）加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥。 HTTP+SSLHTTPS，可以看做是 HTTP+SSL，所以我们应该把重点在 SSL 上面。 HTTPS在 HTTP 基础上提出的一种安全的 HTTP 协议，因此可以称为安全的超文本传输协议。 HTTP 协议直接放置在 TCP 协议之上，而 HTTPS 提出在 HTTP 和 TCP 中间加上一层加密层。 从发送端看，这一层负责把 HTTP 的内容加密后送到下层的 TCP，从接收方看，这一层负责将 TCP 送来的数据解密还原成 HTTP 的内容。 SSL(Secure Socket Layer)是 Netscape 公司设计的主要用于 WEB 的安全传输协议.它在 HTTPS 协议栈中负责实现上面提到的加密层. 一个 HTTPS 协议栈大致是这样的： TLSHTTPS，也称作 HTTP over TLS. TLS (传输层安全, Transport Layer Security) 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3. 苹果 ATS (App Transport Security)，要求支持 HTTPS 的 TLS 版本最低为 V1.2. 下图描述了在 TCP/IP 协议栈中 TLS(各子协议）和 HTTP 的关系: 其中 Handshake protocol，Change Ciper Spec protocol 和 Alert protocol 组成了 SSL Handshaking Protocols. SSL 和 TLS 的发展历史: 1994年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布。 1995年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞。 1996年，SSL 3.0 版问世，得到大规模应用。 1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。 2006年和2008年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版.最新的变动是2011年 TLS 1.2 的修订版。 TLS 1.3 改动会比较大，目前还在草案阶段。 HTTP 和 HTTPS 区别HTTPS 和 HTTP 的区别主要为以下四点: 1、HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费，费用越高那么安全性会越好，所谓一分价钱一分货在这里被体现的淋漓尽致。 2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SLL/TLS 加密传输协议(非对称加密)。 3、HTTP 和 HTTPS 不同的连接方式，用的端口也不一样，前者是 80，后者是 443. 4、HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议更加安全。]]></content>
      <categories>
        <category>iOS</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>ATS HTTP HTTPS SSL TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: Yarn]]></title>
    <url>%2F2017%2F02%2F05%2FRN-Yarn%2F</url>
    <content type="text"><![CDATA[React Native 正式版已经更新到 0.41.1 了. 最近使用 react-native-cli 来创建 React Native 工程, 提示如下信息: 123This will walk you through creating a new React Native project in /Users/mark/workspace/mzProjs/ReactNative/LatestRNInstalling react-native...Consider installing yarn to make this faster: https://yarnpkg.com 其实 Yarn 也一直在更新, 最新版本 v0.20.0. 官网对应的有中文版本和中文文档, 可以 点此进入. Yarn 简介一句话介绍: A new package manager for JavaScript Yarn 是一个依赖管理工具，它能够管理你的代码，并与全世界的开发者分享你的代码. Yarn 是高效、安全和可靠. 1.高效: 使用了缓存, 可以很快的获取已经 download 的包.2.安全: 在代码被执行之前，会使用CheckSum算法验证每一个依赖包的完整性.3.可靠: 在不同平台(windows/mac/linux)只要是同一份配置文件, 执行结果是一样的. 还有很多特性: 123456789101112Offline ModeIf you&apos;ve installed a package before, you can install it again without any internet connection.DeterministicThe same dependencies will be installed the same exact way across every machine regardless of install order.Network PerformanceYarn efficiently queues up requests and avoids request waterfalls in order to maximize network utilization.Same PackagesInstall any package from npm and keep your package workflow the same.Network ResilienceA single request failing won&apos;t cause an install to fail. Requests are retried upon failure.Flat ModeResolve mismatching versions of dependencies to a single version to avoid creating duplicates. Yarn 能够让你使用其他开发者开发的代码，让你更容易的开发软件. 代码是通过依赖包 (有时也被称为组件). 在每一个依赖中会定义一个 package.json 文件，用来描述这个依赖包中所有要被分享的代码. Yarn 是开源的, 点击 Github 了解更多. 对比 npm 和 yarn, 可以阅读文章:Yarn vs npm: Everything You Need to Know 中文版:译 Yarn vs npm: 你需要知道的一切 安装 Yarn具体安装的教程, 可以参考官网的 安装教程. 在 MacOS 上面使用 Homebrew 安装很方便, 两个命令即可完成. 下面具体说说操作步骤. 强烈开发同事购买一个 VPN, 这个年头没有 VPN, 日子不好过. 1.更新 brew 1brew update --verbose 最后加上参数 --verbose, 不然等待的过程很煎熬, 没有任何提示信息. 2.安装 yarn 1brew install yarn 在安装过程中, 如果提示如下信息: 12345Please note by default only English locale support is provided. If you needfull locale support you should either rebuild with full icu: `brew reinstall node --with-full-icu`or add full icu data at runtime following: https://github.com/nodejs/node/wiki/Intl#using-and-customizing-the-small-icu-build 可以重新安装已经安装的 node, 执行命令: 1brew reinstall node --with-full-icu 在执行上面安装命令的时候, 如果卡住不动或者很久, Ctrl+C 终止当前的操作, 重新操作一遍即可. 安装成功后, 可以查看安装的版本信息, 执行 1yarn --verbose 会显示如下信息: 12345yarn install v0.20.0verbose Performing &quot;GET&quot; request to &quot;https://yarnpkg.com/latest-version&quot;.[1/4] 🔍 Resolving packages...success Already up-to-date.✨ Done in 0.29s. 使用 brew 安装 Yarn 后, 不需要设置环境变量. Yarn 与 React Native在 React Native 0.37 版本中已经加入了对 Yarn 的支持. 可以在 React Native 的官方的这篇 Blog 找到更多信息. 用 Yarn 创建 React Native 工程 既然 RN 已经支持了 Yarn, 那么就可以使用 Yarn 来管理和创建 RN 工程了. 使用 Yarn, 必须满足几个条件: 1.react-native-cli 的版本不能小于 1.2.0 版本.2.React Natvie 必须是 0.37 及以上的版本. 1react-native init MZLatestRN 当你安装好 Yarn 后, 执行上面的命令可以出现提示信息: 123This will walk you through creating a new React Native project in ~/workspace/Projs/ReactNative/MZLatestRNUsing yarn v0.20.0Installing react-native... 可以看出, RN 会使用 Yarn 来创建工程. 其中, ~/workspace/Projs/ReactNative 是我本地的工作目录. MZLatestRN 是要创建的 RN 工程名称. 如果你的网络好的话, 大概1分钟就可以创建成功. 工程目录: 可以看出多了 yarn.lock 文件. Yarn 还在茁壮成长, 希望它越来越好, 更多的使用和工作原理可以参考 官方 Doc, 介绍的很详细.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative iOS Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 PHP 遇到的问题]]></title>
    <url>%2F2017%2F02%2F02%2F%E5%AE%89%E8%A3%85-PHP-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简介在博客 PHP 开发准备 介绍了安装并部署 PHP 程序到 Nginx. 今天分享在安装中遇到的问题和其他工具的安装, 以及常用的操作, 包括 MySQL, Nginx 等. pecl 安装 PEAR 是 PHP 扩展与应用库(PHP Extension and Application Repository) 的缩写。它是一个 PHP 扩展及应用的一个代码仓库，简单地说，PEAR 就是 PHP 的 CPAN. PECL (PHP Extension Community Library)，PHP 的扩展库，它提供了一系列已知的扩展库，由 C++ 等其他语言编写而成，以 .so 形式出现，.so 为共享库, 是 shared object, 用于动态连接的, 和 dll 差不多，为比 PEAR 更快，但是与 PEAR 不同的是，PECL 需要在服务器上配置并被注册到主机中. 最直接的表述: PEAR 是 PHP 的上层扩展，PECL 是 PHP 的底层扩展. 下面说如何安装 pecl 和 pear. 1.下载 pear 1curl -O http://pear.php.net/go-pear.phar 2.安装 pear 1sudo php -d detect_unicode=0 go-pear.phar 3.执行以上命令后会进行安装过程，会有一些配置选项 输入1，回车，配置 pear 路径为：/usr/local/pear输入4，回车，配置命令路径为：/usr/local/bin 4.回车两次，其他让其默认，安装完成. 5.可以通过命令检查 pear 是否安装成功 1pear version 或者执行: 1pecl version 可以看到类似信息: 123PEAR Version: 1.10.1PHP Version: 5.6.27Zend Engine Version: 2.6.0 常用操作MySQL 操作基本操作： 1234mysql.server start #启动mysql.server stop #停止mysql -u root -p #用 user 和 pwd 连接php-fpm 相关操作 1.运行 php-fpm 1sudo php-fpm -D 2.关闭 php-fpm 1sudo killall php-fpm 3.查看 php-fpm 运行状态 1sudo lsof -Pni4 | grep LISTEN | grep php 可以看到 (fpm 默认在 9000 端口) 1234php-fpm 84200 root 8u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 84201 _www 0u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 84202 _www 0u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 84203 _www 0u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN) 4.php-fpm 开机启动 12ln -sfv /usr/local/opt/php56/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.php56.plist Nginx1.测试配置是否有语法错误 1nginx -t 2.启动 nginx 1sudo nginx 3.重新加载配置|重启|停止|退出 nginx 1nginx -s reload|reopen|stop|quit 4.开机启动： 12ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist 5.nginx 监听 80 端口： 12sudo chown root:wheel /usr/local/Cellar/nginx/1.6.0_1/bin/nginxsudo chmod u+s /usr/local/Cellar/nginx/1.6.0_1/bin/nginx 常用目录因为使用了 Homebrew 安装的 PHP, 配置文件的目录不是常规的 /etc 这里有几个目录需要知道, 如下: 123/private/etc/usr/local/etc/php/5.6/usr/local/var/www 遇到问题1.执行 sudo php-fpm -D 报 php56-intl/intl.so 加载问题 warning 的内容大致如下: 123456789NOTICE: PHP message: PHP Warning: PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found in Unknown on line 0&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;: PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;Unknown(0) : Warning - PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found[31-Dec-2016 22:40:38] NOTICE: PHP message: PHP Warning: PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match in Unknown on line 0 解决方案: 执行下面的命令, 即可解决.方案来源 Github. 1brew reinstall --build-from-source php56-intl 2.执行 sudo php-fpm -D 报 PHP Startup: mcrypt: Unable to initialize module 12345678910111213141531-Dec-2016 22:56:51] NOTICE: PHP message: PHP Warning: PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match in Unknown on line 0&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;: PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;Unknown(0) : Warning - PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match 解决方案: 1brew reinstall --build-from-source php56-intl 3.连接 mysql 使用 mysql -u root -p 连接 mysql, 提示 Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock 错误. 解决方案: 启动 mysql 1mysql.server start 重新连接即可.]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>PHP MySql nginx php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 开发准备]]></title>
    <url>%2F2017%2F02%2F02%2FPHP-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[注意：这篇文章是基于 Homebrew 安装 php5.6 以及 nginx 和 mysql 的介绍，安装高版本的 php 请绕行。 简介亲自实践在 MacOS 上面安装 PHP5.6+MySQL+Nginx. 将自己遇到的问题和对应的解决方案, 分享出来, 希望能帮到你. MacOS 上面搭建 PHP 开发环境, 使用 Homebrew 来安装对应的开发套件, 就更加简单了. 这篇博客的目的就是安装 PHP 开发环境, 并将第一个 PHP 程序部署在 Nginx 上面. 如果在安装和使用过程中遇到问题, 可以查看这篇博客: Mac PHP 安装遇到的问题. 下面开始介绍具体的安装步骤. 一. 安装 Homebrew这个大家可以自行访问 Homebrew 了解, 这里不再涉及具体的安装过程和方法. 二. 安装 php56 1.加入官方源 123brew tap homebrew/dupesbrew tap homebrew/versionsbrew tap homebrew/php 2.安装 PHP 默认安装会运行在 Apache 下.而我们要使它运行在 PHP-fpm 下，所以要增加参数: 1--with-fpm --without-apache 查看所有安装参数可以输入: 1brew option php56 进行查看，参考安装指令： 123456789101112brew install php56 \--without-snmp \--without-apache \--with-debug \--with-fpm \--with-intl \--with-homebrew-curl \--with-homebrew-libxslt \--with-homebrew-openssl \--with-imap \--with-mysql \--with-tidy 这里使用了下面的选项: 1with-homebrew-curl 我试过不带此选项, 安装 PHP56 会失败, 找不到 curl. 安装成功后, 可以查看版本信息: 12php -vphp-fpm -v 此时看到是的系统自带的版本. 下面一步是增加环境变量, 完成后在看版本信息, 即可. 3.配置 PHP 环境变量 配置环境变量的目的是要使用 brew 安装的 PHP 和 PHP-fpm, 不使用 MacOS 自带的 PHP 版本. /usr/local/sbin/ 下面是我们 brew 安装的 PHP, 其实他是一个软连接指向:/usr/local/Cellar/php56/5.6.27_4/sbin /usr/local/bin/ 下面也是 brew 安装的 PHP, 指向:/usr/local/Cellar/php56/5.6.27_4/bin vim ~/.bash_profile 增加 1export PATH=&quot;/usr/local/sbin:$PATH&quot; 使其立即生效, 执行 1source ~/.bash_profile 或者重启终端. 如果想看系统的 PHP 版本可以这样: 1/usr/bin/php -v 4.配置 php-fpm 1sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf 1sudo vi /private/etc/php-fpm.conf 找到 error_log 项，添加下面配置： 12error_log = /usr/local/var/log/php-fpm.logpid = /usr/local/var/run/php-fpm.pid 否则会报: 1FPM initialization failed 三. 安装 nginx1brew install nginx 创建文件 12345mkdir -p /usr/local/var/logs/nginxmkdir -p /usr/local/etc/nginx/sites-availablemkdir -p /usr/local/etc/nginx/sites-enabledmkdir -p /usr/local/etc/nginx/conf.dmkdir -p /usr/local/etc/nginx/ssl 1234567sudo mkdir -p /var/wwwsudo chown :staff /var/wwwsudo chmod 775 /var/wwwvi /var/www/info.phpvi /var/www/index.htmlvi /var/www/403.htmlvi /var/www/404.html 改变 nginx.conf 配置文件 该配置文件在 /usr/local/etc/nginx/nginx.conf 下面. 我的配置: 1234567891011121314151617181920212223242526272829303132333435363738worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log debug;pid /usr/local/var/run/nginx.pid; events &#123; worker_connections 256;&#125; http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*; include /usr/local/etc/nginx/conf.d/*; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php &#125; &#125;&#125; 注意: 1234location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php&#125; 配置了我的 web 目录和支持的文件. 四. 运行 PHP创建 index.php 启动 PHP-fpm 1sudo php-fpm 或者以守护进程的方式来启动 PHP-fpm 1sudo php-fpm -D 启动 Nginx 1sudo nginx 编辑 index.php 在 web 目录(我配置的) /Users/mark/workspace/mzProjs/phpdev/nginx/nginx_sites/ 新建文件 index.php. index.php 里面可以编写代码: 12345678910&lt;!-- lang: php --&gt;&lt;!-- ~/nginx_sites/index.php --&gt;&lt;?php echo &quot;Hello PHP&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;学习 php&quot;; echo &quot;&lt;/br&gt;&quot;; echo phpinfo();?&gt; 打开浏览器, 你会看到下面的页面: 也可以在该目录下创建其他 php 文件, 如 mark.php 文件. 浏览器中输入:http://localhost:8080/mark.php 可以执行相对应的文件. 这里的 mark.php 是自己新建的 php 文件. 五. 安装 MySQL1brew install mysql 等待安装成功后，直接启动和连接数据库。 启动 mysql 1mysql.server start 连接 mysql 1mysql -u root -p]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>PHP MySql nginx php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过年回家这几天]]></title>
    <url>%2F2017%2F01%2F31%2F%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6%E8%BF%99%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[从放假回家到现在已经一个多星期了, 感触颇多. 主要有以下几个感触: 1.健康最重要.2.坚持做好一件事情.3.感恩. 健康前两年回家, 还能见着很多长辈, 互相嘘寒问暖, 家长里短的闲聊, 如今有些已离我远去. 无情的疾病夺走了尚未花甲的他们, 让人不禁感叹生命的脆弱. 我小的时候, 很喜欢和长辈们聊天. 主要是他们讲, 我做一个小小的听众, 觉得他们懂得特别多, 从天文到地里, 从文学到艺术, 讲的有声有色.每逢夏季, 我都会搬着小板凳, 在屋前的老树下, 纠缠他们, 逼着嚷着让他们给我讲故事, 甭提有多高兴. 如今, 老树犹在, 他们已不在人世.睹物思人. 农村大部分人, 不太关注自己的健康, 唯一衡量自己身体状况的标准就是 米饭馒头能吃多少. 很多人, 明明已经感觉到身体不适, 也不愿意去医院做检查, 就这样日积月累成疾.等实在忍受不了才去医院检查, 为时已晚. 平时不注意自己的身体, 身体早晚都会让你注意. 无论平时工作再忙, 也要坚持锻炼, 没有健康的体魄, 其他的都是扯淡. 坚持农村这几年鼓励年轻人在家创业, 搞养殖. 有很多人放弃了打工, 回家拿着补贴开始有模有样的创业. 前几年回老家, 看到各种搞养殖的, 有养鸡养鸭养鹅的, 有养羊养猪养牛的, 如雨后春笋, 遍地开花. 但是今年回家, 看到很多荒凉的房子, 无人问津. 我问过几个小伙子(之前在家搞养殖的人, 最后放弃了的).他们跟我说的基本都一样, 太累了, 收益慢!搞养殖, 的确很累, 也很枯燥无味, 每天和这些不会说话的动物们待在一起, 喂它们吃喝, 管他们温饱, 实在乏味. 另外有两个年轻人, 从开始养殖到现在已经坚持五六年了, 搞得风生水起, 家里盖起了楼房, 取了巧媳妇, 生了胖小子, 一家人其乐融融.他们跟我说的基本一样, 只要坚持, 就有收获! 这两个坚持下来的年轻人, 他们相信自己能够把这份事业做好, 他们把别人眼中的脏活累活当做一种快乐, 一种享受! 刚开始, 很艰难, 他们也想过放弃, 但是又舍不得这几年的付出, 于是就坚持下来了, 并且收获了不少意想不到的知识, 不管是物质上还是精神上都得到了满足. 世上, 没有一帆风顺的事业. 只要自己喜欢, 感兴趣的行业, 就值得你去坚持.如果你从内心都不感兴趣, 趁早放弃, 因为你很难坚持下来. 想投机取巧的成就一份事业, 只有神话故事里有吧! 不经一番寒彻骨, 哪得梅花扑鼻香! 感恩小的时候, 家里很拮据, 我能够把大学念完, 简直就是天意. 父母永远只会对我说一句话, 只要你想上学, 我们就支持到底. 我知道家里的经济情况, 所以在学习上也是不遗余力, 每次放学除了帮爸爸妈妈干农活, 就是完成家庭作业, 练字背书. 那个时候, 不知道哪来的狠劲, 即使是寒冬腊月, 也要坚持写作业, 即使是手都冻肿了, 也要练字. 当我接到重点高中通知书的那天, 父亲高兴的合不拢嘴, 心理充满了骄傲. 我能感觉到…… 然而考上高中, 接下来就是凑钱交学费, 隔壁有个伯伯, 他说学费不够, 算他的.那个时候, 大家家里都不宽裕, 能借钱给你的, 简直就是大恩人.一直到现在, 我都很感激他, 每年过年回家, 我都会给伯伯买点礼物, 给个红包, 陪他聊聊天.他还开玩笑的说, 当年自己的投资, 算是有了回报了. 这辈子, 我们最应该感谢的是我们自己的父母, 养育我们成人, 送我们读书上学. 过年回家, 要多陪陪他们, 珍惜和他们在一起的每一刻.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习杂谈]]></title>
    <url>%2F2017%2F01%2F27%2F%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[今天是中国传统节日, 大年三十, 祝大家新年快乐, 身体健康, 幸福美满. 引子最近无论是朋友还是同事或者博友, 都问过我关于学习方面的事情. 探讨的问题大概分为如下几种: 怎么有效的学习新知识?怎么快速掌握新知识?是否有必要每天学习?如何坚持学习?谈到关于学习的话题, 我也不是什么专家, 更不是心理咨询师, 只是谈谈个人的一些看法和经历, 希望能给大家带来一点点的帮助. 不要只是嘴上说 我感兴趣, 如果没有驱动和目标, 兴趣永远都只是兴趣. 你为什么学习它学习知识之前, 问问自己为什么要学它? 大部分人学习新东西都是为了工作或者为了更好的工作或者为了转行或者其他目的, 也有一部分人是为了兴趣爱好. 这里我只谈为了工作而去学习新知识的内容, 其他方面的我自己也没有什么心得体会, 不能乱说. 既然为了工作或者更好的工作来学习, 那么我们就明确了目标, 如果你已经有了目标, 恭喜你, 你即将成功了. 有一些人说, 我学习它, 这个东西不一定哪天就有用了, 我怕将来失业.这中担心不是在杞人忧天, 特别是在互联网的时代, 如果不学习很容易就落伍啦, 君担心完全在理! 但是, 当下你最应该考虑的是目前掌握的技能是否已经熟练了, 是否是能够独当一面了, 如果深学下去会不会更有前途? 如果是, 请你深入去学习, 不要太杞人忧天了! 在精钻一门学问的情况下, 可以扩大自己的知识面, 而不是 吃着碗里看着锅里 的, 要脚踏实地的大步向前. 坚持学习上面的扯淡有点多啊.回正题. 既然搞清楚了为什么学习它, 接下来就是搞定它. 你需要有坚持学习的态度和行动, 不然一切都会成为云烟. 那么当初咬牙切齿的抱负, 结果都是冲动的惩罚. 学习新知识的前期是很累的, 但是只要你意志足够坚定, 一定可以克服种种困难. 记得当初接手一个二手项目, 项目也是足够复杂, 并且有很多引擎之前都没有用过, 上面领导逼得比较紧, 没办法, 只能将其拿下, 每天晚上挑灯夜战, 在 log 的海洋里遨游. 很快自己掌握了新的知识, 结合项目, 不断的去调试和总结, 最终按期完成需求, 回过头想想, 想要坚持做好一件事情, 除了自身的自我约束, 还需要外界环境的 倒逼. 当你坚持不住的时候, 问问自己, 是否已经到了极限, 如果感到累了, 适当的放松一下, 比如出去跑个步, 打个球或者找朋友叙叙旧. 适当的给自己一点压力, 事半功倍. 学习的渠道刚开始学习新知识, 大家都渴望有一些大牛能够指导自己, 或者能够从前辈那里获取一些武林秘籍, 这些都是学习的渠道. 有些小伙伴在学习的过程中, 会遇到各种各样的困难, 比如在学习一门知识的时候, 发现竟然还需要学习另一门新知识, 真是日了狗了!到这里, 可能有些人就会情不自禁的选择了放弃, 嘴上说还在学习, 其实心里已经疲倦. 还有一些初学者, 他们没有什么经验, 如果主动性再差点, 动辄遇到问题就问, 根本没有过思考, 哪怕是一点点的思考都没有.其实他们不是不想搞, 就怕搞错了.仅仅是因为怕, 就戛然而止了!这种人, 确实可惜, 所以他们需要更多的指导和教育.这里提醒大家, 学习知识, 不要怕犯错, 大胆的去试错, 在错误中成长, 这样你才能有所收获. 记得以前为了安装 linux, 我把办公室的办公电脑都格式化了, 组长差点要开除我了, 现在想想虽然挨了骂, 但是挺值得. 现在互联网很发达, 想学习的东西基本网上都有, 你可以没有智商, 没有情商, 但是你一定要有 搜商 (搜索能力).当你自己经过思考, 无法解决问题, 就去搜索相关的知识, 如果搜索也失败了, 再去请教别人, 这样你就可以从中收获意外的惊喜. 所以, 学习渠道的重要来源之一就是在互联网搜索, 培养自己的搜索能力很重要, 我建议大家使用谷歌浏览器, 然后使用 google 的搜索引擎, 搭建一套翻墙的 VPN, 这样你可以在知识的海洋里爽翻. 另外一个比较重要的学习渠道就是你认为的牛人, 向他们学习相关的学习方法, 问他们是怎么学习的, 然后结合自己的实际情况加以运用, 跟他们多交流. 对自己’狠’一些我之前有个坏习惯, 喜欢晚上躺在床上看视频, 这些视频可能是优酷或者腾讯视频客户端的, 也有可能是新闻类的 app 来源的视频.视频只要看起来, 时间就不受控制了.第二天早晨起床也很困难. 最后自己把视频类和新闻类 app 全部卸载掉了, 然后把目标转移到 stackoverflow 和 github 上面.那里才是程序员的世界, 只有你想不到的, 没有做不到的. 为了学习新知识, 你需要对自己狠一点, 每天拿点时间出来总结和学习, 一个月一个季度一年下来, 你比别人都进步了很多. 养成一个好习惯, 终生受益.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学习 生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 聊聊 UIWebView 缓存]]></title>
    <url>%2F2017%2F01%2F15%2FiOS-%E8%81%8A%E8%81%8A-UIWebView-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[前言在开发项目过程中, 一些若交互的页面会使用 HTML 展示. 在 iOS 中, 使用 UIWebView 的频率还是比较高的. 今天跟大家聊聊 UIWebView 缓存相关的话题. 准备工作我今天使用 Tomcat 来作为 web 容器, 在本机搭建一个 web 服务器, 然后使用 iPhone 访问该 web 页面, 展示和梳理 UIWebview 关于缓存的问题. 如果你对 Tomcat 还不熟悉, 希望你可以先去大概了解一下, 如何在 Mac os 上面安装和使用 Tomcat, 可以参考我的博文: [Mac 配置 Tomcat8]. Tomcat 是一个开放源代码、运行 servlet 和 JSP Web 应用软件的基于 Java 的 Web 应用软件容器.Tomcat Server 是根据 servlet 和 JSP 规范执行的，因此可以说 Tomcat Server 实行了 Apache-Jakarta 规范，且比绝大多数商业应用软件服务器要好.但是 Tomcat 对静态文件、高并发的处理比较弱. 写这篇文章的时候, 我使用的版本分别是 apache-tomcat-8.5.8, jdk1.8. 配置 Tomcat修改 server.xml 文件文件在 Tomcat 的根目录的 conf 目录下, 如我的文件在这个目录: 1apache-tomcat-8.5.8/conf/server.xml 增加如下内容: 1234&lt;Host name=&quot;&lt;your local ip&gt;&quot; debug=&quot;0&quot; appBase=&quot;&lt;base dir&gt;&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;&lt;html file path&gt;&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 注意:1.将上述内容放到 &lt;/Host&gt; 和 &lt;/Engine&gt; 节点中间.2.将 name=&quot;&lt;your local ip&gt;&quot; 中的 改为你本机的 ip 地址.查看本机的 ip 地址方法很简单: 1ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 3.将 appBase=”“ 中的 改为你的 web 目录.4.将 docBase=”“ 中的 改为你的 html 目录. 我的配置如下(部分): 1234567891011121314151617181920212223 &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; &lt;/Host&gt; &lt;!--mark 配置静态网页. [BEGIN] --&gt; &lt;Host name=&quot;192.168.1.103&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt; &lt;/Host&gt; &lt;!--mark 配置静态网页. [END] --&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 搞定上面的配置, 接下来可以配置相关目录了. 在 Tomcat 的根目录有个文件夹 webapps, 在 webapps 目录下新建目录 test 即可. 构建 HTML 页面在 test 目录, 新建一个 html 文件 1touch test.html 文件内容如下: 123456789101112131415161718192021222324252627282930313233343536 &lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy&lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy &lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt; mark.zhang is itman.&lt;/p&gt;&lt;style&gt;.button &#123; background-color: #4CAF50; border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 86px; margin: 50px 200px 100px 300px; cursor: pointer; border-radius: 15;&#125;&lt;/style&gt;&lt;p&gt; &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot; class=&quot;button&quot;&gt;Try it&lt;/button&gt;&lt;/p&gt;&lt;script&gt; function myFunction() &#123; alert(&quot;Blog: www.veryitman.com&quot;); &#125;;&lt;/script&gt; 搭建完成后, 启动 Tomcat 服务器. 1startup.sh 在浏览器里面通过 ip:port/test.html 的方式来访问该页面. 看到类似下面的效果即表示搭建成功: 客户端访问客户端访问该页面, 使用 UIWebview 来请求(HTTP 协议)页面内容. 一般请求会使用下面的方法: 1+ (instancetype)requestWithURL:(NSURL *)URL; 该方法的描述如下: 12Creates and returns a URL request for a specified URL with default cache policy and timeout value.The default cache policy is NSURLRequestUseProtocolCachePolicy and the default timeout interval is 60 seconds. 大概意思是使用的缓存策略是根据协议来的, 即 NSURLRequestUseProtocolCachePolicy. 超时时间默认是60s. 也就是说类似如下的请求: 1NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60.f]; 如果协议支持缓存的话, UIWebview 请求到的数据就是缓存数据.该缓存是需要 WEB 服务器支持的. 这里我没有配置 Tomcat 的缓存.可以抓包看下: 后续博客会分别为大家介绍在 Tomcat 和 Nginx 配置缓存下, 客户端 UIWebview 请求的相关问题. 客户端显示页面效果: ViewController 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#import &quot;ViewController.h&quot;static NSString * const H5Url = @&quot;http://192.168.1.104:8080/test.html&quot;;@interface ViewController () &lt;UIWebViewDelegate&gt;@property (nonatomic, strong) UIWebView *webView;@property (nonatomic, strong) UIButton *refBtn;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; _webView = [[UIWebView alloc] init]; CGSize boundsSize = self.view.bounds.size; self.webView.frame = CGRectMake(0, 20, boundsSize.width, boundsSize.height); self.webView.backgroundColor = [UIColor whiteColor]; self.webView.scrollView.showsHorizontalScrollIndicator = NO; self.webView.scrollView.showsVerticalScrollIndicator = NO; self.webView.scalesPageToFit = YES; self.webView.delegate = self; [self.view addSubview:self.webView]; UIButton *refreshBtn = [UIButton buttonWithType:UIButtonTypeCustom]; [self.view addSubview:refreshBtn]; [refreshBtn addTarget:self action:@selector(onRefreshWebView) forControlEvents:UIControlEventTouchUpInside]; refreshBtn.backgroundColor = [UIColor redColor]; refreshBtn.layer.masksToBounds = YES; refreshBtn.layer.cornerRadius = 5.f; refreshBtn.frame = CGRectMake(50, 250, 200, 50); [refreshBtn setTitle:@&quot;刷新页面&quot; forState:UIControlStateNormal]; _refBtn = refreshBtn; [self loadDataUsingCache];&#125;- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error&#123; NSLog(@&quot;didFailLoadWithError: %@&quot;, error); [self hideLoading];&#125;- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSLog(@&quot;shouldStartLoadWithRequest: %@&quot;, request); return YES;&#125;- (void)webViewDidStartLoad:(UIWebView *)webView&#123; NSLog(@&quot;webViewDidStartLoad&quot;);&#125;- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; NSLog(@&quot;webViewDidFinishLoad&quot;); [self hideLoading];&#125;//刷新页面.- (void)onRefreshWebView&#123; // 方式1: 不使用缓存请求数据 //[self loadDataNoUsingCache]; // 方式2: 清除 NSCache 缓存, 再请求数据 [self clearAllCache]; [self loadDataUsingCache];&#125;- (void)loadDataUsingCache&#123; [self showLoading]; NSURL *url = [NSURL URLWithString:H5Url]; NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataDontLoad timeoutInterval:10.f]; [self.webView loadRequest:urlReq];&#125;- (void)loadDataWithProtocol&#123; [self showLoading]; NSURL *url = [NSURL URLWithString:H5Url]; [NSURLRequest requestWithURL:url]; NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60.f]; [self.webView loadRequest:urlReq];&#125;- (void)loadDataNoUsingCache&#123; [self showLoading]; NSURL *url = [NSURL URLWithString:H5Url]; NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:20.0]; [self.webView loadRequest:urlReq];&#125;- (void)clearAllCache&#123; // remove cache rsp [[NSURLCache sharedURLCache] removeAllCachedResponses]; [[NSURLCache sharedURLCache] setDiskCapacity:0]; [[NSURLCache sharedURLCache] setMemoryCapacity:0];&#125;- (void)showLoading&#123; [self.refBtn setTitle:@&quot;刷新中...&quot; forState:UIControlStateNormal];&#125;- (void)hideLoading&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [self.refBtn setTitle:@&quot;刷新页面&quot; forState:UIControlStateNormal]; &#125;);&#125;@end 这里注意下面的 三个方法 : 123456789// 使用缓存数据, 如果有缓存的话// 使用这个方法, 改变 HTML 或者 JS 代码// 页面不会拉取最新数据, 还是使用之前请求到的数据.// 除非重新刷新- (void)loadDataUsingCache;// 使用协议缓存, 需要 web 服务器支持.- (void)loadDataWithProtocol;// 不使用缓存, 加载数据- (void)loadDataNoUsingCache; 另外, 刷新 UIWebview 的方式如下, 有 两种方式 来刷新页面: 123456789101112/** * 刷新页面. */- (void)onRefreshWebView&#123; // 方式1: 不使用缓存请求数据 //[self loadDataNoUsingCache]; // 方式2: 清除 NSCache 缓存, 再请求数据 [self clearAllCache]; [self loadDataUsingCache];&#125; 这种刷新方式, 会重新加载数据.但是不适合多层级的 HTML 页面, 比如你的 HTML 页面有很多层, 想刷新当前页面, 可以使用下面的方式: 12// 重新加载当前页面[self.webView reload]; 附加查看本机 IP 的 shell 12#!/bin/shifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 停止 Tomcat 的运行 1shutdown.sh]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS UIWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[f8app]]></title>
    <url>%2F2017%2F01%2F01%2Ff8app%2F</url>
    <content type="text"><![CDATA[本文主要探讨的是如何编译和运行 f8app. 介绍f8app 是 Facebook 开源的, 基于 React Native 开发的一款 App. 代码基本都是 js 的, 很少有原生的代码. f8app 是借鉴和学习 React Native 的上好资料. 原文介绍: This is the entire source code of the official F8 app of 2016, available on Google Play and the App Store. 项目开源地址: Github 编译运行环境要求 安装和配置了 React Native 开发环境. Xcode 7.3 + CocoaPods (only for iOS) 1.0+ MongoDB (needed to run Parse Server locally) 源码构建下载源码 1git clone https://github.com/fbsamples/f8app.git 下载完成后, 进入下载的 f8app 目录 12cd f8appnpm install 如果是 iOS 的话, 需要进入 iOS 目录执行 pod install 12cd iospod install 在项目 f8app 目录下运行: 1npm start 打开浏览器输入地址 http://localhost:8080, 可以看到 graphql 的界面. 安装 MongoDB使用 Homebrew 来安装. 1brew install mongodb 导入数据导入例子数据. 注意:在源码的路径即 ~/yourpath/f8app 下面执行, 下面操作没有特殊说明都是在源码根目录下面操作.你可以多开几个终端端口来进行操作. 1npm run import-data 导入例子数据, 会报下面的 错误: 123456error: Uncaught internal server error. &#123; [MongoError: connect ECONNREFUSED 127.0.0.1:27017]name: &apos;MongoError&apos;,message: &apos;connect ECONNREFUSED 127.0.0.1:27017&apos; &#125; Error: connect ECONNREFUSED 127.0.0.1:27017at Object.exports._errnoException (util.js:893:11)at exports._exceptionWithHostPort (util.js:916:20)at TCPConnectWrap.afterConnect as oncomplete 需要安装 mongodb-runner 安装方法如下: 1sudo npm install -g parse-server mongodb-runner 运行 mongodb-runner: 1mongodb-runner start 这里执行完毕后, 需要等待一会. 你会看到如下信息: 1Starting a MongoDB deployment to test against... 上面运行结束后, 你可以查看 MongoDB 是否在运行: 1lsof -iTCP:27017 -sTCP:LISTEN 会显示当前正在运行的信息: 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmongod 86824 mark 7u IPv4 0x91959c43a65644ed 0t0 TCP *:27017 (LISTEN) 停止 mongodb 运行的方式如下: 1mongodb-runner stop 查看数据Parse Dashboard GraphiQL 启动 react-native1react-native start 运行 f8appAndroid: 123react-native run-androidadb reverse tcp:8081 tcp:8081 # required to ensure the Android app canadb reverse tcp:8080 tcp:8080 # access the Packager and GraphQL server iOS: 1react-native run-ios 如果出现红色背景的 error 提示, 可以不管, 直接 Dismiss 即可. 然后可以看到如下界面: 问题1.在运行后关闭登录按钮, 报错: 1AppEventsLogger.logEvent 解决方案: 在 /js/store/track.js 文件的第 43 行, 注释掉 log, 如下: 123case &apos;SKIPPED_LOGIN&apos;: //AppEventsLogger.logEvent(&apos;Skip login&apos;, 1); break; 在模拟器上面重新 Reload 即可.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS Android JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见 2016]]></title>
    <url>%2F2016%2F12%2F31%2F%E5%86%8D%E8%A7%81-2016%2F</url>
    <content type="text"><![CDATA[今天是2016年的最后一天，正好赶上放假，给自己的这一年做个小结。 2016，继续做项目，作为一名软件工程师，不停地在学习。 2016，学习到了很多关于产品和运营相关的知识。知道了 倒逼 的作用. 2016，读了20本非技术类书籍，养成了读书的习惯，并把读书的好处讲给身边的人听。 2016，开始减肥，注意锻炼身体，几乎每周都有一次从公司到家的步行，一次篮球或者跑步运动。 2016，购买了域名，建立了自己的 博客网站。 2016，儿子大了一岁，自己老了一岁，家庭依旧幸福着。渐渐地理解了做父亲的责任。 2016，对自己影响最大的几句话，分享给大家: 1. 技术要给产品提供最大的自由度. 2. 不要轻易的说 NO. 3. 要不断的让自己值钱, 而不是简单的为了金钱而跳槽. 4. 不要总是抱怨你的产品设计是狗屎, 学会和产品沟通更优的方案. 5. 关注细节, 把产品做好. 6. 多关注别人的优点. 7. 让对方把话说完. 8. 多看书, 多思考. 感谢所有陪伴和支持我的朋友，同事，亲人！ 祝愿所有人2017幸福、健康、快乐！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 配置 Tomcat8]]></title>
    <url>%2F2016%2F11%2F26%2FMac-%E9%85%8D%E7%BD%AE-Tomcat8%2F</url>
    <content type="text"><![CDATA[Tomcat 简介Tomcat 是一个 Web 服务器. Web 服务器是指为特定组件提供服务的一个标准化的运行时的环境.可为组件提供事务处理, 数据访问, 安全性和持久性等服务. Tomcat 是免费且开源的, 他是 Apache 软件基金会 Jakarta 项目中的其中一个子项目.由 Apache, Sun 和其他一些公司及个人共同开发完成. Tomcat 也是使用最为广泛的 JSP 服务器. JSP 是 Java Server Pages 的简称, 是在传统的 HTML 文件中插入 Java 程序段和 JSP 标记的一种动态网页技术. 下载 Tomcat前往 这里 可以下载 Tomcat. 我目前安装的是 8.5.8 版本的. 安装先安装 JDK, 安装教程可以参考 Mac 配置 JDK1.8 这篇文章. 解压下载的 tar.gz 即可. 最好解压到自己的工作目录, 如: 1~/workspace/developr/ 配置环境变量编辑 /etc/profile 文件 1sudo vim /etc/profile 添加如下变量: 12345JRE_HOME=$JAVA_HOMETOMCAT_HOME=/Users/mark/developer/apache/apache-tomcat-8.5.8PATH=$JAVA_HOME/bin:$TOMCAT_HOME/bin:$PATHexport JRE_HOMEexport PATH 其中的 JAVA_HOME 是 Mac 配置 JDK1.8 这篇文章里面设置的 JDK 的环境变量. 配置环境变量的目的, 可以让我们方便的使用 Tomcat 的命令. 检验安装是否成功使 /etc/profile 配置文件立即生效. 1source /etc/profile 如果没有生效, 重启终端即可. 开启 Tomcat 服务, 执行下面的命令: 1startup.sh 该命令在 Tomcat 的安装目录的 bin 目录下面. 执行后, 可以看到: 123456Using CATALINA_BASE: /Users/mark/developer/apache/apache-tomcat-8.5.8Using CATALINA_HOME: /Users/mark/developer/apache/apache-tomcat-8.5.8Using CATALINA_TMPDIR: /Users/mark/developer/apache/apache-tomcat-8.5.8/tempUsing JRE_HOME: /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/HomeUsing CLASSPATH: /Users/mark/developer/apache/apache-tomcat-8.5.8/bin/bootstrap.jar:/Users/mark/developer/apache/apache-tomcat-8.5.8/bin/tomcat-juli.jarTomcat started. 在浏览器里面打开: http://localhost:8080/ 即可看到一只可爱的 Tom 猫. 执行 shutdown.sh 可以关闭 Tomcat.]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tomcat Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装和使用 infer]]></title>
    <url>%2F2016%2F11%2F26%2FMac-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-infer%2F</url>
    <content type="text"><![CDATA[介绍infer 是 Facebook 开源的一款代码静态检查工具, 源码可以在 Github 上面获取. 支持 Java/C/OC 等语言, 支持 Gradle, Buck, Maven, Xcodebuild, Make 等. 我一般用来分析 iOS 和 Android 工程. 可以在 这里 查看 Start. 安装 infer只要你用 Homebrew, mac 下安装 infer 很简单: 12brew updatebrew install infer 在早期版本, infer 不支持 brew 安装. 安装起来各种问题, 现在 infer 支持了 brew 安装, 很方便. 这里我使用的 infer 版本是 0.9.4. 安装成功后, 可以查看安装版本: 1infer -version 可以看到如下信息: 12345Infer version v0.9.4Copyright 2009 - present Facebook. All Rights Reserved.Mac:public mark$ infer --versionInfer version v0.9.4Copyright 2009 - present Facebook. All Rights Reserved. 这里有个问题, 有时候 brew 无法更新最新的 infer, 我目前的解决方案是先卸载之前安装的 infer, 然后再重新安装. 卸载 infer 1brew uninstall infer 安装 xcprettyxcpretty 是一款格式化 xcodebuild 输出结果的工具. 123456▸ Building X/N [(Release)]▸ Check Dependencies▸ Copying Info.plist▸ Running script &apos;[CP] Check Pods Manifest.lock&apos;▸ Running script &apos;Replace PaySdk&apos;▸ Compiling User.m 从0.9.4版本后, infer 默认使用了 xcpretty. 可以使用 gem 安装 xcpretty 工具: 1gem install xcpretty 如果没有安装成功, 或者提示权限不够, 那就这样折腾: 1sudo gem install xcpretty 想了解更多关于 xcpretty 的使用可以去 github. 使用 inferiOS 项目使用 inferinfer 的文档写的也较全面. 可以在 这里 查看使用方法. 1.分析 Cocoapods 项目 1infer -- xcodebuild -workspace N.xcworkspace -scheme NSchema 其中 N.xcworkspace 是你的 workspace 名称, NSchema 是你需要检查的 Schema 名称. 2.分析 .xcodeproj 1infer -- xcodebuild -target targetName -configuration Debug -sdk iphonesimulator 其中 targetName 是项目的 target 名称, 必须指定. 分析成功后, infer 会有输出报告. 该报告在你的项目目录下, 名称是 infer-out. bug.txt 是以文本方式输出的 issue 文档.另外还有 csv 格式的 issue 文档. Android Gradle 工程使用 infer12gradle cleaninfer -- gradle build 其他用法infer 还有很多高级的用法, 比如可以增量检查. 增量检查的功能依赖于你的编译器是否支持. infer 增量检查的选项是 –reactive. 之前的版本是 –incremental 选项.自从 v0.8.0 版本后使用了 –reactive 选项. 可以这样来进行增量检查: 1infer --reactive -- xcodebuild -workspace N.xcworkspace -scheme NSchema infer 还有很多高级用法, 可以在 Advanced usage 中去查阅和使用. 再使用过程中, 随着 MacOS, Xcode 的升级, infer 会面临更多的挑战, 如果遇到问题, 第一时间去 GitHub 上面提 issue.]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS infer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 配置 JDK1.8]]></title>
    <url>%2F2016%2F11%2F26%2FMac-%E9%85%8D%E7%BD%AE-JDK1-8%2F</url>
    <content type="text"><![CDATA[下载 JDK在 这里下载 jdk. 下载版本是 1.8u112, 信息如下: 安装 JDK下载完成后, 直接双击安装即可. 配置 Path成功安装后, 目录/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/ 就会存在. 编辑 /etc/profile 文件: 1sudo vim /etc/profile 添加如下代码: 123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/HomeCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOMEexport CLASSPATHexport PATH 保存文件. 使这个文件立即生效.可以 source 一下 1source /etc/profile 检验执行下面命令来检验 jdk 是否安装成功. 1java -version 输出如下信息, 标示配置 JDK 成功. 123java version “1.8.0_112”Java(TM) SE Runtime Environment (build 1.8.0_112-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode) 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MacOS java jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameDevelopment: 与 Cocos2d 的再相逢]]></title>
    <url>%2F2016%2F11%2F12%2FGameDevelopment-%E4%B8%8E-Cocos2d-%E7%9A%84%E5%86%8D%E7%9B%B8%E9%80%A2%2F</url>
    <content type="text"><![CDATA[认识 Cocos2d相信很多人听说过 cocos2d-x 这个引擎, 但听过 cocos2d-objc 的人应该不多. cocos2d-objc 是 cocos 系列的 objective-c 版本.开发语言是 OC.在 iOS 上面使用该版本的引擎, 基本是无缝连接(写的没有什么障碍). 欣赏一下 cocos2d-objc 的 logo, 如图: 如果你对 OC 版感兴趣, 可以通过博文 coco2d-iphone: 环境搭建 去了解. cocos2d-x 目前支持 JavaScript, lua, c++ 等主流语言来开发.cocos 还在迅猛发展中, 不断的完善开发工具, 广大游戏开发者依然热力贡献, 程序猿们在游戏的战场挥洒青春. 现在 cocos 的开发者会得到更多的支持. 下面给张图来展示 cocos 家族及其发展: 由 libgdx 转向 Cocos2d几年前, 那个时候还在开发棋牌游戏, 当时自己也是刚刚接触游戏开发这个「高逼格」的行业, 之前自己是个纯 App 开发者. 内心还是蛮激动的, 心想可能要走上人生巅峰了… 棋牌游戏, 当时使用的是 java 的游戏引擎 libgdx 0.X.X 的版本, 该引擎和 Android 基本也是无缝连接, Api 设计的很好. 现在 libgdx 也发展到了1.6.x 版本了, 工具也完善了很多. 虽然 libgdx 也可以跨平台, 但是最终我们还是选择了 cocos2d-x 来移植该游戏.其中原因是因为 cocos2d-x 太火了, 人也好找. 改为 cocos2d-x 的版本之后, 我就被安排到了另外一个项目, 也是一个棋牌游戏, 该游戏现在在腾讯的微信游戏里面运营. 这个游戏是 cocos2d-objc 的引擎写的, 自己也不会 objc, 于是硬着头皮学习, 很快的就上手了这个项目.写的也是风生水起. cocos2d-objc, 现在也支持跨平台, 并且有 xcode 的插件, 可以在 xcode 里面写 Android 的代码, 调试开发等. 因为接触 cocos2d, 后面就直接开搞 iOS 开发了. 再次使用 Cocos2d互联网 IT 业的发展, 刺激了各个行业的发展, 也促进和激发了新生的技术, 在这个行业, 每个人都能体会 活到老学到老 这句话的含义. 这两年, HTML5 的发展, 让很多程序员重新认识了 JavaScript 的重要性. 特别是最近 ReactNative 的发展, jsPacth 的开源, 微信小程序的推出, 让 JavaScript 火得不要不要的. 说实话, 是时候开始学习前端相关的技术了, 至少你需要去了解. cocos2d-js 的发展, 给 HTML 游戏开发带来了很多便利. 最近我们需要开发 H5 的游戏, 直接拿起 coco2d-x(支持 JavaScript) 就撸起. 去 GitHub 上面直接 clone 最新版就可以, 按照 README.md 来搭建环境就好了. 后记这篇博客也是有感而发, 没有实质性的内容. 主要目的是想告诉大家, 技术的发展日新月异, 想在这里大展拳脚, 你需要保持一颗年轻的心, 不怕苦, 勇往直前的精神. 我们需要学习的技术有很多, 我认为, 要根据项目本身的发展来适度的学习, 切记盲目的学习, 学习一门新技术之后, 要及时的运用在项目当中, 并分享给你身边的人. 不拒绝不排斥新技术, 坚持学习和乐于分享, 应该是必备的技能.]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Cocos2d Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac install Cocoapods]]></title>
    <url>%2F2016%2F11%2F08%2FMac-install-Cocoapods%2F</url>
    <content type="text"><![CDATA[声明这篇博客原本被我发表在 CSDN . 那里不再更新, 现在在这里做持续更新. 导引如果你的 Mac OSX 升级到 10.11.x+, 并且需要安装 Cocoapods, 可以参考本博客. 安装 rubyMac 系统自带了 ruby, 但是建议大家使用 Homebrew 安装 ruby. 因为 Cocoapods 升级需要对应的 ruby 版本也要升级, 使用 Homebrew 比较方便. 安装 ruby: 1brew install ruby 查看当前安装的 ruby 版本: 1ruby -v 会得到类似下面的信息: 1ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin15] gem 是管理 Ruby 库和程序的标准包.安装了 ruby, 自带了 gem 工具. 可以使用 gem -v 查看 gem 版本. 安装 Cocoapods1.移除原来的源, 不管以前是否安装过 Cocoapods. 1gem sources --remove http://ruby.taobao.org/ 2.重新添加源, 注意是 https. 1gem sources -a https://gems.ruby-china.org/ 之前 taobao 的源 好像已经不行了. 注意：添加源之前在浏览器打开 https://gems.ruby-china.org/ 这个地址看一看是否能访问，如果不能访问就修改一下为 https://gems.ruby-china.com 这个地址。 3.查看是否添加成功, 该步骤可选. 1gem sources -l 安装, 使用 root 权限安装. 1sudo gem install -n /usr/local/bin cocoapods 这种安装方式, 会安装最新的 release 版本. 你也可以使用下面两种方式来安装. 指定版本安装: 1sudo gem install -n /usr/local/bin cocoapods -v 1.0.0 安装最新的 release beta 版本: 1sudo gem install -n /usr/local/bin cocoapods --pre 卸载 Cocoapods卸载 Cocoapods 只需执行: 1sudo gem uninstall cocoapods 如果想删除本地的 pod repo, 可以这样: 1rm -fr ~/.cocoapods/ 建立本地 repo安装完 Cocoapods 后, 需要建立本地的 repo. 1pod setup 即使你现在不执行 pod setup, 后面进行 pod install 或者 pod update 的时候, 也会自动的进行 pod setup. 执行 pod setup 的目的是将所有第三方的 podspec 索引文件更新到本地的 ~/.cocoapods/repos 目录中. 安装使用中遇到的问题问题1: 命令行执行 pod 发生: pod command not found, 但是 sudo pod 却可以执行. 解决方案即如下步骤: [1].卸载原有的 Cocoapods 1sudo gem uninstall cocoapods [2].重新安装 Cocoapods 1sudo gem install -n /usr/local/bin cocoapods [3].赋予/usr/local/bin给予执行与读取权限: 1sudo chmod -R +rx /usr/local/bin/ 建议最好使用代(fanq)理(qiang). 问题2: 更新 gem 过程中, 遇到 1Operation not permitted - /usr/bin/update_rubygems 可以通过通过 brew 安装 ruby 解决. 1brew install ruby 问题3: pod setup 失败 失败提示信息类似: 12345Cloning into &apos;master&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案: 更新 gem 1sudo gem update --system 问题4: 添加源, 提示如下问题 1source https://gems.ruby-china.org/ already present in the cache 这个说明你已经添加过该源, 可以使用 1gem sources -l 来查看已经添加的源. 常用操作1.更新 gem 1sudo gem update --system 2.pod repo update 更新本地仓库. 3.pod search xxx 搜索 cocoapods 项目. 4.pod list 列出所有可用的库. 5.pod install 根据 podfile 和 podfile.lock来安装库. 默认会执行 pod repo update. 可以加入参数 –no-repo-update 不执行 pod repo update. 6.pod update 更新已安装的库到最新版本, 并且创建新的 Podfile.lock 文件. 该命令也会默认会执行 pod repo update. 可以加入参数 –no-repo-update 不执行 pod repo update. 更新记录2017-01-04 更新 升级 ruby 到 2.4 版本后, cocoapods 无法使用了. 升级的 ruby 版本信息: 1ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-darwin15] 12345使用任何 pod 命令都报错:/usr/local/Cellar/ruby/2.4.0/lib/ruby/2.4.0/rubygems.rb:270:in `find_spec_for_exe&apos;: can&apos;t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)from /usr/local/Cellar/ruby/2.4.0/lib/ruby/2.4.0/rubygems.rb:298:in `activate_bin_path&apos;from /usr/local/bin/pod:22:in `&lt;main&gt;&apos; 查找各种解决方案, 最终还是没有解决. 你可以在 这里 下载 Cocoapods 的 Mac 版本 App 使用. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>CocoaPods, iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 问题集锦]]></title>
    <url>%2F2016%2F11%2F08%2FCocoapods-%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[承诺本文会持续更新, 分享在使用 cocoapods 过程中遇到的问题和解决方案. 欢迎大家补充. 安装问题可以阅读博客 Mac 安装 Cocoapods. pod search 问题 pod search 无法搜索到指定的项目 问题描述: 执行 pod search [Name], 出现类似下面的提示: 1[!] Unable to find a pod with name, author, summary, or description matching `[Name]` 解决方案: 删除 search_index.json 文件 1rm ~/Library/Caches/CocoaPods/search_index.json 然后, 重新执行: 1pod search 项目名称 如果这样行不通的话, 可以这样: 123rm -rf ~/.cocoapodsrm ~/Library/Caches/CocoaPods/search_index.jsonpod setup 如果你的网络不好, 需要漫长的等待… 这个时候, 可以去抽半盒烟了. Orz… pod setup 问题 pod setup 卡死 问题描述: pod setup 会在本地建立 cocoapods 仓库. 在执行的过程中, 你可以在 ~/.cocoapods/repos 使用du -sh * 来看 repos 目录的大小变化. 如果观察好久, 大小没有变化, 最终会出现类似下面的错误: 12345Cloning into &apos;master&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案，如下： 先更新 gem 1sudo gem update --system 再重新执行 1pod setup pod install 问题无法使用，报类似下面的两种错误信息： 1can&apos;t find gem cocoapods (&gt;= 0.a) with executable pod (Gem::GemNotFoundException) 12While executing gem ... (TypeError) no implicit conversion of nil into String 解决方案，如下： 1. 重新安装 ruby 1brew reinstall ruby 2. gem 更新 123rm /usr/local/bin/update_rubygemssudo gem update --system 3. 重新安装 Cocoapods 并重新添加源 12345sudo gem uninstall cocoapodssudo gem install -n /usr/local/bin cocoapodsgem sources -a https://gems.ruby-china.org/ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>CocoaPods, iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 管理开源项目]]></title>
    <url>%2F2016%2F11%2F01%2FCocoapods-%E7%AE%A1%E7%90%86%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[准备工作在进行下面工作之前，请确保你做了下面三件事情： 1. 创建或者已经有了 github 账号.2. 了解和熟悉如何在 github 上面创建 Repository.3. MacOS 上面安装了 Cocoapods. 如果你还没有使用 Cocoapods, 建议看看 Mac OSX 10.11.1+ 安装 Cocoapods 这篇博客. 在博客 iOS 项目: 打造本地 pod 库 里面有介绍如何打造本地的 pod 库，不需要借助任何仓库就可以完成，操作简单，适合项目组内使用。 今天给大家分享如何将代码开源并放到 pod 库中，供别人使用。这种方式属于打造公共（Public repo）仓库， 任何人都可以搜索到你贡献的库并使用你的库。后面会跟大家分享如何打造私有（Private repo），敬请期待。 这篇博客是基于一个实际例子 MZInsetLabel 来说明的，期待与优秀的你交流讨论。 创建 Repository 并完善项目1. 在 Github 上面创建 Repository，取名为 MZInsetLabel. 2. 将该工程 clone 到本地磁盘. 3. 写代码，这里我只写了 MZInsetLabel.h | .m 文件. 4. 创建 podspec 文件. 使用下面命令，即可产生该文件。 1pod spec create MZInsetLabel 在当前目录会生成 MZInsetLabel.podspec 文件。按照文件规范和实际情况填写即可，如果不知道怎么填写，可以在 Github 上面找一个开源项目参考即可。 注意: Tag 版本号不要错误. 最终内容如下: 12345678910111213141516Pod::Spec.new do |s| s.name = &quot;MZInsetLabel&quot; s.version = &quot;0.2.0&quot; s.summary = &quot;MZInsetLabel is subClass of UILabel.&quot; s.description = &lt;&lt;-DESC MZInsetLabel is a sub class of UILabel that can be set insets. DESC s.homepage = &quot;http://www.veryitman.com&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;veryitman&quot; =&gt; &quot;veryitman@126.com&quot; &#125; s.platform = :ios, &quot;7.0&quot; s.source = &#123; :git =&gt; &quot;https://github.com/veryitman/MZInsetLabel.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; s.source_files = &quot;*.&#123;h,m&#125;&quot; s.framework = &quot;UIKit&quot; s.requires_arc = trueend 项目检测检查该 podspec 文件，执行下面命令 1pod lib lint MZInsetLabel.podspec –verbose 可以输出更加详细的内容 1pod lib lint MZInsetLabel.podspec --verbose 正确的话, 你可以看到下图如所示的内容： 在检测的过程中，如果有一些警告导致无法验证通过，可以使用 --allow-warnings 参数规避这些 warning，但我还是建议大家尽量将 warning 修改好。 1pod lib lint --allow-warnings pod lib lint *.podspec 是只从本地验证你的 pod 能否通过验证. pod spec lint*..podspec 是从本地和远程验证你的 pod 能否通过验证. 大家可自行选择这两种方式。 添加项目到 Github Repository将本地的代码 push 到 Github 的 Repository, 就是刚才创建的 MZInsetLabel. 12345git add `文件`或者`文件夹`git commit -m &quot;Init&quot;git push 在你的 Github Repository 上面创建一个 Release 作为 Tag（0.1.0版本），如图所示: 推送到 cocoapods1. 注册 trunk pod trunk register 你的邮箱 ‘用户名’ –description=’简单描述’ 完整命令如下: 1pod trunk register veryitman@126.com &apos;veryitman&apos; --description=&apos;mark&apos; 2. 打开邮箱, 激活邮件, 点击链接激活 3. 检查注册信息 执行命令如下： 1pod trunk me 4.添加到 cocoapods 执行下面命令, 即可. 1pod trunk push MZInsetLabel.podspec 成功的效果图: 验证使用1. 检查是否可以搜索到 1pod search MZInsetLabel 如果搜索不到, 请执行 1pod setup 2. 在项目中可以使用该项目 1pod &apos;MZInsetLabel&apos;, &apos;~&gt; 0.1.0&apos; 然后在你的测试项目中，执行 pod install 即可。 可能遇到的麻烦1. 执行 pod trunk push *.podspec 时, 好久没反应? 这种情况, 大多数都是因为你的网络不给力造成的, 如果你确定你的网络没问题, 那么请翻墙. 2. 执 行 pod trunk push *.podspec 时报错? 报错信息: 1ERROR | [iOS] unknown: Encountered an unknown error (Simulator iPhone 4s is not available.) during validation. 这个错误是因为, 更新了 xcode8 之后不再支持 ios7 的缘故. 解决方案(我的), 升级 cocoapods. 1sudo gem install -n /usr/local/bin cocoapods 3. pod trunk push 失败 失败提示信息类似: 12345Cloning into &apos;master&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案: 更新 gem 1sudo gem update --system Git 命令行操作1. 向远程 Repository 添加 tag 123git tag -m &quot;注释&quot; 0.0.1git push --tags 执行后，可以看到 Github Repository 上会多一个对应的 tag 版本。 2.删除本地 Tag 1git tag --delete [TagName] 如: 1git tag --delete 0.0.1 3. 删除远程 Tag 1git push --delete origin [TagName] 如: 1git push --delete origin 0.0.1 在 Github 上面如果你不小心打错了 Release, 然后删除该 Release.你会发现, tag 无法删除.使用上面方式妥妥的解决. 如果你删除 tag，想重新打一个相同的 tag，需要先删除本地的 tag，否则会失败。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 谈谈 frame 和 bounds]]></title>
    <url>%2F2016%2F10%2F22%2FiOS-%E8%B0%88%E8%B0%88-frame-%E5%92%8C-bounds%2F</url>
    <content type="text"><![CDATA[起因大家知道, 我们可以设置 view 的四个角或者其中一个或者几个为圆角. 使用的方法: 123+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; 拖好界面元素之后, 在代码中来修改其为圆角, 居然失败了. 想要的效果是这样的: 但是最终是这样的: 于是总结了一下, 分享给大家. 设置圆角这里分两种情况. 第一种: 只放置控件, 不设置约束. 1.storyboard 中拖好控件. 注意: 这里我并没有设置任何约束. 2.vc 代码 123456789101112131415161718192021222324252627@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *lb;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; [self changeLbCorner];&#125;- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.frame byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125;@end 代码编译运行到模拟器(iphone6), 看不到任何东西. log 日志显示 lb 的信息如下: 123[ViewController viewDidLoad]:lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; 位置信息是正确的, 咨询检查发现是参数传入错误, 修改 changeLbCorner 方法: 12345678910- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125; 这里只是将 self.lb.frame 改成了 self.lb.bounds. 再次运行可以看到效果: 第二种: 放置控件并设置约束. 1.设置 lb 距离父 view 左边和上边的约束.2.运行上面的代码, 发现, lb 并没有被设置为圆角.并且 lb 的宽度和高度变小了, 变成了文字的实际的宽高. 看 log: 123[ViewController viewDidLoad]:lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; 其实这个时候, (从上面图中可以看出) 这里的信息是错误的. 正确的信息应该是这样的(在 viewDidAppear 中)打印信息: 123[ViewController viewDidAppear]:lb.bounds: &#123;&#123;0, 0&#125;, &#123;58.5, 19.5&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;58.5, 19.5&#125;&#125; 于是, 将 1[self changeLbCorner]; 放到 viewDidAppear 中, 圆角就正常了. 接下来, 我们把 lb 的宽高(136*39)约束也加上. 看一下, viewDidLoad 和 viewDidAppear 方法中打印的信息: 123456[ViewController viewDidLoad]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewDidAppear:]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; 可以看出, viewDidLoad 中错的一塌糊涂. 这里也说明一个问题: xib 或者 storyboard 中设置过约束(现实开发中, 基本都会设置约束)的组件, 在 viewDidLoad 中并没有完全 layout, 只是预加载了这些组件.想获取组件如 frame 何 bounds 信息, 在 viewDidLoad 中是不合适甚至是错误的. 那么, 问题来了, 哪里合适哪里正确. 上面如果你认真看了, 在 viewDidAppear 中是可以正确获取的, 那么还有没有其他方法可以获取呢? VC 生命周期函数要回答上面的问题, 大家要知道 vc 的生命周期函数. 上面的例子, 可以看出: 当函数 ViewDidLoad 被调用的时候，IBQutlets 已经被连接，但View 还没有被加载出来，无法获取 frame 等信息.可以在 viewDidLoad 中完成在 IB 中不能完成的 view 的自定义。 关于 loadView 和 viewDidLoad 在后面博客跟大家分享. 今天要说的是 1viewDidLayoutSubviews viewDidLayoutSubviews 在 VC 子视图位置或者尺寸 (position|size) 被改变的时候被调用. 直到 AutoLayout 已经完成工作的时候才会被确定，所以在执行完 AutoLayout 之后会调用此方法. 换句话说, view 的 frame 和 bounds 这个时候是正确可以获取的. viewDidLayoutSubviews 这个方法在 viewDidAppear 之前被调用, 有可能会被调用多次. 即依赖 bounds 或者 frame 的操作，都应该放在viewDidLayoutSubviews 中，而不是 viewDidLoad 或 viewWillAppear 中. 改变后的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;ViewController.h&quot;#define MZLog(fmt, ...) NSLog((@&quot;%s\n&quot; fmt), __FUNCTION__, ##__VA_ARGS__)#define MZLogLbInfo \MZLog(@&quot;lb.bounds: %@ \nlb.frame: %@&quot;, NSStringFromCGRect(self.lb.bounds), NSStringFromCGRect(self.lb.frame))@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *lb;@property (strong, nonatomic) IBOutlet UILabel *displayedText;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; MZLogLbInfo;&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; MZLogLbInfo;&#125;- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; MZLogLbInfo;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; MZLogLbInfo; [self changeLbCorner];&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; MZLogLbInfo;&#125;#pragma mark Callback.- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125;@end 打印的 log 如下: 123456789101112131415161718192021[ViewController viewDidLoad]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewWillAppear:]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewWillLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewDidLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;[ViewController viewWillLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;[ViewController viewDidLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;[ViewController viewDidAppear:]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; frame 和 bounds上面的例子, 大家看到由于传入了 frame 而不是 bounds 造成设置圆角失败. 下面说说 frame 和 bounds. 概念从网上”偷”过来的图 1.frame 该 view 在父 view 坐标系统中的位置和大小(参照点是，父坐标系统). 2.bounds 该 view 在本地坐标系统中的位置和大小(参照点是，本地坐标系统，就相当于 view 自己的坐标系统，以(0,0)点为起点).其实本地坐标系统的关键就是要知道的它的原点(0,0). bounds 默认值是(0, 0, width, height).除非手动改变 bounds 的值. 单纯的从概念上面, 很难理解二者的区别. 提供一个例子, 例子大概是这样的:redView 是 yellowView 的父视图, yellowView 是 blueView 的父视图. 通过改变 redView 的 bounds 会影响子视图的位置(不是frame).将 redView 的 bounds 起点设为(-20, -20), 子视图相对于 redView 的本地坐标(0, 0), 也就需要往下增加20, 这样, yellowView 就往下移动了. 效果图: 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#import &quot;ViewController.h&quot;#define MZLog(fmt, ...) NSLog((@&quot;%s\n&quot; fmt), __FUNCTION__, ##__VA_ARGS__)#define MZLogLbInfo \MZLog(@&quot;lb.bounds: %@ \nlb.frame: %@&quot;, NSStringFromCGRect(self.lb.bounds), NSStringFromCGRect(self.lb.frame))@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *lb;@property (strong, nonatomic) IBOutlet UILabel *displayedText;@end@implementation ViewController&#123; UIView *redView; UIView *yellowView; UIView *blueView;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; MZLogLbInfo; // 将 redView 添加到 self.view &#123; redView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 120, 120)]; redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; &#125; // 将 yellowView 添加到 redView &#123; yellowView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 90, 90)]; yellowView.backgroundColor = [UIColor yellowColor]; [redView addSubview:yellowView]; &#125; // 将 blueView 添加到 yellowView &#123; blueView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 60, 60)]; blueView.backgroundColor = [UIColor blueColor]; [yellowView addSubview:blueView]; &#125; [self logViewInfo];&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; MZLogLbInfo;&#125;- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; MZLogLbInfo;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; MZLogLbInfo; [self changeLbCorner];&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; MZLogLbInfo;&#125;#pragma mark Callback.- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125;- (IBAction)doResetAction:(id)sender&#123; [UIView animateWithDuration:1.0f animations:^&#123; [redView setBounds:CGRectMake(0, 0, 120, 120)]; [yellowView setBounds:CGRectMake(0, 0, 90, 90)]; &#125; completion:^(BOOL finished) &#123; [self logViewInfo]; &#125;];&#125;- (IBAction)doChangeRedViewBounds:(id)sender&#123; [UIView animateWithDuration:1.0f animations:^&#123; [redView setBounds:CGRectMake(-20, -20, 120, 120)]; &#125; completion:^(BOOL finished) &#123; [self logViewInfo]; &#125;];&#125;- (IBAction)doChangeYellowViewBounds:(id)sender&#123; [UIView animateWithDuration:1.0f animations:^&#123; [yellowView setBounds:CGRectMake(-20, -20, 90, 90)]; &#125; completion:^(BOOL finished) &#123; [self logViewInfo]; &#125;];&#125;#pragma mark Display Debug Info.- (void)logViewInfo&#123; NSString *log4rView = [NSString stringWithFormat:@&quot;RedView\nframe:%@ \nbounds:%@&quot;, NSStringFromCGRect(redView.frame), NSStringFromCGRect(redView.bounds)]; NSString *log4yView = [NSString stringWithFormat:@&quot;YellowView\nframe:%@ \nbounds:%@&quot;, NSStringFromCGRect(yellowView.frame), NSStringFromCGRect(yellowView.bounds)]; NSString *log4bView = [NSString stringWithFormat:@&quot;BlueView\nframe:%@ \nbounds:%@&quot;, NSStringFromCGRect(blueView.frame), NSStringFromCGRect(blueView.bounds)]; NSString *log = [NSString stringWithFormat:@&quot;%@\n%@\n%@&quot;, log4rView, log4yView, log4bView]; [self display:log];&#125;- (void)display:(NSString *)content&#123; self.displayedText.text = content;&#125;@end 总结 frame, 描述的是当前视图在其父视图中的位置和大小.bounds, 描述的是当前视图在其自身坐标系统中的位置和大小. 所以, bounds 默认是 (0, 0, frame.size.width, frame.size.height) 另外, 还有一个 center 描述的是当前视图的中心点在其父视图中的位置. bounds 和 frame 是两个不等同的概念, 改变 bounds 会影响子视图的位置(人眼看到其改变了位置), 设置 bounds 可以修改自己坐标系的原点位置. 但是不会改变子视图的 bounds 和 frame. 明白上面的道理很重要, iOS 中滚动视图能让你看到其中的内容, 正是利用了 contentoffset 和 bounds 属性. 这里以 tableView 为例子, 当我们向上滚动 tableView, tableView 的 contentOffset 和 bounds 的坐标都是正数, 相当于其本地坐标(0, 0)改变了即增加了(坐标系往下为增加), 那么其子视图就会向上去. 向下滑动时, 也是同一个道理.可以通过运行 完整 Demo 中[查看 TableView]按钮来打开例子, 看日志. 改变子视图所有父视图的 bounds, 子视图的位置是累加改变的.如上面改变 redView 和 yellowView 的 bounds, blueView 的位置相对 redView 往下移动了 40. 当同一个视图的 bounds 大于 frame, 会导致 frame 被撑大，frame 的 x, y, width, height 都会被改变. 反之, bounds 小于 frame, frame 也会变小. 附录 GitHub 上面可以下载 完整 Demo 推荐之前写在 CSDN 上的博文: iOS UI 技巧: 视图无法被点击 可关注我的微信公众号:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS frame bounds</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 模拟 Mobx]]></title>
    <url>%2F2016%2F10%2F11%2FRN-%E6%A8%A1%E6%8B%9F-Mobx%2F</url>
    <content type="text"><![CDATA[前言看过 [React Native 使用 Mobx] 这篇博客的同学, 对 Mobx 应该有了一个简单直观的认识. 其实, 我们完全可以使用 RN 中的 State 来达到同样的效果. 今天的主要内容是使用 State 来模拟 Mobx, 也算是对 Mobx 的进一步认识. 效果 实现效果和 [React Native 使用 Mobx] 中的效果一致, 只是代码没有使用 Mobx 框架. 实现LegacyCounter.js Add 和 Minus 两个按钮分别触发各自的回调, 来更新 state.使用 state 的变化来到达更新 View (计数的 Text 会相应的做出变化)的目的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 模拟 Mobx 在 ReactNative 上的一个小例子. * * state -&gt; view */&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableHighlight&#125; from &apos;react-native&apos;;class LegacyCounter extends Component &#123; //构造方法 constructor(props) &#123; super(props); this.state = &#123; //计数 counter: 0 &#125;; &#125; render () &#123; return ( &lt;View style = &#123;styles.container&#125;&gt; &#123;/*加一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.setState(&#123; counter: ++this.state.counter &#125;)&#125;&#125;&gt; &lt;Text&gt;Add&lt;/Text&gt; &lt;/TouchableHighlight&gt; &#123;/* 显示处理结果 */&#125; &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt; &#123;this.state.counter&#125; &lt;/Text&gt; &#123;/*减一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.setState(&#123; counter: --this.state.counter &#125;)&#125;&#125;&gt; &lt;Text&gt;Minus&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;export default class LegacyComponent extends Component &#123; render () &#123; return ( &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt; &lt;LegacyCounter/&gt; &lt;/View&gt; ); &#125;&#125;/* 样式定义 */const styles = StyleSheet.create(&#123; container: &#123; flexDirection: &apos;row&apos;, justifyContent: &apos;space-around&apos; &#125;, resultTxtStyle: &#123; fontSize: 22, color: &apos;red&apos; &#125;&#125;); index.ios.js 这个文件很简单, 只是调用 LegacyCounter 中的组件. 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;//引入自定义模块import LegacyComponent from &apos;./js/Mobx/LegacyCounter&apos;import &#123; AppRegistry&#125; from &apos;react-native&apos;;class RNMobxDemo extends Component &#123; render() &#123; return( &lt;LegacyComponent/&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;RNMobxDemo&apos;, () =&gt; MZRNTutorial); 后记如果你想了解更多关于 RN 中 State 的知识, 请移步官方文档查阅 State 的用法. 后续会给大家带来更多关于 RN 这些方面的东西.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS Android ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 使用 Mobx]]></title>
    <url>%2F2016%2F10%2F06%2FRN-%E4%BD%BF%E7%94%A8-Mobx%2F</url>
    <content type="text"><![CDATA[来由在 JSFiddler 上面看到 React 结合 Mobx 的一个小例子. 爱不释手, 遂拿来改造一下, 让其能在 RN 上面一展雄风. 之前听过 Mobx, 说是要替代 Redux, 反正我是不知道这些东东, 第一次听说没有什么感觉!如今又再次偶遇 Mobx, 决定认真学习一下它. Mobx 简介Mobx 的 github 地址.目前关于他和 React Native 的(中文)资料不多, 大多数是关于 React 的. 看来想学好 React Native, 还是要做好 React 的功课呀! 官网给了一个 Mobx 的图: 我也是刚接触这个「牛逼闪闪」的 Mobx, 共勉! 效果图今天的例子很简单, 效果图如下 点击 Add 点击 Minus 下面具体说说如何搞定这个 Demo. 准备「材料」这里假设你已经具备 React Native 的基本开发环境, 至少成功运行过一次 React Native 的程序. 1.创建 React Native 项目1react-native init RNMobxDemo 你也可以给你的工程取一个你喜欢的名字.这里姑且称之为 RNMobxDemo 2.安装 mobx 和 mobx-react1npm i mobx mobx-react --save 3.Counter.js 该文件使用了 mobx 和 mobx-react 的组件. 具体代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableHighlight&#125; from &apos;react-native&apos;;import &#123; observer &#125; from &apos;mobx-react/native&apos;;import &#123; observable &#125; from &apos;mobx&apos;;// 被观察者, 观察 counter 变量 const storer = observable(&#123; counter: 0&#125;);//---------------------------------// ES6 写法: Arrow Function//---------------------------------storer.plus = () =&gt; &#123; storer.counter ++;&#125;;storer.minus = () =&gt; &#123; storer.counter --;&#125;;class Counter extends Component &#123; render () &#123; return ( &lt;View style = &#123;styles.container&#125;&gt; &#123;/*加一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.props.store.plus()&#125;&#125;&gt; &lt;Text&gt;Add&lt;/Text&gt; &lt;/TouchableHighlight&gt; &#123;/* 显示处理结果 */&#125; &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt; &#123;this.props.store.counter&#125; &lt;/Text&gt; &#123;/*减一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;storer.minus()&#125;&#125;&gt; &lt;Text&gt;Minus&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;// 使用 observer 创建const CounterComponent = observer(Counter);export default class ReactionsComponent extends Component &#123; render () &#123; return ( &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt; &lt;CounterComponent store = &#123;storer&#125; /&gt; &lt;/View&gt; ); &#125;&#125;/* 样式定义 */const styles = StyleSheet.create(&#123; container: &#123; flexDirection: &apos;row&apos;, justifyContent: &apos;space-around&apos; &#125;, resultTxtStyle: &#123; fontSize: 22, color: &apos;red&apos; &#125;&#125;); 4.index.ios.js 该文件使用自定义的组件 ReactionsComponent 具体代码如下: 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;//引入自定义模块import ReactionsComponent from &apos;./js/Mobx/Counter&apos;import &#123; AppRegistry&#125; from &apos;react-native&apos;;class RNMobxDemo extends Component &#123; render() &#123; return( &lt;ReactionsComponent/&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;RNMobxDemo&apos;, () =&gt; MZRNTutorial); Mobx 支持「注解」. 这里的注解就是 ES7 中的 decorators (装饰者模式). 下面代码是使用注解的方式来声明, 但是你需要安装相关的插件(babel plugin)来支持. 安装该插件很简单, 在项目根目录按照下面步骤即可: Step 1: 创建 .babelrc 文件 1touch .babelrc Step 2: 编辑 .babelrc 文件 1234&#123; &apos;presets&apos;: [&apos;react-native&apos;], &apos;plugins&apos;: [&apos;transform-decorators-legacy&apos;]&#125; Step 3: 安装插件 1npm i babel-plugin-transform-decorators-legacy babel-preset-react-native-stage-0 --save-dev 修改「Counter.js」, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableHighlight&#125; from &apos;react-native&apos;;import &#123; observer &#125; from &apos;mobx-react/native&apos;;import &#123; observable &#125; from &apos;mobx&apos;;// 被观察者, 观察 counter 变量 const storer = observable(&#123; counter: 0&#125;);//---------------------------------// ES6 写法: Arrow Function//---------------------------------storer.plus = () =&gt; &#123; storer.counter ++;&#125;;storer.minus = () =&gt; &#123; storer.counter --;&#125;;@observer //使用@方式来前置声明class Counter extends Component &#123; render () &#123; return ( &lt;View style = &#123;styles.container&#125;&gt; &#123;/*加一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.props.store.plus()&#125;&#125;&gt; &lt;Text&gt;Add&lt;/Text&gt; &lt;/TouchableHighlight&gt; &#123;/* 显示处理结果 */&#125; &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt; &#123;this.props.store.counter&#125; &lt;/Text&gt; &#123;/*减一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;storer.minus()&#125;&#125;&gt; &lt;Text&gt;Minus&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;export default class ReactionsComponent extends Component &#123; render () &#123; return ( &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt; &lt;Counter store = &#123;storer&#125; /&gt; &lt;/View&gt; ); &#125;&#125;/* 样式定义 */const styles = StyleSheet.create(&#123; container: &#123; flexDirection: &apos;row&apos;, justifyContent: &apos;space-around&apos; &#125;, resultTxtStyle: &#123; fontSize: 22, color: &apos;red&apos; &#125;&#125;); 从例子可以看出, storer 相当于 state, 当 state 发生改变了, 视图 View 也跟着变化.也就是状态驱动. Android 开发的同学应该知道 Adapter 和 notifyDatasetChanged 的机制, 当数据源发生变化的时候, 可以通知视图进行刷新操作. 这里的 Mobx 也可以这么简单的理解. Mobx 的强大之处还有很多, 需要慢慢学习和挖掘.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS Android ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 0.34 运行在 Android 的问题]]></title>
    <url>%2F2016%2F09%2F26%2FRN-0-34-%E8%BF%90%E8%A1%8C%E5%9C%A8-Android-%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天闲来无事, 想使用 RN 工程在 Android 设备上面跑跑. 想看看运行效果怎么样?! 适合读者 有 Android 开发基础. 会使用 Android Studio. 初级 React Native 的开发者. 开发环境和工具 Android Studio 2.2 ReactNative 0.34 Android 模拟器 Mac 操作系统 预期效果不出所料, 真的不能一帆风顺的 Run. 在我的博客 ReactNative: 不一样的 HelloWorld 中展示了 RN 在 iOS 上面的运行情况. 今天还是这个例子, 部署和运行到 Android 上面. 效果如下: 在这个过程中, 遇到几个问题. 特此记录. 问题描述和解决问题1: 直接运行 crashlog 描述(部分) E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.mzrntutorial, PID: 5849java.lang.RuntimeException:Unable to start activity ComponentInfo{com.mzrntutorial/com.mzrntutorial.MainActivity}: java.lang.ClassCastException: android.app.Application cannot be cast to com.facebook.react.ReactApplicationat android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2416)at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2476) 解决方案:Manifest.xml 配置 Application 名称 android:name=”.MainApplication” 问题2:1could not get batchedbridge make sure your bundle is packaged correctly 解决问题1后, 再次运行, 会报问题2.该问题是因为没有启动本地的 server. 使用 Xcode 可以自动运行本地 server.可以参考博客 React Native 如何启动 local server 解决方案:手动启动 server. cd 项目根目录 1react-native start 问题3: 模拟器没有 menu 按键, 无法 Reload 这个其实不是什么大问题, 但是对于初学者, 也算是一个问题. 新版的 Android SDK 创建的模拟器没有 menu 按键了 解决方案:连续按两次字母 r 即可刷新. 这些问题, FB 后面肯定会解决的.阿门! 附录(代码)index.ios.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import React, &#123; Component &#125; from &apos;react&apos;;import &#123;getPlatformString, isIOS&#125; from &apos;./js/Generals/Utils/IDSRNPlatformUtil&apos;;import MZButton from &apos;./js/ReactUIKit/MZButton&apos;import &#123; AppRegistry, StyleSheet, Text, View, Platform, TouchableOpacity, TouchableHighlight&#125; from &apos;react-native&apos;;// 调用其他模块方法var os = getPlatformString();var iosPlatform = isIOS();//when run on &apos;ios&apos; trueclass MZRNTutorial extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;status:1&#125;; &#125; customPressHandler = () =&gt; &#123; alert(&apos;当前状态: &apos; + this.state.status); this.state.status = 2; &#125; render() &#123; console.log(&apos;render ...&apos;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Near use React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Press &apos;R&apos; twice to reload,&#123;&apos;\n&apos;&#125; or shake for dev menu &lt;/Text&gt; &#123;/* 显示当前平台信息*/&#125; &lt;Text style=&#123;styles.welcome&#125;&gt; current os: &#123;Platform.OS&#125; &lt;/Text&gt; &#123;/* &lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;this.customPressHandler&#125; &gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;确定&lt;/Text&gt; &lt;/TouchableOpacity&gt; */&#125; &lt;MZButton text=&quot;确定?&quot; bgColor=&quot;green&quot; dianjishijian=&#123;()=&gt;&#123;alert(&apos;居然点击确定?!&apos;)&#125;&#125;&gt; &lt;/MZButton&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; button: &#123; height: 40, width: 150, borderRadius: 20, justifyContent: &apos;center&apos;, backgroundColor: &apos;green&apos;, overflow: &apos;hidden&apos; &#125;, buttonText: &#123; textAlign: &apos;center&apos;, color: &apos;white&apos; &#125;, container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;, flowRight: &#123; flexDirection: &apos;row&apos;, alignItems: &apos;center&apos;, alignSelf: &apos;stretch&apos; &#125;,&#125;);AppRegistry.registerComponent(&apos;MZRNTutorial&apos;, () =&gt; MZRNTutorial); MZButton.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, Text, View, Platform, TouchableOpacity&#125; from &apos;react-native&apos;;//-----------------------------------------------------//外部使用该模块, ES6需要使用关键字 export default//-----------------------------------------------------export default class MZButton extends Component&#123; constructor(props) &#123; super(props); this.state = &#123;status:1&#125;; &#125; costumPressHandler = () =&gt; &#123; alert(&apos;当前状态:&apos; + this.state.status); const &#123;dianjishijian&#125; = this.props; dianjishijian(); &#125;; // 使用属性值设置背景颜色 // style=&#123;[styles.button], &#123;backgroundColor:this.props.beijingyanse&#125;&#125; render() &#123; //解构 const &#123;text, bgColor&#125; = this.props; return ( &lt;TouchableOpacity style=&#123;[styles.button], &#123;backgroundColor:bgColor&#125;&#125; onPress = &#123;this.costumPressHandler&#125; &gt; &lt;Text style=&#123;styles.buttonText&#125;&gt; &#123;/* 使用属性值 */&#125; &#123;this.props.text&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; button: &#123; height: 40, width: 150, borderRadius: 20, justifyContent: &apos;center&apos;, backgroundColor: &apos;green&apos;, overflow: &apos;hidden&apos; &#125;, buttonText: &#123; textAlign: &apos;center&apos;, color: &apos;white&apos; &#125;&#125;); IDSRNPlatformUtil.js 123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Platform&#125; from &apos;react-native&apos;;export function getPlatformString()&#123; console.log(Platform.OS); return Platform.OS;&#125;export function isIOS()&#123; return Platform.OS === &apos;ios&apos;;&#125;export function isAndroid()&#123; return Platform.OS == &apos;android&apos;;&#125;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>Android ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 项目: 打造本地 pod 库]]></title>
    <url>%2F2016%2F09%2F25%2FiOS-%E9%A1%B9%E7%9B%AE-%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0-pod-%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本篇的姊妹篇 Cocoapods 管理开源项目 已准备完毕，直戳 链接 即可达到。 Cocoapods 管理代码的必要性项目到了一定规模, 代码组织和结构显得尤为重要. 重构项目结构，可以从分离代码开始，代码分离，可以把常用稳定的组件封装抽离出来. 分离代码, 常用的有几种方式: 放到不同的文件夹, 管理和组织代码. 使用 framework 的方式, 提供给项目使用. 工具管理如 Cocoapods. 这几种方式, 各有所长, 各有优劣, 无所谓好与坏, 根据自己的项目特点来组织即可. 我的做法是使用 cocoapods 来管理. 下面进入今天的主题: 使用 cocoapods 管理自己的本地代码. 博客 Mac OSX 10.11.1+ 安装 Cocoapods介绍了如何在最新版 MacOS 中安装 Cocoapods 以及注意事项, 并且作者保证持续「更新, 更正」内容. 创建工程使用 Xcode 创建一个工程, 工程名就起为 TestPods 吧. 工程目录可以防止在桌面或者你喜欢的目录下面都可以. 在 TestPods 下面创建 LocalLib 目录, 用来放置分离的代码.当然, 你也可以将 LocalLib 这个目录放到其他目录. 在 LocalLib 下面, 我的 pod 库代码名称为 download. 可以新建这个目录. 目录如下: 创建 podspec 文件在 download 目录下面, 创建 podspec 文件 1pod spec create download 创建完成后, 会生成 download.podspec 文件. 具体内容, 创建后, 大家可以自行查看. 修改 podspec 文件修改 download.podspec, 主要修改几个关键地方: 源码位置源码版本 123456789101112131415――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――# # # Specify the location from where the source should be retrieved. # Supports git, hg, bzr, svn and HTTP. # s.source = &#123; :git =&gt; &quot;&quot;, :tag =&gt; &quot;0.0.1&quot; &#125; # ――― Source Code ――――――――――――――――――――――――――――――――――――――――――――# # # CocoaPods is smart about how it includes source code. For source files # giving a folder will include any swift, h, m, mm, c &amp; cpp files. # For header files it will include any header in the folder. # Not including the public_header_files will make all headers public. # s.source_files = &quot;Source&quot;, &quot;Source/**/*.&#123;h,m&#125;&quot; s.exclude_files = &quot;Source/Exclude&quot; 另外, 配置好相关描述信息, 不要包含 ‘Example’ 的字样, 不然, 新版的 Cocoapods 执行 pod install 时候, 会报出警告和错误. 这样, 工程可以使用 pods 库了. 工程使用 pod 库将 TestPods 改为 cocoapods 项目. 在 TestPods 目录, 执行 1pod init 会生成 Podfile 等文件. 修改 Podfile 文件 123456789101112# Uncomment this line to define a global platform for your project# platform :ios, &apos;7.0&apos;# Uncomment this line if you&apos;re using Swift# use_frameworks!target &apos;TestPods&apos; dopod &apos;download&apos;, :path =&gt; &apos;./LocalLib/download/&apos;#pod &apos;core_lib_spec&apos;, :svn =&gt; &apos;http://svn.ids111.com/o2o/client/ios/trunks/master/Frameworks/CoreLibrary&apos;endtarget &apos;TestPodsTests&apos; doendtarget &apos;TestPodsUITests&apos; doend 关键是指明 pod 库的位置.路径一定要正确.否则无法找到该库. 1pod &apos;download&apos;, :path =&gt; &apos;./LocalLib/download/&apos; 在 TestPods 下面, pod install 即可. 如果, pod install 报错, 一般都是你的 pod 库的配置文件(.podspec)里面写的不符合要求. 根据报错信息, 加以修改即可. xcode 打开工程. 示例下载工程示例代码, 可以 戳这里下载 玩耍! 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 如何启动 local server]]></title>
    <url>%2F2016%2F09%2F22%2FRN-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8-local-server%2F</url>
    <content type="text"><![CDATA[使用 react-native init 创建的工程, 在 xcode 中运行会自动启动一个 RN 的本地 Server. 像下面图片展示这样: 那么, 这里问题来了. 比如, 我想暂时不启动这个本地 Server, 那么如何关闭呢? 下面跟大家一起探讨和追究一下. 找到启动的根源启动这个终端的是在一个 React.xcodeproj 工程的 「Build Phases」中脚本里面配置的. 脚本内容如下: 12345678if nc -w 5 -z localhost 8081 ; then if ! curl -s &quot;http://localhost:8081/status&quot; | grep -q &quot;packager-status:running&quot; ; then echo &quot;Port 8081 already in use, packager is either not running or not running correctly&quot; exit 2 fielse open &quot;$SRCROOT/../packager/launchPackager.command&quot; || echo &quot;Can&apos;t start packager automatically&quot;fi 真正起作用的是: 1open &quot;$SRCROOT/../packager/launchPackager.command&quot; 解决方案这样我们就可以关闭这个自启动了, 示例代码如下: 123456789if nc -w 5 -z localhost 8081 ; then if ! curl -s &quot;http://localhost:8081/status&quot; | grep -q &quot;packager-status:running&quot; ; then echo &quot;Port 8081 already in use, packager is either not running or not running correctly&quot; exit 2 fielse#open &quot;$SRCROOT/../packager/launchPackager.command&quot; || echo &quot;Can&apos;t start packager automatically&quot; echo &quot;Nothing...&quot;fi 看看 launchPackager.command这个文件在「node_modules/react-native/packager/」下面. 该文件是启动另外一个脚本 packager.sh, 核心代码: 1source ./packager.sh 最终执行: 1node &quot;$THIS_DIR/../local-cli/cli.js&quot; start &quot;$@&quot; 大家有兴趣可以去看看源码, 一探究竟.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative iOS Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 创建iOS工程代码的indent问题]]></title>
    <url>%2F2016%2F09%2F19%2FRN-%E5%88%9B%E5%BB%BAiOS%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%9A%84indent%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起因使用最新版RN(0.33)来创建工程, 大家可以发现, OC 代码的退格变成了两个空格.如下: 12345678910111213141516- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSURL *jsCodeLocation; jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;Mark&quot; initialProperties:nil launchOptions:launchOptions]; rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *rootViewController = [UIViewController new]; rootViewController.view = rootView; self.window.rootViewController = rootViewController; [self.window makeKeyAndVisible]; return YES;&#125; 无论你回车或者 tab 或者格式化(右键/Structure/Re-Indent)代码, 会发现, 都是这种调调. 面对这突如其来的变化, 我开始觉得有点淡淡的忧伤. 对于一直使用 tab width = 4 的我来说, 无法忍受. 必须改过来. 思考打开 Xcode 的 preferences, 看到其『设置』正常的不要不要的. 所以可以断定不是 Xcode 的问题. 因为升级了 Xcode 到最新版 Xcode8, 还以为是 Xcode8 的 bug, 打开之前的 React Native 工程或者其他 Xcode 工程, 就没有这个「蛋疼」的问题. 最终猜想是工程配置文件引起的… 解决既然和 Xcode 没有关系, 那么问题就一定出现在配置文件上面. 罪魁祸首 project.pbxproj 123indentWidth = 2;sourceTree = &quot;&lt;group&gt;&quot;;tabWidth = 2; 修改为: 123indentWidth = 4;sourceTree = &quot;&lt;group&gt;&quot;;tabWidth = 4; 或者直接删除: 12indentWidth = 2;tabWidth = 2; 关闭工程, 重启 Xcode 就可以了.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative iOS Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: Mac 配置 ES6 简易开发环境]]></title>
    <url>%2F2016%2F09%2F16%2FRN-Mac-%E9%85%8D%E7%BD%AE-ES6-%E7%AE%80%E6%98%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[创建文件夹 ES6123ES6-lib-src 你可以任意取一个你喜欢的目录名称. 初始化项目1npm init 填写项目信息. 查看一下 package.json 1cat package.json 123456789101112131415&#123; &quot;name&quot;: &quot;es6tutorials&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Tutorial&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ &quot;es6&quot;, &quot;.etc&quot; ], &quot;author&quot;: &quot;mark.zhang&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 目录结构如下 安装 babel-cli1npm install --save-dev babel-cli 也可以全局安装 1npm install babel-cli -g 全局安装上后，会安装如下四个程序到全局环境中： 1234babelbabel-nodebabel-doctorbabel-external-helpers 安装 babel-core1npm install babel-core --save 安装 ES2015 插件1npm install babel-preset-es2015 编写配置文件 .babelrc 注意该文件有个点符号. 在工程目录下新建该文件 1touch .babelrc 写入如下内容 123456&#123; &quot;presets&quot;: [ &quot;es2015&quot;, ], &quot;plugins&quot;: []&#125; 编写测试代码 tutorials.js 12345678910111213141516171819202122function test()&#123; console.log(a); var a = 0;&#125;test();var a = [];for (var i = 0; i &lt; 10; i++) &#123; var c = i; a[i] = function () &#123; console.log(c); &#125;;&#125;a[6](); // 9var b = [];for (var i=0; i&lt;10; i++) &#123; let c = i; //let 是 es6中的关键字 b[i] = function() &#123; console.log(c) &#125;;&#125;b[6](); 编译 1babel src/tutorials.js 运行 1babel-node src/tutorials.js 这里可以下载 工程源码. 其他操作1.将 ES6 语法的文件转换为 ES5 的语法1babel -d lib/ src/ 在 lib 目录下会生成 src 目录中对应的文件. 2.进入交互模式1babel-node 两次 ctrl+c 退出 3.检查babel状况1babel-doctor 检查以下内容 配置文件.babelrc 是否有重复的babel安装包，比如说安装了5和6 babel安装包是否已经升级到了最新版 npm &gt;= 3.3.0 4.卸载全局的 babel-cli1npm uninstall --global babel-cli 感谢 Babel comes with a built-in CLI which can be used to compile files from the command line. 阮一峰老师的 ECMAScript 6入门]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 手机是否设置网络代理]]></title>
    <url>%2F2016%2F09%2F16%2FiOS-%E6%89%8B%E6%9C%BA%E6%98%AF%E5%90%A6%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[情景项目开发过程中, 会遇到下面这样一种情景: 产品或者设计同事需要体验目前产品开发的进度, 然后要求开发人员, 将现在的版本给他们体验.做过程序开发的人都知道, 开发版本会有不少问题.这时, 产品和设计同事就会抱怨, 怎么登录不了, 这里没有数据了!有个小伙伴被折腾的实在受不了, 连网页都打不开了.最后找到原因:他手机被之前的程序猿设置了网络代理, 代理到程序猿哥哥的电脑上来抓包调试问题, 忘记取消设置了. 假如可以判断当前手机是否设置了网络代理, 就可以很好地解决上面情景中提到的问题了. 找到线索在 ASIHttpRequest 中找到如下方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243- (BOOL)configureProxies&#123; // Have details of the proxy been set on this request if (![self isPACFileRequest] &amp;&amp; (![self proxyHost] &amp;&amp; ![self proxyPort])) &#123; // If not, we need to figure out what they&apos;ll be NSArray *proxies = nil; // Have we been given a proxy auto config file? if ([self PACurl]) &#123; // If yes, we&apos;ll need to fetch the PAC file asynchronously, so we stop this request to wait until we have the proxy details. [self fetchPACFile]; return NO; // Detect proxy settings and apply them &#125; else &#123;#if TARGET_OS_IPHONE NSDictionary *proxySettings = [NSMakeCollectable(CFNetworkCopySystemProxySettings()) autorelease];#else NSDictionary *proxySettings = [NSMakeCollectable(SCDynamicStoreCopyProxies(NULL)) autorelease];#endif proxies = [NSMakeCollectable(CFNetworkCopyProxiesForURL((CFURLRef)[self url], (CFDictionaryRef)proxySettings)) autorelease]; // Now check to see if the proxy settings contained a PAC url, we need to run the script to get the real list of proxies if so NSDictionary *settings = [proxies objectAtIndex:0]; if ([settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]) &#123; [self setPACurl:[settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]]; [self fetchPACFile]; return NO; &#125; &#125; if (!proxies) &#123; [self setReadStream:nil]; [self failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileBuildingRequestType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to obtain information on proxy servers needed for request&quot;,NSLocalizedDescriptionKey,nil]]]; return NO; &#125; // I don&apos;t really understand why the dictionary returned by CFNetworkCopyProxiesForURL uses different key names from CFNetworkCopySystemProxySettings/SCDynamicStoreCopyProxies // and why its key names are documented while those we actually need to use don&apos;t seem to be (passing the kCF* keys doesn&apos;t seem to work) if ([proxies count] &gt; 0) &#123; NSDictionary *settings = [proxies objectAtIndex:0]; [self setProxyHost:[settings objectForKey:(NSString *)kCFProxyHostNameKey]]; [self setProxyPort:[[settings objectForKey:(NSString *)kCFProxyPortNumberKey] intValue]]; [self setProxyType:[settings objectForKey:(NSString *)kCFProxyTypeKey]]; &#125; &#125; return YES;&#125; 踏破铁鞋无觅处… 判断 iphone 是否设置网络代理的示例代码如下: 12345678910111213141516171819202122+ (BOOL)hasSetProxy&#123; BOOL proxy = NO; NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings()); NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef)(url), (__bridge CFDictionaryRef)(proxySettings))); MZLOG(@&quot;proxies:%@&quot;, proxies); NSDictionary *settings = proxies[0]; MZLOG(@&quot;kCFProxyHostNameKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyHostNameKey]); MZLOG(@&quot;kCFProxyPortNumberKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyPortNumberKey]); MZLOG(@&quot;kCFProxyTypeKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyTypeKey]); if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@&quot;kCFProxyTypeNone&quot;]) &#123; proxy = NO; &#125; else &#123; proxy = YES; &#125; return proxy;&#125; 用户体验判断如果设置了代理, 提示用户, 帮他直接跳到 wifi 设置界面. 下面说说如何跳到系统的 wifi 设置界面. 1.配置 URL TYPES 注意这里的配置是 prefs. 2.openURL 1234567891011121314NSString * urlString = @&quot;prefs:root=WIFI&quot;;NSURL *url = [NSURL URLWithString:urlString];UIApplication *app = [UIApplication sharedApplication];if ([app canOpenURL:[NSURL URLWithString:urlString]]) &#123; if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0) &#123; [app openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; [app openURL:url]; &#125;&#125; 另外, 跳转到系统其他界面的 URL 如下: 123456789101112131415161718192021222324252627281.系统设置prefs:root=INTERNET_TETHERING2.WIFI设置prefs:root=WIFI3.蓝牙设置prefs:root=Bluetooth4.系统通知prefs:root=NOTIFICATIONS_ID5.通用设置prefs:root=General6.显示设置prefs:root=DISPLAY&amp;BRIGHTNESS7.壁纸设置prefs:root=Wallpaper8.声音设置prefs:root=Sounds9.隐私设置prefs:root=privacy10.打开 APP Storeprefs:root=STORE11.打开 Notesprefs:root=NOTES12.打开 Safariprefs:root=Safari13.打开 Musicprefs:root=MUSIC14.打开 photoprefs:root=Photos]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与 CSDN 的诀别]]></title>
    <url>%2F2016%2F09%2F10%2F%E4%B8%8E-CSDN-%E7%9A%84%E8%AF%80%E5%88%AB%2F</url>
    <content type="text"><![CDATA[写这个话题, 内心还是蛮沉重的. 几年前与 CSDN 不期而遇, 在里面各种折腾, 翻阅大牛们的博客, 写评论, 甚至打印出来. 在技术论坛不停地”灌水”, 订阅 CSDN 杂志, 准备练就一身武艺. 互联网的蓬勃发展, 让我原来不安的心有了更加狂躁的冲动. 在某个夜深人静的夜晚, 开启了奋笔疾书的历程, 踏上了 CSDN 的博客之旅.这么多年以来, CSDN 就像我的一个朋友, 不管是家长里短, 还是技术讨论, 各种心酸, 我都会记录在那里. 一坚持就是几年… 如今, 要离开 CSDN 的博客了, 不准备在那里继续’耕耘’了.总结起来有如下几个原因: 文章被任意的转载, 没经过本人的允许.我在论坛也问过该事, 没有任何回应, 很失望! 广告越来越多. 相比以前, 很难找到让人满意的有质量的文章. 再见, CSDN! 请原谅我的不辞而别!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 写作</tag>
      </tags>
  </entry>
</search>
