<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaIO中神奇的flush]]></title>
    <url>%2F2019%2F05%2F19%2FJavaIO%E4%B8%AD%E7%A5%9E%E5%A5%87%E7%9A%84flush%2F</url>
    <content type="text"><![CDATA[这篇文章在之前已经写过，只是没有在公众号发布过。该文阅读量已经达到了 36503 次了，有必要分享给大家。 后续我会陆续的把一些大家评论比较多并且很好的知识点在公众号分享给大家，希望和大家在编程的道路上一起进步，把苦涩的日子变得有趣一点。 内容概要Java IO流的设计不得不让人拍案叫绝，佩服设计者鬼斧天工的手法。 如果你是Java初学者，我敢保证第一次接触Java的IO类，一定会 ”狂晕！”，倒不是因为它有多么难学而是太多，而且及其让人有种 “不识庐山真面目” 的感觉，当你学完他之后又有种 “只缘身在此山中” 的顿悟。 在Java编程的日子中尤其是在网络编程中，几乎离不开Java的IO流，所以学好他是很有必要的。 关于Java的IO流的分类，可以到网上soso，今天跟大家分享一下神奇的 flush 方法。 flush 与 OutputStream该类实现了 Flushable 接口，所以重写了 flush 方法，看看 flush() 源码，会更加的让你明白： 1public void flush() throws IOException &#123; &#125; Sorry，该实现为空。这里的 flush() 居然是一个空方法，什么也没做。看清楚啊，该方法不是抽象方法，是一个实实在在的方法。除了方法体中一无所有，其它还好！看JDK的API如何解释吧！ 12345678flush public void flush() throws IOException 刷新此输出流并强制写出所有缓冲的输出字节。flush 的常规协定是：如果此输出流的实现已经缓冲了以前写入的任何字节，则调用此方法指示应将这些字节立即写入它们预期的目标。 如果此流的预期目标是由基础操作系统提供的一个抽象（如一个文件），则刷新此流只能保证将以前写入到流的字节传递给操作系统进行写入，但不保证能将这些字节实际写入到物理设备（如磁盘驱动器）。OutputStream 的 flush 方法不执行任何操作。指定者： 接口 Flushable 中的 flush 抛出： IOException - 如果发生 I/O 错误。 开始，我安慰自己，该类是一个抽象类，它的子类肯定重写了该方法。 好吧，OutputStream 的直接子类有：ByteArrayOutputStream 、FileOutputStream、FilterOutputStream、ObjectOutputStream 、OutputStream、PipedOutputStream 等几个类。 注意：这里的子类 OutputStream 是包 org.omg.CORBA.portable 的。 对于 FileOutputStream、ByteArrayOutputStream、org.omg.CORBA.portable.OutputStream 类它们的flush() 方法均是从父类继承的 flush 方法。 FilterOutputStream 类重写了 flush() 方法，但是实质还是调用父类的 flush() 方法。 ObjectOutputStream、PipedOutputStream 类重写了 flush() 方法。 来举两个小例子，第一个例子主要是向文本中写入字符串，第二个例子向文本中写入一定字节的数据。 1、例子1：向文本中写入字符串 1234567891011121314151617import java.io.BufferedOutputStream; import java.io.DataOutputStream; import java.io.File; import java.io.FileOutputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); DataOutputStream dos = new DataOutputStream(fos); dos.writeBytes("java io"); &#125; &#125; 2、例子2：向文本中写入一定字节的数据 1234567891011121314151617import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] b = new byte[1024*8]; bos.write(b); bos.flush(); &#125;&#125; 这两段代执行后，分别会在当前目录下产生7字节的文件（内容为 java io）和1KB字节的文件。 说到这里，有些人会说，这有什么稀奇，至于吗？？？呵呵，别急哈！ 现在我们修改第二个代码，主要是注释掉调用 flush() 方法，如下： 1234567891011121314151617import java.io.BufferedOutputStream;import java.io.File;import java.io.FileOutputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] b = new byte[1024]; bos.write(b); //bos.flush(); &#125;&#125; OK，再次运行代码，额的神啊？？？文件大小居然是0字节。 why？ 仔细的你会发现，第一个例子中的代码中并没有调用 flush() 方法，居然可以正常的写入。为什么第二个就不可以呢？还是从源码入手找答案吧！ DataOutputStream 继承 FilterOutputStream ，实现了 DataOutput 接口。我们知道 FilterOutputStream 类重写了 flush() 方法，但是实质还是调用父类的 flush() 方法。DataOutputStream 类的 flush() 方法效仿其父类 FilterOutputStream 的做法，如下： 123public void flush() throws IOException &#123; out.flush(); &#125; 那么，即使你在第一个例子的代码后面加上 dos.flush() 结果也是正常的，与不加是一样的效果，因为它们的父类 flush() 方法均为空，这就是为什么第一个代码的神奇所在。 再看看第二个代码的 “病因” 在哪里？先看看 BufferedOutputStream 类的结构： 1public class BufferedOutputStream extends FilterOutputStream 再看看，它的 flush() 方法： 123456789101112public synchronized void flush() throws IOException &#123; flushBuffer(); out.flush();&#125; /** Flush the internal buffer */ private void flushBuffer() throws IOException &#123; if (count &gt; 0) &#123; out.write(buf, 0, count); count = 0; &#125; &#125; 不错，该类重写了 flush() 方法，不像前面几个类那样不是继承就是山寨父类的 flush() 方法。BufferedOutputStream 类是一个使用了缓冲技术的类，这种类一把都会自己实现 flush() 方法。 那么，有人会问使用这种类的时候，难道必须使用 flush() 方法吗，当然不是喽？？！！不过有个前提，你的字节数据必须不能小于8KB。实例代码，注意没有 flush()方法。 1234567891011121314151617import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; public class Test &#123; public static void main(String[] args) throws Exception &#123; File file = new File("text.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] b = new byte[1024*8]; bos.write(b); //bos.flush(); &#125;&#125; 执行代码，会产生8KB的文本文件。 当然，怎么可能每时每刻都知道你的数据一定会不小于8KB呢，所以调用 flush() 方法比较安全。 不过，话又说回来，一般用完IO流之后（如果你有一个好的习惯）我们都会去调用 close() 方法，看源码可以知道该方法也是调用相对应的 flush() 方法。 这里提醒一下，如果你的文件读写没有达到预期目的，十之八九是因为你没有调用 flush() 或者 close() 方法。 另外，字符流类大多数都实现了 flush() 或者 close() 方法，只不过，它们调用的是 StreamEncoder 类的该方法。该类位于 sun.nio.cs 包下面，其源码在我们JDK中是没有的。 可以点击 StreamEncoder.java 查看源码。 flush 与 Writer该类 Writer 是一个抽象类，声明如下： 1public abstract class Writer implements Appendable, Closeable, Flushable Writer 类的 flush() 方法是一个抽象方法，其子类一般都实现了该方法。 所以，一般使用字符流之后需要调用一下 flush() 或者 close() 方法。 1abstract public void flush() throws IOException; 细节请看JDK的API，或者Java的源码以及上面的 StreamEncoder 类源码。 今天就说到这里吧，本文主要借助Java IO中字节流与字符流的 flush() 方法，来说明学编程语言看源码和思考是很重要的。 总之，不管你使用哪种流（字符、字节、具有缓冲的流）技术，不妨调用一下 flush() 或者 close() 方法，防止数据无法写到输出流中。 学习没有一蹴而就的方法，坚持思考、练习才是王道~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>flush OutputStream JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 生成 RSA 公钥和私钥]]></title>
    <url>%2F2019%2F05%2F11%2FmacOS-%E7%94%9F%E6%88%90-RSA-%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%2F</url>
    <content type="text"><![CDATA[如果你没有安装 openssl，请先使用 brew 安装它。 生成 RSA 私钥在 macOS 终端输入下面命令，会生成1024位的私钥，如下： 1openssl genrsa -out rsa_private.pem 1024 执行成功后，在当前目录会生成 rsa_private.pem 文件了。 注意：这里生成的是 PKCS1 格式的文件，也称之为传统的私钥格式。 生成 RSA 公钥得到私钥后，执行如下命令可以得到公钥，命令如下： 1openssl rsa -in rsa_private.pem -out rsa_public.pem -pubout 执行成功后，在当前目录会生成 rsa_public.pem 的文件，这个就是公钥。 格式转换 有些后端服务需要 PKCS8 格式的密钥，可以使用 openssl 工具把 PKCS1 和 PKCS8 进行互转。 PKCS 全称是 Public-Key Cryptography Standards，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准。 把 RSA 私钥转 PKCS1 转换为 PKCS8 格式，执行如下： 1openssl pkcs8 -topk8 -inform PEM -in rsa_private.pem -outform PEM -nocrypt -out rsa_private_pkcs8.pem 把 RSA 私钥 PKCS8 格式转换为 PKCS1 格式，执行如下： 1openssl rsa -in rsa_private_pkcs8.pem -out pkcs1.pem 以上生成的 RSA(pem) 文件，可以使用 vim、vscode 等文本编辑器打开查看。 无论是 PKCS1 还是 PKCS8，它们都是 PEM 编码存储的格式。 PEM 格式PEM 格式既是对 DER 编码转码为 Base64 字符格式，通过解码，将会还原为 DER 格式。即 PEM 是建立在 DER 编码之上的一种格式。 总之，PEM 是明文格式，可以包含证书或者是密钥，其内容通常是以类似 —–BEGIN …—– 开头，以 —–END …—– 为结尾的这样的格式，如下示例： 123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQDX+VXh+9zZBC3jRLcLyGGygb/vuiQj13x9ElH9pQmUg29UJ0q1hcSFuoKmt4id8jyj82fI2PMISzoGucqQFm9HXIV65UcgeUx7REDhgZOBmSCWZ2lWe2Fnf/htyiy9YVEN4jL7H+b67cIcEDHgYZLtPvSZgyr0UyOMC+E40kTcnQIDAQABAoGBAKKsYD7l6VPgrPuY31LVrJi62ComB2Cjx1WhffZR3+RoF2vImNtkB0E+2Xffl9x3/6ry1IMove3KTzadrHBZJZi1Y6lmHE95uv0O4p16ETnqvKzO8MkcH3qVQe1ZEyNd/wXr4A8DW3ZlNP/QIPOgzK949yTiP53wapiRwExEf7nhAkEA7CbbdoslRzhQ9YY1Sdbmc7NHpZdKhkgZwOVJZBoRwfHtSnFcpQUlOzLGCOxP+tGn5mpzhmpDFeURbv7mgaQvtQJBAOogUtiJbffk0p3uu7r5nCBmC6BqbG8yVqBVk+r/gS5iHBeBQVypFGYYLPQ9daHWluNku07MhqarPcXytEk7ekkCQDBjofK/fmsCkixNTNwNiflJUiVOW/n6CjTphslZQhIGNb5cTkSOMlvYApZPffACR+pCA9wWKBrzbkgVOTx1XUUCQQDEKJLg47wkLy6brhLss6ewqW7iV3hEfhuAOFM3WB1mvEKnGt+lf/AcXfMEK54sGzvOh2475jaG3ABkoiWVGeUpAkAgckc/Pf7KVRF/mDVruMJBbJLYL4H4s78nssFQ4d9VyXKsIM/AHUxZ5ZKiC7vtEtaGrTLAiuIuQZzBgGpSHX/e-----END RSA PRIVATE KEY----- 以下是证书文件名称，来自维基百科 X.509 的截图。 要始终保持学习的激情~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>RSA OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C函数中返回字符数组]]></title>
    <url>%2F2019%2F05%2F10%2FC%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[内容简介在阅读本篇文章之前，建议大家看一下下面2篇文章： 不见得你会计算C字符串长度 双宿双飞的 malloc 和 free 这篇文章主要分享三个点： 1、为什么作为局部变量的字符数组不能直接返回，而字符指针却可以? 2、当字符数组是局部变量的时候，函数如何返回它？ 3、字符数组(char [])和字符指针(char *)如何互转？ 局部变量的字符数组在C中如果我们直接返回字符数组，编译会直接报警告。如下示例： 12345char * fork_user_name()&#123; char name[] = "veryitman"; return name;&#125; 在Xcode中编译警告信息是这样的： 1Address of stack memory associated with local variable 'name' returned 在Linux上面GCC编译显示警告是这样的： 1warning: function returns address of local variable [-Wreturn-local-addr] 无论哪种警告信息，基本意思都是告诉我们不应该返回一个局部变量 name 的地址（函数内部的变量在栈内存上）。 如果我们修改一下代码，将 char 改为指针变量 char * ，示例如下： 12345char * fork_user_name2()&#123; char *name = "veryitman"; return name;&#125; 无论是Linux的GCC还是Xcode的Clang编译器都不会报出警告。 首先我们要知道，常量是放在数据段里面的。 这里比较特殊，局部变量 name 保存在栈中，但是字符串 veryitman 的值是一个常量，保存在常量区。即便函数返回了，数据段里面的常量数据也还不会消亡，它会直到程序结束才会消失，其内存空间直到程序运行结束才会被释放。 所以，返回的地址是一个实际存在的有效地址。 12345678910111213141516171819char * fork_user_name()&#123; char name[] = "veryitman"; return name;&#125;char * fork_user_name2()&#123; char *name = "veryitman"; return name;&#125;int main()&#123; printf("fork_user_name: %s\n", fork_user_name()); printf("fork_user_name2: %s\n", fork_user_name2()); return 0;&#125; 用GCC编译、运行后的打印结果，如下： 12fork_user_name: (null)fork_user_name2: veryitman 总之，在函数中的局部变量只要是返回类似 int[]、char[]、long[] 地址的，都是不正确的做法。 一切皆有可能下面例子是不正确的，如下： 12345char * v_string()&#123; char rest[10] = &#123;'\0'&#125;; return rest;&#125; 1、使用 static 在C语言中，用 static 限定外部变量与函数，该外部变量或者函数除了对该所在的文件可见外，其他文件都无法访问。 而用 static 声明内部变量，则该变量是某个特定函数的局部变量，只能在该函数中使用。但它与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。 所以使用static修饰一下，就没有问题了。示例如下： 12345char * v_string()&#123; static char rest[10] = &#123;'\0'&#125;; return rest;&#125; 2、使用 malloc 这种方式可以解决这个问题，是因为使用 malloc 分配的内存是在堆上而不是在栈内存上面。但是要记得将其在调用方使用 free 释放申请的内存空间，否则容易造成内存泄漏问题。 具体可以看看 双宿双飞的 malloc 和 free) 这篇文章。 123456char * v_string()&#123; char *p = (char *)malloc(10 * sizeof(char)); p = "\0"; return p;&#125; 3、全局变量 这个很好理解。全局变量在程序真个生命周期中都是有效的，所以使用全局变量也可以解决类似问题。 但是这种方案就会让这个封装的方法不够内聚，因为它依赖了全局变量。 123456char g_rest[100];char * v_string()&#123; strcpy(g_rest, "verytiamn"); return g_rest;&#125; 4、返回形参指针变量 在Linux Kernel(内核源码版本5.0.7)中，函数 strcpy 的实现如下： 1234567891011121314151617#ifndef __HAVE_ARCH_STRCPY/** * strcpy - Copy a %NUL terminated string * @dest: Where to copy the string to * @src: Where to copy the string from */#undef strcpychar *strcpy(char *dest, const char *src)&#123; char *tmp = dest; while ((*dest++ = *src++) != '\0') /* nothing */; return tmp;&#125;EXPORT_SYMBOL(strcpy);#endif 参考内核实现，我们可以修改一下自己的代码，示例如下： 123456char * v_string(char *s1, char *s2)&#123; char *tmp = s1; // 省略... return tmp;&#125; 这里补充另外一个知识点，函数 strcpy 在glibc和Linux Kernel中实现不一样。 在glibc的新版中(2.29版本)，本质是调用了函数 memcpy， 实现如下： 123456789101112131415#include &lt;stddef.h&gt;#include &lt;string.h&gt;#undef strcpy#ifndef STRCPY# define STRCPY strcpy#endif/* Copy SRC to DEST. */char * STRCPY (char *dest, const char *src)&#123; return memcpy (dest, src, strlen (src) + 1);&#125;libc_hidden_builtin_def (strcpy) 包括 strncpy 在glibc和Linux Kernel中实现也不一样，有兴趣的可以去看看源码。 字符数组和字符指针的互转char [] 转 char *这种情况下，可以直接进行赋值，示例如下： 12345678int main()&#123; char c_str_array[] = "veryitman.com"; char *p_str; p_str = c_str_array; printf("p_str: %s\n", p_str); return 0;&#125; char * 转 char []是不是也可以直接进行赋值呢？撸段代码看看，如下： 12345678int main()&#123; char c_str_array[] = "veryitman.com"; char *p_str = "veryitman.com"; c_str_array = p_str; printf("c_str_array: %s\n", c_str_array); return 0;&#125; 很遗憾，编译报错，GCC编译错误截图如下： Clang编译错误如下： 1Array type &apos;char [14]&apos; is not assignable 可以考虑使用 strncpy 来实现，示例代码如下： 123456789101112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char c_str_array[] = "veryitman.com"; char *p_str = "veryitman.com"; strncpy(c_str_array, p_str, strlen(p_str)); printf("c_str_array: %s\n", c_str_array); return 0&#125; 时间可以改变一切，但你得做点什么！]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>strcpy char[]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双宿双飞的 malloc 和 free]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%8F%8C%E5%AE%BF%E5%8F%8C%E9%A3%9E%E7%9A%84-malloc-%E5%92%8C-free%2F</url>
    <content type="text"><![CDATA[简介函数 malloc 和 free 是一对好朋友，几乎是形影不离。有 malloc 的地方就应该有 free 的存在。 今天跟大家聊聊 malloc 和 free 这对好基友，这两个函数都是对堆内存进行管理的函数，另外还有 calloc、realloc、reallocf、valloc 等堆内存管理函数。 void *在进行下面话题之前，我们先回忆一下 void * 是什么？ void * 表示未确定类型的指针。C/C++规定，void * 类型可以强制转换为任何其它类型的指针。 void * 也被称之为无类型指针，void * 可以指向任意类型的数据，就是说可以用任意类型的指针对 void * 赋值，如下示例： 123void *p1;int *p2;p1 = p2; 但一般不会反过来使用，如下示例在有些编译器上面可以编译通过，有些就不行： 123void *p1;int *p2;p2 = p1; 可以修改一下代码，将 void * 转换为对应的指针类型再进行赋值，如下示例： 123void *p1;int *p2;p2 = (char *)p1; 由于 GNU 和 ANSI 对 void * 类型指针参与运算的规定不一样，所以为了兼容二者并且让程序有更好的兼容性，最好还是将 void * 转换为有明确类型的指针再参与运算，如下示例。 1234void *pd;char *pc = (char *)pd;pc ++;pc += 1; malloc函数原型： 1void * malloc(size_t size); malloc 向系统申请分配指定 size 个字节的内存空间，即 malloc 函数用来从堆空间中申请指定的 size 个字节的内存大小，返回类型是 void * 类型，如果成功，就会返回指向申请分配的内存，否则返回空指针，所以 malloc 不保证一定成功。 查看函数手册或者直接在Linux、macOS等Unix系统上面直接 man malloc 会显示对应的函数信息： 1234The malloc() function allocates size bytes of memory and returns a pointer to the allocated memory.If successful, malloc() function return a pointer to allocated memory. If there is an error, they return a NULL pointer and set errno to ENOMEM. 另外需要注意一个问题，使用 malloc 函数分配内存空间成功后，malloc 不会对数据进行初始化，里边数据是随机的垃圾数据，所以一般结合 memset 函数和 malloc 函数 一起使用。 123456int *arr;arr = (int *)malloc(10 * sizeof(int));if (NULL != arr) &#123; memset(arr, 0, 10 * sizeof(int)); printf("arr: %p\n", arr);&#125; 123456char *arr;arr = (char *)malloc(10 * sizeof(char));if (NULL != arr) &#123; memset(arr, '\0', 10 * sizeof(char)); printf("arr string: %s\n", arr);&#125; 为了安全起见，建议可以考虑使用 calloc() 函数，后面会提到它。 函数 free、malloc、calloc() 都被包含在 stdlib.h 头文件中，当然了 malloc.h 头文件也有对应的函数声明，实现在 malloc.c 文件中。 关于 malloc 函数中的 size 参数务必要大于指针本身的数值，在32位操作系统上，指针占用4字节的大小；在64位操作系统上，指针占用8字节的大小。 free函数原型： 1void free(void *ptr); 我们知道在 C 语言中， 堆上的内存空间不会自动释放（Java 有自动回收机制，而 C 语言没有），直到调用 free 函数，才会释放堆上的存储空间，即 free 函数会释放指针指向的内存分配空间。 下面是函数手册查到关于 free 函数的资料： 12The free() function deallocates the memory allocation pointed to by ptr.If ptr is a NULL pointer, no operation is performed. 对于 free 函数我们要走出一个误区，不要以为调用了 free 函数，变量就变为 NULL 值了。本质是 free 函数只是割断了指针所指的申请的那块内存之间的关系，并没有改变所指的地址（本身保存的地址并没有改变）。如下示例： 12345678910111213char *pchar = (char *)malloc(10 * sizeof(char)); if (NULL != pchar) &#123; strcpy(pchar, "blog"); /* pchar所指的内存被释放，但是pchar所指的地址仍然不变 */ free(pchar); /* 该判断没有起到防错作用，此时 pchar 并不为 NULL */ if (NULL != pchar) &#123; strcpy(pchar, "it"); printf("pchar: %s", pchar); &#125;&#125; 正确且安全的做法是对指针变量先进行 free 然后再将其值置为 NULL，如下下面示例： 123456789101112131415char *pchar = (char *)malloc(10 * sizeof(char)); if (NULL != pchar) &#123; strcpy(pchar, "blog"); /* pchar所指的内存被释放，但是pchar所指的地址仍然不变 */ free(pchar); /* 将其置为 NULL 值 */ pchar = NULL; /* 该判断没有起到防错作用，此时 pchar 并不为 NULL */ if (NULL != pchar) &#123; strcpy(pchar, "it"); printf("pchar: %s", pchar); &#125;&#125; 函数 free 只能释放alloc的内存空间，对于其他非alloc的指针变量使用free会出现错误，如下面的例子： 1234int a = 0x2010;int *p;p = &amp;a;free(p); 运行后直接跪了，报类似下面的错误信息： 1pointer being freed was not allocated. 另外，告诉大家一个秘密，free 一个空指针没问题。如下例子： 123int *p;p = NULL;free(p); 代码可以正常运行，在 free 函数源码为证： 1234/* free(0) has no effect */if (mem == 0)&#123; return; &#125; 而 NULL 在源码（在 morecore.c 文件中）中定义就是0，如下： 123#ifndef NULL# define NULL 0#endif malloc、free 小结1、连续内存块 malloc 函数申请的是连续的一块内存，如果所申请的内存块大于目前堆上剩余内存块，则内存分配会失败，函数返回 NULL 值。 注意：上面说的 堆上剩余内存块 不是所有剩余内存块之和，而是连续的内存。 2、双宿双飞才好 调用 malloc 函数多余 free 函数会发生内存泄漏，这个很好理解，因为申请过的内存没有被释放完。调用 malloc 函数少于free 函数，肯定会出错。换句话说，在程序中 malloc 的使用次数务必要和 free 相等，否则必有隐患或者发生错误。 如下面的例子 free 两次指针变量就会在运行时报错： malloc: *** error for object 0x10071be90: pointer being freed was not allocated，也称之为 double free。 123char *pchar = (char *)malloc(10 * sizeof(char));free(pchar);free(pchar); 对指针变量进行 free 之后，一定要记得对其赋值为 NULL，否则该指针就是一个野指针，这个在上面已经说明。 3、0字节的内存有毒 使用 malloc 函数也可以申请0字节的内存，该函数的返回值并不是 NULL，而是返回一个正常的内存地址，所以如果使用这种方式申请的内存很危险，如下面的例子，指针 pchar 是一个使用 malloc 函数创建的占用0字节的内存空间的一个指针变量，if (NULL == pchar) 并没有生效，而是执行了 else 语句中的代码，执行到 strcpy(pchar, &quot;blog&quot;) 就直接崩溃了。 123456789char *pchar = (char *)malloc(0);if (NULL == pchar) &#123; printf("malloc 0 byte memory failed.\n");&#125; else &#123; printf("malloc 0 byte successfully and pchar: %s.\n", pchar); pchar = "veryitman"; strcpy(pchar, "blog"); printf("pchar: %s.\n", pchar);&#125; 4、调皮的free 使用非alloc方式创建的内存，使用 free 函数会报错，这个要注意。另外，free 空指针没有影响。 calloc、realloc、reallocf、valloc1、calloc 函数 1void * calloc(size_t count, size_t size); 在堆上，分配 n*size 个字节，并初始化为0，返回 void *类型，返回值情况跟 malloc 一致。 函数 malloc() 和函数 calloc() 的主要区别是前者不能初始化所分配的内存空间，而后者能。如果由 malloc() 函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存曾经被分配过，则其中可能遗留有各种各样的数据。也就是说，使用 malloc() 函数的程序开始时(内存空间还没有被重新分配)能正常进行，但经过一段时间(内存空间还已经被重新分配)可能会出现问题。 函数 calloc() 会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存，那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。 123The calloc() function contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory.The allocated memory is filled with bytes of value zero. 2、realloc() 函数 1void * realloc(void *ptr, size_t size); realloc() 会将 ptr 所指向的内存块的大小修改为 size，并将新的内存指针返回。假设之前内存块的大小为 n，如果 size &lt;= n，那么截取的内容不会发生变化，如果 size &gt; n，那么新分配的内存不会被初始化。 对于上面说的新的内存指针地址可能变也可能不变，假如原来alloc的内存后面还有足够多剩余内存的话，realloc后的内存=原来的内存+剩余内存，realloc还是返回原来内存的地址即不会创建新的内存。假如原来alloc的内存后面没有足够多剩余内存的话，realloc将申请新的内存，然后把原来的内存数据拷贝到新内存里，原来的内存将被free掉，realloc返回新内存的地址。 另外要注意，如果 ptr = NULL，那么相当于调用 malloc(size)；如果 ptr != NULL且size = 0，那么相当于调用 free(ptr)。 当调用 realloc 失败的时候，返回NULL，并且原来的内存不改变，不会释放也不会移动。 123456789The realloc() function tries to change the size of the allocation pointed to by ptr to size, and returns ptr. If there is not enough room to enlarge the memory allocation pointed to by ptr, realloc() creates a new allocation, copies as much of the old data pointed to by ptr as will fit to the new allocation, frees the old allocation, and returns a pointer to the allocated memory. If ptr is NULL, realloc() is identical to a call to malloc() for size bytes. If size is zero and ptr is not NULL, a new, minimum sized object is allocated and the original object is freed. When extending a region allocated with calloc(3), realloc(3) does not guarantee that the additional memory is also zero-filled. 看一下源码的关键部分，如下： 123456789101112void * __libc_realloc (void *oldmem, size_t bytes)&#123; // 省略... #if REALLOC_ZERO_BYTES_FREES if (bytes == 0 &amp;&amp; oldmem != NULL) &#123; __libc_free (oldmem); return 0; &#125;#endif // 省略...&#125; 这里可以看出，如果 oldmem 不为NULL且 bytes 为0的情况下，会自动进行 free 操作。如下面的例子运行后会报错。 123456789101112131415#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt; int main()&#123; char *pre_ptr = (char *)malloc(20); int bytes = 0; if(NULL != pre_ptr) &#123; void *ptr = realloc(pre_ptr, bytes); // 对pre_ptr进行了double free，这种条件下源码中会进行一次free free(pre_ptr); &#125; return 0;&#125; 所以为了保险起见，要对 bytes 进行判断再做处理。 传递给 realloc 的指针变量必须是先前通过 malloc()、 calloc() 或 realloc() 等alloc分配的，否则会报 pointer being realloc&#39;d was not allocated. 错误。如下例子（运行直接报错）： 12char *p = "";void *newP = realloc(p, 10); 3、reallocf() 函数 1void * reallocf(void *ptr, size_t size); reallocf() 函数是由 FreeBSD 实现的，它会在任何情况下释放输入的指针（即使是再分配失败之后）。reallocf() 一样会调用 realloc 函数，但是只有我们在获得空的指针之后才会调用 free 函数。 下面是 reallocf 函数具体的实现部分： 12345678void * reallocf(void *p, size_t size) &#123; void *ptr = realloc(p, size); if (!p) &#123; free(p); &#125; return ptr;&#125; 123The reallocf() function is identical to the realloc() function, except that it will free the passed pointer when the requested memory cannot be allocated.This is a FreeBSD specific API designed to ease the problems with traditional coding styles for realloc causing memory leaks in libraries. 4、valloc() 函数 1void * valloc(size_t size); 这个函数是最少见也是最少用的一个函数。 malloc 或 realloc 返回的是以8字节对齐的内存地址，在64bits上是16字节对齐。然而 memalign 或 valloc 可以更大的粒度进行字节对齐。 valloc 是一个废弃的函数，分配 size 大小的字节，返回已分配的内存地址指针，其内存地址将是页大小(page size)的倍数，如果分配失败返回 NULL。 123The valloc() function allocates size bytes of memory and returns a pointer to the allocated memory. The allocated memory is aligned on a page boundary. 说了这么多，接下来我们看一下例子，如下代码示例： 123456789101112131415161718192021222324252627// 对其分配内存，这个时候pchar值是随机的垃圾值char *pchar = (char *)malloc(16);// 手动初始化pchar的值，下面的方法则不需要memset(pchar, 0, 16);// calloc分配内存，会自动设置为0，不需要memsetchar *pchar_orig = (char *)calloc(12, sizeof(char));// 在原内存基础上，在堆内存空间中连续增加内存// 如果原内存没有连续空间可拓展，realloc会新分配一个空间，将原有内存copy到新空间，然后释放原内存 // 注意：realloc和malloc，只分配内存不进行赋值操作char *pchar_dest = (char *)realloc(pchar_orig, 10); // 相当于 malloc(60)char *pchar_ini = (char *)realloc(NULL, 60);free(pchar);pchar = NULL;free(pchar_orig);pchar_orig = NULL;free(pchar_dest);pchar_dest = NULL;free(pchar_ini);pchar_ini = NULL; glibc 与 libc上面说过这些内存管理函数都在头文件 stdlib.h 中，函数实现都在 malloc.c 文件中，这些都可以在 glibc 中找到对应的代码，我下载的 glibc 是 2.29 这个版本。 libc 是 Stantard C Library 的简称，它是符合ANSI C标准的一个标准函数库。libc库提供C语言中所使用的宏，类型的定义，字符串操作符，数学计算函数以及输入输出函数等。正如ANSI C是C语言的标准一样，libc只是一个函数库标准，每个操作系统都会按照该标准对标准库进行具体实现。通常我们所说的libc是特指某个操作系统的标准库，比如：在Linux操作系统下所说的libc即glibc。glibc是类Unix操作系统中使用最广泛的libc库，它的全称是GNU C Library. glibc是 Linux 下的 C 函数库。libc 库是Linux下的ANSI C的函数库也泛指一切符合C规范的库，glibc 是Linux下的GNU C函数库，是一种 libc 的实现。glibc 本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准C库。Linux下面的标准C库不仅有这一个，如 uclibc、klibc，但是 glibc 无疑是用得最多的，用 glibc 作为系统的C函式库，是GNU/Linux演进的一个重要里程碑，可以查看 维基百科 对 glibc 的介绍。 还有比如Android的Bionic库也是一种libc的实现，只是在Android上面使用罢了。Bionic是Google为Android操作系统提供的BSD标准C库的衍生库，专门为移动计算而精心设计的，针对移动设备上有限的CPU周期和可用内存进行了裁剪以提高工作效率。 这里也说一下基本的C语言函数库，这个库可以根据头文件划分为 15 个部分，其中包括： 文件 assert.h：包含宏和信息，用于进行诊断，帮助程序调试； 文件 ctype.h：包含用来测试某个特征字符的函数的函数原型，以及用来转换大小写字母的函数原型； 文件 errno.h：定义用来报告错误条件的宏； 文件 float.h：包含系统的浮点数大小限制； 文件 math.h：包含数学库函数的函数原型； 文件 stddef.h：包含执行某些计算 C 所用的常见的函数定义； 文件 stdio.h：包含标准输入输出库函数的函数原型，以及他们所用的信息； 文件 stdlib.h：包含数字转换到文本，以及文本转换到数字的函数原型，还有内存分配、随机数字以及其他实用函数的函数原型； 文件 string.h：包含字符串处理函数的函数原型； 文件 time.h：包含时间和日期操作的函数原型和类型； 文件 stdarg.h：包含函数原型和宏，用于处理未知数值和类型的函数的参数列表； 文件 signal.h：包含函数原型和宏，用于处理程序执行期间可能出现的各种条件； 文件 setjmp.h：包含可以绕过一般函数调用并返回序列的函数的原型，即非局部跳转； 文件 locale.h：包含函数原型和其他信息，使程序可以针对所运行的地区进行修改。地区的表示方法可以使计算机系统处理不同的数据表达约定，如全世界的日期、时间、美元数和大数字； 文件 limits.h：决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值； 在 glibc 库中可以找到 malloc.c 文件(路径是 glibc-2.29/malloc/malloc.c )，从中可以看到如下别名的定义： 1234567891011strong_alias (__libc_calloc, __calloc) weak_alias (__libc_calloc, calloc)strong_alias (__libc_free, __free) strong_alias (__libc_free, free)strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)strong_alias (__libc_memalign, __memalign)weak_alias (__libc_memalign, memalign)strong_alias (__libc_realloc, __realloc) strong_alias (__libc_realloc, realloc)strong_alias (__libc_valloc, __valloc) weak_alias (__libc_valloc, valloc)strong_alias (__libc_pvalloc, __pvalloc) weak_alias (__libc_pvalloc, pvalloc)strong_alias (__libc_mallinfo, __mallinfo)weak_alias (__libc_mallinfo, mallinfo)strong_alias (__libc_mallopt, __mallopt) weak_alias (__libc_mallopt, mallopt) __malloc 是 __libc_malloc 的别名，malloc 也是 __libc_malloc 的别名。其他以此类推。 所以看 malloc 函数的源码，直接看 __libc_realloc 函数实现即可，看 free 的源码可以看 __libc_free 的实现。 12void *__libc_realloc (void *oldmem, size_t bytes) 也可以在线查看 glibc 的源码，点击 这里 前往欣赏！ 以后要是有人问你在哪里可以下载libc的源码，你就可以告诉他libc只是一个标准，不同的平台上面有不同的libc实现，比如glibc，bionic等。 锄禾日当午，汗滴禾下土，五一节快乐~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>malloc free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C实现抽象类]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%94%A8Objective-C%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[插图的花是我上个月发工资当天晚上加班回家的路上从一个老人家那里买的，一枝独秀！ 上周在微信公众号发布的一篇名为 反向代理) 的文章，居然真被微信给封掉了，当时在写的时候我还在想是不是会被微信给封杀掉，真是怕什么来什么，完全符合墨菲定律！那篇文章我就是想给大家分享一下如何设置 Nginx 的反向代理，其中的一些概念可能是因为牵涉到了敏感词汇，本无恶意！ 不说这件事情了，还是回到今天分享的主题上面来吧~ 在软件设计或者架构设计领域，架构师都会跟大家强调对业务一定要抽象，把具体的业务场景抽象为程序实现很考验一个人的编程和思维能力。所以在面向对象的编程中，抽象是一种必备的能力。 设计框架的时候，一般我们都会约定一些协议，各个模块在交互通信中能够遵守和实现这些协议，就可以保证通信的畅通性，就好比大家遵守排队规则一样，一个一个来就不会乱。 协议可以使用接口的形式或者抽象类的形式都可以定义，不同的编程语言有不同的形式。例如，在Java中提供给开发者的有接口 Interface 还有抽象类 Abstract，示例如下： 123456789/** 接口 */interface ISeverListener &#123; public void covertService(String name);&#125;/** 抽象类 */abstract class AbstractServer &#123; protected abstract String destroyService(String serverID);&#125; 在 C++ 中也有抽象类，示例如下： 12345678class Point&#123;protected: int x, y;public: //纯虚函数 virtual void disp()=0;&#125;; 在 Objective-C 中提供了协议 protocol，没有提供抽象类的东西，但是我们可以借助 protocol 模拟实现抽象类。 DownloaderProtocol.h 协议 123456789101112131415#import &lt;Foundation/Foundation.h&gt;@protocol DownloaderProtocol &lt;NSObject&gt;@required- (BOOL)checkDownloader;- (void)startDownload:(id)url;- (void)stopDownload;- (void)deleteAllDownloadFile;@end AbstractDownloader.h 12345678#import &lt;Foundation/Foundation.h&gt;#import "DownloaderProtocol.h"@interface AbstractDownloader : NSObject &lt;DownloaderProtocol&gt;- (void)setDownloadUrl:(NSString *)url;@end AbstractDownloader.m 12345678910111213141516171819202122232425262728293031323334353637383940414243#import "AbstractDownloader.h"#define AbstractMethodNotImplemented() \@throw [NSException exceptionWithName:NSInternalInconsistencyException \reason:[NSString stringWithFormat:@"You must override %@ in a subclass.", NSStringFromSelector(_cmd)] \userInfo:nil]@implementation AbstractDownloader- (instancetype)init&#123; NSAssert(![self isMemberOfClass:[AbstractDownloader class]], @"AbstractDownloader is an abstract class, you should not instantiate it directly."); return [super init];&#125;- (BOOL)checkDownloader&#123; AbstractMethodNotImplemented();&#125;- (void)startDownload:(id)url&#123; AbstractMethodNotImplemented();&#125;- (void)stopDownload&#123; AbstractMethodNotImplemented();&#125;- (void)deleteAllDownloadFile&#123; AbstractMethodNotImplemented();&#125;- (void)setDownloadUrl:(NSString *)url&#123; NSLog(@"AbstractDownloader's url = %@", url);&#125;@end 从上面的代码可以看出AbstractMethodNotImplemented()是模拟抽象类的关键，有了这个宏动议之后，凡是需要继承AbstractDownloader必须要实现对应的方法，否则会报错。ImageDownloader继承 AbstractDownloader 并且实现对应的方法，示例如下： ImageDownloader.h 12345#import "AbstractDownloader.h"@interface ImageDownloader : AbstractDownloader@end ImageDownloader.m 123456789101112131415161718192021222324252627#import "ImageDownloader.h"@implementation ImageDownloader- (BOOL)checkDownloader&#123; NSLog(@"ImageDownloader checkDownloader..."); return YES;&#125;- (void)startDownload:(id)url&#123; NSLog(@"ImageDownloader startDownload...");&#125;- (void)stopDownload&#123; NSLog(@"ImageDownloader stopDownload...");&#125;- (void)deleteAllDownloadFile&#123; NSLog(@"ImageDownloader deleteAllDownloadFile...");&#125;@end 这样做的话，团队相关的开发人员就知道自己继承自 AbstractDownloader 应该做什么了。 这里只是给大家提供一种设计思路，有更好的思路欢迎交流，感谢每一位关注者、阅读者。 一直致力于让开发变得更美好的公众号~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 抽象类 Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu19安装Swift5]]></title>
    <url>%2F2019%2F04%2F20%2FUbuntu19%E5%AE%89%E8%A3%85Swift5%2F</url>
    <content type="text"><![CDATA[内容概要通过实践，分享如何在 Ubuntu19 下面如何安装 Swift5. 安装必备库在使用 apt-get 之前，有必要做一次更新，如下： 1sudo apt-get update 更新完成后，安装对应的库文件，如下： 1sudo apt-get install git cmake ninja-build clang python uuid-dev libicu-dev icu-devtools libbsd-dev libedit-dev libxml2-dev libsqlite3-dev swig libpython-dev libncurses5-dev pkg-config libblocksruntime-dev libcurl4-openssl-dev systemtap-sdt-dev tzdata rsync 然后再安装下面的库，如下： 1sudo apt-get install clang libicu-dev libpython2.7 最后，一定要安装下面的库，执行安装即可。 12sudo apt-get install libtinfo5sudo apt install python-dev 否则会报错： 123/bin/lldb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory/bin/lldb: error while loading shared libraries: libpython2.7.so.1.0: cannot open shared object file: No such file or directory 下载 Swift下载 Swift 源码，使用 wget 下载即可。 1wget https://swift.org/builds/swift-5.0-release/ubuntu1804/swift-5.0-RELEASE/swift-5.0-RELEASE-ubuntu18.04.tar.gz 下载成功后，解压源文件，如下： 1tar zxvf swift-5.0-RELEASE-ubuntu18.04.tar.gz 为了使用方便，可以对解压后的文件重新命名，这里我改为了 swift5.0 1mv swift-5.0-RELEASE-ubuntu18.04 swift5.0 配置环境变量将 swift 对应的加入到环境变量中，编辑 ~/.bashrc 文件即可。 1vim ~/.bashrc 添加下面内容在文件最后，如下： 1export PATH=/home/username/developer/swift_linux/swift5.0/usr/bin:$&#123;PATH&#125; 注意：/home/username/developer/swift_linux/swift5.0/usr/bin 是你自己解压后的目录。 为了验证 Swift 是否安装成功，可以让 ~/.bashrc 文件 立即生效，命令如下： 1source ~/.bashrc 在终端执行以下下面命令： 1swift -version 成功会显示如下信息： 12Swift version 5.0 (swift-5.0-RELEASE)Target: x86_64-unknown-linux-gnu Done. 人生总是在不断的上演着重逢和离别~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>swift linux Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反向代理]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇内容概要不知道大家有没有问过别人，或者是自己偷偷在网上搜过 “什么是正向和反向代理“ 类似的问题，即使问过、搜过是不是也很懵？ 总结一句话，正向代理就是代理客户端的代理服务，反向代理就是代理服务端的代理服务。 那我们今天就来掰扯掰扯这个问题。 VPN 和正向代理小明：“你昨天看了我给你发的YouTube视频链接了吗？超级精彩哟！”。小丽：“哦，那个链接根本打不开呀，看个屁！”，小明失望的看了看小丽。小明：“好吧，肯定是你没有使用 VPN(fanqiang) 软件，怪不得你看不了…”。 相信你也有经历过类似的场景，朋友给了一个需要你拥有VPN服务才能打开的链接，无论你是万兆光纤也好还是亿兆光纤也罢，死活都无法打开。 这里所说的 VPN 就是人们通常所说的正向代理服务器，VPN(虚拟私人网络 Virtual Private Network)，是一种加密通讯技术。VPN 有很多的具体实现，比如 PPTP、L2TP、IPSec 和 openvpn。VPN 不是为了翻墙而生的，他只是一中技术，就好比菜刀本来是用来切菜的道理一样。使用 VPN 来翻墙基本已经作废了，但当大家谈及翻墙的时候说得最多的还是 “你有好用的 VPN 吗？”，所以把 VPN 当成翻墙工具的代名词也情有可原。 如果你有了翻墙软件就可以轻松访问全世界的网站了，特别是程序员，可以在知识的海洋里遨游。简单来说正向代理服务器类似于下面图所示： 反向代理和 Nginx这里可以给大家举个例子，假如你想让电信公司给你安装宽带或者网络电视，这个时候你可能需要打电话咨询一下相关的内容，于是你拿起了手机给电信公司打电话，经过一番复杂操作后终于可以等待人工服务了。电信的人工客服人员有很多，系统会根据一定的规则给你分配一个人，接下来可能是美眉也可能是汉子为你服务，究竟是谁给你提供语音服务取决与系统的分配，而不是你可以决定的。 系统分配和调度的功能就类似于反向代理服务器，对用户来说没有感知。类似于下面图所示： 在软件设计中，服务端开发经常会用到反向代理服务器，比如 Nginx、Apache 等，它们经常也被用作为 WEB 服务器，Nginx 被当做代理服务器比较多，所谓的代理服务器是架设在 WEB 服务器和网络中断(比如手机客户端)之间的服务器，换句话说，Nginx 提供了反向代理服务的能力。 由于 Nginx 和 Apache 各自的优势，现在很多开发者选择让两者在服务器中共存。在服务器端让 Nginx 在前 Apache 在后，由 Nginx 做负载均衡和反向代理，并且处理静态文件，将动态请求交给 Apache 去处理。 下图是一个典型的 Nginx 作为反向代理服务器部署 ELK 的架构图，如下： 用 Nginx 的反向代理，用户可以从外部访问到 Kibana，并且它本身具有负载均衡的作用，也能够提高了其性能。 再看一个微服务架构中的架构图（在网关前面也部署了 Nginx），如下图所示： 关于 Nginx 作为负载均衡器的配置和实例，下一次跟大家分享。你现在只需要聚焦在 Nginx 作为反向代理服务器上面的功能即可。 Nginx 配置反向代理Nginx 本身已经提供了反向代理服务的能力，下面我们结合实例给大家分享一下，假设你本机已经安装了 Nginx 并且会基本的操作命令。 1、启动 Nginx 1sudo nginx 在浏览器打开 http://localhost:80，确保 Nginx 启动成功。 2、配置 host 我们配置一下本机的 host，vim 编辑即可。 1sudo vim /etc/hosts 增加下面一行： 1127.0.0.1 www.ithome.com 在浏览器打开 http://www.ithome.com:80，跟刚才显示一样的WEB 界面。 3、配置 Nginx 编辑 Nginx 配置，如下： 1sudo vim /usr/local/etc/nginx/nginx.conf 在 http { 节点下增加下面内容： 12345678910111213141516server &#123; # 监听80端口号 listen 80; # 监听访问的域名 server_name www.ithome.com; # 根据访问路径配置 location / &#123; # 设置 http 版本 proxy_http_version 1.1; proxy_set_header Connection ""; # 把请求转发到 https://www.baidu.com proxy_pass https://www.baidu.com; &#125;&#125; 重新启动 Nginx，重新加载配置文件，操作命令如下： 1sudo nginx -s reload 在浏览器打开 http://www.ithome.com:80，此时打开的是百度首页。至此，简单的配置 Nginx 作为反向代理服务器的功能已经完成，当然想配置好 Nginx 还需要大家多去实践和看官方技术手册。 proxy_pass 默认使用的是 http 1.0，可以通过 proxy_http_version指令让它使用 http 1.1，以便开启 keepalive 之类的功能。官方说明 如下： 123Sets the HTTP protocol version for proxying. By default, version 1.0 is used. Version 1.1 is recommended for use with keepalive connections and NTLM authentication. 附录：Nginx 命令1、查看 nginx 的配置信息 1nginx -V 注意：是大写字母 V。 2、查看 nginx 版本信息 1nginx -v 3、启动 nginx 1sudo nginx 4、查看 nginx 进程 1ps -ef|grep nginx 5、重启 nginx 1234567nginx -s reload``` **6、完美停止 nginx**```shkill -QUIT `cat /var/run/nginx.pid` 7、快速停止 nginx 1kill -TERM `cat /var/run/nginx.pid` 或者 1kill -INT `cat /var/run/nginx.pid` 8、完美停止工作进程，主要用于平滑升级 1kill -WINCH `cat /var/run/nginx.pid` 9、强制停止 nginx 1pkill -9 nginx 10、检查 nginx.conf 修改是否正确 1nginx -t 11、停止 nginx 的命令 1nginx -s stop 不经历风雨怎么见彩虹，没有人能够随随便便成功~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Nginx VPN 代理服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 自动装箱、拆箱引起的耗时]]></title>
    <url>%2F2019%2F04%2F07%2FJava-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E6%8B%86%E7%AE%B1%E5%BC%95%E8%B5%B7%E7%9A%84%E8%80%97%E6%97%B6%2F</url>
    <content type="text"><![CDATA[耗时问题在说 Java 的自动装箱和自动拆箱之前，我们先看一个例子。 这个错误我在项目中犯过(尴尬)，拿出来共勉！ 12345678910111213141516private static long getCounterResult() &#123; Long sum = 0L; final int length = Integer.MAX_VALUE; for (int i = 0; i &lt; length; i++) &#123; sum += i; &#125; return sum;&#125;public static void main(String[] args) &#123; long startCountTime = System.currentTimeMillis(); long result = getCounterResult(); long endCountTime = System.currentTimeMillis(); System.out.println("result = " + result + ", and take up time : " + (endCountTime - startCountTime) / 1000 + "s");&#125; 在我的电脑(macOS 64位系统，配置较高)，打印结果如下： 1result = 2305843005992468481, and take up time : 12s 居然使用了 12s，是可忍叔不可忍，再正常不过的代码怎么会耗时这么久呢？如果在配置差一点的电脑上运行耗时会更久(惊呆了.jpg)。 我们不妨先阅读下面的内容，再来分析、解决上述耗时的问题。 基本概念 自从 jdk1.5 之后就有了自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)。 自动装箱，就是 Java 自动将原始(基本)类型转换成对应的封装器(对象)类型的过程，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱。 自动拆箱，就是 Java 自动将封装器(对象)类型转换成基本类型的过程，如将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。 之所以称之为自动装箱和拆箱，是因为这些操作并非人工(程序猿)操作的，而是 Java 自带的一个特性。 下表是 Java 中的基本类型和对应的封装类型的对应表： 基本类型 封装器类 int Integer byte Byte long Long float float double Double char Character boolean Boolean 自动装箱示例： 12int a = 3;Integer b = a; 自动拆箱示例： 12Integer b = new Integer(7);int a = b; Integer/int 自动拆箱和装箱下面这段代码是 Integer 的源码中 valueOf 方法。 1234567891011121314151617181920212223/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; // 如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; // 否则返回 new 一个Integer 对象 return new Integer(i);&#125; 我们在执行下面的这句代码，如下： 1Integer i = 100; 上面的代码等同于下面的代码： 1Integer i = Integer.valueOf(100); 结合上面的源码可以看出来，如果数值在 [-128，127] 之间(双闭区间)，不会重新创建 Integer 对象，而是从缓存中(常量池)直接获取，从常量池中获取而不是堆栈操作，读取数据要快很多。 我们再来看一下常见的基础面试题(请给出打印结果)，如下: 123456789101112131415161718192021public static void main(String[] args) &#123; // ⓵ Integer a = new Integer(121); Integer b = new Integer(121); System.out.println(a == b); // ⓶ Integer c = 121; Integer d = 121; System.out.println(c == d); // ⓷ Integer e = 129; Integer f = 129; System.out.println(e == f); // ⓸ int g = 50; Integer h = new Integer(50); System.out.println(g == h);&#125; 分析结果： ⓵: false, 两个对象进行比较分别指向了不同堆内存⓶: true, 自动装箱且数值在 [-128，127] 之间(双闭区间)⓷: false, 自动装箱且数值不在 [-128，127] 之间(双闭区间)⓸: true, 自动拆箱且数值在 [-128，127] 之间(双闭区间) 解析耗时问题类 Long 对应的也有一个 valueof 方法，源码如下： 1234567public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125; 这个和 Integer 的很像，道理上面说过，这里不再赘述。 在开篇的例子中，getCounterResult 方法有下面这句代码，如下： 1Long sum = 0L; 很明显我们声明了一个 Long 的对象 sum，由于自动装箱，这句代码并没有语法上面的错误，编译器当然也不会报错。上面代码等同于如下代码： 1Long sum = Long.valueof(0); 在 for 循环中，超过 [-128，127] 就会创建新的对象，这样不断的创建对象，不停的申请堆内存，程序执行自然也就比较耗时了。 修改一下代码，如下： 1234567891011121314151617private static long getCounterResult() &#123; // 修改为普通的基本类型数据 long sum = 0L; final int length = Integer.MAX_VALUE; for (int i = 0; i &lt; length; i++) &#123; sum += i; &#125; return sum;&#125;public static void main(String[] args) &#123; long startCountTime = System.currentTimeMillis(); long result = getCounterResult(); long endCountTime = System.currentTimeMillis(); System.out.println("result = " + result + ", and take up time : " + (endCountTime - startCountTime) / 1000 + "s");&#125; 执行时间大大缩短。 优柔寡断，是人生最大的负能量。对，别犹豫了赶紧扫码关注~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自动拆箱 自动装箱 autoboxing unboxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dumpdecrypted 砸壳：导出头文件]]></title>
    <url>%2F2019%2F04%2F07%2Fdumpdecrypted-%E7%A0%B8%E5%A3%B3%EF%BC%9A%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[导出头文件在 iOS 逆向: dumpdecrypted 砸壳记中已经给大家分享了对 ipa 文件如何砸壳了， 接下来就可以导出其头文件了。 这里需要用到 class-dump 工具。如果你使用 class-dump, 出现如下错误： 1Error: Cannot find offset for address 0xxxxxxxxx in stringAtAddress 报这种错误说明你即将 dump 的文件是 OC 和 Swift 混编的项目，class-dump 这个工具对它们无能为力。 还好, 伟大的程序员们给我们解决了这个问题。 去获取 class-dump 改进版 源码, 然后使用 Xcode 编译即可. 编译完成后生成的 class-dump 就可以拿来使用了. 改变其可执行的权限: 1234567chmod +x class-dump``` 查看 decrypted 文件的 arm 架构:```shclass-dump --list portkey-prod.decrypted 显示为：arm64 开始 dump: 123mkdir portkey-headerclass-dump -H portkey-prod.decrypted -o portkey-header/ 遇到问题dumpdecrypted 砸壳出现了问题, 错误信息如下: 12dyld: could not load inserted library 'dumpdecrypted.dylib' because no suitable image found. Did find:dumpdecrypted.dylib: required code signature missing for 'dumpdecrypted.dylib' 解决方案, 重新签名 dumpdecrypted 后将其拷贝到 Documents 目录. 12345## 列出可签名证书, 找到 mac 上面已经安装的证书security find-identity -v -p codesigning## 为 dumpecrypted.dylib 签名codesign --force --verify --verbose --sign "iPhone Developer: xxx xxxx (xxxxxxxxxx)" dumpdecrypted.dylib 注意：iPhone Developer: xxx xxxx (xxxxxxxxxx) 为你自己本机安装的开发者证书名称. 看到的工具 class-dump-swift 针对 Swift 的工具。这个需要自己先编译 llvm，然后才能使用. dumpdecrypted, 比较自动化的一个版本，但我使用这个没有砸壳成功(估计是需要针对这个文件进行签名)。 Clutch 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 一个神奇的二维码~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oh-my-zsh 配置]]></title>
    <url>%2F2019%2F04%2F03%2Foh-my-zsh-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[喜欢使用终端的朋友都知道在 linux、macOS 上面默认使用的是 bash shell，虽然 bash 比较强大，但是比起 zsh 还是稍逊一筹。zsh 虽然好用但配置比较复杂，于是乎 oh-my-zsh 就诞生了，它统一管理 zsh 的配置。 macOS 上面安装 oh-my-zsh 后，感觉敲命令更爽了，特别是在进行 git 操作的时候，很方便。 安装比较简单，可以在终端通过 curl 也可以通过 wget 方式，安装方法如下。 1、通过 curl 方式 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 2、通过 wget 方式 1sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" oh-my-zsh 支持 linux、macOS 和 windows，但是在 linux 和 macOS 上面支持最好。 安装成功后，原来在系统 shell 配置的环境变量需要让 oh-my-zsh 知道，配置一下 ~/.zshrc 文件，在该文件中的 User configuration 下面增加下面两行配置就可以了。 12source ~/.bash_profilesource /etc/profile 配置完成后保存文件，在终端执行： 1source ~/.zshrc 这样之前配置的环境变量在 oh-my-zsh 下就生效了。 oh-my-zsh 支持三方插件和主题配置，默认的配置已经够用了，有兴趣的可以自行探索。 工欲善其事必先利其器]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>zsh git tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Follow your heart]]></title>
    <url>%2F2019%2F03%2F24%2FFollow-your-heart%2F</url>
    <content type="text"><![CDATA[今天不聊技术，聊聊人生~ 最近天气像疯了一样，气温反复无常，时冷时热，让人有点应接不暇。 正好刚搬完家，家里很多东西需要购买，首先考虑的是给自己买对舒服的桌椅。实体店里面的桌椅实在是贵的离谱，动辄告诉我说是实木哟，现在低价处理之类的，还好我不是很傻。最后索性就在网上购买了，性价比也比较高，我也算是来了一把沉浸式的疯狂购物体验。 现在物流服务很是贴心，关注对应的公众号就可以及时告诉你当前物流的进度。相比之前，无论是送货速度还是服务都有显著提升，主要是实惠。 网上淘的这个桌子比较重，要想自己把这个桌子弄到家还是相当费劲的。快递员看出了我的窘境，说：“我这个推车反正现在也闲着，你先拿去用吧！”，我连忙道谢，有了这个推车搬起来就容易多了。 不到十分钟的时间，我就把货送到家了。心理一直想别人也许这会需要急着用车，就赶紧下楼，走到楼下拐角的时候，突然被一个人喊住，我回头一看是一个陌生的快递员。 他语调比较高：“喂，先生，你那个车子放到我这里就可以了，是我们的！”。我瞄了他一眼，说道：“你是哪个快递公司的，我不是从你手上拿的车呀！”，这哥们依旧强势：“我是xx快递，这车就是我们的。”。 我心想这两个快递员是不是认识，这个车子原本就是眼前这个气势汹汹的人的？ 心理正在犯着嘀咕，决定还是要物归原主。 我没有再理他，继续朝着原来收快递的地方走去，把车还给了主人。我顺便问道：“刚才有个xx快递的小哥说车子是他的？”，他说：“可能是他看错了，你看这车子上面有我们公司的标记呢”。我仔细一看果然是，庆幸自己没有把车交给别人。 人生中，仿佛也有很多类似上面的场景，假如你遇到了会怎么处理呢？ 就拿婚姻来说，你认定的自己的另一半就是这辈子要娶或者要嫁的那个人，但是你身边的朋友或者家人并不看好你们，甚至他们压根不承认你的另一半，你又会怎么办？ 我觉得遇到这样的事情，要听从自己的内心(Follow your heart)，不要因为别人的三言两语，你就轻易放弃当初的选择，而应该更加理性的做出判断，相信自己的判断不会错，只有这样你才不会后悔，至少爱过。 学习、工作和生活也是一样，既定了目标就应该勇往直前，在路上遇到的任何困难那是再正常不过的，别人的冷嘲热讽也好，打击刺激也罢，你要做的就是坚守你自己的内心，一帆风顺得到的幸福终究会昙花一现。 ~ 充满酸甜苦辣的人生才值得回味，不是吗？ 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 枚举的本质]]></title>
    <url>%2F2019%2F03%2F16%2FJava-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[概要本文跟大家一起探讨一下 Java 枚举的本质，这篇文章的内容是我在 2012年09月05日 发布到 CSDN 上面的一篇博文 Java 枚举：理解枚举本质，虽然已经不在 CSDN 上面耕耘了，但偶尔也会去看看朋友们的留言，毕竟感情在那里！今天偶然看到有小伙伴评论这篇文章，一时兴起就想再次分享给大家。 学习编程语言，会用只是最基本的要求，了解和熟悉其实现、运行机制才使得你有别于常人！ C 枚举在 C 语言中，可以这样来定义枚举，如下示例： 123enum color &#123; RED=0, GREEN, BLUE, YELLOW&#125; col; 关键字 enum 定义枚举，在定义枚举的同时，声明该枚举变量 col. 注意：C 语言中枚举成员的值是根据上下文自动加 1 的（GREEN = 1，BLUE = 2 等）。 C 语言中 switch 语句支持枚举类型，如下示例： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main() &#123; enum color &#123; RED=0, GREEN, BLUE, YELLOW &#125; col; int cl; printf("0=red, 1=green, 2=blue, 3=yellow. seclect:\n"); scanf("%d",&amp;cl); col=(enum color) cl; switch(col) &#123; case RED: printf("the color is red\n"); break; case GREEN: printf("the color is green\n"); break; case BLUE: printf("the color is blue\n"); break; case YELLOW: printf("the color is yellow\n"); break; defalut: printf("no this color\n"); break; &#125; return 0;&#125; Java 枚举那么，Java 里面的枚举与其类似，但是又不是完全一样。Java 语言中定义枚举也是使用 enum 关键字，如下示例是 Java 语言的枚举： 123public enum Color &#123; RED, GREEN, BLUE, YELLOW;&#125; 上述定义了一个枚举类型 Color（可以说是类，编译之后是 Color.class）. 上面的定义，还可以改成下面的这种形式: 123public enum Color &#123; RED(), GREEN(), BLUE(), YELLOW();&#125; 到这里你可能会觉得迷茫（如果你是初学者的话），为什么这样子也可以，why？ 其实，枚举的成员就是枚举对象，只不过它们是静态常量而已。 使用 javap 命令（javap 文件名&lt;没有后缀.class&gt;）可以反编译 class 文件，如下：​​​​ 我们可以使用普通类来模拟枚举，下面定义一个 Color 类，如下： 123456public class Color &#123; private static final Color RED = new Color(); private static final Color GREEN = new Color(); private static final Color BLUE = new Color(); private static final Color YELLOW = new Color();&#125; 结合上图反编译的结果，做一下对比，你是否看出了一点端倪（坏笑），如果没有看出来，那就接着往下看吧。 如果按照这个逻辑，是否还可以为其添加另外的构造方法？答案是肯定的！ 123456789101112public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); Color(String name, int id) &#123; _name = name; _id = id; &#125; String _name; int _id;&#125; 为 Color 声明了两个成员变量，并为其构造带参数的构造器。 如果你这样创建一个枚举: 1234public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3);&#125; 编译器就会报错: 1The constructor EnumDemo.Color(String, int) is undefined 到此，你应该看明白了，枚举和普通的 Java 类很像。 对于类来讲，最好将其成员变量私有化，并且为成员变量提供 get、set 方法。 按照这个原则，可以进一步写好 enum Color，如下示例： 12345678910111213141516171819202122232425262728public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); Color(String name, int id) &#123; _name = name; _id = id; &#125; private String _name; private int _id; public void setName(String name) &#123; _name = name; &#125; public void setId(int id) &#123; _id = id; &#125; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125;&#125; 但是 Java 设计枚举的目的是提供一组常量，方便开发者使用。如果我们冒然的提供 set 方法（外界可以改变其成员属性），好像有点违背了设计的初衷。 那么，我们应该舍弃 set 方法，保留 get 方法。 1234567891011121314151617181920public enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); Color(String name, int id) &#123; _name = name; _id = id; &#125; private String _name; private int _id; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125;&#125; 对于普通的基本类可以将其实例化，那么，能否实例化枚举呢？ 在回答这个问题之前，先来看看 Color.class 文件: 1234567891011121314151617181920public static enum Color &#123; RED("red color", 0), GREEN("green color", 1), BLUE("blue color", 2), YELLOW("yellow color", 3); private String _name; private int _id; private Color(String name, int id) &#123; this._name = name; this._id = id; &#125; public String getName() &#123; return this._name; &#125; public int getId() &#123; return this._id; &#125;&#125; 可以看出，编译器淘气的为其构造方法加上了 private，那么也就是说，我们无法实例化枚举。 所有枚举类都继承了 Enum 类的方法，包括 toString、equals、hashcode 等方法。因为 equals、hashcode 方法是 final 的，所以不可以被枚举重写（只可以继承），但可以重写 toString 方法。 文末的附录中提供了 Enum 的源码，有兴趣可以查看阅读！ 那么，使用 Java 的类来模拟一下枚举，大概是这个样子： 1234567891011121314151617181920212223242526272829303132333435363738394041package mark.demo;import java.util.ArrayList;import java.util.List;public class Color &#123; private static final Color RED = new Color("red color", 0); private static final Color GREEN = new Color("green color", 1); private static final Color BLUE = new Color("blue color", 2); private static final Color YELLOW = new Color("yellow color", 3); private final String _name; private final int _id; private Color(String name, int id) &#123; _name = name; _id = id; &#125; public String getName() &#123; return _name; &#125; public int getId() &#123; return _id; &#125; public static List&lt;Color&gt; values() &#123; List&lt;Color&gt; list = new ArrayList&lt;Color&gt;(); list.add(RED); list.add(GREEN); list.add(BLUE); list.add(YELLOW); return list; &#125; @Override public String toString() &#123; return "the color _name=" + _name + ", _id=" + _id; &#125;&#125; 附录Enum.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package java.lang;import java.io.Serializable;import java.io.IOException;import java.io.InvalidObjectException;import java.io.ObjectInputStream;import java.io.ObjectStreamException;/** * This is the common base class of all Java language enumeration types. * * @author Josh Bloch * @author Neal Gafter * @version %I%, %G% * @since 1.5 */public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; /** * The name of this enum constant, as declared in the enum declaration. * Most programmers should use the &#123;@link #toString&#125; method rather than * accessing this field. */ private final String name; /** * Returns the name of this enum constant, exactly as declared in its * enum declaration. * * &lt;b&gt;Most programmers should use the &#123;@link #toString&#125; method in * preference to this one, as the toString method may return * a more user-friendly name.&lt;/b&gt; This method is designed primarily for * use in specialized situations where correctness depends on getting the * exact name, which will not vary from release to release. * * @return the name of this enum constant */ public final String name() &#123; return name; &#125; /** * The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this field. It is designed * for use by sophisticated enum-based data structures, such as * &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. */ private final int ordinal; /** * Returns the ordinal of this enumeration constant (its position * in its enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this method. It is * designed for use by sophisticated enum-based data structures, such * as &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. * * @return the ordinal of this enumeration constant */ public final int ordinal() &#123; return ordinal; &#125; /** * Sole constructor. Programmers cannot invoke this constructor. * It is for use by code emitted by the compiler in response to * enum type declarations. * * @param name - The name of this enum constant, which is the identifier * used to declare it. * @param ordinal - The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). */ protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125; /** * Returns the name of this enum constant, as contained in the * declaration. This method may be overridden, though it typically * isn't necessary or desirable. An enum type should override this * method when a more "programmer-friendly" string form exists. * * @return the name of this enum constant */ public String toString() &#123; return name; &#125; /** * Returns true if the specified object is equal to this * enum constant. * * @param other the object to be compared for equality with this object. * @return true if the specified object is equal to this * enum constant. */ public final boolean equals(Object other) &#123; return this==other; &#125; /** * Returns a hash code for this enum constant. * * @return a hash code for this enum constant. */ public final int hashCode() &#123; return super.hashCode(); &#125; /** * Throws CloneNotSupportedException. This guarantees that enums * are never cloned, which is necessary to preserve their "singleton" * status. * * @return (never returns) */ protected final Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException(); &#125; /** * Compares this enum with the specified object for order. Returns a * negative integer, zero, or a positive integer as this object is less * than, equal to, or greater than the specified object. * * Enum constants are only comparable to other enum constants of the * same enum type. The natural order implemented by this * method is the order in which the constants are declared. */ public final int compareTo(E o) &#123; Enum other = (Enum)o; Enum self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; &#125; /** * Returns the Class object corresponding to this enum constant's * enum type. Two enum constants e1 and e2 are of the * same enum type if and only if * e1.getDeclaringClass() == e2.getDeclaringClass(). * (The value returned by this method may differ from the one returned * by the &#123;@link Object#getClass&#125; method for enum constants with * constant-specific class bodies.) * * @return the Class object corresponding to this enum constant's * enum type */ public final Class&lt;E&gt; getDeclaringClass() &#123; Class clazz = getClass(); Class zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? clazz : zuper; &#125; /** * Returns the enum constant of the specified enum type with the * specified name. The name must match exactly an identifier used * to declare an enum constant in this type. (Extraneous whitespace * characters are not permitted.) * * @param enumType the &lt;tt&gt;Class&lt;/tt&gt; object of the enum type from which * to return a constant * @param name the name of the constant to return * @return the enum constant of the specified enum type with the * specified name * @throws IllegalArgumentException if the specified enum type has * no constant with the specified name, or the specified * class object does not represent an enum type * @throws NullPointerException if &lt;tt&gt;enumType&lt;/tt&gt; or &lt;tt&gt;name&lt;/tt&gt; * is null * @since 1.5 */ public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException("Name is null"); throw new IllegalArgumentException( "No enum const " + enumType +"." + name); &#125; /** * prevent default deserialization */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125; private void readObjectNoData() throws ObjectStreamException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125; /** * enum classes cannot have finalize methods. */ protected final void finalize() &#123; &#125;&#125; 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>macOS java enum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json-c]]></title>
    <url>%2F2019%2F03%2F10%2Fjson-c%2F</url>
    <content type="text"><![CDATA[简介json-c 是 C 语言写的一套构建和解析 JSON 的库。 12JSON-C implements a reference counting object model that allows you to easily construct JSON objects in C, output them as JSON formatted strings and parse JSON formatted strings back into the C representation of JSON objects. It aims to conform to RFC 7159. 使用 C 语言编写的 JSON 库还有很多，可以在 介绍 JSON 中查找到，除了 C语言的还有其他语言编写的 JSON 开源库。 所有发布的 json-c 库版本在 这里 都可以找到，本篇编译的是 json-c-0.13.1-20180305 这个版本。 编译一、下载、解压 直接下载最新版本 json-c-0.13.1-20180305，截止到本文发布该版本为最新版本。 解压刚才下载好的文件，解压后将文件夹重命名为 json-c-src，当然你也可以不重名它。 打开 macOS 终端，进入 json-c-src 文件夹 1cd json-c-src 二、源码编译 在编译之前，确保你已经在 macOS 中安装了下面的工具： 1、gcc, clang, 或者其他 C 编译器；2、libtool 工具，版本不能低于 2.2.6b；3、autoconf 工具，版本不能低于 2.64 (autoreconf)；4、automake工具，版本不能低于 1.13； 如果没有安装上面的工具，可以使用 Homebrew 进行安装。 在桌面新建个文件夹 json-c，这个文件夹用来放待会编译后的文件（库和头文件）。 执行下面的命令开始配置和编译，如下： 12345./configure --prefix=/Users/man/Desktop/json-cmakemake install 注意：/Users/man/Desktop/json-c 要写绝对路径，否则编译报错。 如果要支持多线程，可以加上 --enable-threading 这个选项，即： 12345./configure --enable-threading --prefix=/Users/man/Desktop/json-cmakemake install 编译成功后，在 json-c 会生成对应的库和头文件，如下： 使用 json-c编译成功后，可以试用一下 json-c 这个库了，我把 libjson-c.a 和对应的 include 文件夹放进 macOS 工程，编译无法通过，报错，然后换为 libjson-c.4.dylib 编译通过但是运行报错，意思是无法加载该库。 同样道理，在 iOS 工程上面直接使用这两个库也是无法使用。 于是我就使用 lipo 来查看一下库所支持的架构，看一下下面的结果。 1234567$ lipo -info libjson-c.a Non-fat file: libjson-c.a is architecture: x86_64$ lipo -info libjson-c.4.dylib Non-fat file: libjson-c.4.dylib is architecture: x86_64 可以看出两个库均可以支持 x86_64，按道理是可以支持 macOS 和 iOS 模拟器运行的，macOS 上面可以使用 set | grep &quot;MACHTYPE&quot; 命令查看其操作系统架构。 libjson-c.a 是静态库，libjson-c.4.dylib 是动态库，可以使用 file 命令查看。 1234567$ file libjson-c.a libjson-c.a: current ar archive$ file libjson-c.4.dylib libjson-c.4.dylib: Mach-O 64-bit dynamically linked shared library x86_64 注意：显示 ar archive 表示是静态库。 最后自己没有找到好的办法，只能采取第二个办法，源码直接放进 Xcode 工程里面编译使用。 在放进 Xcode 工程之前，需要将下载的源码进行配置操作，即： 1./configure 这样会产生对应 config.h 等文件，然后将源码中所有 .h 和 .c 的文件拷贝至工程中即可编译使用了。 注意：如果不执行 ./configure 操作，拷贝的源文件不全，无法通过编译。 简单例子，如下： 1234567891011121314151617181920212223#import "ViewController.h"#import "json-c/json.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; json_object *jsonObj = NULL; jsonObj = json_tokener_parse("&#123; \"uid\": 12, \"name\": \"foobar\", \"isComer\": 1, \"age\": 21, \"extras\": [ 11, 52, 3, \"unknow\", 75 ] &#125;"); const char *jsonString = json_object_to_json_string(jsonObj); printf("obj.to_string()=%s\n", jsonString);&#125;@end 对应输出结果，如下： 1obj.to_string()=&#123; &quot;uid&quot;: 12, &quot;name&quot;: &quot;foobar&quot;, &quot;isComer&quot;: 1, &quot;age&quot;: 21, &quot;extras&quot;: [ 11, 52, 3, &quot;unknow&quot;, 75 ] &#125; 疑问Objective-C 已经提供了关于 JSON 的库了，干嘛还折腾 json-c 呢？ 的确，自从 iOS 5.0+，macOS 10.7+ 之后，Foundation 框架已经提供了 NSJSONSerialization，我主要是好奇 json-c 这个库，看他的跨平台能力而已。 关于 NSJSONSerialization 可以查看 API 文档。 本次分享，告辞！ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C json json-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不见得你会计算C字符串长度]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%B8%8D%E8%A7%81%E5%BE%97%E4%BD%A0%E4%BC%9A%E8%AE%A1%E7%AE%97C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[C 字符串在 C 语言中，字符串实际上是使用字符 &#39;\0&#39; 终止的一维字符数组。 以下几种方式表示的都是 C 字符串的正确表达方式。 1234567891011121314// 要以 '\0' 结尾char greeting[6] = &#123;'H', 'e', 'l', 'l', 'o', '\0'&#125;;// 要以 '\0' 结尾char greeting[] = &#123;'H', 'e', 'l', 'l', 'o', '\0'&#125;;// 默认会在末尾增加'\0'char greeting[] = &#123;"Hello"&#125;;// 上面的简写形式char greeting[] = "Hello";// 默认会在末尾增加'\0'char *greeting = "Hello"; 看下面另外一种声明方式： 123char greeting[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;printf("greeting: %s\n", greeting); 输出结果： 1greeting: hello\376 这个结果在不同编译器下面可能还会不一样，总之输出都不是我们想要的结果。这种方式创建的字符串没有 &#39;\0&#39;，不算是真正的 C 字符串，所以建议大家在声明 C 字符串的时候使用字符指针（char *）的方式。 string.h 里面声明了很多关于操作 C 字符串的库函数。 字符串长度这里在说计算字符串长度的前提是字符编码都是按照UTF-8（中文占用3个字节，英文占用1个字节）的编码形式为前提的。我们先来看下面这个例子，如下： 123456789101112char *greeting1 = "hello";char greeting2[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;char greeting3[] = &#123;'h', 'e', 'l', 'l', 'o', '\0'&#125;;char greeting4[] = "hello"; printf("greeting1 sizeOf: %ld, strlen: %ld\n", sizeof(greeting1), strlen(greeting1));printf("greeting2 sizeOf: %ld, strlen: %ld\n", sizeof(greeting2), strlen(greeting2));printf("greeting3 sizeOf: %ld, strlen: %ld\n", sizeof(greeting3), strlen(greeting3));printf("greeting4 sizeOf: %ld, strlen: %ld\n", sizeof(greeting4), strlen(greeting4)); 如果你能说出上面 printf 的结果，基本上关于计算字符串长度的问题就迎刃而解了。 按照 UTF-8 编码，上面例子的输出结果如下所示： 1234greeting1 sizeOf: 8, strlen: 5greeting2 sizeOf: 5, strlen: 7greeting3 sizeOf: 6, strlen: 5greeting4 sizeOf: 6, strlen: 5 如果输出结果令你无法相信，可以选择继续往下看或者你自己写代码试试。 sizeof、strlen在 linux.die 可以查到 strlen 的说明，如下： 123456789Synopsis:#include &lt;string.h&gt;size_t strlen(const char *s);Description:The strlen() function calculates the length of the string s, excluding the terminating null byte (aq\0aq).Return Value:The strlen() function returns the number of bytes in the string s. 函数 strlen 返回字符串里的字符数，不包括终止字符 &#39;\0&#39;，这里注意 strlen 是一个 C 的函数，而 sizeof 只是一个操作符。 我们知道，sizeof 操作符的参数可以是数组、指针、类型、对象、函数等，函数 strlen 的参数只能是字符串。 对于 sizeof， 其参数不同时，其返回的值也不一样，如下： 1、数组：编译时分配的数组空间大小；2、指针：存储该指针所用的空间大小(32位机器上是4，64位机器上是8)；3、类型：该类型所占的空间大小；4、对象：对象的实际占用空间大小(这个指的是在 C++ 中)；5、函数：函数的返回类型所占的空间大小。函数的返回类型不能是 void 类型； 那我们再回头看看上面的例子，我把要说明的写在注释上面了。 1234567891011121314151617181920212223242526// 注意这里是指针char *greeting1 = "hello";// 没有结束符 '\0'，其 strlen 结果不确定char greeting2[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;char greeting3[] = &#123;'h', 'e', 'l', 'l', 'o', '\0'&#125;;char greeting4[] = "hello"; /* 结果是 8、5 *//* greeting1是指针，sizeOf计算的是其存储该指针所用的空间大小，因为我使用的是64位 macOS，所以输出是8 *//*strlen 计算的是字符个数但是不包括结束符 '\0'*/printf("greeting1 sizeOf: %ld, strlen: %ld\n", sizeof(greeting1), strlen(greeting1));/* 结果是 5、7 *//* sizeof 计算的是编译时分配的数组空间大小，这里是5 *//* greeting2没有结束符，strlen 的计算结果不确定 */printf("greeting2 sizeOf: %ld, strlen: %ld\n", sizeof(greeting2), strlen(greeting2));/* 结果是 6、5 *//* sizeof 计算的是编译时分配的数组空间大小，这里是6，因为多了结束符 *//*strlen 计算的是字符个数但是不包括结束符 '\0'*/printf("greeting3 sizeOf: %ld, strlen: %ld\n", sizeof(greeting3), strlen(greeting3));/* 结果是 6、5，这里类似上面的情况，不再赘述 */printf("greeting4 sizeOf: %ld, strlen: %ld\n", sizeof(greeting4), strlen(greeting4)); 小结： 1、sizeof 是一个操作符，而 strlen 是 C 语言的库函数。 2、sizeof 的参数可以是任意数据类型或者表达式，而 strlen 只能以结尾为 &#39;\0&#39; 的字符串作参数。 3、sizeof 的结果在编译时就计算出了，而 strlen 必须在运行时才能计算出来。 4、sizeof 计算数据类型占内存的大小，strlen 计算字符串实际长度，要记住 strlen 计算出来的结果不包括结束符 &#39;\0&#39;。 5、sizeof 反应的并非真实字符串长度而是所占空间大小，所以memset 初始化字符串的时候用 sizeof 较好。 6、系统函数返回值是 char * (字符指针)类型的会在末尾加上结束符 &#39;\0&#39;。 7、无论是 sizeof 还是 strlen 计算结果的单位都是字节。 我们还需要注意一点，strlen 函数，当数组名作为参数传入时，实际上数组就退化成指针了。举个例子，如下图所示： 可以看出传入进来的参数会被退化为指针。 探索无止境在文章的开始，我给出了几种 C 字符串的正确表达方式，那我们再来看另外一种。 1char greeting[4] = "blog"; 这种方式看起来好像很完美的样子，其实是不对的，写个例子给大家，如下： 123456789int main(int argc, const char *argv[])&#123; char greeting[4] = "blog"; size_t len = strlen(greeting); printf("greeting len: %ld\n", len); printf("greeting: %s\n", greeting); return 0;&#125; 编译运行，结果如下： 12greeting len: 10greeting: blog\330\365\277\357\376 苍天呀，这结果让人无语。。。 对于 char greeting[4] = &quot;blog&quot; 其实是定义一个长度为 4 的字符数组，但是字符串 &quot;blog&quot; 实际是要包括结束符 \0 的，也就是说下面的代码 1char greeting[4] = "blog"; 本质和下面代码是一样的，如下： 1char greeting[] = &#123;'b', 'l', 'o', 'g'&#125;; 显然是不正确的，那我们修改一下代码，如下： 12345678910int main(int argc, const char *argv[])&#123; // 注意这里是 5 char greeting[5] = "blog"; size_t len = strlen(greeting); printf("greeting len: %ld\n", len); printf("greeting: %s\n", greeting); return 0;&#125; 或者这样写： 12345678910int main(int argc, const char *argv[])&#123; // 这里干脆不要写数字 char greeting[] = "blog"; size_t len = strlen(greeting); printf("greeting len: %ld\n", len); printf("greeting: %s\n", greeting); return 0;&#125; 这样修改后，再编译运行结果就对了，如下： 12greeting len: 4greeting: blog 我们知道的东西是有限的，我们不知道的东西则是无穷的。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C char strlen sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用 libcurl]]></title>
    <url>%2F2019%2F03%2F03%2FiOS-%E4%BD%BF%E7%94%A8-libcurl%2F</url>
    <content type="text"><![CDATA[libcurl 简介libcurl 是用C语言写的一套 开源 库，是为网络客户端提供数据传输功能的函数库。 libcurl 支持 SMTP、HTTP、HTTPS、FTP、TELNET 等协议和各种 SSL 安全认证，支持 Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS 等平台，在 Android 和 iOS 上面也可以使用 libcurl 这个库。 下面是官网的英文简介： 123456libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!libcurl is highly portable, it builds and works identically on numerous platforms, including Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS and more...libcurl is free, thread-safe, IPv6 compatible, feature rich, well supported, fast, thoroughly documented and is already used by many known, big and successful companies. 分享内容今天跟大家分享 libcurl 在 iOS 上面如何使用，主要分享内容如下： 1、iOS 工程集成 libcurl以及集成注意事项。2、利用 libcurl 发送 HTTP GET 和 POST 请求。3、使用 springboot 搭建本地服务，这个只是为了演示不是分享的重点。 搭建本地服务本地服务采用 Spring Boot 开发，开发语言是 Java，JDK 版本1.8，Spring Boot 版本是 v2.1.3.RELEASE，集成 Web 组件即可，比较简单。关于如何搭建 Spring Boot的开发环境，大家自行搜索解决，也可以直接使用我的 git 工程，猛戳前往 即可获取完整代码示例。 工程结构如下图所示： 关键代码如下： 该工程只是为了配合 libcurl 的使用而诞生的，没有什么难度。 集成 libcurl1、新建 iOS 工程 这里工程为 tutorial_libcurl_iOS。 2、准备库文件、头文件 libcurl 可以自己编译，也可以使用别人编译好的二进制文件。我使用的是 curl-android-ios 这个工程里面编译好的文件。 3、给工程 tutorial_libcurl_iOS 添加库和头文件 将上面的文件拷贝至工程目录即可，现在工程目录如下： 4、设置路径 在 xcode 中 Building Settings 找到 User Header Search Paths 为如下内容： 1$(SRCROOT)/tutorial_libcurl_iOS/Classes 这一步不是必须的，我个人比较喜欢这样整理和设置目录。 5、添加 libz.tbd 如果不添加这个库，编译无法通过，会显示如下错误： 发送 HTTP 请求下面说一下如何使用 libcurl 来发送 HTTP 的 GET 和 POST 请求。只给出核心示例代码，其余的大家去 tutorial_libcurl 获取完整示例代码，包括 Spring Boot 的。 ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#import "ViewController.h"#import "curl/curl.h"// 我本机的 IP 和端口，实际你要换成你自己的#define HOST_URL @"http://172.20.10.2:8080/user"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad];&#125;- (IBAction)doHTTPGETToFileAction:(id)sender&#123; NSString *reqUrl = [NSString stringWithFormat:@"%@%@", HOST_URL, @"?id=1&amp;name=veryitman"]; const char *url = [reqUrl cStringUsingEncoding:NSUTF8StringEncoding]; http_get_req(url);&#125;- (IBAction)doHTTPPOSTToFileAction:(id)sender&#123; const char *url = [HOST_URL cStringUsingEncoding:NSUTF8StringEncoding]; const char *data = "id=2&amp;name=veryitman"; http_post_req(url, data);&#125;#pragma mark - Cvoid http_get_req(const char *url)&#123; CURL *curl; const char *fpath = rspDataPath(@"http_get_rsp_data.log"); FILE *fp; fp = fopen(fpath, "wt+"); struct curl_slist *headers = NULL; //增加HTTP header headers = curl_slist_append(headers, "Accept:application/json"); headers = curl_slist_append(headers, "Content-Type:application/json"); headers = curl_slist_append(headers, "charset:utf-8"); //初始化 curl = curl_easy_init(); if (curl) &#123; //改协议头 curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_POST, url); //wt+：读写打开或着建立一个文本文件；允许读写 if (NULL != fp) &#123; // 请求结果写入到文件当中 curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); &#125; CURLcode rsp_code = curl_easy_perform(curl); if (CURLE_OK == rsp_code) &#123; NSLog(@"请求返回成功"); &#125; else &#123; NSLog(@"请求返回失败，返回码是 %i", rsp_code); &#125; curl_slist_free_all(headers); curl_easy_cleanup(curl); &#125; fclose(fp);&#125;void http_post_req(const char *url, const char *req_data)&#123; const char *fpath = rspDataPath(@"http_post_rsp_data.log"); FILE *fp; fp = fopen(fpath, "wt+"); CURL *curl; curl = curl_easy_init(); if (curl) &#123; curl_easy_setopt(curl, CURLOPT_URL, url); NSLog(@"length: %ld", strlen(req_data)); /* size of the POST data */ curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(req_data) + 1); /* pass in a pointer to the data - libcurl will not copy */ curl_easy_setopt(curl, CURLOPT_POSTFIELDS, req_data); if (NULL != fp) &#123; // 请求结果写入到文件当中 curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); &#125; CURLcode rsp_code = curl_easy_perform(curl); if (CURLE_OK == rsp_code) &#123; NSLog(@"请求返回成功"); &#125; else &#123; NSLog(@"请求返回失败，返回码是 %i", rsp_code); &#125; curl_easy_cleanup(curl); &#125; fclose(fp);&#125;@end 启动 Spring Boot 项目，启动成功后，再运行 xcode 工程，可以测试。 点击对应的按钮就可以发送 GET 和 POST 请求了。 请求返回的结果被写入到了沙盒文件中，可以在终端使用 cat 命令查看对应的响应结果。 GET 响应结果： 1cat ~/Library/Developer/CoreSimulator/Devices/BA882AC3-7977-49C7-8B0D-65EFD1541B68/data/Containers/Data/Application/3A21CFC5-3044-4FC0-9BFA-B311A59187AF/Documents/http_get_rsp_data.log 1user info: id=2 name=veryitman POST 响应结果: 1cat ~/Library/Developer/CoreSimulator/Devices/BA882AC3-7977-49C7-8B0D-65EFD1541B68/data/Containers/Data/Application/86E7D457-97B1-4D8C-80D5-E8179B691F76/Documents/http_post_rsp_data.log 1user info: id=2 name=veryitman 后续为大家分享如何使用回调来接收 HTTP 响应数据、其他网络请求的情况以及 Android 上面如何使用 libcurl 库。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>curl libcurl springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emscripten：JS 调用 C、C++]]></title>
    <url>%2F2019%2F03%2F02%2FEmscripten%EF%BC%9AJS-%E8%B0%83%E7%94%A8-C%E3%80%81C%2F</url>
    <content type="text"><![CDATA[在 了解 Emscripten 中，给大家简单分享了 Emscripten 是什么以及其使用场景。今天继续分享如何使用 JS 调用 C/C++ 代码。 神奇的 main 函数下面是 了解 Emscripten 中的例子代码，只有一个 main 函数。 123456#include &lt;stdio.h&gt;int main(int argc, char ** argv) &#123; printf(&quot;Emscripten show in browser...\n&quot;);&#125; 使用 Emscripten SDK 编译后生成了对应的 html、js 和 wasm 文件。 第一次编译会较慢, 编译完成后会在 ~/.emscripten_cache 生成缓存目录和缓存文件, 以后再次编译就比较快了. 可以在火狐或者 Chrome 或者 Safari 上面运行 h_emcc.html 文件. 这里在火狐浏览器上面可以直接打开 mz.html 文件, 如果是在 Chrome 或者 Safari 需要执行下面命令: 1emrun mz.html 或者指定浏览器打开该文件. 1emrun --browser chrome mz.html 关于 emrun 的其他用法，可以使用 emrun --help 来查看。这里在浏览器可以看到对应 main 函数的输出，说明 Emscripten 生成的代码默认会调用 main 函数。 EMSCRIPTEN_KEEPALIVE既然 Emscripten 生成的代码默认会调用 main 函数，那么如果想使用其他函数怎么办呢？ 我们可以在函数前添加 EMSCRIPTEN_KEEPALIVE，它在emscripten.h 文件中有声明，这个可以通过源码查看。 下面还是举个例子来说明。 my.html 123456789101112131415161718&lt;!doctype html&gt;&lt;html lang="en-us"&gt;&lt;!-- 省略... --&gt; &lt;body&gt;document.querySelector('.mybutton').addEventListener('click', function()&#123; alert('检查控制台'); var result = Module.ccall('sum', // name of C function null, // return type null, // argument types null); // arguments &#125;); &lt;/script&gt; &lt;script async type="text/javascript" src="hello3.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 里面引用了 hello3.js 并且使用 Module.ccall 调用了 C 函数 sum。 hello.c 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;emscripten/emscripten.h&gt;int main(int argc, char ** argv) &#123; printf("Hello emcc\n");&#125;#ifdef __cplusplusextern "C" &#123;#endifint EMSCRIPTEN_KEEPALIVE sum() &#123; printf("sum = %i\n", 100); return 1;&#125;#ifdef __cplusplus&#125;#endif 编译 hello.c 1emcc -o hello.html hello.c -O3 -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[&apos;ccall&apos;]&quot; 注意：EXTRA_EXPORTED_RUNTIME_METHODS 设置了 Module 的导出函数，不导出 ccall 的话，会报以下错误: 1&apos;ccall&apos; was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ) 现在可以运行 my.html 1emrun my.html 可以修改一下 sum 函数，使其带参数，修改如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;emscripten/emscripten.h&gt;int main(int argc, char ** argv) &#123; printf("Hello World emcc\n");&#125;#ifdef __cplusplusextern "C" &#123;#endifint EMSCRIPTEN_KEEPALIVE sum(int a, int b) &#123; printf("sum = %i\n", (a+b)); return 1;&#125;#ifdef __cplusplus&#125;#endif 需要修改 my.html 文件，修改内容如下： 1234var result = Module.ccall('sum', // name of C function null, // return type ['number'], // argument types [12, 13]); // arguments 注意 argument types 和 arguments 的填写，运行可以看到预期效果。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Emscripten wasm JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冷笑话的启示]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%86%B7%E7%AC%91%E8%AF%9D%E7%9A%84%E5%90%AF%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[几乎所有人都比较喜欢听或者看笑话故事，笑话故事可以让你开心，也可能让你随时哈哈大笑。下面几则笑话故事，在笑的同时可以想想其中蕴藏的道理。 女浴室起火，里面人乱作一团，赤裸身体往外跑，只见大街上白花花一大群，一老者大喊“快捂住”，众裸女突然醒悟，但身上要紧部位有三处，手忙脚乱捂不过来，不知所措。这时老者又大喊：“捂脸就行，下面都一样！” 😆 在特殊情况下抓工作不可能面面俱到，要抓住重点。 少妇报案：“我把钱放在胸衣内，在拥挤的地铁内被一帅哥偷走了…”警察纳闷：“这么敏感的地方你就没觉察到？”少妇红着脸答：“谁能想到他是摸钱呢？” 😆 让客户的钱在愉快体验中不知不觉地被摸走，是商业模式的最高境界。 某富翁想娶老婆，有三个人选，富翁给了三个女孩各一千元，请她们把房间装满。第一个女孩买了很多棉花，装满房间的1/2。第二个女孩买了很多气球，装满房间的3/4。第三个女孩买了很多蜡烛，让光线充满房间。 最终，富翁选了胸部最大的那个。 😆 把握客户内心猥琐但真实的需求至关重要。 很多年前认识一小三，当然是别人的小三，但这小三算是有本领的，不仅人长的漂亮，长发飘飘，也很有脑。爱上某金融界人士，但人家已有妻室，这小三不屈不挠，投其所好，知道男人热爱古诗词，小三楞是用了不长的时间将唐诗三百首倒背如流，小三便转正了。 😆 没有拆不散的夫妻，只有不努力的小三！ 一男子在狱中闲来无事训练蚂蚁，蚂蚁可在他指令下倒立、翻跟头 、鞠躬…. 出狱后，男子迫不及待去酒吧炫耀他的绝活，他点了一杯啤酒，然后，掏出蚂蚁放在桌上对服务员说：看，这只蚂蚁。服务员转身一掌拍死了蚂蚁，抱歉地对他说说：对不起先生，我马上给您换一杯! 😆 遇事要三思而后行。 从前有只羊，它一天干10个小时的活。有一天它的主人告诉它，你好好干，多干活有奖励，于是它照做了。接下来每个月它的主人把它身上的羊毛剪了三分之一 ，年底到了，给它织了件毛衣，然后告诉它：诺，这是你的奖励，恭喜你，继续努力吧！ 😆 这笑话告诉我们：羊毛出在羊身上。 赵四小姐从十六岁开始跟张学良。跟一年，属奸情；跟三年，算{敏感词}；跟六十年，便成为千古爱情！ 😆 很多事情不看做不做，而看你做多久。 民国初名妓小凤仙，如果跟了民工，就属于扫黄对象；她跟了蔡锷，则千古留芳了；倘若她跟了孙中山，那便可能成为国母。 😆 不在于你干什么，而看你跟谁干。 组织几个人收保护费，那是黑社会。朱元障组织几百万人抢下王位，就是伟大的皇帝。武则天睡了公公睡儿子，虽属乱*伦，但乱的够大，故成为女皇。 😆 不在你干没干坏事，而在于干多大！ 一公司在小便池上贴上条：“往前一小步，文明一大步”，结果地上仍有许多尿渍。后来公司认真吸取教训，重新设计成：“尿不到池里说明你短；尿到池外说明你软”，结果地上比以前干净许多。 😆 给客户的投资建议一定要具体，确切，中要害。 某日，女秘书神色凝重地说：王总，我怀孕了。 王继续低头看文件，然后淡淡一笑：我早结扎了。 女秘书楞了一会媚笑道：我和您开玩笑呢! 王抬起头看了她一眼，喝了口茶说：我也是。 😆 在江湖上混的人，遇事不要慌，先让子弹飞一会。 男子去提亲，女方家长：请自我介绍。 A说：我有一千万； B说：我有一栋豪宅，价值两千万； 家长很满意。就问C，你家有什么？ C答：我什么都没有，只有一个孩子，在你女儿肚子里。 AB无语，走了。 😆 核心竞争力不是钱和房子，是在关键的岗位有自已的人。 一男干部怕吃苦不愿援藏，谎称眼睛突然失明。领导闻听，出面让一美女脱光站在他面前，问“看见了吗”？答：看不见。领导飞起一脚给他臀部：狗日的，老二都直了还看不见？收拾行李，明天进藏。 😆1.人性化才能真正了解人。2.组织比个人高明。3.本能会出卖你 一小朋友问一富翁说 叔叔你为什么这么有钱。富翁摸摸小朋友的头说：小时候我爸给了我一个苹果，我卖掉了它有了两个苹果，后来我又赚到了四个苹果。小朋友若有所思的说 哦…叔叔，我好像懂了。富翁说，“你懂你妹阿，后来我爸死了，我继承了他的财产… 😆 不要痴迷于从阅读成功人士的传记，从中寻找经验，这些书大部分经过了精致的包装，很多重要的事实不会告诉你。例如盖茨的的书不会告诉你他母亲是IBM董事，是她给儿子促成了第一单大生意，巴菲特的书只会告诉你他8岁就知道去参观纽交所，但不会告诉你他国会议员的父亲带他去的，是高盛的董事接待的。 参考 lupaworld 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笑话 冷笑话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给 Homebrew 设置代理]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%BB%99-Homebrew-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[可以给 Homebrew 工具设置代理，设置方法和步骤如下。 1、打开终端，进入用户根目录 1cd ~/ 2、查看当前目录 1ls -al 查看是否有 .curl 文件，如果没有，新建一个吧 1touch .curl 3、编辑 .curl 文件 写入下面内容，如下： 1proxy=ip:port 把 ip 和 port 改为你的代理 ip 和端口值，如: 1proxy=127.0.0.1:8087 保存文件即可。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS brew proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解 Emscripten]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%86%E8%A7%A3-Emscripten%2F</url>
    <content type="text"><![CDATA[Emscripten 是什么？Emscripten 是一个 开源的编译器，可以将 C/C++ 的代码编译后高效运行在现代浏览器上面。Emscripten 的底层是基于 LLVM 编译器的，可以查看其开源的 emscripten llvm 和 emscripten clang。 下图是其编译 C/C++ 的代码的流程图： 官网 对 Emscripten 的定义： Emscripten is a toolchain for compiling to asm.js and WebAssembly, built using LLVM, that lets you run C and C++ on the web at near-native speed without plugins. 截止本文发布，Emscripten 最新版本是 1.38.27. 安装条件以下是我安装和使用 Emscripten 的条件。 macOS 版本 10.14 Git，可通过 Homebrew 安装 CMake，可通过 Homebrew 安装 Xcode 10.1 Python 2.7.x，Mac 系统自带 稳定快速的网络环境，最重要和最关键的的是要有(neng)梯(fan)子(qiang) 解决问题的态度和毅力 通过 emsdk 安装安装 Emscripten 可以通过安装 emscripten SDK 来完成，emscripten SDK 可以简单的理解为是 Emscripten 的一套工具链。 在你自己的电脑上面任意新建一个目录，如我的 ~/dev/emscwork，打开终端，进入此目录。 1、下载 emsdk 1git clone https://github.com/juj/emsdk.git 2、进入 emsdk 目录 1cd emsdk 3、开始安装 1234567891011# Fetch the latest version of the emsdk (not needed the first time you clone)git pull# Download and install the latest SDK tools../emsdk install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file)./emsdk activate latest# Activate PATH and other environment variables in the current terminalsource ./emsdk_env.sh 注意: 每次更新完 emsdk 后，依旧需要执行上面命令重新安装和激活。 另外一个比较常用的是 ./emsdk update-tags 这个命令，可以直接更新 emsdk 的最新 tags 版本，更新 tags 完成后，重新安装和激活最新版的 emsdk 套件。 配置 emsdk如果你想在任意路径下都可以使用 emsdk 里面的各种工具(就是一些二进制可执行文件)，需要为其设置环境变量。 编辑 ~/.bash_profile 文件，新增如下代码: 1234export EMSDK=~/emscwork/emsdkexport EMSCRIPTEN=$EMSDK/emscripten/1.38.27export BINARYEN_ROOT=$EMSDK/binaryen/master_64bit_binaryenexport PATH=$EMSDK:$EMSCRIPTEN:$BINARYEN_ROOT:$PATH 执行下面命令, 使刚配置的文件生效。 1source ~/.bash_profile 至此，安装和设置环境变量完成。 可以使用下面命令来查看 emsdk 的安装情况。 1emcc --version 1234emcc (Emscripten gcc/clang-like replacement) 1.38.27 (commit ea5d631a5446632e195765d89a53ead71cd6de45)Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)This is free and open source software under the MIT license.There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. emcc 是一个可执行脚本，该脚本在 emsdk/emscripten/1.38.27 目录下。 1emcc --help 上面命令可以查看更多关于 emcc 的使用方法. 编译 C/C++ 代码这里举个实际的例子。 main.c 123456#include &lt;stdio.h&gt;int main(int argc, char ** argv) &#123; printf("Emscripten show in browser...\n");&#125; 使用 emcc 编译，如下： 1emcc main.c -s WASM=1 -o mz.html 这里要注意 WASM=1 这个选项，现在新版 SDK 默认 WASM=1 了，如果不想生成 .wasm 这个文件，需要指定 WASM=0 选项。 生成另外三个文件如下： 1mz.html mz.js mz.wasm 简单介绍一下这三个文件 1、mz.wasm 二进制的 wasm 模块代码 2、mz.js 胶水代码，包含了原生 C 函数和 JavaScript/wasm 之间转换的 JS 文件 3、mz.html 用来加载、编译和实例化 wasm 代码并且将其输出在浏览器显示上的 HTML 文件 最后执行下面的命令，可以在 Safari 浏览器中显示效果 1emrun mz.html main.cpp 12345678910#include &lt;iostream&gt;using namespace std;int main(int argc, char ** argv)&#123; cout &lt;&lt; "Emscripten show in browser..." &lt;&lt; endl; return 0;&#125; 编译 C++ 文件(main.cpp) 1emcc main.cpp -s WASM=1 -o mzcpp.html 同样的方式编译和运行 mzcpp.html 即可看到同样的效果。 Emscripten 应用场景Emscripten 只是一个编译器，能将我们的高级语言编译为浏览器可以识别并运行的程序，这个看起来确实很诱人。 就目前来说，Emscripten 应用场景可以使用在安全和游戏上面。 1、安全 C/C++ 代码经过编译之后，会生成 wasm 格式 的二进制文件，这个安全级别较高，即使在浏览器中运行，破解者也不会很轻松的破解代码，这样一些在 JS 中涉及到安全的问题，可以使用 C/C++ 来写结合一些加密技术，然后用 Emscripten 编译。 2、游戏 如果能把用 C/C++ 语言写的游戏，转为可在浏览器直接运行的H5游戏，那就很美好了，用户不需要下载游戏，直接玩。现代浏览器技术的更新和发展已经让这个想法变成了现实，至少在主流的浏览器上面。 推荐大家看看这篇文章 JavaScript是如何工作的：与WebAssembly比较及其使用场景 参考文档About Emscripten Download and install 编译 C/C++ 为 WebAssembly WebAssembly 概念 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Emscripten wasm JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 结构体指针初始化]]></title>
    <url>%2F2019%2F02%2F08%2FC-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在使用指针之前，务必要将其初始化。这个是我们最早学习 C 语言的时候，书上经常说的一个问题。在工作中，我们反而会经常忘记这条金科玉律。 本篇文章的所有代码都经 gcc-7 编译器编译过。关于在 macOS 中如何安装和使用 gcc，可以参考 GCC: Homebrew 安装 GCC 和 Binutils 这篇文章。 结构体成员指针的初始化 结构体成员指针的初始化，指的是初始化结构体中指针变量的成员。 我们举个例子，下面是 Animal 的结构体。 123456struct Animal &#123; char *name; //指针成员 int age; char info[200]; //字符数组 struct Animal *nextAnimal; //指针成员&#125;; 结构体 Animal 含有4个成员变量，其中 name、info 和 nextAnimal 是指针变量。 写一段测试代码，如下： 12345678int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); return 0;&#125; 运行结果正常，终端输出如下： 1animal&apos;s name: (null), age: 0, info: 我们来验证一下 Animal *nextAnimal 在没有初始化的情况下，会不会有什么问题。 123456789101112int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 程序编译没有问题，运行报错 123animal's name: (null), age: 0, info: animal.nextAnimal: 0x1127fa036Segmentation fault: 11 修改一下代码，初始化一下 animal.nextAnimal 这个指针，如下： 123456789101112131415int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 再次编译重新运行，还是报错。还需要初始化 animal.nextAnimal-&gt;name 这个变量。 1234567891011121314151617181920212223242526int main(int argc, const char *argv[])&#123; struct Animal animal; printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); // 初始化 name 变量 animal.nextAnimal-&gt;name = "cat"; printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125;``` 编译运行，一切正常。```canimal's name: (null), age: 0, info: animal.nextAnimal: 0x10f0f1036animal.nextAnimal-&gt;name: cat, age: 0, info: 通过上面的例子，结构体指针变量有些会给默认值，有些又不会给，所以都要初始化指针变量。修改一下代码，示例如下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Animal &#123; char *name; //指针成员 int age; char info[200]; //字符数组 struct Animal *nextAnimal; //指针成员&#125;;int main(int argc, const char *argv[])&#123; struct Animal animal; animal.name = "cat"; strcpy(animal.info, "This is a cat."); printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); // 初始化变量 animal.nextAnimal-&gt;name = "cat"; strcpy(animal.nextAnimal-&gt;info, "This is a cat."); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); return 0;&#125; 结构体指针的初始化 指的是初始化结构体指针变量。 12345678int main(int argc, const char *argv[])&#123; struct Animal *ptAnimal; printf("ptAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;name, ptAnimal-&gt;age, ptAnimal-&gt;info); return 0;&#125; 编译运行报错： 1Segmentation fault: 11 同样的道理，需要初始化指针变量。完成后的示例代码如下： 12345678910111213141516171819202122int main(int argc, const char *argv[])&#123; struct Animal *ptAnimal; // 初始化结构体指针 ptAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;info, "This is a big dog"); printf("ptAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;name, ptAnimal-&gt;age, ptAnimal-&gt;info); // 初始化结构体指针的成员指针变量 nextAnimal ptAnimal-&gt;nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;nextAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;nextAnimal-&gt;info, "This is a big dog"); printf("ptAnimal-&gt;nextAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;nextAnimal-&gt;name, ptAnimal-&gt;nextAnimal-&gt;age, ptAnimal-&gt;nextAnimal-&gt;info); return 0;&#125; 完整示例main.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Animal &#123; char *name; //指针成员 int age; char info[200]; //字符数组 struct Animal *nextAnimal; //指针成员&#125;;int main(int argc, const char *argv[])&#123; /// 验证结构体指针成员变量 &#123; struct Animal animal; animal.name = "cat"; strcpy(animal.info, "This is a cat."); printf("animal's name: %s, age: %i, info: %s\n", animal.name, animal.age, animal.info); printf("animal.nextAnimal: %p\n", animal.nextAnimal); // 初始化指针变量 animal.nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); // 初始化变量 animal.nextAnimal-&gt;name = "cat"; strcpy(animal.nextAnimal-&gt;info, "This is a cat."); printf("animal.nextAnimal-&gt;name: %s, age: %i, info: %s\n", animal.nextAnimal-&gt;name, animal.nextAnimal-&gt;age, animal.nextAnimal-&gt;info); &#125; /// 验证结构体指针 &#123; struct Animal *ptAnimal; // 初始化结构体指针 ptAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;info, "This is a big dog"); printf("ptAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;name, ptAnimal-&gt;age, ptAnimal-&gt;info); // 初始化结构体指针的成员指针变量 nextAnimal ptAnimal-&gt;nextAnimal = (struct Animal *)malloc(sizeof(struct Animal)); ptAnimal-&gt;nextAnimal-&gt;name = "dog"; strcpy(ptAnimal-&gt;nextAnimal-&gt;info, "This is a big dog"); printf("ptAnimal-&gt;nextAnimal's name: %s, age: %i， info: %s\n", ptAnimal-&gt;nextAnimal-&gt;name, ptAnimal-&gt;nextAnimal-&gt;age, ptAnimal-&gt;nextAnimal-&gt;info); &#125; return 0;&#125; 编译 1gcc-7 main.c -o main 运行 1./main 运行结果如下： 12345animal's name: cat, age: 0, info: This is a cat.animal.nextAnimal: 0x0animal.nextAnimal-&gt;name: cat, age: 0, info: This is a cat.ptAnimal's name: dog, age: 0， info: This is a big dogptAnimal-&gt;nextAnimal's name: dog, age: 0， info: This is a big dog 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>gcc macOS struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致结婚8周年]]></title>
    <url>%2F2019%2F01%2F30%2F%E8%87%B4%E7%BB%93%E5%A9%9A8%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[自己明明是个理科生，偏偏有颗文科生的心，多愁善感，心理总有道不完的情结。 很多人问我：“写博客是不是很费时间，把写博客的时间腾出来做点其他的不是更好吗？“ 言下之意在说，反正你也成不了作家，干嘛浪费这个时间呢？人生有很多有乐趣的事情可以做，兴趣是最好的老师，不是吗？写博客的确是费时间，但这是个人的一个小爱好，所以，在我看来不算是浪费时间。坚持阅读和写作是我唯一没有放弃的爱好之一，因为它们能给我带来快乐，也是我忙碌之后停歇的港湾，能让我独立思考，静下心来憧憬美好的未来。 所以，爱你所爱吧！ 2010年农历12月21日我们结婚了，在结婚之前我和太太认识了大概5年的时间，风风雨雨的一路走来，坎坷而又幸福，一个女人能为你坚守这么多年，并且总是能帮你，娶她两遍都不为过，哈哈！ 那个时候家里条件很不好，在我的记忆深处，家里总是有还不完的债，每个学期的学杂费让父母焦头烂额，但最终还是被父母搞定了，所以我觉得他们很了不起。我坚持着自己的信念：“必须要考上大学，走出这里！”，母亲是家里最赞成我上学的，可能是被我炽热的学习热情给感染到了，这辈子不能忘记母亲为我上学奔波的日子，母爱之所以伟大是因为他为自己的孩子能倾出所有，并且不求回报！ 大学时期，平时自己会找一些家教做，算是补贴一下日常的开销，寒暑假是我最盼望的日子，因为可以和太太在一起打工挣钱了，那时候挣钱只有一个目的，赚到学费！一到开学她就把自己积累的钱都给我了，简直是义薄云天，她还壮志豪情的说：“拿去花！”，我也厚颜无耻的接过来了。当时我在想，这姑娘就不怕我以后跑掉吗？！关于这个事情，后来我问过她，她说：“我相信你！”，朴实的回答让我无言以对。其实，当我看见她的第一眼，就毅然决定这辈子非她不娶了！ 我们结婚后没几天，就离开了老家赶往深圳，我们手里也没有钱，穷的叮当响，记得去深圳的盘缠还是弟弟给我的。在深圳刚工作的日子里，每天中午我们还要自己做饭，粗茶淡饭的倒也觉得开心，就是在那个时候太太开始会做饭了，特别是捞面和蛋炒饭，至今还让我记忆犹新，每天晚上下班我都会去接她，在月光下她瘦小的身影显得格外别致，一起牵手回家，我们决定就这样幸福的奋斗下去！ 结婚前我们彼此骂过、切磋过，多半是我的过错但我总是觉得自己是个男人，不能低头，不然真他妈没面子。现在想想自己挺可笑的，所以婚后我基本上没有和太太打骂过，女人的脾气很奇怪，一会晴天一会雨天，自己忍一忍就过去了，不要再火上浇油了，就像这句话所说的：“你虽然赢了吵架，但是你却输了感情”，退一步海阔天空！ 2012年3月，儿子出生了，这个小家伙的到来让我们的生活变得更加忙碌了，我们算是步入了父母的行列了。太太算告别了所有的打工生涯，全职在家照顾孩子，我负责在外挣钱，一家三口幸福的生活在一起！太太自从有了儿子之后，儿子就像是他的全部，把孩子照顾的无微不至，做事情比以前认真了很多，开始关注一些公众号，读一些育儿书籍，学习别人是怎么养育孩子的，孩子在成长，太太也在成长。也许，女人从一名妻子的角色转换为母亲的角色的这个过程，算是一次蜕变，尤其是母亲的角色，她扮演的十分精彩！ 2019年1月，我们的第二个孩子出生了，是个可爱的千金，我们之前也讨论过到底要不要二胎，我说生孩子太辛苦了，有一个孩子就够折腾的了，不要二胎也罢。太太坚决反对，说一个孩子太孤单，以后遇到事情连个商量的亲人都没有，必须要二胎，就这样我们孕育了这个小千金。无论你跟你的太太有多大的仇多大的冤，她能为你生孩子，就值得你为她付出一辈子。 今年是我们结婚8周年，7年之痒的传说没有在我们两个身上发生，我们会这样继续幸福下去，迎接下一个周年。 祝大家新年新气象，身体健康，阖家幸福，万事如意，诸事顺利！祝天下有情人终成眷属！ 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class、isa、元类]]></title>
    <url>%2F2019%2F01%2F29%2FClass%E3%80%81isa%E3%80%81%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[声明本文的所涉及到的源码是 objc4 源码，截止到写本文最新的是 objc4-750 这个版本。 Class我们在学习面向对象的学习中，接触最多的就是类，那么在OC类是由Class类型来表示的，Class是用C的数据结构来表示的。 看一下 NSObject 的声明，在头文件中，如下图所示： 123456@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wobjc-interface-ivars" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 可以看到：1、NSObject 是实现了 &lt;NSObject&gt; 协议的。2、NSObject 中有 Class 类型的 isa 成员变量，外界是无法访问的，另外 isa 指针可能在将来也会被隐藏起来(OBJC_ISA_AVAILABILITY标示了)。 继续看一下 Class 到底是什么？ 在上面的文件中可以看到 Class 的定义，如下代码： 123typedef struct objc_class *Class;typedef struct objc_object *id; 可以看出 Class 是一个指向 objc_class 的结构体指针，Objective-C 中的类是由 Class 类型来表示的，它实际上是一个指向 objc_class 结构体的指针。 在下面的头文件中看一下 objc_class 的定义，如下： 12345678struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // ....&#125; 可以看出，objc_class 用来描述OC中的类，而 objc_object 用来描述OC中的对象，类(objc_class)其实也是一个对象(objc_object)，另外 id 是代表对象的，它是指向 objc_object 的结构体指针，它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中 void * 指针类型的作用。 这里要注意，objc_class 的定义在 objc-runtime-old.h中和 objc-runtime-new.h 中的不一样。这里以 objc-runtime-new.h 为主，建议可以看看 被误解的 objc_class 这篇文章。 再来看一下 objc_object，如下图所示： 12345struct objc_object &#123;private: isa_t isa;// ...&#125; objc_object 是一个结构体，里面有个私有成员变量 isa 是 isa_t 类型的。 而 isa_t 是一个 union 类型的，如下代码： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 总之在OC中，类也是一个对象称之为类对象，根据凡是对象都有自己的类的原理，那么类对象的肯定存在自己的类，这个类就是元类(meta-class)。 元类在说元类之前，先看一下下面的例子，创建一个 NSMutableDictionary 实例对象 dict，即向 NSMutableDictionary 发送 alloc 和 init 消息。 1NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; 上面代码的大概执行流程如下几个步骤： 1、先执行 [NSMutableDictionary alloc]，但是 NSMutableDictionary 没有 +alloc 方法，于是再去父类NSObject 中查找该方法。 2、NSObject 响应 +alloc 方法，开始检测 NSMutableDictionary 类，并根据其所需的内存空间大小开始分配内存空间，然后把 isa 指针指向 NSMutableDictionary 类。同时，+alloc 也被加进 cache 列表里面。 3、接着，执行 -init 方法，如果 NSMutableDictionary 响应该方法，则直接将其加入 cache，如果不响应，则去父类查找。 4、在后期的操作中，如果再以 [[NSMutableDictionary alloc] init] 这种方式来创建字典对象，则会直接从 cache 中取出相应的方法，直接调用。 上面是创建一个实例对象的大致流程，接下来我们说说元类。 元类简单来说就是类对象的类。类描述的是对象，那么元类描述的就是Class类对象的类。元类定义了类的行为（类方法），在平时开发时，meta-class 基本是用不着接触的，但最好还是要知道它的存在，这样可以更好的理解OC的设计。 1NSMutableDictionary *tDatas = [NSMutableDictionary dictionaryWithCapacity:5]; 拿上面的示例来说，向 NSMutableDictionary 发送 dictionaryWithCapacity 这个消息的时候，Runtime 会在这个类的 meta-class 的方法列表中查找，通过 SEL 找到后取出方法中的 IMP 函数入口指针，并执行该方法，如果找不到就进行消息转发的流程中，最终可能会导致 Crash，消息转发的原理和机制可以参考 消息机制 这几篇文章。 元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有则该元类会向它的父类查找该方法，直到一直找到继承链的头。 1Class object_getClass(id obj); object_getClass 可以获取一个对象的 class object，其源码实现如下： 12345Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 举个例子吧，示例如下： 123456789101112131415161718NSObject *obj = [NSObject new];Class obj1 = object_getClass(obj);Class obj2 = object_getClass([NSObject class]);Class obj3 = objc_getMetaClass("NSObject");Class obj4 = object_getClass(obj1);const char *name = [NSStringFromClass(obj1) UTF8String];NSLog(@"name: %s", name); //name: NSObjectClass obj5 = objc_getMetaClass(name);Class obj6 = objc_getClass(name); NSLog(@"obj : %@, -&gt;%p: ", obj, obj); NSLog(@"obj1: %@, -&gt;%p: ", obj1, obj1);NSLog(@"obj2: %@, -&gt;%p: ", obj2, obj2);NSLog(@"obj3: %@, -&gt;%p: ", obj3, obj3);NSLog(@"obj4: %@, -&gt;%p: ", obj4, obj4);NSLog(@"obj5: %@, -&gt;%p: ", obj5, obj5);NSLog(@"obj6: %@, -&gt;%p: ", obj6, obj6); 打印结果如下： 1234567obj : &lt;NSObject: 0x600002b19d70&gt;, -&gt;0x600002b19d70:obj1: NSObject, -&gt;0x10c96bf38:obj2: NSObject, -&gt;0x10c96bee8:obj3: NSObject, -&gt;0x10c96bee8:obj4: NSObject, -&gt;0x10c96bee8:obj5: NSObject, -&gt;0x10c96bee8:obj6: NSObject, -&gt;0x10c96bf38: 可以看出，obj 是一个实例对象，obj1和obj6是一个 class object，其二者地址也一致，obj2、obj3、obj4 和 obj5 都获取到的是元类。 通过类对象调用的 object_getClass 得到的是该类对象的 meta-class，如 obj2 和 obj4，而通过实例对象调用的object_getClass 得到的是该实例对象的类对象，如 obj1，objc_getClass 这个方法获取是实例对象的类对象，与object_getClass 还是有点不一样的。而 objc_getMetaClass 可以直接获取 meta-class，如 obj3。 总之:1、objc_getClass 参数是类名的字符串，返回的就是这个类的类对象。2、object_getClass 参数是 id 类型，它返回的是这个 id 的 isa 指针所指向的Class；如果传参是Class，则返回该Class的meta-class。 在 NSObject.mm 中，可以看到 self 和 class 方法都要实例和类方法，class 方法返回的都是类对象。 12345678910111213141516171819+ (id)self &#123; return (id)self;&#125;- (id)self&#123; return self;&#125;+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125; 所以，无论是类还是实例调用 class 方法，返回的都是同一个 class object，举例： 123456Class objClz1 = [NSObject class];Class objClz2 = [[[NSObject alloc] init] class]; if (objClz1 == objClz2) &#123; NSLog(@"objClz1: %@, -&gt;%p", objClz1, objClz1);&#125; 输出结果是： 1objClz1: NSObject, -&gt;0x10fa30f38 isa下面的例子来源自 这里，感谢 kingizz’s blog，代码中 Son 是 Father 的子类，而 Father 是 NSObject 的子类。 123@interface Father : NSObject@end 123@interface Son : Father@end 我们结合下面这个图来理解一下，子类、父类、元类以及 isa 指针。 一个实例对象的 isa 指向对象所属的类，这个类的 isa 指向这个类的元类，而这个元类的 isa 又指向 NSObject 的元类，NSObject 的元类的 isa 指向其本身，最终形成形成一个完美的闭环。 在OC中，所有的对象都有一个 isa 指针，指向对象所属的类，类也是一个对象，类对象的 isa 指针指向类的元类。 参考文章1、Objective-C 中的对象、类、元类 2、Objective-C Runtime(一)对象模型及类与元类 3、被误解的 objc_class 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>元类 isa class meta-class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被误解的 objc_class]]></title>
    <url>%2F2019%2F01%2F28%2F%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84-objc-class%2F</url>
    <content type="text"><![CDATA[网上绝大多数的博客讲 objc_class 的定义，基本上都使用了下面的代码一来讲解，与 objc4 源码 objc-runtime-new.h 中关于 objc_class 中的定义完全不一样，我认真地去探究了一下，发现这个世界上实属雷同的事件还是蛮多的，老实做事做学问的缺少的可怜！ 本文的所涉及到的 objc4 源码，截止到写本文最新的是 objc4-750 这个版本。 代码一：简洁版也称坑货版 1234567891011121314151617struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 在上面的代码中 OBJC2_UNAVAILABLE 看起来让人觉得有点奇怪，从字面意思上可以理解为在OC2.0版本不可用了，还有一个 OBJC_ISA_AVAILABILITY 是在表示 Objective-C 都可以使用吗？ 在 objc-api.h 中有关于这两个宏的定义，如下： 代码二：关键宏定义 12345678910111213141516171819202122/* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */#if !defined(OBJC_ISA_AVAILABILITY)# if __OBJC2__# define OBJC_ISA_AVAILABILITY __attribute__((deprecated))# else# define OBJC_ISA_AVAILABILITY /* still available */# endif#endif/* OBJC2_UNAVAILABLE: unavailable in objc 2.0, deprecated in Leopard */#if !defined(OBJC2_UNAVAILABLE)# if __OBJC2__# define OBJC2_UNAVAILABLE UNAVAILABLE_ATTRIBUTE# else /* plain C code also falls here, but this is close enough */# define OBJC2_UNAVAILABLE \ __OSX_DEPRECATED(10.5, 10.5, "not available in __OBJC2__") \ __IOS_DEPRECATED(2.0, 2.0, "not available in __OBJC2__") \ __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __BRIDGEOS_UNAVAILABLE# endif#endif 从定义来看，OBJC_ISA_AVAILABILITY 在OC2.0版本中标示已经过时了，OBJC2_UNAVAILABLE 标示在OC2.0中已经不可用了，将来会被移除的。 我们不妨来摘录完整的代码，如下： 代码三：完整版也称整明白版 123456789101112131415161718192021222324252627282930313233#if !OBJC_TYPES_DEFINED/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// An opaque type that represents a category.typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */#endif 这里居然还有个宏 OBJC_TYPES_DEFINED，看一下其在 objc-private.h 中的定义，如下： 1#define OBJC_TYPES_DEFINED 1 那么 #if !OBJC_TYPES_DEFINED 已经限制了其到 #endif 中间的代码都是无效的，所以关于代码一处的代码其实已经没有实际意义了，网上的朋友们请不要拿这段代码再 骗人 了。 源码 objc-runtime-new.h 中关于 objc_class 中的定义代码如下： 代码四：正解版 123456789101112131415161718192021222324252627struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // ....&#125;struct objc_object &#123;private: isa_t isa;// ...&#125;union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 无论是学知识还是做知识，老实认真应该是最基本的要求，千万不要以讹传讹，误人子弟！ 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS objc_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合对象可变与不可变的那点事]]></title>
    <url>%2F2019%2F01%2F13%2F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[简介在文章 NSString NSMutableString 可变与不可变的那些事儿 分享了关于 NSString 和 NSMutableString 与 copy 以及 mutableCopy 之间的点滴。 今天跟大家分享一下集合类数据的可变与不可变性，再结合 copy 以及 mutableCopy 说一说注意事项。如果你仔细看过 NSString NSMutableString 可变与不可变的那些事儿 这篇文章，那么接下来看本篇会很轻松。 本篇内容主要涉及以下几个方面: 在 OC 中的集合对象 集合对象的 copy、mutableCopy 可变与不可变集合对象之间等号赋值 property 中的集合对象的 copy 和 strong 实际案例分析 为了说明问题，这里，我选用数组(NSArray)作为集合对象的代表，其他的集合类以此类推即可。 集合对象在 Objective-C 中，非集合类对象指的是 NSString、NSNumber、NSValue 之类的对象，除了 NSString 有对应的可变类 NSMutableString 外，NSNumber、NSValue 都没有可变类与其对应。 集合类对象是指 NSArray、NSMutableArray、 NSDictionary、NSMutableDictionary、NSSet、NSMutableSet 之类的对象。 集合对象的 copy、mutableCopy看一个具体例子，请接着看下面的示例代码和说明。 例子1：NSArray 的 copy、mutableCopy 12345678910111213141516171819202122NSArray *array = [NSArray arrayWithObjects:@"veryitman.com", nil];NSLog(@"array addr: %p, array: %@ ", array, array);// 地址未变和array一致，内容也一致NSArray *array1 = array;NSLog(@"array1 addr: %p, array1: %@", array1, array1);// 地址未变和array一致，内容也一致// copy 之后仍然是不可变的数组对象id array2 = [array copy];NSLog(@"array2 addr: %p, array2: %@", array2, array2);// 地址改变id array3 = [array mutableCopy];NSLog(@"array3 addr: %p, array3: %@", array3, array3);// 进一步说明了经过mutableCopy后，array3变成了可变数组[(NSMutableArray *)(array3) addObject:@"my blog"];NSLog(@"array3 addr: %p, array3: %@", array3, array3);// 因为array3地址变了，不会影响array的地址和值NSLog(@"array addr: %p, array: %@ ", array, array); 小结 1： 1、不可变数组 copy 之后，仍然是不可变数组，其地址和内容不变，即拷贝了原对象的内容和指针，属于指针拷贝。 2、不可变数组 mutableCopy 之后，变成了可变数组，其地址发生了变化，即只拷贝了原对象的内容，指针没有拷贝，属于内容拷贝。 3、不可变数组之间的等号(=)赋值，是指针拷贝。 例子2：NSMutableArray 的 copy、mutableCopy 1234567891011121314151617181920212223242526272829NSMutableArray *marray = [NSMutableArray arrayWithObjects:@"veryitman.com", nil];NSLog(@"marray addr: %p, marray: %@ ", marray, marray);// 地址未变和marray一致，内容也一致NSMutableArray *marray1 = marray;NSLog(@"marray1 addr: %p, marray1: %@ ", marray1, marray1);// copy 之后，地址改变且变成了不可变的数组对象id marray2 = [marray copy];NSLog(@"marray2 addr: %p, marray2: %@ ", marray2, marray2);// mutableCopy 之后，地址改变但仍是可变数组对象id marray3 = [marray mutableCopy];NSLog(@"marray3 addr: %p, marray3: %@ ", marray3, marray3);// Crash：进一步说明了可变数组对象经过 copy 之后变成了不可变的marray2// -[__NSSingleObjectArrayI addObject:]: unrecognized selector sent to instance 0x600002cbd320// *** Terminating app due to uncaught exception 'NSInvalidArgumentException',// reason: '-[__NSSingleObjectArrayI addObject:]: unrecognized selector sent to instance 0x600002cbd320'// [(NSMutableArray *)(marray2) addObject:@"my blog"];// NSLog(@"marray2 addr: %p, marray2: %@ ", marray2, marray2);// 进一步证明了mutableCopy 之后，marray3是可变数组[(NSMutableArray *)(marray3) addObject:@"my blog"];NSLog(@"marray3 addr: %p, marray3: %@ ", marray3, marray3);// 因为marray3地址改变了，所以对marray3的操作不会影响原来的数组对象marray// marray 地址和内容保持不变NSLog(@"marray addr: %p, marray: %@ ", marray, marray); 小结 2： 1、可变数组 copy 之后，会变成不可变数组，其内容不变，但是地址改变了，即只拷贝了原对象的内容，没有进行指针拷贝，属于内容拷贝。 2、可变数组 mutableCopy 之后，仍然是不可变数组，其地址发生了变化，内容没有变化，即只拷贝了原对象的内容，指针没有拷贝，属于内容拷贝。 3、可变数组之间等号(=)赋值，是指针拷贝。 例子3：NSMutableArray 和 NSArray 之间等号赋值 123456789101112131415161718192021222324252627/** 向不可变数组赋值可变数组 */&#123; NSMutableArray *tDatas = [NSMutableArray arrayWithObjects:@"veryitman.com", nil]; NSLog(@"--1--- tDatas addr: %p, tDatas: %@", tDatas, tDatas); // 类似但不同于可变数组的mutableCopy操作，此时 array 的地址未变和tDatas地址一致 // array的内容和地址未发生变化，和tDatas一致 NSArray *array = tDatas; NSLog(@"--2--- array addr: %p, array: %@", array, array);&#125; /** 向可变数组赋值不可变数组 */&#123; NSArray *tDatas = [NSArray arrayWithObjects:@"veryitman.com", nil]; NSLog(@"--1--- tDatas addr: %p, tDatas: %@", tDatas, tDatas); // 类似进行了不可变数组的 copy 操作 // array 仍旧是不可变的，地址和内容与tDatas一致 NSMutableArray *array = tDatas; NSLog(@"--2--- array addr: %p, array: %@", array, array); // crash: 还是不可变的数组 // -[__NSArrayI addObject:]: unrecognized selector sent to instance 0x6000025499c0 // Terminating app due to uncaught exception 'NSInvalidArgumentException', // reason: '-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x6000025499c0' // [array addObject:@"blog"];&#125; 输出结果，如下： 12345678910111213--1--- tDatas addr: 0x6000023a8bd0, tDatas: ( "veryitman.com")--2--- array addr: 0x6000023a8bd0, array: ( "veryitman.com")--1--- tDatas addr: 0x600002dbbf00, tDatas: ( "veryitman.com")--2--- array addr: 0x600002dbbf00, array: ( "veryitman.com") 以上是使用 NSArray、NSMutableArray 来进行测试的，NSDictionary 和 NSSet 以及其对应的可变类型都遵循上面总结的内容。 copy、strong 修饰属性在属性中，我们如何来选择 copy 或者 strong 来作为集合数据的修饰语呢？ 根据上面示例分析结果可以看出，在属性中，如果使用 strong 修饰不可变数组，那么在使用过程中(被可变数组赋值)该不可变数组有可能会变为可变数组。如果使用 copy 修饰可变数组，那么在使用过程中（被不可变数组赋值）该可变数组有可能变为不可变数组。 小结 3： 当修饰可变类型的属性时，如 NSMutableArray、NSMutableDictionary、NSMutableSet 等集合类型时，用 strong 修饰。 当修饰不可变类型的属性时，如 NSArray、NSDictionary、NSSet 等集合类型时，用 copy 修饰。 大家如果有兴趣可以参考文章 NSString NSMutableString 可变与不可变的那些事儿 的做法来验证上面的理论知识。 实际案例分析再给大家举个实际的开发案例，我们需要定时上报目采集APP的数据，这个需求看起来是没有任何难度的。 我们使用代码来模拟一下上报数据的这个过程。 1234567// 采集到的数据NSMutableDictionary *tDatas = [NSMutableDictionary dictionaryWithCapacity:5];[tDatas setObject:@"https://" forKey:@"req_m"];NSLog(@"--采集数据--- tDatas addr: %p, tDatas: %@", tDatas, tDatas);// 开始发送[self sendDatas:tDatas];NSLog(@"--上报完成，原数据--- tDatas addr: %p, tDatas: %@", tDatas, tDatas); 发送数据的模拟示例如下： 1234567891011- (void)sendDatas:(NSDictionary *)datas&#123; NSLog(@"--上报中--- datas addr: %p, datas: %@", datas, datas); /** 下面两行代码只是为了模拟原数据被外界在传输过程中被改变，比如其他采集线程改变了它 */ if ([datas isKindOfClass:[NSMutableDictionary class]]) &#123; [(NSMutableDictionary *)datas setObject:@"veryitman.com" forKey:@"test_m"]; &#125; NSLog(@"--上报完成--- datas addr: %p, datas: %@", datas, datas);&#125; 根据上面例子3提到的，不可变向可变等号赋值时，原不可变对象会变成可变对象。 控制台输出日志，如下所示： 1234567891011121314151617--采集数据--- tDatas addr: 0x600000b788e0, tDatas: &#123; req_m = https://;&#125;--上报中--- datas addr: 0x600000b788e0, datas: &#123; req_m = https://;&#125;--上报完成--- datas addr: 0x600000b788e0, datas: &#123; req_m = https://; test_m = veryitman.com;&#125;--上报完成，原数据--- tDatas addr: 0x600000b788e0, tDatas: &#123; req_m = https://; test_m = veryitman.com;&#125; 下面代码的代码，我是为了模拟原数据被其他代码改变了的情况，只是为了说明，不可变对象容易被外界影响和改变。 1234/** 下面两行代码只是为了模拟原数据被外界在传输过程中被改变，比如其他采集线程改变了它 */if ([datas isKindOfClass:[NSMutableDictionary class]]) &#123; [(NSMutableDictionary *)datas setObject:@"veryitman.com" forKey:@"test_m"];&#125; 上面的总结又提到无论是可变对象还是不可变对象经过 copy 之后都是不可变对象的原理，我们修改一下代码，示例如下： 1234567891011121314- (void)sendDatas:(NSDictionary *)datas&#123; NSDictionary *copy_datas = [datas copy]; NSLog(@"--上报中--- copy_datas addr: %p, copy_datas: %@", copy_datas, copy_datas); if ([copy_datas isKindOfClass:[NSMutableDictionary class]]) &#123; [(NSMutableDictionary *)copy_datas setObject:@"veryitman.com" forKey:@"test_m"]; &#125; else &#123; NSLog(@"Yes, copy_datas 是不可变字典。"); &#125; NSLog(@"--上报完成--- copy_datas addr: %p, copy_datas: %@", copy_datas, copy_datas);&#125; 输出结果如下： 1234567891011121314151617 --采集数据--- tDatas addr: 0x600003b08740, tDatas: &#123; req_m = https://;&#125;--上报中--- copy_datas addr: 0x600003b08700, copy_datas: &#123; req_m = https://;&#125;Yes, copy_datas 是不可变字典。--上报完成--- copy_datas addr: 0x600003b08700, copy_datas: &#123; req_m = https://;&#125;--上报完成，原数据--- tDatas addr: 0x600003b08740, tDatas: &#123; req_m = https://;&#125; 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 集合对象 可变 不可变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS下生成字符串md5]]></title>
    <url>%2F2019%2F01%2F13%2FmacOS%E4%B8%8B%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2md5%2F</url>
    <content type="text"><![CDATA[在 macOS 系统下生成任意字符串的 md5 值，很简单，直接使用 md5 命令即可。 例如，要生成 veryitman.com 这个字符串的md5值，直接使用下面的命令即可，示例如下： 1md5 -s veryitman.com 对应生成的结果如下： 1MD5 (&quot;veryitman.com&quot;) = c5c401dcdacd95052eef360c3533a8bd 这里要注意，有些使用者会这样来计算： 1echo &quot;veryitman.com&quot; | md5 生成结果如下： 1bc239ea4ba4ebbd4ef9e61c160fcac3c 发现和上面的结果不一致，这是因为 echo 默认会添加一个换行符，导致计算的md5值不一致，修改一下： 1echo -n &quot;veryitman.com&quot; | md5 生成结果 c5c401dcdacd95052eef360c3533a8bd 与上面一致了。 注意： echo -n 用来不显示结尾的换行符。 更多关于 md5 的命令 可以问男人(man)，如下： 1man md5 MD5(Message-Digest Algorithm 5) 全称是报文摘要算法，此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件也能产生相同的报文摘要，但是可能性是极其小的。 MD5 算法 常常被用来验证网络文件传输的完整性，防止文件被人篡改，但是现在 MD5 的算法并不安全了。 在 macOS 上面还有 md5sum 这个命令，一般用来计算文件的md5值。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>macOS string md5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中如何使用对象的弱引用]]></title>
    <url>%2F2019%2F01%2F06%2FiOS-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介我们都知道使用 UIImage imageNamed 创建的 UIImage 对象会被持有(强引用)，如果图片太大会占用内存，损耗 APP 的性能，影响用户体验，如果能改造对其的强引用变为弱引用就可以解决问题。 我们可能会有类似上面的场景，有些对象暂时保存起来，可能后面会用到，也有可能不会使用，但是又不想去管理它们的生命周期，如果它们能够自己被销毁就很省事，不需要去关心这些对象到底耗费了多少内存。 今天跟大家聊聊如何在 iOS 开发中保持对对象的弱引用而不是强引用，希望看完之后，能帮助到大家去解决实际问题。 NSObject retainCount在 iOS 中创建一个对象，该对象的引用计数就会加1，例如下面的例子： 12NSObject *obj = [NSObject alloc] init];NSLog(@"obj retain count: %zd", [obj retainCount]); 上面的例子输出是1，当然在 ARC 下是无法使用 retainCount 这个方法的，只有在非 ARC 条件下才可以，如果要运行上面的例子，对应的文件需要设置为 -fno-objc-arc. 1- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE; 可以在 usr/include/objc/NSObject.h 中查看，retainCount 是 NSObject 协议（@protocol NSObject）中定义的一个方法，而 NSObject 类是实现了该协议的，如下： 1@interface NSObject &lt;NSObject&gt; 所以，任何OC对象都具有 retainCount 方法。另外，你添加一个视图，视图其实也是被容器引用了，其计数也会加1被容器持有其强引用，再例如在数组中添加一个对象，会使对象的引用计数加1，被数组所持有。 NSValue valueWithNonretainedObject在 iOS 中，NSValue 的类方法 valueWithNonretainedObject 可以保持对对象的弱引用。 1+ (NSValue *)valueWithNonretainedObject:(nullable id)anObject; This method is useful if you want to add an object to a Collection but don’t want the collection to create a strong reference to it. 大概意思是，该方法可以不持有对象的强引用，换句话说，只持有对象的弱引用。 举个栗子~ MZDog.h 123@interface MZDog : NSObject@end MZDog.m 12345678910#import "MZDog.h"@implementation MZDog- (NSString *)description&#123; return [NSString stringWithFormat:@"MZDog-obj retain count: %zd", [self retainCount]];&#125;@end 这里 MZDog 是设置了非 ARC 的，如图： 在测试文件中使用 MZDog，如下： 123456789101112131415// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 对 dog 使用弱引用，此时其引用计数还是1NSValue *value = [NSValue valueWithNonretainedObject:dog];NSLog(@"dog: %@, value: %@", dog, value); // 获取 value 对应的对象id obj = value.nonretainedObjectValue;NSLog(@"obj isKindOfClass MZDog: %i", [obj isKindOfClass:[MZDog class]]);if (obj == dog) &#123; NSLog(@"The obj is same dog object.");&#125; 对应的控制台输出，如下： 1234dog: MZDog-obj retain count: 1dog: MZDog-obj retain count: 1, value: &lt;308cf600 00600000&gt;obj isKindOfClass MZDog: 1The obj is same dog object. 从上面的例子可以看出，valueWithNonretainedObject 对 MZDog 对象 dog 是没有强应用的。修改代码，示例一下： 123456789101112// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 对 dog 使用弱引用，此时其引用计数还是1NSValue *value = [NSValue valueWithNonretainedObject:dog];NSLog(@"dog: %@, value: %@", dog, value); // 经过NSValue包装后，可以放到对应的集合对象(如数组，字典等)中，这样这些集合就不会对 dog 进行强引用了NSArray *array = [NSArray arrayWithObjects:value, nil];// dog 的引用计数还是1NSLog(@"dog: %@, array: %@", dog, array); 对应的输出日志： 123dog: MZDog-obj retain count: 1dog: MZDog-obj retain count: 1, value: &lt;40b7a401 00600000&gt;dog: MZDog-obj retain count: 1, array: ("&lt;40b7a401 00600000&gt;") 方法 valueWithNonretainedObject 等同于 1NSValue *theValue = [NSValue value:&amp;anObject withObjCType:@encode(void *)]; 上面的示例，可以改写一下： 123456789101112// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 对 dog 使用弱引用，此时其引用计数还是1NSValue *value = [NSValue value:&amp;dog withObjCType:@encode(void *)];NSLog(@"dog: %@, value: %@", dog, value);// 经过NSValue包装后，可以放到对应的集合对象(如数组，字典等)中，这样这些集合就不会对 dog 进行强引用了NSArray *array = [NSArray arrayWithObjects:value, nil];// dog 的引用计数还是1NSLog(@"dog: %@, array: %@", dog, array); 输出日志： 123dog: MZDog-obj retain count: 1dog: MZDog-obj retain count: 1, value: &lt;40568a02 00600000&gt;dog: MZDog-obj retain count: 1, array: ("&lt;40568a02 00600000&gt;") 此时 dog 的引用计数还是没有增加~ 自写弱引用的集合分类根据上面的理论知识，我们可以使用 NSValue 写出弱引用的集合对象，思路很简单，创建集合类的分类，然后使用 NSValue 来进行包装。看下面的示例代码即可。 NSArray+MZWeak.h 1234567891011@interface NSArray (MZWeak)- (id)mz_weak_objectAtIndex:(NSUInteger)index;@end@interface NSMutableArray (MZWeak)- (void)mz_weak_addObject:(id)obj;@end NSArray+MZWeak.m 123456789101112131415161718192021222324#import "NSArray+MZWeak.h"@implementation NSArray (MZWeak)- (id)mz_weak_objectAtIndex:(NSUInteger)index&#123; NSValue *value = [self objectAtIndex:index]; return value.nonretainedObjectValue;&#125;@end@implementation NSMutableArray (MZWeak)- (void)mz_weak_addObject:(id)obj&#123; NSValue *value = [NSValue valueWithNonretainedObject:obj]; if (nil != value) &#123; [self addObject:value]; &#125;&#125;@end 在文件中使用，示例如下： 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); NSMutableArray *array = [NSMutableArray arrayWithCapacity:1];// 弱引用[array mz_weak_addObject:dog]; // 此时 dog 的引用计数还是1NSLog(@"dog: %@", dog); 依次类推，对于其他集合类 NSDictionary、NSSet 都可以实现。当然实现方式不止这一种，这里只是举了一个 NSValue 包装对象来实现的例子。 当然你也可以使用 NSProxy 或者 block 来解除对对象的强引用。关于 block 的解除方法，可以参考开源项目 HXImage，另外开源项目 YYWeakProxy 里面使用了 NSProxy 来解除强引用。 那么，除了上面提到的方法，系统类库中有没有现成的类呢？聪明的你一定猜到了，一定有！ 是的，往下看。。。 NSPointerArray、NSMapTable、NSHashTable集合类 NSArray、NSDictionary 和 NSSet 以及其对应的可变版本，都可以用来存储 OC对象的, 但是对其中的对象都是强引用的。 从 iOS6.0 版本及以后的版本中，系统给我们提供了 NSPointerArray、NSMapTable 和 NSHashTable 分别对应 NSArray、NSDictionary 和 NSSet，最大的不同就是，NSPointerArray、NSMapTable 和 NSHashTable 对对象是弱引用而不是强引用。 现在大部分的 iOS APP 或者 iOS 游戏应该都至少在 iOS7 以上了吧，所以可以尽情使用这些系统提供的类库了。 使用 NSPointerArray 保存弱引用的对象，需要使用下面三种方式来创建 NSPointerArray 对象，如下： 12345678// 创建 NSPointerArray 对象方式一NSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray]; // 创建 NSPointerArray 对象方式二NSPointerArray *pointerArray1 = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory]; // 创建 NSPointerArray 对象方式三NSPointerArray *pointerArray2 = [NSPointerArray pointerArrayWithOptions:NSPointerFunctionsWeakMemory]; 那么下面还是以 MZDog 来举例子，如下： 12345678910111213141516171819// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 创建 NSPointerArray 对象方式一// 注意 weakObjectsPointerArray 而不是 strongObjectsPointerArrayNSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray];[pointerArray addPointer:(__bridge void *)(dog)]; // 创建 NSPointerArray 对象方式二NSPointerArray *pointerArray1 = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];[pointerArray1 addPointer:(__bridge void *)(dog)]; // 创建 NSPointerArray 对象方式三NSPointerArray *pointerArray2 = [NSPointerArray pointerArrayWithOptions:NSPointerFunctionsWeakMemory];[pointerArray2 addPointer:(__bridge void *)(dog)]; // dog 引用计数还是1NSLog(@"dog: %@", dog); 对应的输出 dog 对象的 retainCount 仍然是 1，其引用计数没有增加。 对应 NSMapTable 和 NSHashTable 的示例如下： NSMapTable 示例 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 弱应用对象NSMapTable *map = [NSMapTable weakToWeakObjectsMapTable];[map setObject:dog forKey:@"first"]; // 引用计数还是1，没变NSLog(@"dog: %@", dog); NSHashTable 示例 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSLog(@"dog: %@", dog); // 弱应用对象NSHashTable *hashTable = [NSHashTable weakObjectsHashTable];[hashTable addObject:dog]; // 引用计数还是1，没变NSLog(@"dog: %@", dog); NSPointerArray 与 NULL在 NSMutableArray 中添加的对象不可以是 nil，而 NSPointerArray 中却可存储 NULL(nil 经过转换得到C指针为 NULL)，也可以用来存储weak对象。weak类型的对象释放之后，NSPointerArray 的对应位置会自动变成 NULL，使用count 属性, 会将 NULL 元素也计算进来，即 NULL 算是它的一员。下面示例可以证明，如下： 123456789101112MZDog *dog = nil; NSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray];void *cobj = (__bridge void *)(dog);NSLog(@"obj: %@", cobj); //NULL[pointerArray addPointer:cobj];// 虽然存储的是 NULL，但是 count 仍然是 1NSLog(@"pointerArray count: %zd", [pointerArray count]);NSArray *array = [pointerArray allObjects];NSLog(@"pointerArray allObjects: %@", array); 一般这样删除 NSPointerArray 中的 NULL 元素，如下： 12[pointerArray addPointer:NULL];[pointerArray compact]; 这里要注意，将OC对象转换为C指针要使用 (__bridge void *) 这种方式，不要使用 (__bridge_retained void *) 或者 CFBridgingRetain，这二者会对 dog 对象进行强引用。如下示例： 12345678910// retainCount -&gt; 1MZDog *dog = [MZDog new];NSPointerArray *pointerArray = [NSPointerArray weakObjectsPointerArray];// 这里会 retain dog 对象，使其引用计数加1，此时retainCount 是 2[pointerArray addPointer:(__bridge_retained void *)dog];// 这里会 retain dog 对象，使其引用计数再加1，retainCount 是 3[pointerArray addPointer:CFBridgingRetain(dog)]; // 此时的 retainCount 是 3NSLog(@"dog: %@", dog); 如果你对 (__bridge_retained void *) 或者 CFBridgingRetain 感兴趣，可以看看 C 指针与 OC 对象之间的转换 这篇文章。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>weak strong NSPointerArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018，不会重来]]></title>
    <url>%2F2018%2F12%2F31%2F2018%EF%BC%8C%E4%B8%8D%E4%BC%9A%E9%87%8D%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[今天是2018年的最后一天，即2018年12月31日。提前祝愿所有人2019身体健康，万事如意，阖家幸福！ 这篇文章 再见 2016 是在2016年末写的，算是一个hin随心的小结。比较遗憾的是在2017年没有给自己写个总结，所以，不能再错过2018了，我怕老了没有可以寻迹的回忆！ 2018 有太多需要感谢的人了，感谢所有工作上，生活上关心、支持和鼓励我的人们，感谢我的家人给予了我太多的理解和包容，非常感谢你们！ 工作2018年我的职业没有太大的变化，仍然是奋斗在一线工作岗位上的一名软件工程师，我喜欢这份职业，它没有过多的纷争，工程师之间的沟通简单、直接！ 唯一和以前不同的是自己开始负责一个团队了，责任比以前要大了很多，压力也随之剧增。慢慢地，写代码变成了可望不可求的事情了，因为你要处理比写代码更重要的事情，比如团队的磨合，目标的制定，任务的规划等等一系列工作。 在 《蚂蚁金服：科技金融独角兽的崛起》 这本书里讲到过： 作为领导，团队里每一个人的错误都是自己的错误，但团队里每一个人的成果未必是自己的成果，这时整个人的心态就需要重新调整。 我算是一个比较幸运的人，因为团队中有很多比自己更优秀的人，他们有想法，有执行，总是能带动其他人积极的工作。这些人是团队学习的榜样，更是我们团队的财富。 公司在改变，各个方面也越来越成熟，无论是公司文化还是技术能力都在步步高升，今年尤为看到的是 CTO 对技术中台下定的一些决心，这是让人兴奋的。公司一直在强调赋能，把更多优秀、有担当、有责任心的人提拔上来，给他们配备资源，以便发挥他们更大的潜能，大家工作的热情也更上一层楼，因为公司相信他们。 很多时候，并不是你身边没有优秀的人，只是你不愿意相信他们，前怕狼后怕虎的心态阻止了这些优秀人的发挥。其实，他们只是需要你一个肯定的答复，所以试着去改变自己，相信团队里面的每个人，给他们更多的肯定，鼓励和支持他们，结果不会让你失望的。 生活自从老婆孩子回老家之后，我就过上了“单身“的生活，每天早出晚归，努力用工作来代替对他们的思念。 我家的大宝是个天生的运动狂，感觉他总是有用不完的力气，除非他自己在拼图或者画画，否则你甭想清静。一会在家里穿上溜冰鞋给你表演各种溜冰技能，一会拿起篮球给你表演球技，再不是就让你陪他玩跳棋。 老婆大人在家待产了，自己一个人挺着肚子还要给大宝做饭，每天接送他去学校，知道她一个人在家不容易，我也经常鼓励她，她说：“为了孩子，这点苦不算什么！”。有时候，想一想二宝快要跟我们见面了，挺兴奋的。 有时候挺想念他们娘俩的，工作不忙的时候我也会请假回老家，记得上次回去离开的时候，儿子问了我一个问题，他说：“爸爸，你说是钱重要，还是人重要？”，我当时愣了一下，告诉他：“当然是人重要呀！”，他不开心的点了点头。显然，这家伙对我的离开很不满意，那天晚上我赶火车走的时候，大宝在被窝里哭了很久，其实，我也流泪了，只是不愿意承认罢了！ 你自己除了是一名员工之外，还是一名儿子、女儿，或者是一名父亲、母亲，一名丈夫、妻子，只有处理好生活上面的事情，才能更好的投入到工作当中来。无论如何，人还是需要有梦想的！我的梦想就是努力学习更多有用的知识，然后用自己的知识去教育自己的子女，让他们将来能有更好的生活，做一个有用的社会人。 用电影《中国合伙人》成东青的一句话来说：“梦想是什么，梦想就是一种让你感到坚持就是幸福的东西！”。 阅读这些年，自己唯一没有丢弃的爱好就是阅读。 工作上的忙碌，生活上的疲惫，很多时候让我们无法静下心来去阅读，甚至有时候会觉得阅读简直在浪费时间，浪费生命。如果你有这种想法，建议你请假去好好休息几天，抛开喧嚣的尘世，放空一下自己。 我一直坚持阅读，无论是技术书籍还是人文历史，抑或人物传记，平时工作也很忙，我就利用零散的时间来阅读，就算这样，每周每个月累计下来阅读量也不少了，随着阅读量的增多，感觉自己的气色好了很多，因为心态好了，遇事比以前更加沉着冷静了，也更加理性了。 您的气质里藏着你读过的那些书。 今年读到自认为不错的书籍，推荐给大家： 1. 蚂蚁金服：科技金融独角兽的崛起 2. 赋能：打造应对不确定性的敏捷团队 3. 我的情绪为何总被他人左右 4. 终身成长 20191. 加强对上沟通 沟通不能仅限于对下沟通，对上沟通尤为重要，让上级知道目前项目的进度和规划，以及遇到的问题。这一点自己做的还不够好，在2019年要加强。 2. 加强自我管理 管理，不是管理别人，而是要管理好自己，没有人愿意被管理，如果有需要被严格管理的，他可能不适合在你的团队中生存。加强自我管理是我们每个人的目标。 3. 个人、团队技术能力再上一层楼 补齐自己的短板，想尽一切办法提高自己和团队其他技术人员的技术能力，在稳定、高效的同时寻找更多自我成长的途径和方法。 4.更加关心自己的家人和身边的朋友 没有家人的支持和鼓励，你很难去投入工作，所以要好好的对待自己的家人，多关心他们，家人对你的要求不多，往往只需要知道你有没有惦记他们就够了。当然了，我很期待和我们家的二宝见面，嘿嘿😜！ 朋友多了，路才好走，记得跟朋友多聊天，多听听他们的故事，最重要的是经常约他们喝喝酒。 最后分享给大家一句话，共勉： 你的目的不是给谁打工，而是成为更好的自己，建设更好的未来！所以尽快去调整心态，停止抱怨，立即行动，积极沟通！ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString、NSMutableString 可变与不可变的那些事儿]]></title>
    <url>%2F2018%2F12%2F30%2FNSString%E3%80%81NSMutableString-%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[简介这篇文章的主要包含如下内容： 可变对象和不可变对象 NSString 的 copy 和 mutableCopy NSMutableString 的 copy 和 mutableCopy property 中 copy、strong 修饰 NSString property 中 copy、strong 修饰 NSMutableString 很多 iOS 开发的朋友会争论一个问题，我用 copy 和 strong 来修饰 NSString 对象都是一样的效果，在大部分情况下，这二者确实是没有区别，但是在特殊情况下，二者截然不同，所以我们必须搞清楚里面的道道。 我已经尽力简化了这篇文章的内容了，但依然需要你花个15分钟左右的时间，所以当你心情不错又没有其他事情的情况下，就可以来阅读了。 可变对象和不可变对象在 Objective-C 中最常用来处理字符串的是 NSString 与 NSMutableString 这两个类，NSString 被创建赋值后字符串的内容与长度不能再做动态的修改，除非重新给这个字符串赋值。而 NSMutableString 被创建赋值后可以动态的修改字符串的内容。 那么简单来说，可变对象是指，对象的内容是可变的，例如 NSMutableString 对象。不可变的对象则相反，表示其内容不可变，例如 NSString 对象。 可变与不可变是针对对象来说的。在实际开发中，要根据实际的业务场景来选择使用可变还是不可变对象。今天我们只讨论 Objective-C 中 NSString 与 NSMutableString 这两个类，关于其他集合类的可变与不可变特性，后面专门再来写文章分享。 NSString 的 copy 和 mutableCopy在 NSString.h 中，我们可以看到其定义如下： 1@interface NSString : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding&gt; NSString.h 本身实现了 NSCopying, NSMutableCopying 这两个协议，协议的定义如下内容所示： 1234567891011@protocol NSCopying- (id)copyWithZone:(nullable NSZone *)zone;@end@protocol NSMutableCopying- (id)mutableCopyWithZone:(nullable NSZone *)zone;@end 也就是说，我们可以针对 NSString 对象进行 copy 和 mutableCopy 的操作，妥妥的。 举一个简单的栗子，示例代码如下： 12345678NSString *name = @"www.";NSLog(@"name addr: %p, name content: %@", name, name); NSString *name1 = name;NSLog(@"name1 addr: %p, name1 content: %@", name1, name1); NSString *name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2); 输出结果，如下： 123name addr: 0x10090ecf8, name content: www.name1 addr: 0x10090ecf8, name1 content: www.name2 addr: 0x10090ecf8, name2 content: www. 从输出结果可以看出，三个对象的内容和地址都是一样的，经过 name 对象 copy 后的 name2 与 name 还是指向同一块内存地址。 在断点过程中，发现无论是 name 还是 name1、name2 对象，其都是 ConstantString，表明三者都是不可变对象，如下图所示： 从这张图也说明了一个问题，NSString 对象经过 copy 后仍然是不可变对象。 紧接着，我们再来看看 mutableCopy 的使用情况，例子如下： 1234567891011NSString *name = @"www.";NSLog(@"name addr: %p, name content: %@", name, name); NSString *name1 = name;NSLog(@"name1 addr: %p, name1 content: %@", name1, name1); NSString *name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2); id name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3); 对象 name3 是经过 name 对象 mutableCopy 后的，这个时候因为我不确定 name3 到底是可变的还是不可变的，所以采用了 id 来修饰 name3 对象。 可以看一下输出内容： 1234name addr: 0x104a6acf8, name content: www.name1 addr: 0x104a6acf8, name1 content: www.name2 addr: 0x104a6acf8, name2 content: www.name3 addr: 0x1c0052cf0, name3 content: www. 可以看出，name3 的地址变了，再看一下断点的截图： 充分说明了 name3 经过不可变的 name 进行mutableCopy 后变成了可变对象。那么可以将上面的示例代码稍作修改： 1234NSMutableString *name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3);[name3 appendString:@"veryitman.com"];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3); 从下面的输出结果也充分说明了 name3 经过不可变的 name 进行 mutableCopy 后变成了可变对象。输出结果如下： 1name3 addr: 0x1d0058270, name3 content: www.veryitman.com 结论 1： 不可变的 NSString 对象经过 copy 后，还是不可变对象。 不可变的 NSString 对象经过 mutableCopy 后，变成了可变的 NSMutableString 对象。 NSMutableString 的 copy 和 mutableCopy类 NSMutableString 继承自 NSString 的，其当然也是实现了 NSCopying, NSMutableCopying 这两个协议的。 1@interface NSMutableString : NSString 我们还是看例子，示例代码如下： 1234567891011121314NSMutableString *name = [NSMutableString stringWithString:@"www."];NSLog(@"name addr: %p, name content: %@", name, name);// 简单赋值NSMutableString *name1 = name;NSLog(@"name1 addr: %p, name1 content: %@", name1, name1); // 使用 copy id name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2); // 使用 mutableCopy id name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3); 因为事先我们不知道 NSMutableString 经过 copy 和 mutableCopy 之后到底会变成可变还是不可变，上面的例子暂时将 name2 和 name3 用 id 来表示。 断点截图如下： 结合一下输出的日志： 1234name addr: 0x1d044a980, name content: www.name1 addr: 0x1d044a980, name1 content: www.name2 addr: 0xa0000002e7777774, name2 content: www.name3 addr: 0x1d044a5f0, name3 content: www. 可以看出 name2 是一个不可变的 NSString 对象， name、name1 和 name3 都是可变的 NSMutableString 对象。 也可以从另外一个角度来验证一下上面的说法，我们修改一下代码： 1234567NSMutableString *name2 = [name copy];NSLog(@"name2 addr: %p, name2 content: %@", name2, name2);[name2 appendString:@"veryitman.com"]; NSMutableString *name3 = [name mutableCopy];NSLog(@"name3 addr: %p, name3 content: %@", name3, name3);[name3 appendString:@"veryitman.com"]; 运行后，可以看到，代码 [name2 appendString:@&quot;veryitman.com&quot;] 这里会引起 Crash，报错内容如下： 12345 -[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa0000002e7777774 *** Terminating app due to uncaught exception 'NSInvalidArgumentException'reason: '-[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa0000002e7777774' 也充分说明了，name2 是一个不可变的 NSString 对象。 结论 2： 可变的 NSMutableString 对象经过 copy 后，会变成不可变的 NSString 对象。 可变的 NSMutableString 对象经过 mutableCopy 后，仍然是可变的 NSMutableString 对象。 copy、strong 修饰 NSString创建 Employee 文件，如下： 12345@interface Employee : NSObject@property (nonatomic, copy) NSString *userName;@end 其 userName 属性是 copy。 使用示例，如下： 1234567891011121314151617181920212223Employee *employee = [Employee new];employee.userName = @"John";NSLog(@"--before-- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // 创建一个可变对象NSMutableString *newUserName = [[NSMutableString alloc] initWithString:@"new_user_name"];NSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName); // 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@"---after1--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // 试图改变 newUserName 的内容，看 employee.userName 的内容是否改变[newUserName appendString:@"_hello"];// newUserName 的内容被改变成了 new_user_name_helloNSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName);// employee.userName 的内容未变化NSLog(@"---after2--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // Crash，因为 employee.userName 还是不可变对象// [(NSMutableString *)(employee.userName) appendString:@"nana"]; 在上面的示例中，故意将 NSMutableString 对象 newUserName 赋值给不可变的 NSString 对象 employee.userName，看一下输出结果，如下： 123456789--before-- employee.userName addr: 0x100096cf8, employee.userName content: JohnnewUserName addr: 0x174070a00, newUserName content: new_user_name---after1--- employee.userName addr: 0x174023b80, employee.userName content: new_user_namenewUserName addr: 0x174070a00, newUserName content: new_user_name_hello---after2--- employee.userName addr: 0x174023b80, employee.userName content: new_user_name 按照 1可变的 `NSMutableString` 对象经过 `copy` 后，会变成不可变的 `NSString` 对象。 这个结论来看，employee.userName 肯定是不可变的对象，即使改变 newUserName 的内容也不会影响 employee.userName 这个对象的内容。 那么，我们将 employee.userName 的属性修饰符 copy 改为 strong，又会是什么样子呢？ 我们修改两处代码 Employee.h 1234567@interface Employee : NSObject//@property (nonatomic, copy) NSString *userName;@property (nonatomic, strong) NSString *userName;@end 示例代码，只是打开之前会 crash 的部分 123// employee.userName 经过 strong 修饰过后， 彻底变成了可变对象[(NSMutableString *)(employee.userName) appendString:@"_oc"];NSLog(@"---after3--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); 看一下输出日志： 1234567891011--before-- employee.userName addr: 0x1000a6cf8, employee.userName content: JohnnewUserName addr: 0x17426b280, newUserName content: new_user_name---after1--- employee.userName addr: 0x17426b280, employee.userName content: new_user_namenewUserName addr: 0x17426b280, newUserName content: new_user_name_hello---after2--- employee.userName addr: 0x17426b280, employee.userName content: new_user_name_hello---after3--- employee.userName addr: 0x17426b280, employee.userName content: new_user_name_hello_oc 可以看到 employee.userName 最终和 newUserName 的地址、内容完全相同了，彻底变成了可变对象。 另外，如果不是将可变的 NSMutableString 对象赋值给不可变的 NSString 对象，换句话说，NSString 对 NSString 赋值，那么使用 strong 和 copy 效果都是一样的。 示例代码（无论 employee.userName 使用 strong 还是 copy，效果都是 employee.userName 不可变的）： 1234567891011Employee *employee = [Employee new];employee.userName = @"John";NSLog(@"--before-- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // 创建一个不可变对象NSString *newUserName = @"new_user_name";NSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName); // 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@"---after1--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); copy、strong 修饰 NSMutableString在 property 的修饰语中，只有 copy 修饰语而没有 mutableCopy 的修饰语。 Employee.h 12345@interface Employee : NSObject@property (nonatomic, copy) NSMutableString *userName;@end 示例代码： 12345678910111213141516Employee *employee = [Employee new];employee.userName = [NSMutableString stringWithString:@&quot;John&quot;];NSLog(@&quot;--before-- employee.userName addr: %p, employee.userName content: %@&quot;, employee.userName, employee.userName);// 创建一个可变对象NSMutableString *newUserName = [NSMutableString stringWithFormat:@&quot;new_user_name&quot;];NSLog(@&quot;newUserName addr: %p, newUserName content: %@&quot;, newUserName, newUserName);// 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@&quot;---after1--- employee.userName addr: %p, employee.userName content: %@&quot;, employee.userName, employee.userName); // employee.userName 虽然是 NSMutableString 对象，但经过 copy 修饰过后，仍然是不可变对象// 所以，运行到这里会引起 crash[employee.userName appendString:@&quot;_oc&quot;];NSLog(@&quot;---after2--- employee.userName addr: %p, employee.userName content: %@&quot;, employee.userName, employee.userName); 可以看出 copy 后的的可变对象还是不可变的。 那么，我们将 employee.userName 的属性修饰符 copy 改为 strong，又会是什么样子呢？ Employee.h 12345@interface Employee : NSObject@property (nonatomic, strong) NSString *userName;@end 示例代码： 123456789101112131415161718192021Employee *employee = [Employee new];employee.userName = [NSMutableString stringWithString:@"John"];NSLog(@"--before-- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName);// 创建一个可变对象NSMutableString *newUserName = [NSMutableString stringWithFormat:@"new_user_name"];NSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName);// 将一个新的对像赋值给 employee.userName，此时 employee.userName 的地址肯定会变化employee.userName = newUserName;NSLog(@"---after1--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); // employee.userName 虽然是 NSMutableString 对象，但经过 strong 修饰过后，变成了可变对象[employee.userName appendString:@"_hello"];NSLog(@"---after2--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); [newUserName appendString:@"_oc"];// newUserName 的内容被改变成了 new_user_name_hello_ocNSLog(@"newUserName addr: %p, newUserName content: %@", newUserName, newUserName);// employee.userName 的内容发生了变化NSLog(@"---after2--- employee.userName addr: %p, employee.userName content: %@", employee.userName, employee.userName); 经过 strong 修饰后，可变的 NSMutableString 对象还是可变的对象。 在这个部分的开始，说过在 property 中没有 mutableCopy 的修饰语，那么我们能否达到 mutableCopy 的效果呢？ 很显然是可以的，我们可以重写属性的 set 方法，改造一下 Employee 的代码，如下： Employee.h 12345@interface Employee : NSObject@property (nonatomic, copy) NSMutableString *userName;@end Employee.m 12345678910#import &quot;Employee.h&quot;@implementation Employee- (void)setUserName:(NSMutableString *)userName&#123; _userName = [userName mutableCopy];&#125;@end 这样，就达到了和是 strong 修饰语一样的效果了。 大家，可以使用同样的方法来实践一下 NSArray、NSMutableArry 等集合数据的 copy 以及 mutableCopy 的效果了。 小结 不可变的 NSString 对象经过 copy 后，还是不可变对象。 不可变的 NSString 对象经过 mutableCopy 后，变成了可变的 NSMutableString 对象。 可变的 NSMutableString 对象经过 copy 后，会变成不可变的 NSString 对象。 可变的 NSMutableString 对象经过 mutableCopy 后，仍然是可变的 NSMutableString 对象。 不可变的 NSString 对象在 property 中，尽量使用 copy 来修饰，因为使用 strong 修饰符可变字符串如果给不可变字符串赋值后，会导致你原本预期发生了变化，除非你有特殊的目的才使用 strong 修饰符。 可变的 NSMutableString 对象在 property 中，尽量使用 strong 来修饰，除非你有特殊的目的才使用 copy 修饰符。 虽然在 property 中没有 mutableCopy 修饰符，但是可以通过重写其 set 方法来达到目的。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSString NSMutableString copy mutableCopy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC: self]]></title>
    <url>%2F2018%2F12%2F23%2FOC-self%2F</url>
    <content type="text"><![CDATA[为了更好的说明 Objective-C 中的 self，我们先从 Java 的 this 关键字开始来引入话题。 Java 中的 this在 Java 中 this 关键字表示当前类对象，其只能在类的非静态方法中使用，静态方法和静态的代码块中绝对不能出现 this，this 只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的 this. 先看一个 Java 示例，能说明上面的问题，示例如下： 12345678910111213141516171819202122232425262728// 静态代码块中也不可以使用 this// Error: non-static variable this cannot be referenced from a static contextstatic &#123; // this.eat();&#125;public void play() &#123; System.out.println("play()"); // this 调用类方法 this.eat(); // this 调用实例方法 this.finish();&#125;public static void eat() &#123; System.out.println("static eat()"); // 不可以在类方法中使用 this // Error: non-static variable this cannot be referenced from a static context // this.play(); // System.out.println(this);&#125;public void finish() &#123; System.out.println("finish()");&#125; 通过实际的 Java 例子，基本表明了在静态方法和实例方法中 this 的使用场景。 Objective-C 中的 self在 Objective-C 中，self 是一个比较特殊的对象，它既可以是实例对象也可以是类对象，有点类似于上面 Java 中的 this 关键字。 下面结合实际例子，来说明 self 这个关键字。 1、实例方法中的 self实例方法中的 self 可以直接调用实例方法但不可以直接调用类方法，如下示例中，调用实例方法 finish没有问题，而调用类方法 eat 直接报编译错误。 12345678910111213141516171819202122- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------"); NSLog(@"self: %@, self -&gt; %p", self, self); // 无法使用 self 来调用类方法 // Error: No visible @interface for 'MZPerson' declares the selector 'eat' // [self eat]; // 调用实例方法 [self finish];&#125;+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------");&#125;- (void)finish&#123; NSLog(@"--------------- '- (void)finish' ----------------");&#125; 我们知道，在实例方法中可以直接通过`[类 类方法] 的方式来调用类方法，那么如果想在实例方法中使用 self 关键字，如何办呢？ 很简单，使用 [self class] 即可。 1234567- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------"); NSLog(@"self: %@, self -&gt; %p", self, self); [[self class] eat];&#125; 关于 class 后续再分享给大家，这里只需要知道可以这么使用就好了。 2、类方法中的 self这个跟 Java 的 this 有点不一样，上面的 Java 示例中我们可以看到无论是打印 this 还是使用 this 调用方法都不可以，但是在 Objective-C 中却可以使用 self，只是不能使用 self 来调用实例方法和实例变量。 123456789101112131415161718+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------"); // No known class method for selector 'finish' // [self finish]; // 调用类方法 [self beat]; // 打印 self NSLog(@"self: %@", self);&#125;+ (void)beat&#123; NSLog(@"---------------- '+ (void)beat' ------------------");&#125; 那么为什么在类方法中可以使用 self 呢？ 别着急，接着往下看。 3、实例和类方法中的 self 区别其实，在类方法中，self 表示当前类对象，在实例方法中 self 表示实例对象，这个是本质区别，务必要理解透彻。 举个例子，如下： 123456789101112131415161718192021222324252627282930313233- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------"); NSLog(@"self: %@, self -&gt; %p", self, self); // 打印对应的类地址 NSLog(@"self class: %p", [self class]); [[self class] eat]; &#125;+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------"); // No known class method for selector 'finish' // [self finish]; // 打印 self 地址 NSLog(@"self: %p", self); // 调用类方法 [self beat];&#125;+ (void)beat&#123; NSLog(@"---------------- '+ (void)beat' ------------------"); // 打印 self 地址 NSLog(@"self: %p", self);&#125; 在实例方法 play 中打印类地址，在类方法 eat 和 beat 中打印 self 的地址，输出结果是一样的，都是 0x10adb3f98 这个地址。 1234567---------------- &apos;- (void)play&apos; ------------------self: &lt;MZPerson: 0x6000000d8f90&gt;, self -&gt; 0x6000000d8f90self class: 0x10adb3f98---------------- &apos;+ (void)eat&apos; ------------------self: 0x10adb3f98---------------- &apos;+ (void)beat&apos; ------------------self: 0x10adb3f98 为了更好的说明，我给大家再举一个形象的例子帮助大家理解。 在 MZPerson 中声明两个方法，方法同名，一个是实例方法，另一个是类方法，如下： 1234567891011@interface MZPerson : NSObject- (void)play;+ (void)play;+ (void)eat;- (void)finish;@end 1234567891011121314151617181920212223242526@implementation MZPerson- (void)play&#123; NSLog(@"---------------- '- (void)play' ------------------");&#125;+ (void)play&#123; NSLog(@"---------------- '+ (void)play' ------------------");&#125;+ (void)eat&#123; NSLog(@"---------------- '+ (void)eat' ------------------"); [self play];&#125;- (void)finish&#123; NSLog(@"---------------- '- (void)finish' ------------------"); [self play];&#125;@end 在类方法 eat 中调用 [self play] 在实例方法 finish 中也调用 [self play]，那么结果如何呢？ 12345---------------- &apos;- (void)finish&apos; ------------------------------- &apos;- (void)play&apos; --------------------------------- &apos;+ (void)eat&apos; ---------------------------------- &apos;+ (void)play&apos; ----------------- 可以看出符合如期，类和实例方法中的 self 分别代表类本身和实例对象。 self 表示谁，在运行时是由编译器来决定的。 4、每个实例对象的 self 都是不一样的这个跟 Java 的 this 是一样的，每个类的实例对象对应的 this 都是不一样的，self 亦如此。 下面的例子，分别创建两个 MZPerson 实例对象，然后分别调用play 方法，如下： 12345MZPerson *iperson1 = [MZPerson new];[iperson1 play]; MZPerson *iperson2 = [MZPerson new];[iperson2 play]; 输出结果表明了上面说法的正确性。 1234---------------- &apos;- (void)play&apos; ------------------self: &lt;MZPerson: 0x600000576ee0&gt;, self -&gt; 0x600000576ee0---------------- &apos;- (void)play&apos; ------------------self: &lt;MZPerson: 0x600000576f40&gt;, self -&gt; 0x600000576f40 最后在继承关系中，使用 self 调用方法时，首先从当前类的方法列表中开始寻找，如果没有再从父类中寻找。 运行时(runtime)会使用 objc_msgSend 向对象发送消息，这个也是调用方法的本质。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C self keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark: 分析 TCP 四次挥手]]></title>
    <url>%2F2018%2F12%2F16%2FWireshark-%E5%88%86%E6%9E%90-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[简介首先要明白 TCP 协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。 其次，TCP 是全双工模式，需要两边的连接全部关闭，此 TCP 会话才算完全关闭，四次挥手使得 TCP 的全双工连接能够可靠的终止。 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 下面根据客户端(IP: 10.4.17.176)请求服务端(IP: 116.211.186.208) 来分析四次挥手(four-way handshake)的过程。 这里需要注意一个问题，任何一方执行 close() 操作即可产生挥手操作，所以断开连接端可以是 Client 端，也可以是 Server 端。 在阅读下面内容之前，我假设你已经阅读过 Wireshark: 简单分析 TCP 三次挥手 这篇文章。 分析使用 iOS 设备的浏览器客户端 Safari 访问 116.211.186.208 这个网站，关于如何开启 iOS 设备的虚拟网卡可以参考 初识 Wireshark 这篇文章。 针对 HTTP 的请求，可以进行 Follow，选择 TCP Stream 即可，如下图所示： 此时，可以看到四次挥手的抓包情况，如下图所示：另外，从上图中可以看出，首先发起 Close 的是服务端。 第一次挥手，发送 FIN 和 ACK 报文，如图： 第二次挥手，客户端发送 ACK 报文给服务端，如图： 第三次挥手，客户端发送 FIN 和 ACK 报文给服务端，如图： 第四次挥手，服务端发送 ACK 报文给客户端，如图： 从图中抓包来看，seq 和 ack 的值变化如下表： 次数 seq 值 ack 值 1 140 447 2 447 141 3 447 141 4 141 448 小结结合上面抓包的示例，小结一下四次挥手的过程。 在前面说过，断开连接端可以是 Client 端，也可以是 Server 端，我上面的例子首先发起 close 的一方是 Server 端。 第一次挥手：服务端发送一个 [FIN+ACK] 报文，表示自己没有数据要发送了，想断开连接，并进入 fin_wait_1 状态（不能再发送数据到客户端，但能够发送控制信息 ACK 到客户端）。 第二次挥手：客户端收到 [FIN] 报文后，客户端知道不会再有数据从服务端传来，发送 ACK 进行确认，客户端进入 close_wait 状态。此时服务端收到了客户端对 FIN 的 ACK 后，进入 fin_wait2 状态。 第三次挥手：客户端发送 [FIN ACK] 报文给对方，表示自己没有数据要发送了，客户端进入 last_ack 状态。服务端收到了客户端的 FIN 信令后，进入 time_wait 状态，并发送 ACK 确认消息。 第四次挥手：服务端在 time_wait 状态下，等待 2MSL(MSL是数据分节在网络中存活的最长时间) 一段时间，没有数据到来的，就认为对面已经收到了自己发送的 ACK 并正确关闭了进入 close 状态，自己也断开了到客户端的 TCP 连接，释放所有资源。当客户端收到服务端的ACK 回应后，会进入 close 状态，并关闭本端的会话接口，释放相应资源。 根据 wireshark 抓包和上面流程的分析，可以画出如下示意流程图： 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip udp http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当 NTFS 遇上 MacOS]]></title>
    <url>%2F2018%2F11%2F24%2F%E5%BD%93-NTFS-%E9%81%87%E4%B8%8A-MacOS%2F</url>
    <content type="text"><![CDATA[简介自己使用的 MacBook Pro 电脑是 256G 的，这个本陪了我5个春秋，性能依旧强劲，一直舍不得抛弃换新(好吧，我承认自己穷)。 由于工作需要，里面安装了不少软件，也存储了不少资料，逐渐发现硬盘容量不足，我也一直在删除一些非必要的东西，发现还是杯水车薪，没办法，又买了一块移动硬盘，网盘用起来还是没有硬盘方便，我使用网盘的频率很低。 MacOS 挂载我觉得移动硬盘买回来，直接插在电脑上就可以使用了，最后发现硬盘只能读不能写，卧槽！ 上网查了一下，在默认情况下，NTFS 格式的硬盘插入到 MacOS 里，是只能读不能写的，需要挂载。 于是结合网上前辈的经验，弄了一个 shell 脚本，用了一段时间，发现挺好用的，但是电脑重启后，脚本就需要修改，还要查找当前硬盘到底在 disk0 还是在 disk2 上面，麻烦。 还好有一些比较成熟的工具帮我们解决问题，Paragon NTFS for MAC 就是其中一个。 这个工具是收费的，我试用了一段时间，感觉功能挺强大的，因为穷也懒得折腾破解，就找了另外一个工具 mounty，小巧可爱关键免费，在公众号上面收到的赞赏我也会 donate 给他们。 mounty 最新版本是 1.9，介绍如下： 1A tiny tool to re-mount write-protected NTFS volumes under Mac OS X 10.9+ in read-write mode. mounty 失效在使用 mounty 挂载移动硬盘时, 弹框提示以下错误: 12The volume My Passport is not re-mountable in read/write mode.Probably it was not clean unmounted before. 这种错误的原因大部分是因为在 Windows 上面使用后没有安全退出(直接拨出)而造成的，网上有两种方案，分别如下： 方案 1 插入移动硬盘到 Windows 下面 打开 dos 命令行，输入 chkdsk /f, 然后回车，输入 Y 使用右下角的安全删除后再拔出移动硬盘 将移动硬盘再次插入 Mac 打开 mounty重新挂载就可以了 反正这种方案我是没有成功，报错如下： 方案 2 在 Windows 系统中，将移动硬盘插入，使用 360软件 点击 安全退出 退出硬盘，不要直接拔掉，再在 Mac 中插入使用 mounty 重新挂载就解决问题了。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>NTFS MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F10%2F28%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组件间通信，我会优先使用路由的通信方式(iOS中需要用到 runtime，Android 中需要用到反射和注解)，组件之间按照路由协议(类似 url)实现各自的职责即可，组件间的松耦合性增强了软件设计的弹性和高可用性。 路由结合观察者模式，可以让你的组件设计更上一层楼。路由可以解决单向调用的问题，让组件之间无需知道对方是否存在。观察者模式可以让调用者(使用你框架的)可以很方便的知道组件的内部事件。 武林至尊，宝刀屠龙，号令天下，莫敢不从，倚天不出，谁与争锋? 在说观察者模式之前，先介绍一下 iOS 中的代理(delegate). 代理 delegate在 iOS 中，代理(delegate)的本质是 protocol，类似 java 中的 Interface，一般用来处理 一对一 的关系，如下图所示： 下面的例子模拟了调用和实现过程，使用 Bank 对象和 BankDelegate 代理来模拟这种模式。Bank 有变动的时候，通过 notifyAccount 来授权 onAccountChanged 通知用户。 BankDelegate.h 12345@protocol BankDelegate &lt;NSObject&gt;- (void)onAccountChanged:(NSUInteger)account;@end Bank.h 1234567@interface Bank : NSObject@property (nonatomic, weak) id&lt;BankDelegate&gt; delegate;- (void)notifyAccount;@end Bank.m 12345678910@implementation Bank- (void)notifyAccount&#123; if ([self.delegate respondsToSelector:@selector(onAccountChanged:)]) &#123; [self.delegate onAccountChanged:100]; &#125;&#125;@end 使用者实现 delegate 12345678910111213- (void)viewDidLoad&#123; [super viewDidLoad]; Bank *bank = [Bank new]; bank.delegate = self; [bank notifyAccount];&#125;- (void)onAccountChanged:(NSUInteger)account&#123; NSLog(@"Bank tell me that account is changed. %zd", account);&#125; 当然，delegate 也可以做到 一对多，改造一下 Bank 就可以实现。 1234567@interface Bank : NSObject- (void)addBankDelegate:(id&lt;BankDelegate&gt;)delegate;- (void)notifyAccount;@end Bank 内部使用数组将 addBankDelegate 得到的 delegate 存起来，notifyAccount 中就可以进行通知了。 12345Bank *bank = [Bank new];// 模拟添加多个 delegate[bank addBankDelegate:self];[bank addBankDelegate:self];[bank notifyAccount]; 观察者模式理解了 delegate，观察者模式就很好理解了。 当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新，这是观察者模式的常规定义。 观察者模式是一种 一对多 的设计模式，如下图所示： 继续上面的例子，使用 Bank 对象和 BankDelegate 来模拟这种模式，Bank 有变动的时候，通过 notifyAccount 来授权 onAccountChanged 通知所有注册了 BankDelegate 的用户。 Talk is cheap. Show me the code BankDelegate.h 12345@protocol BankDelegate &lt;NSObject&gt;- (void)onAccountChanged:(NSUInteger)account;@end Bank.h 123456789@interface Bank : NSObject- (void)addBankObserver:(id&lt;BankDelegate&gt;)delegate;- (void)removeBankObserver:(id&lt;BankDelegate&gt;)delegate;- (void)notifyAccount;@end Bank.m 123456789101112131415161718192021222324- (void)notifyAccount&#123; for (id&lt;BankDelegate&gt; delegate in self.delegates) &#123; if ([delegate respondsToSelector:@selector(onAccountChanged:)]) &#123; [delegate onAccountChanged:100]; &#125; &#125;&#125;- (void)addBankObserver:(id&lt;BankDelegate&gt;)delegate&#123; if (nil == delegate) &#123; return; &#125; [self.delegates addObject:delegate];&#125;- (void)removeBankObserver:(id&lt;BankDelegate&gt;)delegate&#123; if (self.delegates.count &gt; 0) &#123; [self.delegates removeObject:delegate]; &#125;&#125; 调用者 12345678910111213141516171819- (void)viewDidLoad&#123; [super viewDidLoad]; [self registerObserver];&#125;- (void)onAccountChanged:(NSUInteger)account&#123; NSLog(@"Bank tell me that account is changed. %zd", account);&#125;- (void)registerObserver&#123; Bank *bank = [Bank new]; [bank addBankObserver:self]; [bank addBankObserver:self]; [bank notifyAccount];&#125; 看到这里，你应该发现 delegate 的设计其实就是观察者的一种设计手段而已，它本身也是观察者模式。 在 iOS 中，除了 delegate，还有很多这种设计模式的体现，如 KVO、Notification、Observer、Block 等。 发布-订阅模式观察者模式中观察者对被观察者(Bank)是有感知的，至少需要实现对应的 BankDelegate，二者之间还是是有一定的耦合度。 那么，有没有一种方法再来降低这种耦合，让双方都不用去关心对方的存在呢？发布-订阅模式是一个不错的选择。 发布-订阅本质也是观察者模式，但是他更加的松耦合，发布者和订阅者都不用清楚对方，全部由订阅中心做处理，这样耦合度就几乎没有了。 如图展示发布-订阅模式： 在 iOS 中，Notification 就是发布-订阅模式的一种实现，NSNotificationCenter 就类似订阅中心。 12345678// 发布[[NSNotificationCenter defaultCenter] postNotificationName:@"name_protocol" object:nil];// 订阅[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onUpdate:) name:@"name_protocol" object:nil]; 争论网上有很多人说，观察者模式和发布-订阅模式是两种不同的设计模式，它们压根就是两码事，不能混为一谈。也有很多人说，两者其实都是观察者模式，只是实现手段有点不一样罢了，本质是一样的。 江湖纷争，众说纷纭！ 设计模式是一种设计思想，在观察者模式基础上你可以衍生更多的设计模式和更多的设计思想。模式的实现手段可以多样化，没有最好只有更好，就好比 MVC、MVP、MVVM 等，你说它们是设计模式也好，是设计思路也罢，关键是利用它们有没有解决业务需求，为了模式而模式的设计华而不实！ 个人觉得，发布-订阅模式只是观察者模式的一种实现手段，它本质还是观察者模式。 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>架构 模块化 组件化 Observer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 中神秘的 GCC]]></title>
    <url>%2F2018%2F10%2F13%2FmacOS-%E4%B8%AD%E7%A5%9E%E7%A7%98%E7%9A%84-GCC%2F</url>
    <content type="text"><![CDATA[这个事情，要从编译一个简单的代码开始说起。 gcc 和 g++ 的区别gcc 是 GCC 中的 GUN C Compiler，C 编译器。 g++ 是 GCC 中的 GUN C++ Compiler，C++编译器。 就本质而言，gcc 和 g++ 并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的 GUN 编译器而已。 gcc 与 g++ 都可以编译 C 和 C++ 文件，只是处理方式不同。 可以参考 GCC的gcc和g++区别 这篇文章。 交换变量：用指针下面这段代码很简单，利用 C 指针实现交换两个变量的目的。 源文件：mz_swap.c 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;// 使用指针的方式交换两个变量int mz_swap(int *ap, int *bp);int main(int argc, char * argv[]) &#123; int xp = 901; int yp = 902; printf("--Before-- xp = %i, yp = %i\n", xp, yp); mz_swap(&amp;xp, &amp;yp); printf("--After--- xp = %i, yp = %i\n", xp, yp); return 0;&#125;int mz_swap(int *ap, int *bp) &#123; if (NULL == ap || NULL == bp) &#123; return -1; &#125; int tp = *ap; *ap = *bp; *bp = tp; return 0;&#125; 在 macOS 下使用 gcc 编译 mz_swap.c，产生可执行文件 exec_main.out，如下操作： 1gcc mz_swap.c -o exec_main.out 编译成功，执行 ./exec_main.out，正常输出结果： 12--Before-- xp = 901, yp = 902--After--- xp = 902, yp = 901 采用 g++ 来编译，如下操作： 1g++ mz_swap.c -o exec_main.out 报出如下警告，该警告的意思是在 C++ 模式下强制编译 C 文件，这里可以不予理会。 1clang: warning: treating 'c' input as 'c++' when in C++ mode, this behavior is deprecated [-Wdeprecated] 虽然有警告，但是编译可以产生可执行文件 exec_main.out 且可以正常执行的，执行结果跟上面一样。 交换变量：用引用大家都知道，C 没有 引用 这个概念，而 C++ 是有 引用 概念的，可以在此了解 C++ 引用. 试一下使用 gcc 编译使用 引用 方式编写的 C 代码，按照说法，gcc 是无法编译通过的。 源文件：mz_swap_ref.c 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;// 使用引用的方式交换两个变量int mz_swap_ref(int &amp;ap, int &amp;bp);int main(int argc, char * argv[]) &#123; int xp = 901; int yp = 902; printf("--Before-- xp = %i, yp = %i\n", xp, yp); mz_swap_ref(xp, yp); printf("--After--- xp = %i, yp = %i\n", xp, yp); return 0;&#125;int mz_swap_ref(int &amp;ap, int &amp;bp) &#123; int tp = ap; ap = bp; bp = tp; return 0;&#125; 编译 1gcc mz_swap_ref.c -o exec_main.out 编译失败，错误信息如下： 12345mz_swap_ref.c:4:21: error: expected ')'int mz_swap_ref(int &amp;ap, int &amp;bp); ^mz_swap_ref.c:4:16: note: to match this '('int mz_swap_ref(int &amp;ap, int &amp;bp); 既然按照 C 的编译方式不行，那就换成 g++ 来编译。 1g++ mz_swap_ref.c -o exec_main.out 编译成功，执行可执行文件 1./exec_main.out 12--Before-- xp = 901, yp = 902--After--- xp = 902, yp = 901 大家可以自己动手试试，使用 clang 来编译 mz_swap_ref.c 和使用 gcc 来编译都是报错，使用 clang++ 和 g++ 编译都是没有问题的。 在博客 GCC: Homebrew 安装 GCC 和 Binutils 中，我已经分享了在 macOS 中的 gcc 和 g++ 不是 GNU 提供的，而是 Apple 自己的 clang。 这里要说明的是即使使用自己安装的 gcc(gcc-4.9) 来编译 mz_swap_ref.c 也是无法编译通过的，验证如下： 1gcc-4.9 mz_swap_ref.c -o exec_main.out 错误信息： 12345mz_swap_ref.c:4:21: error: expected &apos;;&apos;, &apos;,&apos; or &apos;)&apos; before &apos;&amp;&apos; token int mz_swap_ref(int &amp;ap, int &amp;bp); ^mz_swap_ref.c:20:21: error: expected &apos;;&apos;, &apos;,&apos; or &apos;)&apos; before &apos;&amp;&apos; token int mz_swap_ref(int &amp;ap, int &amp;bp) &#123; ^ gcc、g++ 和 clang 的关系在 macOS 中，gcc 以某种方式指向 llvm-gcc 编译器，g++ 亦如此。 1In Apple&apos;s version of GCC, both cc and gcc are actually symbolic links to the llvm-gcc compiler. Similarly, c++ and g++ are links to llvm-g++. llvm-gcc 是 c/c++/oc 的编译器，用了 gcc 前端和命令行界面的 llvm. 1llvm-gcc is a C, C++, Objective-C and Objective-C++ compiler. llvm-g++ is a compiler driver for C++. llvm-gcc uses gcc front-end and gcc&apos;s command line interface. 接下来，我们看一下 llvm-gcc，可以使用 which llvm-gcc 看一下 llvm-gcc 所在位置是 /usr/bin/llvm-gcc，打开目录可以看出其实是一个符号链接，如下图所示： 1ls -l /usr/bin/llvm-gcc 1/usr/bin/llvm-gcc -&gt; clang 它们是统一指向 clang 的符号链接，可以看其原始指向，llvm-gcc 指向 clang，llvm-g++ 指向 clang++。 二者都在 /usr/bin/ 目录下： 其实在 macOS 中 cc 编译器也指向 clang。 总结通过上面的例子，我们至少可以学到如下几点知识： 1、C 语言规范中没有 引用 的概念，使用 C 编译器无法使其编译通过，但是使用 C++ 编译器是可以编译通过的。这是因为各自的编译器是遵循语言规范的。 2、macOS 中的 gcc 和 g++ 苹果开发者们并没有去改造和重写它们，只是分别指向 clang 和 clang++ 编译器。 3、如果不想使用 macOS 中的 gcc 和 g++，就需要自己重新安装 GNU 的编译套件，安装和使用方法已经在博客中有说明。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>gcc g++ clang clang++ cc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN 检出文件]]></title>
    <url>%2F2018%2F10%2F06%2FSVN-%E6%A3%80%E5%87%BA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需求对于一些大工程, 整个 svn 仓库文件过大(动辄几十个G的都有)，不想把整个 checkout 下来，但是又想维持整个目录结构以方便后续使用，那么可以使用 Subversion1.5 之后的 --depth 参数来只 checkout 需要的子目录. 如果只想把 svn 仓库里面某个文件 checkout 到本地, 不想 checkout 整个目录, 如何操作呢? 实施假设需要 checkout 出来的文件是 ReadMe.md, 其 svn 地址是: http://svn.xxx.com/path/ReadMe.md，其上级目录的远程地址是 http://svn.xxx.com/path. 注意：以下出现 svn co 就是 svn checkout 的缩写. 方案一大部分人都会在第一时间想到如下的操作: 1svn co http://svn.xxx.com/path/ReadMe.md 实际上这样操作会报错的, 报错信息大概意思是 不可以 checkout 一个文件, 只能 checkout 目录。 所以，该方案不可行。 方案二第一步: checkout 目录 1svn co --depth=empty http://svn.xxx.com/path/ ./ ./ 表示当前目录，--depth=empty 表示检出空目录。 第二步: 更新文件 1svn up ReadMe.md 这里直接 svn up 就可以将你需要的文件 checkout 出来了。 修改文件后, 也可以直接提交到 svn 仓库. 使用如下命令: 1svn ci ReadMe.md -m &quot;update.&quot; 方案三使用 svn export 命令将文件导出，然后将 svn import 命令导入文件到 svn 仓库。 一般临时想 checkout 一个文件，就会使用 方案三, 比较正式的操作，我会选择 方案二，因为 方案二 这样既可在不增加磁盘大小的情况下保持 svn 仓库的目录结构，又可以任意 checkout 文件。 稀疏目录上面的 方案二，其实就是 svn 的一种稀疏检出的操作。 Subversion 1.5 开始支持稀疏检出，允许对目录设置深度（depth）。 关于 depth 几个参数的含义: –depth empty：只包含目录自身，不包含目录下的任何文件和子目录。 –depth files：包含目录和目录下的文件，不包含子目录。 –depth immediates：包含目录和目录下的文件及子目录。但不对子目录递归。 –depth infinity：这是默认的，包含整个目录树。 使用格式如下: 1svn checkout URL --depth empty|files|immediates|infinity 或者 1svn checkout URL --depth=empty|files|immediates|infinity]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>svn depth 稀疏目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods: 私有仓库]]></title>
    <url>%2F2018%2F09%2F24%2FCocoapods-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[使用场景在我之前的博客中分享了几篇关于 Cocoapods 的文章（文末有链接），今天分享另外一个主题即如何创建你自己的私有仓库以及如何使用私有仓库。 为什么会有这种需求呢？ 开发组内或者公司内，不希望把一些核心的公用代码给到外界使用（不开源），但是这些代码基本很稳定很成熟，可以做成组件给到其他人或者组内使用。 那么，就可以使用 Cocoapods 来创建自己的私有仓库，让大家共享代码，也是组件化的一种方案。 下面的分享全是基于实践所得，中间也遇到很多坑，都被我一一解决了，希望能帮到正在阅读文章的你。 创建仓库这里的创建仓库，包括两个仓库，一个是代码仓库，另一个是 pod 源的仓库。 在 Github 创建 repository，如图： 创建名为 iOS_private_lib 的 repository，这个主要用来存放我们的代码。 同样道理，创建一个 Repo 用于存放私有的 SpecRepo 源，我创建的是 https://github.com/veryitman/private_spec_repo.git 这个仓库。 为了说明问题，这里我使用了 Public 来模拟 Private 仓库。在实际开发中，一般都是使用公司自己搭建的私有 git 服务器来做，我这里主要是为了说明问题。 创建代码工程1. 先 clone 刚才创建的 repo 到本地 123cd ~/workspace/git clone https://github.com/veryitman/iOS_private_lib 2. 创建工程 在 ~/workspace/iOS_private_lib 下使用 pod lib create 创建工程，工程名字为 CoreHTTP，执行命令如下： 123cd ~/workspace/iOS_private_libpod lib create CoreHTTP 根据提示输入对应的信息即可完成创建，如图： 创建成功后，包含一个 Example 例子工程，工程目录如下： 使用 Xcode 打开例子工程，在 CoreHTTP/Classes 中创建文件即可，如下图所示： 3. 编辑 podspec 文件 12345678910111213141516171819Pod::Spec.new do |s| s.name = &apos;CoreHTTP&apos; s.version = &apos;0.1.0&apos; s.summary = &apos;CoreHTTP for create private pod, it is a demo only.&apos; s.description = &lt;&lt;-DESC The project of CoreHTTP is a private pod, it is a demo only. DESC s.homepage = &apos;https://github.com/veryitman/iOS_private_lib.git&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;veryitman@126.com&apos; =&gt; &apos;veryitman@126.com&apos; &#125; s.platform = :ios, &quot;7.0&quot; s.source = &#123; :git =&gt; &apos;https://github.com/veryitman/iOS_private_lib.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;CoreHTTP/Classes/**/*&apos; s.requires_arc = trueend 这里需要注意，如果 s.source_files 写的不对，会报下面的错误。 1- ERROR | [iOS] file patterns: The `source_files` pattern did not match any file. CoreHTTP 的名字必须是你代码存放的文件夹名，而且这个文件件要与 podspec 文件在同一级文件目录下，从上面截图的目录结构可以看出。 另外一个提示的错误点，可能是因为空目录的问题造成的，如果这样的话，可以在各个文件夹下面创建 .gitkeep 文件，该文件的作用是为了提交空文件夹，因为 git 默认是不会添加空文件夹到仓库的。 创建 .gitkeep 文件的命令如下： 123cd 文件夹下touch .gitkeep 这里我折腾了蛮久，最后思考和参考了自己之前的开源项目管理博客，才解决这个问题。 4. 检查和验证本地 podspec 文件 123cd CoreHTTP pod lib lint CoreHTTP.podspec 验证通过会显示如下图所示的成功提示 使用 Xcode 打开工程，删除对应以 Test开头 的相关的库和文件夹，确保 Xcode 能编译通过，选择模拟器即可。 这里一定要先清空 cocoapods 的缓存，否则后面远程验证还是报错，无法通过验证。 清空 cocoapods 的缓存，命令如下： 123rm ~/Library/Caches/CocoaPods/Pods/External/CoreHTTPrm ~/Library/Caches/CocoaPods/Pods/Specs/External/CoreHTTP 5. 上传工程到 Github 远程代码仓库 1234567cd ~/workspace/iOS_private_libgit add CoreHTTP/git commit -m "Add lib."git push 6. 给版本添加 tag 12345cd ~/workspace/iOS_private_libgit tag 0.1.0 -m "Add lib and example project."git push --tags 7. 进行远程验证 123cd ~/workspace/iOS_private_libpod spec lint CoreHTTP/CoreHTTP.podspec --verbose --use-libraries --allow-warnings 注意：--verbose 选项是为了看编译和验证信息，--use-libraries 是为了能支持 i386 架构，如果不加此参数，私有库无法通过验证，--allow-warnings 参数是允许有警告。 验证成功的示意图： 提交私有 podspec1. 向本地的 cocoapods 仓库添加私有 Spec Repo 123cd ~/workspace/iOS_private_libpod repo add PrivateSpec https://github.com/veryitman/private_spec_repo.git 这里一定要注意：对应的地址是 SpecRepo 仓库地址而不是代码仓库地址。 本地存放 spec 的私有仓库名称，我这里取名为 PrivateSpec，你也可以取其他名字，但是记住在下面的步骤中要保持一致。 1ls -alt ~/.cocoapods/repos/ 可以看到已经成功添加本地 repo 中，其他 master 是 cocoapods 官方公开的源，其他为私有源。如下图所示： 2. 向私有的 Spec Repo 中提交 podspec 下面的 PrivateSpec 是与上面的名称对应的。 123cd ~/workspace/iOS_private_libpod repo push PrivateSpec ./CoreHTTP/CoreHTTP.podspec --verbose --use-libraries --allow-warnings 这里要注意，添加私有库和之前博文 Cocoapods 管理开源项目 中提到的 pod trunk push 是不一样的操作。 使用私有库1. 搜索库 1pod search CoreHTTP 如果搜索不到，可以执行下面的两条命令: 123rm ~/Library/Caches/CocoaPods/search_index.jsonpod setup 然后继续搜索就可以了，搜索成功会显示如下内容： 123456CoreHTTP (0.1.0) CoreHTTP for create private pod, it is a demo only. pod &apos;CoreHTTP&apos;, &apos;~&gt; 0.1.0&apos; - Homepage: https://github.com/veryitman/iOS_private_lib.git - Source: https://github.com/veryitman/iOS_private_lib.git - Versions: 0.1.0 [PrivateSpec repo] 为了避免和其他私有库命名冲突，建议在自己的私有库前面加上公司或者其他标示，如 TepdCoreHTTP、FphCoreHTTP 等。 2. 在 Podfile 文件的顶部添加 source 12source &apos;https://github.com/veryitman/private_spec_repo.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos; 注意一个是我们私有 SpecRepo 地址（非私有代码库地址），另一个是官方公有源地址。 使用私有库的工程的 Podfile 写法示例如下： 12345678source &apos;https://github.com/veryitman/private_spec_repo.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;7.0&apos;target &apos;TestCoreHTTP&apos; do pod &apos;CoreHTTP&apos;, &apos;~&gt; 0.1.0&apos;end 在工程中可以直接使用私有库了，示例代码如下： 1234567891011121314151617#import &quot;ViewController.h&quot;#import &lt;CoreHTTPHeader.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *lib_desc = [CoreHTTPHeader libDesc]; NSLog(@&quot;The HTTP&apos;s library desc: %@&quot;, lib_desc);&#125;@end pod 命令12345678//将工程添加到本地 repo 中 pod repo add [本地私有仓库名] [远程仓库地址]//移除本地 repopod repo remove [本地私有仓库名]//查看本地 repopod repo 12345//只从本地验证你的pod能否通过验证pod lib lint *.podspec//从本地和远程验证你的pod能否通过验证pod spec lint *.podspec 参考文档Private Pods 我的其他文章Mac install Cocoapods Cocoapods 问题集锦 Cocoapods 管理开源项目 iOS 项目: 打造本地 pod 库 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>iOS cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈客户端模块化]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%B5%85%E8%B0%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[回忆大学那会喜欢跟着老师在实验室折腾，感觉每天大脑中都有新知识鱼贯而入。 当我被告知要做一个最小单片机系统的时候，兴奋而又紧张！ 最小单片机系统示意图： 从画 PCB 到制板、洗板，再到选择元器件，最后组装调试和写代码，我花费了两个多月的时间，当板子上面的跑马灯亮起来的那一刻，我激动的无法言语。 大家可以看到这个最小单片机系统上面有很多组件组成，有电阻、电容、电阻、二极管和卡槽等，当然还有最核心的组件就是单片机，当时用的是51单片机。 各个元器件就好比组件，功能单一，职责明显，组件之间遵循协议构成模块，最终组合成为（最小单片机）系统。 上面的回忆是为了引出今天的分享，分享的主要内容是客户端开发中常用的模块化、组件化、插件化以及热更新等技术辞藻，并没有涉及到具体的技术问题。 模块化和组件化从程序设计的角度出发，无论是模块化还是组件化，都是指软件架构的范畴，是一种设计思想。两者并没有严格意义上面的区分，二者的目的一致，就是将工程结构化，达到可复用可伸缩的能力，最终提供工作效率。 在说模块化和组件化之前，先解释一下什么是高内聚低耦合。 高内聚：组件内尽可能独立完成自己的功能，坚持单一职责的原则 SRP，不依赖于其他组件的代码。 低耦合：模块与模块之间尽量不要互相引用，模块之间联系越复杂耦合度越高，修改的成本就越高。 组件更加强调可替换可复用的特性，职责和功能比较单一、独立，与其他组件之间没有耦合性。 模块更加强调组合特性，更加偏重于业务，比如一个社区项目，登录注册、论坛和个人中心都是模块，这些业务模块又是有很多个组件组合而成。 下图展示的是一个简易的论坛系统示例图，如下： 可以看出，各个组件可以单独使用到其他模块当中，各个模块之间相对独立，只要定义好模块之间的通信协议，就可以做到并行开发，各个模块甚至可以复用到其他系统之中。 通信机制这里说的通信机制并不是指 HTTP 或 TCP 的通信方式，而是指组件与组件之间，模块和模块之间的交互方式。 正常情况下，写业务功能的代码，在不同组件之间需要相互调用，这样就需要 import 其他组件，无形之中就增加了组件之间的耦合度。 有开发经验的同学，可能会用到类似 java 的反射机制，或者一些动态语言的运行时机制如 Objective-C Runtime，对它们不进行 import，而是动态的解析代码，达到组件之间或者是类之间相互调用的目的。 现在提倡也是比较热门的技术是通过路由通信机制，来进行组件之间的通信。这里举一个实际使用场景。 用户安装了我们的 APP，运营同事在某个节日来临之际做一个促活跃的活动，期望用户点在打开推送通知的时候，打开 APP 后可以直接跳转到对应的活动详情页面。大致流程如下： 这是一个再常规不过的需求了，相信经历过产品开发的朋友都见过这种需求。 很显然，我们可以使用路由的通信机制来完成这个需求，开发的流程图大致如下： 这里关键的核心得益于 iOS 和 Android 平台的 scheme 机制，对于 scheme，通俗的讲就是一种可以跨进程或者进程内的通信协议，例如可以在 APP 中打开某个应用商店。 例如下面的 URL： 1bbs://page/activity/activity_detail?id=8978&amp;user_id=67890432 其中，bbs 就是 scheme，可以看到该 URL 完全可以被各自平台来解析。 iOS 和 Android 平台各有很多开源的路由方案，实现手法各有差异，但是思想是一样的，建议大家去了解和学习。 不过，现在你只要知道，路由的通信机制大大降低了组件之间的耦合性就够了。 插件化插件这个词，大家应该很熟悉，例如 Chrome 浏览器中可以安装各种小工具，这些小工具就是插件，还有各种开发使用的 IDE 也支持插件安装，便于提高我们的工作效率。Chrome 和 IDE 被称之为宿主，插件寄生于他们。 支付宝和微信里面的小程序也可以看成是一个个插件，但是他们不能脱离支付宝和微信独立运行。 可以发现这些插件即使被卸载或者被删除，并不会让 Chrome 或者 IDE 受到影响，换句话说，插件让宿主锦上添花。 这种插件思想当然可以运用到 APP 中来，试想一下，如果某个 APP 在线上经过动态下载就具有了一个强大或者好用的功能，岂不美哉？！ 插件化，将 APP 拆分成很多模块，这些模块包括一个宿主和多个插件，宿主提供插件的管理和通信协议及规范，每个模块都是一个的库或者功能包。 插件化是一种编程和解决问题的思想，没有统一的定义。在 Android 上面运用比较多，iOS 上面很少，并不是 iOS 没有这样的技术，主要是因为苹果审核等各方面的限制。在 iOS8 上的 App Extension 功能，也可以看做是插件化了。 在 Android 平台中，插件化已经不是很新鲜的技术了，VirtualAPK、Atlas、Replugin 等框架相继开源，插件化技术已经进入了比较成熟的阶段了。 插件化的编程思想和实现，在不同的平台有所差异，即使在同一个平台上面都会有不同的实现手段，建议选择一个开源方案去了解其原理，然后试着动手去实现一个，千里之行始于足下！ 热更新“不好了，昨天有很多用户反馈我们的 APP 出现闪退。“ 小王一大早的开始撕喊，坐在他旁边的开发大神们顿时微笑凝固，马上去后台看上报的崩溃日志，紧接着开始复现和解决问题，最终得出结论，需要重新提审 APP，并周知渠道部门做好更新准备。 试想一下，如果一个游戏几G的大小，你让用户为了你的一个小失误来整包更新游戏，用户和你估计都要疯了。 最近几年，随着业务发展的需求，热更新技术也是得到了突飞猛进的发展。类似于上面的场景，能在用户神不知鬼不觉的情况下使用热更新的技术解决崩溃的问题，岂不是两全其美。 Android 的热更新技术如火如荼的发展着，而苹果这边严厉禁止热更新，一旦检查到立即会责令你修改或者下架 APP。我们还是从技术的角度来看这个问题，学习和了解一下对应的技术总归没有错，这里 有 iOS 上面的热更新方案，另外 Android热修复方案比较 介绍了很多 Android 热更新的开源的方案，可以了解学习一下。 站在跨平台的角度，我个人比较推荐使用 Lua 实现热更新，Lua 不仅简单高效，而且可以很好的和 C/C++ 结合在一起，而 Android 上面通过 JNI 又能与 C/C++ 通信，iOS 上面就更加不用说了。这只是我个人的一点看法，不喜勿喷。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>架构 模块化 组件化 热更新 插件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 演进史]]></title>
    <url>%2F2018%2F09%2F16%2FHTTP-%E6%BC%94%E8%BF%9B%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[精通 HTTP 吗？在面试相关开发岗位的同学中，我经常会问一些跟编程语言不相关的东西，比如下面这些问题： 1. 你平时是怎么学习的？学习渠道有哪些？2. 项目组中，你认为最重要的是什么？3. 你在项目组中遇到的最大困难（非编程问题）是什么，你是怎么解决的？4. 项目执行过程中，其他同事遇到困难，你是如何做的？ 这些问题可以让面试者自由发挥的题目，并没有固定的标准的答案。这样的问题问出来有诸多好处，首先可以让面试者稳定一下心态不至于太紧张，其次可以看看他的语言组织能力和表达能力，从中也能看出他有没有过实际的项目经验。 很多人的简历上面写的很完美，做过诸多项目，精通某某语言的编程，精通各种网络协议，熟悉各大操作系统等等，当深入问他们熟悉的知识时，发现他们的回答却含糊不清。不排除世界上有这样的全才，但是肯定不会被我们轻易遇到，至少我觉得自己还没有达到那个能力。 如果你还没有但又想精通各种知识，就慢慢去学习并精通相关的知识，循序渐进，相信自己会做到的。好了，不扯了，今天聊聊 HTTP 的发展历史。 我敢保证有绝大部分的人不知道 HTTP/2，虽然他早就来临. HTTP 0.x 到 HTTP/2HTTP/1 是 HTTP 1.0 和 HTTP 1.1 的统称，分别指 HTTP 协议的版本是 1.0 和 1.1. 1960年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）, 这成为了 HTTP 超文本传输协议标准架构的发展根基，所以他被称之为 HTTP 之父。 1989年3月在 CERN（欧洲核子研究组织）工作的 Tim Berners-Lee（蒂姆.伯纳斯.李） 提交了一个提案 Information Management: A Proposal，该提案描绘了其对万维网（World Wide Web）最初的设想即能让远隔两地的人们共享知识，Tim 是 万维网之父，成就和贡献也是不计其数。 直到1990年 HTTP 才算是问世，姑且称之为 HTTP 0.x 版本，也有些地方称之为 HTTP 0.9 版本，总之这不是一个正式版。1996年5月，HTTP 1.0 作为 HTTP 的第一个正式版本正式公布，并记载于 RFC1945 中。 随着人们对互联网的认知和技术的发展（尤其是浏览器等相关的技术），发现 HTTP 1.0 缺点还是比较多，无法满足快速的互联网发展需求。于是在1997年1月发布了 HTTP 1.1 版本，并记载于 RFC2068 中，后来在1999年6月，对 RFC2068 又做了补充和修正，称之为 RFC2616, 至此 HTTP 1.1 开始一统天下，直到现在绝大数开发者使用的都是 HTTP 1.1 版本。 另外一个版本 HTTP/2 标准于2015年5月以 RFC 7540 正式发表，多数主流浏览器已经在2015年底支持了该协议，时隔多年，HTTP/2 才问世。 苹果从 iOS9 开始支持 HTTP2.0，对 iOS 开发人员来说从 iOS9 开始 NSURLSession 可以支持 HTTP2.0 了。目前 Android 绝大部分系统不支持 HTTP/2，Android 原生 HttpURLConnection 框架并不支持 HTTP/2，但可以选用三方开源库 okhttp 作为网络框架，Android 5.0+（系统版本）设备才支持 HTTP/2。所以想全面使用 HTTP/2 还是要付出一定的代价，不过随着技术的革新，相信 HTTP/2 将会大放光彩。 HTTP 不断的改进用一张图来描述 HTTP 的不断改进和演变史，如下图所示： 下面具体看看这些协议版本的演进过程中，究竟是新增和改进了哪些东西？ HTTP 0.9HTTP 0.9 并非出自某个标准化组织，只是 Tim 的个人作品而已，比较简单。可以参阅这篇文章 The Original HTTP as defined in 1991 ，该版本规定了 HTTP 使用 TCP/IP 连接，HTTP 请求只有一个请求行，只有一个 GET 方法加上请求的URI。HTTP 响应则直接返回 HTML 文本，没有状态码，所以也没有办法区分错误消息和正常的文本。可以看出，HTTP/0.9并不完善，也不是那么完美，但是这的确是 Tim 坚持下来的结晶。 HTTP 1.0HTTP 1.0 增加了请求头域和响应头域，增加了 HEAD 和 POST 方法，响应对象不再局限于 HTML 文本，支持长连接和缓存机制等等。 HTTP 1.0 具体特点 1.可以发送更多格式的内容，如图像、视频、二进制文件，不仅仅局限于文字了。 2.增加了 POST 和 HEAD 方法。 3.改变了 HTTP 请求和回应的格式。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据，即增加了请求头信息，响应数据不再局限于 HTML 文本。 4.新增状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等功能。 5.增加了长连接的支持，不过 HTTP 1.0 需要在 request 中增加 ”Connection： keep-alive“ header 才能够支持，后面要说到的 HTTP 1.1 默认就支持了。 可以看出，HTTP 1.0在 HTTP 0.9 的基础上做了大量的扩充和改进。 HTTP 1.0 主要缺点 1.每次请求都需要建立 TCP 连接，即每对 Request/Response 都使用一个新的连接。 2.不支持断点续传。 HTTP 1.1每个新版本的诞生基本都是对上一个版本的补充和改进，就像我们的软件开发一样，协议也需要迭代。 HTTP 1.1 具体特点 1.加强和优化了持久连接即长连接。 HTTP 1.1 支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP 1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP 1.0 每次请求都要创建连接的缺点。 2.增强了缓存机制。 引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头。 3.请求头引入了 range 头域。 它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 4.将 Content-length 字段的作用进行扩充，即声明本次回应的数据长度（一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的）。 5.采用分块传输编码。 对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用流模式（stream）取代缓存模式（buffer）。 6.新增了许多动词方法：PUT、PATCH、HEAD、OPTIONS、DELETE。另外，客户端请求的头信息新增了 Host 字段，用来指定服务器的域名。 7.新增了 24 个错误状态响应码。 HTTP 1.0 主要缺点 HTTP 1.1 虽然增加了很多功能，在一定程度上已经很强大了，但是他自身也是有缺点的，换句话说有优化的空间，主要问题如下： 1.队头堵塞（Head-of-line blocking），各个请求到达的服务器的速度是不同的，如果先发的请求先到达可能会发生阻塞，剩下所有的工作都会被阻塞在那次请求应答之后，这样就降低了带宽。 为了避免这个问题，有两种方法：一是减少请求数，二是同时多开持久连接。 2.臃肿的消息头部 3.不支持服务端推送，例如要求使用 HTTP 协议做一个服务端数据变动页面立即改变的组件就不好做，可用轮询的方式进行，这样就会对带宽影响较大。 SPDY在说到 HTTP/2 之前，必须要先说说 SPDY。SPDY 是由 Google 公司推出的，SPDY 的推出是为了解决 HTTP 1.1 中存在的一些问题的。 1.多路复用（multiplexing） 多路复用通过多个请求 stream 共享一个 TCP 连接的方式，解决了HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。 2.可以对请求设置优先级 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 3.对请求头的压缩 选择合适的压缩算法可以减小包的大小和数量，这样在一定程度上可以提高网络使用效率。 4.为了数据传输的安全性，强制使用基于 HTTPS 的加密协议传输。 5.支持服务端推送。 称之为 Server Push 功能，服务器在还没有收到客户端的请求，服务器就可以把各种资源推送给客户端。 比如，客户端只请求了 index.html，但是服务器把 index.html、x.css、x.jpg 等资源全部发送给客户端。这样的话，只需要一轮 HTTP 通信，客户端就得到了全部资源，提高了通信的性能，也提高了用户体验。 HTTP/2本质上来讲，HTTP/2 是建立在 SPDY 基础之上的，借鉴了很多 SPDY 的设计思想和策略。 HTTP 具有 SPDY 的优点，同时自己也有与 SPDY 的不同点，主要如下： 1.HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。这一点 HTTP/2 相对人性化一些。 2.HTTP/2 会对请求头和响应头做压缩以提升请求性能，HTTP/2 消息头的压缩算法不同于 SPDY。 HTTP/2 采用 HPACK，SPDY 采用的 DEFLATE 算法。 HTTP/2 支持所有的 HTTP 1.1 的核心特征，其提供了 HTTP 语义的传输优化，并且在各方面做到更高效。HTTP/2 的头信息是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为帧（frame），即头信息帧和数据帧。对 HTTP/2 感兴趣的可以看一下 HTTP2 协议初识 这篇文章。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>Wireshark udp http https spdy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark: 简单分析 TCP 三次挥手]]></title>
    <url>%2F2018%2F09%2F09%2FWireshark-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-TCP-%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[话说握手你要是开发人员，相信你一定听说过 TCP（Transmission Control Protocol 传输控制协议）或是 TCP 握手的说法。 所谓握手，通俗来讲就是通信双方协商在后续通信过程中需要使用的通信信息的过程。TCP 为了建立可靠的连接需要三次握手，后续给大家分享 TLS 为了实现加密、校验、身份认证同样需要握手的过程。 TCP 三次握手可以使用下图来表达： 本篇给大家分享如何使用 Wireshark 来跟踪 HTTP 包，查看 TCP 握手的过程。 在看下面内容之前，先简单看一下 TCP 协议报头。 下图是 TCP 报头的格式： 其中，Seq(Sequence Number) 是 32 位的序列号，Acknowledgment number 称之为确认序号，也是 32 位的，但是他不是标志位 ACK，这个要区别开，当 ACK 置 1 时 Acknowledgment number 才有效，指接收方期待的下一个报文段的序列号。 TCP 报头信息中有六个控制位(标志位)，分别是：SYN、ACK、PSH、FIN、RST 和 URG。 123456SYN: 表示建立连接FIN: 表示关闭连接ACK: 表示响应PSH: 表示有数据传输RST: 表示连接重置URG: 表示紧急数据 Seq 序列号有两个作用：第一，在 SYN 置 1 时，此为当前连接的初始序列号(Initial Sequence Number, ISN)，数据的第一个字节序号为此 ISN+1。第二，在 SYN 置 0 时，为当前连接报文段的累计数据包字节数。 TCP 协议设计比较复杂，其涉及的知识较多，这里大家整不明白也没有关系，并不影响你阅读下面的内容，如果对 TCP 协议本身感兴趣，可以去拜读【TCP/IP 详解，卷 1：协议】这本书。 网络模型每次说到网络层，就要拿出类似下面的网络模型图，OSI 将网络模型分为7层，TCP/IP 模型将网络模型分为 4 层，网络 4 层模型由 7 层模型简化合并而来，没有本质的区别，如图： HTTP 仅仅是个协议，属于应用层的面向对象的协议，从上图可以看出 HTTP 是在 TCP 基础之上的。 HTTP 协议一共有五大特点 1、支持客户/服务器模式2、简单快速3、灵活4、无连接5、无状态 这里强调一下 无连接 和 无状态 这两个特点。 无连接，指的是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。Keep-Alive 特性不在本篇讨论范围，暂时你可以将其忽略。 无状态，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，不会记录任何信息。 可以利用 HTTP 的这两个特点来分析 TCP 三次握手的过程。 三次握手过程以 GET 请求下面地址为例，使用 Wireshark 抓包。 1http://www.baidu.com/news/detailV3.html?id=1279391&amp;COMMON_ACCESS_TOKEN=(null)&amp;COMMON_ACCESS_TOKEN_SECRET=(null)&amp;_cT=IOS&amp;_cV=3.1.3&amp;_cA=PM 看返回结果，选中 HTTP/1.1 200 OK 右键, 在弹出框中选择 Follow/TCP Stream，如下图所示： 关闭弹出的弹窗，回到主界面，看到如下图所示的三次（红色 1、2、3处） TCP 握手过程： 第一次，请求客户端发送一个 [SYN] 包，序列号是 0（Seq=0）。 第二次，服务器会发送一个 [SYN, ACK] 包，序列号是 0，ACK 是 1（Seq=0，Ack=1）。 第三次，客户端请求服务器，客户端会发送一个 [ACK] 包，序列号是 1，Ack 是 1（Seq=1，Ack=1）来回复服务器。 简单的画一个草图，如下： 这个过程，简单描述为下面三个步骤： 1.发送方给接收方发送 SYN 信号，此时发送方处于 SYN_SEND 状态。2.接收方确认并回复给发送方 SYN/ACK 信号，此时接收方处于 SYN_RCVD 状态。3.发送方给接收方发送确认 ACK 信号，发送完毕后，发送方(客户端)进入 ESTABLISHED 状态，当接收端(服务端)接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 上面的步骤，建议感兴趣的朋友去实际操作一下。 为什么是三次握手回头再来想一想，TCP 的连接为什么需要三次握手呢，为什么不是一次，两次呢？一次不就挺好吗，三次是不是有点多此一举了？ TCP 协议不是一个人定出来的而是一群人拟定的，设计三次握手固然有它的意义，是经过精心设计且在性能和效率上面衡量过的。 在知乎 TCP 为什么是三次握手，而不是两次或四次？ 上面有不错的答案，虽然有些回答比较搞笑，但是很好理解，比如这位仁兄： 我们不妨换个思路来想这个问题，TCP 协议设计初衷是 让数据进行可靠，高效，安全的传输，如果握手是一次，两次或四次，就无法很好的保证 TCP 的 可靠，安全及高效 的传输，说不定哪天有人设计出来一种可替代 TCP 协议的其他协议就是两次握手或者不需要握手，哈哈！ 参考阅读如何理解HTTP协议的“无连接，无状态”特点? TCP 为什么是三次握手，而不是两次或四次？ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip udp http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark：抓取 HTTP 包]]></title>
    <url>%2F2018%2F09%2F01%2FWireshark%EF%BC%9A%E6%8A%93%E5%8F%96-HTTP-%E5%8C%85%2F</url>
    <content type="text"><![CDATA[开篇简要初识 Wireshark 简单介绍了强大的 Wireshark 工具，想用好或者是说想发挥 Wireshark 的巨大威力，还有很长的路要走（对我来说）。学习 Wireshark 的成本要比其他网络抓包工具的成本高，所以请做好学习的准备。 我身边很多开发同事，甚至包括一些刚入职的测试工程师都不喜欢使用抓包工具，遇到问题凭着自己的感觉在那里侃侃而谈，既耽误时间又没有解决问题，有时候还伤了和气，明明可以使用工具可以解决的问题，偏偏要各抒己见。 说到 Wireshark 更是很少人使用，至少我身边的同事是这样。如果让你一直去看那些 RFC 等网络协议，不到半小时估计你就会感到疲惫，但是结合 Wireshark 来理解网络协议就会感到无比的快乐，何乐而不为呢？！ 继续阅读下去，你可以了解到如下几个知识： 1. 如何抓取 PC 端、iOS 设备的网络包？2. 使用一些过滤条件如何查看包的内容？3. 如何在 Wireshark 中显示域名？ PC 端的 HTTP 请求打开 Wireshark，选择对应的网口，因为我使用的是无线网络（WiFi），所以选择 Wi-Fi：en0 这个网口，你可以根据你的网络使用情况来选择对应的网口，如下图： 可以看到对应有网络数据的网口，Wireshark 还在右侧显示对应的波浪，很人性化的设计。双击对应的网口，就可以使用 Wireshark 来抓包看数据了。 下面我就以 PC 端访问 www.veryitman.com 来演示 HTTP 请求的抓包情况。 查看本机的 ip 地址，我的是 10.4.17.7, 再来看一下 www.veryitman.com 对应的 ip 地址： 1ping ww.veryitman.com 显示结果如下： 164 bytes from 185.199.110.153: icmp_seq=0 ttl=52 time=317.074 ms 那么， 185.199.110.153 就是其对应的 ip 地址。总的来说，对于 PC 端，源地址是 10.4.17.7，目的地址是 185.199.110.153，对于服务器来说，正好反过来。 首先在过滤器中输入 http, 如下图所示： 然后打开浏览器，我使用的是 Chrome，打开 http://www.veryitman.com/2018/08/20/%E5%88%9D%E8%AF%86-Wireshark/ 网站站点，Wireshark 显示如下（部分截图）： 改变一下过滤语句，将之前的 http 改为 ip.src==10.4.17.7 &amp;&amp; http &amp;&amp; ip.dst==185.199.109.153， 显示如下： 可以选择任何一个请求，展示区域如下： 上图中的三个区域分别对应的是 View 中的 Packet List， Packet Details，Packet Bytes 三个视图。 选择任何一个请求，在对应的 区域2 可以看到该请求的详情。 刚才使用的过滤条件只看到 PC（客户端）的请求，没有看到服务器返回信息，我们修改一下过滤条件为 ip.src==185.199.109.153 &amp;&amp; http &amp;&amp; ip.dst==10.4.17.7，这样就看以看到服务器的回包信息了，如下图所示： 双击进入该响应，就可以看到对应的响应数据详情了。 iOS 设备的 HTTP 请求跟查看 PC 端的 HTTP 请求方式基本一致，只是此时的本机 ip 地址是手机端的而不是 pc 端的。 初识 Wireshark 中已经跟大家分享过如何去连接 iOS 设备到 Wireshark 抓包了，这里不再赘述。 至于查看 iOS 设备的 ip 地址，就很简单了，打开 设置/wifi 看一下详情就知道了。 显示域名如果你经常使用 Charles 抓包，就可以发现 Charles 展示的请求中都是以域名来显示的，但是在 Wireshark 都是显示 ip 地址，或许因此感到不适，那么，Wireshark 能否展示域名呢？ Wireshark 是可以像 Charles 那样展示域名的，只是它默认显示 ip 地址罢了。 打开 Preferences，如图： 这样 Wireshark 的显示就是另一番景象了如下图所示： 当然，你也看出来了，过滤条件还是可以使用的。 你还可以使用其他的过滤条件，如下面的一些过滤条件，能帮你快速定位你要的数据。 12345http.host == &quot;veryitman.com&quot;http.host contains &quot;veryitman.com&quot;http contains &quot;HTTP/1.1 200 OK&quot; 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip udp http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卖废品的一次经历]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%8D%96%E5%BA%9F%E5%93%81%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[偶遇这两天在收拾屋子，本来想把一些不重要的物品直接卖掉，省得给自己增加运输成本。但是又有些不舍，毕竟跟自己在一起生活了这么多年，每一本书，每对桌椅，每件衣服都是我和老婆努力挣钱买回来的，里面都包含着奋斗的故事。 话又说回来，无舍无得。于是，我就开始将物品分类，按照优先级挑选，重要的东西就放到箱子中，次要的就放到沙发上，不重要的就扔到大厅里，最后再来审视一遍这些不重要的物品是否还有留下来的必要，最终我把不重要的东西放到一个大袋子中，准备把它们卖给废品站。 在百度上面找了好几家附近收废品的，打电话过去都要求卖家自己把东西拿过去，态度十分不友好，我也就没再多问，就挂掉了电话。 无独有偶，中午下楼去买东西回来的时候，正好看到一个大爷骑着三轮车在我前面驰骋，大爷的车技贼溜，在小巷子中开出了赛车的感觉。还没等我张嘴，他就即将要离开我的视线，急中生智，我看到他车子后面留有电话，于是我就急忙的努力的追赶着去记住他的电话，最后迫不及待的放下手中的东西，拿出手机拨打了他的电话。 大爷办事利落，不一会就到了楼下，三下五除二的把废品收拾了一番，像是收获了一批战利品一样。他很惊诧为什么我知道他的电话，我说我看到了你车上的电话号码了，就记下来了。 大爷说：“小伙子，你的记性还真好，不愧是上过大学的人。“，我说：“是呀，我过目不忘！哈哈！”。 那天中午，我把东西半卖半送的都给这位大爷了，谁叫他夸我呢！ 思量上面这件事算不上什么大事，顶多也就算个鸡毛蒜皮的小事，但是给了我很多回忆和思考。 很多高中生也包括他们的家长们，都经常会说等上了大学就好了，不用那么累了，在大学的殿堂里可以无忧无虑的 享受 了。在我看来这是不对的，高中之所以累是因为有连绵不绝的作业和没有尽头的考试，当然还有班主任喋喋不休的教导，让你的神经时长处于紧绷的状态。高中是人生中必经的一个过程，至少我觉得它锻炼了我的意志和耐力，包括对心理上的考验，我很感激高中三年的生活。 大学生活和学习的确是一个值得向往和想象的，你可以吊儿郎当的过完几年大学生活，也可以努力拼搏过来，没有人逼你去怎么做，完全取决于你自己。 我大学的成绩算是优异，每次看到奖学金名单上有自己的名字，同学们都会说你真厉害，居然考这么好的成绩。我会说，如果你再努力一下肯定比我考的更好，就像那个大爷说我好记性一样，其实并不是我过目不忘，而是自己努力的结果，因为我知道自己并不是天才。 很多人进入社会参加工作后，发现工作并不是想象中的那般一帆风顺，自己一起进公司的同事，明明能力和自己相当甚至还不如自己，为什么别人就升职加薪，马上就要走上人生巅峰了，自己却还是原地踏步或者举步维艰呢？总是想不明白这是为什么，那是因为你自己没有看到别人比你更加努力。 还有不少人会抱怨为什么别人能力没有我强，领导偏偏把一些重要的事情交给了他，开始怀疑对方是不是对领导施了什么魔法，而自己从来都没有想过怎么去向对方请教，或者思考自己是不是真的做好了本职工作。 这件小事给了我几个启发： 1. 一定要给自己树立一个长远目标和短期目标，不断的完成短期目标，向长远目标前进。 2. 对于别人的赞美或是诋毁，要保持一颗平常心，戒骄戒躁。 3. 不要总是夸你的孩子聪明，要夸他比别人更努力，因为努力比聪明更重要。 4. 不要总是抱怨命运的不公，多去审视自己的不足，想办法去补全。 5. 有个可以交心的朋友尤为重要，可以让彼此敞开心扉，无所顾忌的交谈。 这个世上没有免费的午餐，一切都要靠你自己去奋斗去争取，机会总是留给有准备的人，坚持自己的目标一直前行，相信自己，机会总有一天会和你不期而遇。 相信总有一天，你会感激正在努力的自己！ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 感悟 学习 阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Wireshark]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%88%9D%E8%AF%86-Wireshark%2F</url>
    <content type="text"><![CDATA[使用 Charles 介绍了在 MacOS 上面的使用 Charles 工具, 虽然 Charles 很不错, 但是其只能抓 HTTP/HTTPS 的包, 对 TCP、UDP 等其他协议的网络包, 爱莫能助。 今天给大家分享强大的网络抓包工具 Wireshark，算是初步认识一下这个工具，后续分享更多关于 Wireshark 的内容。 简介Wireshark 是免费的，支持 Windows、MacOS 和 Linux，提供丰富的 GUI 交互，能分析所有的网络协议，并且是开源的。 掌握好 Wireshark，能对绝大部分的网络协议进行分析了，所以学习它的使用对你的工作不无裨益。 关于 Wireshark 本身 UI（展示的界面内容） 的部分不在本文的讨论范围内，更多关于 Wireshark 的介绍和特性，可以去 Wireshark 官网 查阅。 安装我的 MacOS 版本: 点击 Wireshark 的 下载地址, 可以去下载对应的平台版本。 注意: 之前的 Mac 系统版本可能需要安装 x11, 现在新系统不需要安装了. 抓 iOS 设备的数据包想抓 iOS 设备的网络数据，需要让 iOS 设备数据通过 MacOS 才行，因为 Wireshark 是针对网口进行抓包的。 当然了，你的 iOS 设备不需要越狱. 通过 usb 连接 iOS 设备后，接下来创建远程虚拟接口，在终端执行下面命令： 1rvictl -s 设备id(udid) rvictl 即 Remote Virtual Interface Tool。它可以通过 iOS 设备的 UDID 创建一个虚拟网卡，然后通过这个虚拟网卡监听设备上所有的网络流量。 执行成功后，Mac 会出现一个对应的虚拟网络接口，名字是 rvi0（如果有多个 iOS 设备， 则累加，rvi1，rvi2…），如下图所示： 只要启动 Wireshark，监听 rvi0 接口就能抓到 iOS 设备的数据了。 关于获取 iOS 设备 ID(UDID)，可以使用 Xcode, 在 Window/Devices and Simulators 中选择相应设备，右面设备信息的 identifier 里就是对应的 UDID. 也可以通过 iTunes 或者第三方工具如 iTools 获取. 你可以安装 ideviceinstaller 来查看设备 ID. 1brew install ideviceinstaller 然后执行下面命令： 1idevice_id -l 以抓取下面的一个 HTTP 请求为例，简单说明一下相关的知识。 GET 请求： 1/news/detailV3.html?id=1279391&amp;COMMON_ACCESS_TOKEN=(null)&amp;COMMON_ACCESS_TOKEN_SECRET=(null)&amp;_cT=IOS&amp;_cV=3.1.3&amp;_cA=PM 看返回结果，选中 Rsponse(200 OK) 右键, Follow/HTTP Stream，如图所示： 在弹出的窗口中就可以看到具体的响应内容，以及响应的 json 数据。 过滤器过滤在 Wireshark 中显示过滤器会显示很多当前网络的数据包，如果你想看指定规则的数据包怎么办？ 别担心，Wireshark 给我们提供了过滤功能，按照一定的过滤规则就可以达到你的目的。 1. 网络协议过滤 比如 TCP，只显示 TCP 协议，HTTP 只显示 HTTP 协议等。在过滤器输入框中直接输入协议名称即可，不区分大小写。 2. IP 地址过滤 如 ip.src == 192.168.1.102 显示源地址为 192.168.1.102，而 ip.dst == 192.168.1.102, 目标地址为 192.168.1.102。 3. 端口过滤 tcp.port == 80, 端口为 80 的 tcp.srcport == 80, 只显示 TCP 协议的原端口为 80 的。 4. Http 模式过滤 http.request.method == “GET”，只显示 HTTP GET 方法的。 5. 结合逻辑运算符 AND/OR 组成复杂的表达式 AND/OR 也可以写成 &amp;&amp; / || 下面举几个常用的示例，如下： 1234567891011121314//源地址或者目标地址是192.168.1.103ip.src == 192.168.1.103 or ip.dst == 192.168.1.103//显示所有目标或源地址是192.168.1.1的数据包ip.addr == 192.168.1.1 //显示目标地址是192.168.1.1的数据包ip.dst == 192.168.1.1 //显示源地址是192.168.1.1的数据包ip.src == 192.168.1.1 //tcp 连接端口为9101的数据包tcp.port == 9101 更多的过滤规则可以去 官方手册 和 CaptureFilters 查阅和学习。 美中不足Wireshark 只能查看封包，而不能修改封包的内容，或者发送封包。 对于 HTTP、HTTPS 网络封包，Wireshark 都可以捕获， 但不能直接解密 HTTPS，所以想使用 Wireshark 来分析 HTTPS 包中的内容，需要去额外配置，较麻烦，后续研究再分享给大家。 所以建议大家，分析 HTTP/HTTPS 去使用各自平台上面的其他工具， 如 Fiddler 和 Charles 等优秀的抓包工具。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Wireshark tcp ip udp http https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置 php7 + Nginx]]></title>
    <url>%2F2018%2F08%2F19%2F%E9%85%8D%E7%BD%AE-php7-Nginx%2F</url>
    <content type="text"><![CDATA[PHP7之前为了配合完成一个项目（PHP 版本为5.6），在本机搭建了 PHP56 的环境，后面自己系统升级为 macOS High Sierra，发现系统自带的 PHP 版本已经是 7.1 了，于是就开始使用系统自带的 PHP 版本了。 1php -v 显示 PHP 版本信息，如下： 123PHP 7.1.16 (cli) (built: Apr 1 2018 13:14:42) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies 系统自带的 PHP7.1 没有默认的 php.ini 文件，执行下面命令查找一下： 1php -r &quot;echo php_ini_loaded_file();&quot; 此时并没有打印对应的配置文件信息。需要我们手动去复制一份： 1sudo cp /private/etc/php.ini.default /private/etc/php.ini 再次执行上面命令，即可看到配置文件的绝对路径了。或者执行 php --ini 123456php --iniConfiguration File (php.ini) Path: /etcLoaded Configuration File: /etc/php.iniScan for additional .ini files in: (none)Additional .ini files parsed: (none) 这里有个问题需要注意，php.ini 文件复制成功后，需要下面两步操作，否则在 php 代码发生致命错误的时候，页面不会输出任何内容，只是报 HTTP ERROR 500 的错误。 第一步，修改 php.ini 文件的权限，否则无法编辑保存，默认是只读属性。 1sudo chmod 777 /private/etc/php.ini 第二步，编辑 php.ini 文件，将 display_errors = Off 改为下面 on 即可。 1display_errors = On 记得每次修改完配置文件，需要重启 php-fpm 和 nginx 服务。 PHP561. 安装 PHP56 可以参考下面两篇文章。 PHP开发准备 安装 PHP 遇到的问题 2. 卸载（删除）PHP56 执行 brew uninstall 1brew uninstall php 即可完成卸载。 如果卸载遇到问题，就打开 /usr/local/Cellar/ 目录，删除对应的 PHP 目录即可。 配置 php-fpm现在新版本的 PHP 其内核已经集成了 php-fpm，我们不需要另外安装了。 配置 php-fpm 配置文件 1sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf 修改配置文件 1sudo vi /private/etc/php-fpm.conf 找到 error_log 项，添加下面两个配置项，如下： 12error_log = /usr/local/var/log/php-fpm.logpid = /usr/local/var/run/php-fpm.pid 如果不配置上面的配置项，启动 php-fpm 会报错： 123ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)ERROR: failed to post process the configurationERROR: FPM initialization failed 接下来, 继续配置，将 www.conf.default 复制一份命名为 www.conf 即可。 123cd /private/etc/php-fpm.d/sudo cp www.conf.default www.conf 不配置上面的，会报如下错误: 12ERROR: No pool defined. at least one pool section must be specified in config fileERROR: FPM initialization failed 至此，可以启动 php-fpm 了，执行下面命令： 1sudo php-fpm -D 不出意外的话，已经成功启动，可以使用下面命令查看端口使用情况 1netstat -an | grep 9000 如果你在启动 php-fpm 遇到下面的错误： 12ERROR: unable to bind listening socket for address &apos;127.0.0.1:9000&apos;: Address already in use (48)ERROR: FPM initialization failed 有两种方式解决这个问题 1.修改 php-fpm 使用的端口号 1sudo vim /private/etc/php-fpm.d/www.conf 将 listen = 127.0.0.1:9000 改为 listen = 127.0.0.1:9001 即可。 2.杀掉9000端口占用的进程 关闭所有之前启动的 php-fpm 1killall php-fpm 找到占用端口的进程号 1netstat -an | grep 9000 然后 kill -9 pid，重新启动 php-fpm 即可。 安装和配置 Nginx1brew install nginx 创建文件 12345mkdir -p /usr/local/var/log/nginxmkdir -p /usr/local/etc/nginx/sites-availablemkdir -p /usr/local/etc/nginx/sites-enabledmkdir -p /usr/local/etc/nginx/conf.dmkdir -p /usr/local/etc/nginx/ssl 1234567sudo mkdir -p /var/wwwsudo chown :staff /var/wwwsudo chmod 775 /var/wwwvi /var/www/info.phpvi /var/www/index.htmlvi /var/www/403.htmlvi /var/www/404.html 改变 nginx.conf 配置文件 该配置文件在 /usr/local/etc/nginx/nginx.conf 下面. 我的配置: 1234567891011121314151617181920212223242526272829303132333435363738worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log debug;pid /usr/local/var/run/nginx.pid; events &#123; worker_connections 256;&#125; http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*; include /usr/local/etc/nginx/conf.d/*; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php &#125; &#125;&#125; 注意: 1234location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php&#125; 配置了我的 web 目录和支持的文件. 运行 PHP 创建 index.php 启动 php-fpm 1sudo php-fpm 或者以守护进程的方式来启动 PHP-fpm 1sudo php-fpm -D 启动 Nginx 1sudo nginx 编辑 index.php 在 web 目录(我配置的) ~/projs/phpdev/nginx/nginx_sites/ 新建文件 index.php. index.php 里面可以编写代码: 12345678910&lt;!-- lang: php --&gt;&lt;!-- ~/nginx_sites/index.php --&gt;&lt;?php echo &quot;Hello PHP&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;学习 php&quot;; echo &quot;&lt;/br&gt;&quot;; echo phpinfo();?&gt; 打开浏览器, 输入地址：http://localhost:8080/index.php 你会看到下面的页面: 也可以在该目录下创建其他 PHP 文件, 如 m.php 文件. 浏览器中输入 http://localhost:8080/m.php 可以执行相对应的文件. 注意：这里的 m.php 是新建的 PHP 文件. 重要文件1. php 配置文件 1/private/etc/php.ini 2. nginx log 文件 12345/usr/local/var/log/nginx/access.log/usr/local/var/log/nginx/error.log/usr/local/etc/nginx/logs/error.log 3. nginx 配置文件 1/usr/local/etc/nginx/nginx.conf 4. php-fpm 配置文件 1/private/etc/php-fpm.d/www.conf 常见问题502 bad gateaway 我是经常看到这个问题，但是每次引起的原因又不太一样，绝大部分是因为 php-fpm 启动不了或者是其端口错误导致的。 这种情况下，建议去看 /usr/local/etc/nginx/logs/error.log 日志文件。 例如下面的错误： 1234567[error] 61016#0: *1 kevent() reported that connect() failed (61: Connection refused) while connecting to upstream, client: 127.0.0.1, server: localhost, request: &quot;GET /3.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost:8080&quot; 最终，我修改了 /private/etc/php-fpm.d/www.conf 中端口为 9000（我之前将该端口修改了其他的），重启 php-fpm 解决问题。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>PHP MySql nginx php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单配置 Apache]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE-Apache%2F</url>
    <content type="text"><![CDATA[声明有时候, 我们希望在自己本机(PC)搭建一个 WebServer, 然后自己可以在浏览器或者手机上面可以访问对应的地址直接查看效果, 再或者希望测试下载功能等, 其实 MacOS 自带的有 Apache 服务器. 下面简单分享一下, 在 MacOS 中如何简单的使用 Apache 服务器. 常用命令常用的命令有开启/重启/停止等. 1.开启: sudo apachectl start2.重启: sudo apachectl restart3.关闭: sudo apachectl stop4.查看版本号: httpd -v 1.查看 Apache 版本号 1httpd -v 或者使用下面的命令: 1sudo apachectl -v 查看结果如下: 12Server version: Apache/2.4.28 (Unix)Server built: Oct 9 2017 19:54:20 2.启动 Apache 1sudo apachectl start 在浏览器打开: http://localhost 会显示: 1It works 3.停止 Apache 1sudo apachectl stop 如果没有开启 Apache 服务, 执行上面命令的话, 会报下面的错误: 12/System/Library/LaunchDaemons/org.apache.httpd.plist: Could not find specified service 4.重新启动 Apache 1sudo apachectl restart 如果修改了 Apache 的配置文件, 需要重新启动 Apache 服务, 执行上面的命令即可. 配置 Sites在自己的用户目录, 新建一个 Sites 目录, 例如我的用户目录是 /Users/mark, 可以在终端分别执行: 123cd /Users/markmkdir Sites 执行成功后, 可以看到如下图所示的目录: 接下来修改 Apache 中的配置文件, 执行下面命令开始编辑 httpd.conf 文件. 1sudo vim /etc/apache2/httpd.conf 打开 httpd.conf 文件，查找 userdir 关键字. 找到如下两行被注释掉的内容: 123#Include /private/etc/apache2/extra/httpd-userdir.conf#LoadModule userdir_module libexec/apache2/mod_userdir.so 将其前面的 #(注释) 去掉, 紧接着编辑这个文件, 增加如下内容: 123&lt;Directory /Users/mark/Sites&gt; Require all granted&lt;/Directory&gt; 将上面的这些代码放到如下代码下面即可: 12345&lt;Directory &quot;/Library/WebServer/CGI-Executables&quot;&gt; AllowOverride None Options All Require all granted&lt;/Directory&gt; 保存该文件并退出 vim. 执行下面的命令修改 httpd-userdir.conf 文件: 1sudo vim /private/etc/apache2/extra/httpd-userdir.conf 增加如下内容: 12345UserDir Sites&lt;IfModule bonjour_module&gt; RegisterUserSite customized-users&lt;/IfModule&gt; 注意: 如果在 /private/etc/apache2/extra/ 目录下没有该文件, 新建一个即可. 保存文件并退出即可. 我们可以将自己需要运行的 html 等文件放到该目录, 如我将 index.html 放到该目录. 重新启动 Apache 服务, 在浏览器中输入 http://localhost/~mark/, 可以看到 index.html 里面的内容. WebServer 目录上面我们提到, 启动 Apache 服务之后, 在浏览器可以看到 It Works 的字样, 那么这个是哪个文件输出的呢? 这个文件是 sudo mvim index.html.en~orig, 在如下目录: 1/Library/WebServer/Documents 可以使用 vim 编辑该文件, 然后再刷新浏览器就可以看到其变化. 我们也可以把自己的 html 文件放到这里, 如 mark.html, 内容如下: 12345&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hi, mark, Apache server works!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器中输入 http://localhost/mark.html, 可以看到对应的输出. 如果嫌配置 Sites 目录麻烦, 可以使用这种方式, 直接拷贝对应的文件或者目录放到 /Library/WebServer/Documents 中, 只不过需要 root 权限罢了. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Apache WebServer MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop: 移除常驻线程]]></title>
    <url>%2F2018%2F07%2F01%2FRunLoop-%E7%A7%BB%E9%99%A4%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概要下面两篇文章: 常驻线程是一种什么体验 NSTimer 实现常驻线程的问题 都是在 iOS 平台上如何利用 RunLoop 的特性实现常驻线程. 可能你看到本篇文章的标题 移除常驻线程, 有点不理解甚至觉得作者是不是有点神经病, 都已经需要常驻线程了, 为什么还要去退出呢? 实际应用场景中的确几乎遇不到这种情况, 所以, 本篇只是从技术的角度给大家分享 RunLoop 其他的一些知识点. 且耐住性子往下看… 为了不让大家误解, 统一一下相关的词汇和语境. 输入源, 包括 source 和 timer. 退出 RunLoop 指的是在常驻线程的方法中立即返回. 这里的 RunLoop 指的是子线程中的 RunLoop 不是主线程中的. 结合之前介绍常驻线程的文章来看现在的文章, 不然不好理解. 运行 RunLoop 的方法这里有三种方式开启运行 RunLoop, 分别如下: 12345- (void)run;- (void)runUntilDate:(NSDate *)limitDate;- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate; run 方法 看一下 API 文档如何解释 run 方法的: 12345Puts the receiver into a permanent loop, during which time it processes data from all attached input sources.If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers. 大致意思讲的是, 在没有任何输入源的情况下, run 方法会立即执行后退出, 不会保持线程的持久性, 换句话说, 在有输入源的情况下, 该方法会进入一个无限循环当中. 本质上, 在 NSDefaultRunLoopMode 模式下, 该方法是反复调用 runMode:beforeDate: 方法的. 在之前文章实现常驻线程的代码中, 我们使用了 run 方法来开启运行 RunLoop. 可以看出, 我们之前实现的常驻线程使用 run 方法是无法退出常驻线程的. runUntilDate:(NSDate *)limitDate 方法 该方法 API 释义: 12Runs the loop until the specified date, during which time it processes data from all attached input sources. 保证有输入源的情况下该方法启动的 RunLoop 可以在指定的日期内一直运行不会返回. 换句话说, 日期只要已到该方法就会立即退出 RunLoop. 示例代码: 12345678//等同于 run, 可保证一直运行[runLoop runUntilDate:[NSDate distantFuture]];//立即返回, 退出 RunLoop[runLoop runUntilDate:[NSDate date]];//然后过12秒后返回[runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:12.0f]]; runMode:(NSString )mode beforeDate:(NSDate )limitDate 方法 该方法有两个参数 mode 和 limitDate, mode 就是 RunLoop 的运行模式, limitDate 就是上面方法一样的释义即在指定的日期内. 1Runs the loop once, blocking for input in the specified mode until a given date. 可以这么理解, 该方法开启的 RunLoop 处理完之后会立即返回(once), 如果在指定日期内事件还没处理, 在该日期后会立即返回.换句话说, 如果指定的日期是当前的, 该方法执行后 RunLoop 会立即退出. 示例代码: 12345//立即返回[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate date]]; //有事件到达处理后就返回，如果没有则过12秒返回[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:12.0]]; 这三个方法, 总结一下大概如下: 这三个方法在没有任何输入源情况下会都立即返回(退出 RunLoop), 不会等待. run 可保证 RunLoop 在有输入源的情况下一直运行. runUntilDate 可以通过设置超时时间来退出 RunLoop. 超时时间一过就会立即退出 RunLoop. 使用 runMode 方式启动的 RunLoop 会在处理完事件后或者超时后, 立即返回. 即可以通过设置超时时间或者使用 CFRunLoopStop 方法来退出 RunLoop. 移除常驻线程先看一下, 在子线程执行的方法中如何实现的. 示例代码如下: 12345678910111213141516171819202122232425262728293031323334- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; _threadRunLoop = runLoop; // 保持常驻线程的方式1: source NSPort *port = [NSMachPort port]; _threadPort = port; [runLoop addPort:port forMode:NSRunLoopCommonModes]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop // [runLoop run]; while (!self.stopLoopRunning &amp;&amp; [runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantPast]]) &#123; // 这里是为了验证常驻线程是否已经退出 NSLog(@&quot;--- asyncRun ----&quot;); // 实际业务中, 建议使用空语句实现 ; //实现为空语句 &#125; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 结合上面讲解的原理, 这里选择使用 runMode 方法来开启运行 RunLoop. 大家也可以自由发挥使用其他的方法. 注意: stopLoopRunning 是定义的一个属性. 移除的示例代码如下: 12345678910111213141516171819202122232425- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; // 取消线程 // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例 BOOL canCancel = YES; if (canCancel) &#123; [[self permanentThread] cancel]; &#125; /// 停止常驻线程 &#123; self.stopLoopRunning = YES; // 移除 port // 如果是用 timer 的方式的常驻线程, 可以 invalid 对应的 timer [self.threadRunLoop removePort:self.threadPort forMode:NSRunLoopCommonModes]; // 停止 RunLoop if (nil != self.threadRunLoop) &#123; CFRunLoopStop([self.threadRunLoop getCFRunLoop]); &#125; &#125;&#125; 离开页面后, 可以发现 NSLog(@&quot;--- asyncRun ----&quot;); 停止了打印, 并且当前的 Controller 也 dealloc 了. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop 常驻线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: dumpdecrypted 砸壳记]]></title>
    <url>%2F2018%2F06%2F07%2FiOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天是一个特别的日子, 高考的第一天, 祝各位莘莘学子金榜题名. iOS 逆向: 砸壳 介绍了如何使用工具 Clutch 对 iOS 的应用进行砸壳操作, 今天继续给大家分享使用另外一个工具 dumpdecrypted 对 APP 进行砸壳. 概要有些朋友就会问了, 既然 Clutch 已经很牛B了, 为什么还需要 dumpdecrypted 这个工具呢? 刚开始的时候, 我也很排斥使用 dumpdecrypted 这个工具的, 使用起来比较复杂, 并且套路不熟的情况下还很容易出错. 之前说过 Clutch 并不是万能的, 从 App Store 下载的 App(比如 WeChat)有些并不能使用 Clutch 来进行砸壳, 换句话说, 使用 Clutch 工具来进行砸壳会失败, 那么, dumpdecrypted 就登场了. 本次砸壳的系统依然是 iOS10.3.x, 工具使用 dumpdecrypted, 砸壳的对象是 WeChat 这个 App. 准备工作 MacOS PC 越狱手机一台(我用的是iPhone6SPlus 10.3.1) dumpdecrypted class-dump 在 Cydia 中安装 cycript, 可以先不用管 cycript 是什么, 下载安装即可. iFunBox 或者其他助手工具 编译 dumpdecrypted去 Github 下载 dumpdecrypted 源码, 源码就一个 C 源文件. 下载 zip 包之后, 解压, 如图: 在当前目录, 执行 make 即可完成编译, 如图所示: 编译成功后生成 dumpdecrypted.dylib 文件. 这里有个小插曲, 编译 dumpdecrypted 的时候报错了, 错误信息如下: 1234xcrun: error: SDK "iphoneos" cannot be locatedxcrun: error: unable to lookup item 'Path' in SDK 'iphoneos'clang: warning: no such sysroot directory: '-F/System/Library/Frameworks' [-Wmissing-sysroot]dumpdecrypted.c:27:10: fatal error: 'stdio.h' file not found 无法找到对应的 SDK 和 stdio.h 文件, 这种问题大多数是 Xcode 路径造成的. 使用下面的命令看一下系统指向的 Xcode 路径: 1xcode-select -p 控制台输出: 1/Library/Developer/CommandLineTools 显然不是 Xcode 的路径, 那只能重新切换一下其路径即指向正确的Xcode 路径即可. 命令如下: 1sudo xcode-select --switch /Applications/Xcode.app 再次编译 dumpdecrypted 即可成功完成. 对 dumpecrypted.dylib 签名 如果不对该文件进行签名, 后续砸壳的操作会失败. 先找到已经在电脑上面安装的苹果开发者证书, 操作如下: 12## 列出可签名证书, 找到 mac 上面已经安装的证书security find-identity -v -p codesigning 为 dumpecrypted.dylib 签名, 命令如下: 1codesign --force --verify --verbose --sign "iPhone Developer: xxx xxxx (xxxxxxxxxx)" dumpdecrypted.dylib 其中, &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; 为你自己本机安装的开发者证书名称. SSH 连接手机使用 OpenSSH 让 Mac 和手机连接起来 这样可以很方便的在 Mac 终端使用 shell 命令来操作手机的目录了. 关于 OpenSSH 的使用请参考我之前的博文 iOS 逆向: 越狱使用 SSH. 查找目标 App 所在进程 双击 Home 按键后, 手动杀掉 iPhone 上面所有在后台的 App. Home 到手机桌面. 打开目标 App 即WeChat, 这里称之为 TargetApp. Home 到手机桌面. 查看当前运行的所有进程, 命令如下: 1ps -e 看到这个货: 在如下目录: 1/var/containers/Bundle/Application/2837EC87-7C28-45C5-9309-24FACD3A97C9/WeChat.app/WeChat WeChat.app 就是我们要找的 TargetApp. 连接 SSH 成功后, 在 MacOS 终端 ls 一下该目录, 可以发现 WeChat.app 躺在那里. 砸壳1. 查找 Documents 目录 WeChat 为当前的进程目标执行文件名称, 从上面的图可以看出, 其对应的进程 id 是 18983. 在命令行中通过 cycript 执行如下操作: 1cycript -p 18983 再执行 OC 的方法, 如下: 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 可以看到对应的输出, 如下图所示, 这就是对应的 Documents 目录. 注意: 执行过程中, 在 iPhone 上面打开运行一下 App, 不然上面的执行一直卡在那里不动. 找到目录如下: 1/var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/ 同理, 你也可以使用 iFunBox 查看该目录. 2. 拷贝 dumpdecrypted.dylib. 拷贝 dumpdecrypted.dylib 这个之前编译签名好的文件到iPhone 上面该 APP 的 Documents 目录有两种方法. 第一种方法, 直接在 mac 上面拖拽 dumpdecrypted.dylib 到 iFunBox 显示的这个目录中, 这种方法比较简单且快. 第二种方法, 使用 scp 命令进行操作. 1scp ~/dumpdecrypted.dylib root@192.168.99.231:/var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/ 192.168.99.231 是 iPhone 设备的 ip 地址. 3. 退出 cycript, 回到命令行模式 1ctrl + d 4. cd 到 Documents 目录 1cd /var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/ 5. 砸壳 终端在 Documents 目录下面, 执行下面命令即可: 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/2837EC87-7C28-45C5-9309-24FACD3A97C9/WeChat.app/WeChat 执行过程显示如下: 最后生成了 WeChat.decrypted 文件, 如下: 12345678910111213-rw-r--r-- 1 root mobile 74513728 Jun 7 15:20 WeChat.decrypteddrwxr-xr-x 14 mobile mobile 448 Jun 7 15:20 .-rw-r--r-- 1 root mobile 207760 Jun 7 15:15 dumpdecrypted.dylib-rw-r--r-- 1 mobile mobile 8 Jun 7 13:22 db.globalconfig-rw-r--r-- 1 mobile mobile 15 Jun 7 11:35 SafeMode.datdrwxr-xr-x 26 mobile mobile 832 Jun 7 11:35 MMappedKVdrwxr-xr-x 3 mobile mobile 96 Jun 7 11:35 CrashReport-rw-r--r-- 1 mobile mobile 1011 Jun 7 11:35 LocalInfo.lstdrwxr-xr-x 5 mobile mobile 160 Jun 7 11:35 MemoryStatdrwxr-xr-x 6 mobile mobile 192 Jun 7 11:35 00000000000000000000000000000000drwxr-xr-x 15 mobile mobile 480 Jun 5 13:43 MMResourceMgr-rw-r--r-- 1 mobile mobile 592 Jun 5 13:43 heavy_user_id_mapping.datdrwxr-xr-x 2 mobile mobile 64 Jun 5 10:07 OpenImResource 使用 iFunBox 或者 scp 命令将 WeChat.decrypted 文件导出到 mac 的任意目录即可. 后续会跟大家分享如何使用砸壳后的文件, 敬请期待. 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 总有一天，你一定会感激正在努力的自己~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: 砸壳]]></title>
    <url>%2F2018%2F05%2F13%2FiOS-%E9%80%86%E5%90%91-%E7%A0%B8%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[所谓的砸壳, 指的是将从 App Store 上面下载的 App 进行破解的过程. 从 App Store 上下载的 ipa 中的二进制文件是经过加密(加壳)的，需要通过破解才能让我们对其 为所欲为, 这里的破解就是通常所说的砸壳. 类似的, Android 应用(apk 文件)也有加壳操作, 如果想破解别人的 apk, 首先要进行砸壳操作. 准备工具[1]. Clutch[2]. iFunBox 或者 pp 助手[3]. 越狱手机一台(本人iPhone6sPlus iOS10.3.x 系统).[4]. 可以正常使用 SSH 功能. 如果你还没有安装上面提到的除 Clutch 之外的工具, 请先阅读 iOS 逆向: 查看系统文件目录和结构 这篇文章, 并安装对应的工具. 安装 Clutch可以在 Github 获取 Clutch 源码, 然后自己在 MacOS 上面编译得到二进制文件. 也可以去直接下载已经编译好的 二进制包, 直接使用, 我是直接下载了已经编译好的二进制包的, 截止到写这篇文章为止, Clutch 版本为 2.0.4. 下载完成后, 我将其放到 ~/Downloads 目录下面了. 准备好越狱设备, 保证可以正常连接 wifi, 使用 scp 命令将 Clutch 二进制文件复制到设备的系统目录中, 命令如下: 1scp ~/Downloads/Clutch root@192.168.91.126:/usr/bin 其中, 192.168.91.126 是我设备连接 wifi 后的 IP 地址. 复制成功后, 使用 iFunBox 可以看到 Clutch 静静地躺在那里. 你可以使用 iFunBox 或者 pp 助手, 直接将 ~/Downloads/Clutch 拖拽到 /usr/bin 目录. Clutch 的基本使用SSH 连接越狱设备, 开始使用 Clutch. 关于使用 SSH, 可以阅读一下 iOS 逆向: 越狱使用 SSH 这篇文章. 如果你发现直接执行 Clutch 说没有权限之类的提示, 可以先将其授予可执行的权限. 1chmod +x /usr/bin/Clutch Clutch 命令选项如下: 123456-b --binary-dump Only dump binary files from specified bundleID-d --dump Dump specified bundleID into .ipa file-i --print-installed Print installed application--clean Clean /var/tmp/clutch directory--version Display version and exit-? --help Display this help and exit -b 选项表示产出一个二进制文件, -d 选项表示产出一个 ipa 文件, -i 表示列出手机上面已经安装的 APP. 我们先看一下手机上已经安装的 App, 命令如下: 1Clutch -i 这些 APP 前面的数字表示指定的 id. -d 和 -b 选项都需要指定这些 id. 砸吧, 骚年我们现在开始使用 Clutch 来对 APP 进行砸壳操作, 这里以已经安装的 App 序号为 8 的为例子. 使用下面的命令开始砸壳: 1Clutch -d 8 效果如下图所示: 砸壳成功后会在 /private/var/mobile/Documents/Dumped 这个目录生成对应的 *.ipa 文件. 砸壳后的 ipa 文件, 可以从 iFunBox 中复制到 MacOS 的目录中, 然后你就可以对该 ipa 进行下一步操作了, 比如获取图片/音频/视频等资源和对应的头文件. 关于这些后续的越狱工作, 我会在下几篇博客中分享给大家. 也许有人会说了, 我自己从 pp 助手 中备份指定的 App 就可以获取资源了, 不需要使用 Clutch 这么麻烦了. 高系统版本, pp 助手 是无法直接获取 ipa 文件的, 况且我们也不仅仅是想获取别人 APP 的资源文件. 当然了, 你可以从越狱 APP 市场直接下载已经被砸壳的 App 进行玩耍, 不需要自己千辛万苦的去砸壳了. Clutch 并不是万能的上面大家可以看出, Clutch 是可以进行砸壳的并且也挺方便, 但 Clutch 并不是万能的, 也就是说, Clutch 不能将任意一个 App Store 下载 APP 进行砸壳. 拿上面序号为4 的微信来说, 执行下面命令报错: 1Clutch -d 4 砸壳执行过程如下: 1234Writing new checksum...FAILED: &lt;WeChat bundleID: com.tencent.xin&gt;Finished dumping com.tencent.xin in 28.7 seconds 还有一些 APP, 再被砸壳的时候会报如下的错误: 1could not obtain mach port either the process is dead 虽然最新版本(2.0.4)说解决了该问题, 但是实际操作过程中, 还是会出现这个问题, 无法进行砸壳. 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 特别喜欢上善如水这句话，你呢？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: 查看系统文件目录和结构]]></title>
    <url>%2F2018%2F05%2F13%2FiOS-%E9%80%86%E5%90%91-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[在 iOS 逆向: 越狱使用 SSH 中给大家分享了如何使用工具对 iOS10.3 的系统进行越狱和配置使用 SSH 的内容, 今天继续探逆向的知识. 手机被越狱之后, 我们首先要搞清楚是否能够正常的访问手机里面的文件和目录结构, 这些文件和目录结构究竟是什么样的, 虽然这些知识很基础, 但是还是很有必要去了解和学习的, 就算是为后期逆向 APP 做点准备吧. 安装 iFunBoxiFunBox 是一个可以浏览 iPhone 文件目录的文件管理工具, 支持 MacOS 和 Windows 两个平台. 点击 下载地址 可以去下载 MacOS 版本的 iFunBox. 关于 iFunBox 的介绍和特性可以去 这里 查阅. 最新版本是 1.8, 如图: 手机插上 USB 连接上 Mac 电脑, iFunBox 就可以识别你的手机了, 如图所示: 这个时候, 你点击 Raw File System 其实是看不到 iPhone 的系统目录的, 接下来在 iPhone 中安装另外一个软件就可以了. 安装 Apple File Conduit”2”在 Cydia 中搜索 Apple File Conduit, 如下图所示. 点击更改/安装即可. 如果你没有搜索到, 那么就需要自己添加对应的软件源地址. 点击【软件源】–编辑/添加 –输入源地址 apt.25pp.com – 添加源, 然后再去搜索 Apple File Conduit 安装. 安装好之后, 再用 iFunBox, 就可以正常查看 iPhone 的系统目录了, 如下图所示: 看到这些目录, 是不是跟 linux 或者 MacOS 的目录有很多相似的地方, 哈哈. 安装 pp 助手既然已经安装了 iFunBox 工具, 那为什么还需要安装 pp 助手 之类的工具呢? 其实, 这个看个人的需要吧, 在某种程度上, pp 助手 的界面和便捷性要比 iFunBox 好一点. 安装好 pp 助手 后, 点击 Tools/File Manager 显示的目录导航, 如图: 可以看出, 相比 iFunBox 的界面显示, pp 助手 工具显得更加友好一些. 至于使用哪个工具, 要看个人爱好和自己的工作需要, 毕竟工具都是为了提高我们学习和工作效率的, 没有什么绝对的好与坏, 自己觉得合适顺手就好了, 最主要的是能够帮到自己. 我一般是将两者结合使用的, 当然你如果你有更好的工具也可以推荐给我. 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 每一个关注，都会激励我继续前行]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向: 越狱使用 SSH]]></title>
    <url>%2F2018%2F05%2F12%2FiOS-%E9%80%86%E5%90%91-%E8%B6%8A%E7%8B%B1%E4%BD%BF%E7%94%A8-SSH%2F</url>
    <content type="text"><![CDATA[越狱使用苹果设备或者做 iOS 开发的朋友们, 几乎都应该听说过越狱这个词. 那么究竟什么是越狱呢? iOS越狱（英语：iOS Jailbreaking）是获取 iOS 设备的 Root 权限的技术手段。iOS 设备的 Root 权限一般是不开放的。由于获得了Root 权限，在越狱之前无法查看的 iOS 的文件系统也可查看. 上面是维基百科的解释, 具体可以去 iOS 越狱) 了解一下. iOS 的越狱就类似 Android 获取 root 权限一样的道理. 手头上面之前闲置了一台 iPhone4s, 闲来无事就把他越狱了, 后面不知道怎么操作的, 手机变成了白苹果(开机就白屏, 无法进入系统), 最后没办法, 只能升级系统, 这台手机也算是废了. 当时使用的工具是 盘古越狱, 越狱的 iOS 系统是 7.x. 现在 iOS 已经升级到 11.x 了, 很多 APP 和游戏已经不再支持 iOS8 以下的系统了, 系统的安全性也越来越好了, 越狱破解的难度也随之提高了, 目前市面上能越狱的最高版本应该是 10.3.x 的系统(截止到该篇文章写的时候). 为了能够分析和学习一些优秀 App 的设计, 我索性买了台iPhone6sPlus 拿来越狱, 所以接下来的分享都是基于这台手机的. 越狱工具和设备 [1]. 设备 iPhone6s Plus, 系统 iOS10.3.2[2]. 越狱工具: 爱思助手和 doubleH3lix.ipa 安装并打开 pc 上面的 爱思助手 直接开始越狱, 爱思助手会帮您在设备上安装 doubleH3lix. 运行 doubleH3lix 应用，点击 jailbreak 按钮，等待设备自行重启. 手机重启后, 你会看到 Cydia 静静的呆在那里了, 这种方式的越狱属于非完美越狱, 换句话说就是没有真正的破解 iOS 系统. 如果发现手机断电关机或者重启后 Cydia 一打开就闪退, 就使用 doubleH3lix 重新越狱就可以了, 如果还是不行就需要重新使用 爱思助手 了. 参考越狱教程 64位设备iOS 10-10.3.3爱思助手一键越狱教程. 安装 iOS 终端安装终端, 在 Cydia 中搜索 MTerminal, 安装即可. 安装好终端工具后，打开终端，输入 1su 紧接着让你输入密码，默认的 root 用户密码是 alpine. 输入改密码回车即可。 为了安全起见, 修改默认密码 alpine. 1passwd 连续输入相同的密码即为呢修改后的新密码。 配置 SSH配置和使用 SSH 功能是后续越狱工作的基础, 这样就可以在 MacOS 的终端中访问 iOS 系统了, 各种 shell 命令让你倍感亲切, 所以大家尽量要完成该步骤. 试想一下, 本来手机上面文字输入的体验就不好, 还需要在 iPhone 设备上面的终端中敲着命令…没法忍! iOS 10 越狱以后自带了 SSH, 所以不需要单独去 Cydia 下载和安装 OpenSSH. 很多人越狱后, 发现也安装了 OpenSSH, 但是一旦连接 iPhone 设备就无法连接甚至报错. 如果你已经安装了 OpenSSH 并且无法使用 SSH 来操作你的 iPhone 设备, 请继续往下看. [1]. 打开 Cydia, 分别搜索 OpenSSL 和 Openssh, 然后分别卸载 OpenSSL 和 Openssh. [2]. 打开 Cydia, 添加源：http://cydia.ichitaso.com/test 点击左上角的 添加, 在弹框中输入对应的源地址即可. [3]. 在 Cydia 中搜索 dropbear 并安装. 安装即可. 安装成功后, 一般就可以正常使用 SSH 功能了. 打开 MacOS 终端, 开始使用 SSH 连接你的 iPhone 设备. [1]. 查看 iPhone 设备的(wifi) IP 地址. 如我的是 192.168.1.105.[2]. 使用 MacOS 终端, 输入: 1ssh root@192.168.1.105 成功的话, 它先会警告你是否继续操作, 输入 yes 即可, 然后又提示你输入 root 密码, 密码就是前面说的修改后的密码. 如果你没有修改密码, 那就是 alpine. 操作流程如下: 12345The authenticity of host '192.168.1.105 (192.168.1.105)' can't be established.ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.1.105' (ECDSA) to the list of known hosts.root@192.168.1.105's password: 之前在 iOS 10.2.x 越狱修改对应的配置文件, 就可以使用 SSH 功能了, 但是在 iOS10.3.x 无济于事, 如果你是iOS 10.2.x 的越狱手机, 可以参考本文末附录配置 SSH, 也是我之前实践的结果. usbmuxd上面是通过 wifi 来连接 iPhone 设备的, 其实还有一种方式, 就是借助于 usbmuxd 这个工具通过 USB 连接(手机数据线连接电脑)不需要 wifi, USB连接比 wifi 响应速度快，且无网络环境的限制. 使用 usbmuxd 的前提是你的手机可以正常的使用 SSH 功能, 否则 usbmuxd 也无法救你. [1].MacOS 安装 usbmuxd 1brew install usbmuxd [2]. 使用 usbmuxd 自带工具 iproxy. iproxy 可以快捷的操作连接 iPhone 等操作. MacOS 上只支持 4 位的端口号，需要把 iPhone 的默认端口 22 映射到 Mac 上面一个 4 位端口号的端口上面，相当于建立一个 Mac 和 iPhone 之间的通道. iproxy 具体使用, 后面再讲. 大家先安装一下即可. 12iproxy 5678 22waiting for connection 以上命令就是把当前连接设备的 22 端口(SSH端口)映射到电脑的 5678 端口，那么想和设备 22 端口通信，直接和本地的 5678 端口通信就可以了. 终端提示 waiting for connection, 表示这两个端口之间已经可以通信了，保留当前终端窗口(如果关闭就停止端口之间的通信了)，新建另一个终端输入，默认密码 root 密码. 1ssh -p 5678 root@127.0.0.1 执行过程如下, 类似上面通过 wifi 操作的方式. 12345The authenticity of host '[127.0.0.1]:5678 ([127.0.0.1]:5678)' can't be established.ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '[127.0.0.1]:5678' (ECDSA) to the list of known hosts.root@127.0.0.1's password: 接下来, 你就可以在 MacOS 终端上面操作你的 iPhone 设备了, 尽情的享受 shell 命令吧。不使用的时候, 输入 exit 即可退出 SSH. 附录[1]. iOS 10.2.x 越狱使用 SSH 功能. 首先修改 root 密码。 iOS 10.2 (越狱后)自带 OpenSSH，不需要自己重新安装 OpenSSH, 但是需要修改一个文件才能使用。 在手机上安装 MTERMINAL，运行 su，输入 root 密码，执行: 1ps aux|grep dropbear 如果你看到的进程没有 dropbear, 执行: 1/usr/local/bin/dropbear -F -R -p 22 然后就可以连接了，重启依然有效。 如果你看到进程是这样的: 1/usr/local/bin/dropbear -F -R -p 127.0.0.1:22 意思是只能数据线重定向连接 SSH，如果你想改成 WIFI 可以访问, 需要修改 /private/var/containers/Bundle/Application/D9185B6D-EA9E-4678-B59C-BF43DEFE67BF/yalu102.app/dropbear.plist把里面有个参数 127.0.0.1:22 改成22 保存，重启手机即可. [2]. 使用 usbmuxd 无法使用 SSH 执行 ssh -p 5678 root@127.0.0.1 后报错，如下: 1ssh_exchange_identification: read: Connection reset by peer 这种情况一般是没有正确的使用数据线连接 Mac 电脑，使用数据线正常连接 Mac 电脑即可解决问题。 越狱系列文章 基于 iOS10.3.1 进行的实践。 iOS 逆向: dumpdecrypted 砸壳记 iOS 逆向: 砸壳 iOS 逆向: 查看系统文件目录和结构 iOS 逆向: 越狱使用 SSH dumpdecrypted 砸壳：导出头文件 关注不是目的，交流、学习，一起进步才是关键]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS安全 越狱 jailbreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop: NSTimer 实现常驻线程的问题]]></title>
    <url>%2F2018%2F05%2F06%2FRunLoop-NSTimer-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[可行性在 常驻线程是一种什么体验 这篇文章中给大家分享了如何利用 RunLoop 的特性, 结合 NSMachPort 实现一个 常驻线程 的主题内容. 今天我们探讨一下使用 NSTimer 如何实现 常驻线程 以及注意事项. 从 RunLoop 的特性来看, 只要有 Source 或者 Timer 都会使其能自循环使用, 不会立即终止当前线程的执行, 所以从理论上来看 NSTimer 是可以达到创建 常驻线程 的目的的. 开始实践完整的例子代码, 可以从文章的附录获取和查看, 这里只给出核心代码. 创建线程 123456789101112131415- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125; 线程执行的函数 12345678910111213141516171819202122- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 保持常驻线程: 使用 NSTimer [self _attachTimerToRunLoop]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 创建定时器 12345678910111213- (void)_attachTimerToRunLoop &#123; if (nil == self.timer) &#123; // scheduledTimerWithTimeInterval 这种方式 // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中 _timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; &#125;&#125; 可以看出, _attachTimerToRunLoop 中是将 timer 加入到当前的 RunLoop 当中了. 这里注意, repeats 值被设置为 YES 了. 跟之前一样, 可以使用点击事件来模拟和验证常驻线程的有效性. 1234567- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125; 每点击一次屏幕, 都会对应执行 runAnyTime 里面的内容. 对 repeat 的思考在上面的示例中, 我将 repeat 参数设置为 YES, 试想一下如果把 repeat 参数设置为 NO, 会不会造成常驻线程失效呢? 动手试试… 12345678910111213- (void)_attachTimerToRunLoop &#123; if (nil == self.timer) &#123; // scheduledTimerWithTimeInterval 这种方式 // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中 _timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO]; &#125;&#125; 再次点击屏幕若干次, 同样会执行对应函数里面的内容. 这就说明了即使将 repeat 参数设置为 NO, 也不会影响常驻线程. 那我们再来点具有挑战的活动… 将当前页面加入 UIScrollview 这个视图, 还是保持 repeat 参数设置为 NO. 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; self.navigationItem.title = @&quot;NSTimer 创建常驻线程&quot;; // 加入滚动视图 _scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.scrollView]; self.scrollView.contentSize = CGSizeMake(1000, 1000); self.scrollView.delegate = self; // 启动线程 [self permanentThread];&#125; 因为加入了滚动视图, 我们换一种方式来模式和验证常驻线程. 在 UIScrollview 代理中来模拟, 示例如下: 1234567- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125; 运行后进入该页面, 可以发现常驻线程被终止了. 12veryitman--timerRun.veryitman--asyncRun. End Run. 当除我以为更换一下模式即使 将 repeat 参数设置为 NO, 也不会出现常驻线程被终止的问题. 如下面的代码: 12_timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 这样更换模式为 NSRunLoopCommonModes 也不行. 在这种情况(有滚动视图的)下, 将 repeat 参数设置为 YES 就不会导致常驻线程被终止了, 无论哪种方式创建的 Timer. 总结1.子线程创建中的 RunLoop 的模式不会与主线程中 RunLoop 的模式冲突, 各自运行在各自的 mode 当中. 2.使用 NSTimer 来创建常驻线程, 在有 UIScrollview 或者其子类的情况下, 需要将 repeats 设置为 YES, 否则不会创建常驻线程. 没有滚动视图的情况下, repeats 设置为 NO 也没有关系. 3.创建 NSTimer 下面两种创建 Timer 的效果是一致的. 12345[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; scheduledTimerWithTimeInterval 默认会将 Timer 加入到当前的 RunLoop 中. 12[NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode]; 附录完整示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#import &quot;MZTimerPermanentThreadController.h&quot;@interface MZTimerPermanentThreadController () &lt;UIScrollViewDelegate&gt;@property (nonatomic, strong) NSTimer *timer;@property (nonatomic, strong) UIScrollView *scrollView;@end@implementation MZTimerPermanentThreadController- (void)dealloc &#123; NSLog(@&quot;veryitman---MZTimerPermanentThreadController dealloc.&quot;);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; self.navigationItem.title = @&quot;NSTimer 创建常驻线程&quot;; // 加入滚动视图 _scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.scrollView]; self.scrollView.contentSize = CGSizeMake(1000, 1000); self.scrollView.delegate = self; // 启动线程 [self permanentThread];&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; // 取消线程 // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例 BOOL canCancel = YES; if (canCancel) &#123; [self.timer invalidate]; _timer = nil; [[self permanentThread] cancel]; &#125;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125;- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 保持常驻线程: 使用 NSTimer [self _attachTimerToRunLoop]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125;- (void)runAnyTime &#123; NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);&#125;- (void)_attachTimerToRunLoop &#123; if (nil == self.timer) &#123; // scheduledTimerWithTimeInterval 这种方式 // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中 _timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; #if 0 _timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];#endif &#125;&#125;- (void)runTimer &#123; NSLog(@&quot;--veryitman--timerRun.&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop 常驻线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常驻线程是一种什么体验]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[简说 RunLoop关于 iOS RunLoop 网上很多文章都有介绍过, 很多技术面试官也会问关于 RunLoop 的相关知识. 我把自己工作中遇到的问题和总结的经验分享出来(会做成一系列的文章), 也算是对自己的一个总结和沉淀, 欢迎大家交流. 网上的文章基本都是针对于 Apple Developer Doc - Run Loops 这篇来展开的, 所以建议大家认真的去通读这篇文章, 并写代码验证, 实践. 可以简单粗暴的这么理解一下 RunLoop, 基于事件驱动的死循环(由内核来调度和管理的), 在需要处理事情的时候就出来干点事, 否则休眠待命.RunLoop 的核心是基于 machport 的，其进入休眠时调用的函数是 mach_msg(). 类似下面的代码来说明一下: 12345678BOOL stopRunning = NO;do &#123; // 处理 App 中各种操作各种事件 // 点击屏幕, 触摸到硬件也会唤醒 RunLoop &#125; while(!stopRunning); 说到这里, 随便提及一下, 学习过 Android 开发的同事应该和好理解 RunLoop 了, iOS 的 RunLoop 跟 Android 的 Looper 机制几乎一样, 只是不同的系统之间实现有差异罢了! 有兴趣的朋友可以看一下我之前写的文章 Handler: 更新UI的方法. 今天跟大家分享如何在 iOS 中结合 RunLoop 和 machport 实现常驻线程, 先跟着实例走, 后续再去总结 RunLoop 的各种细节点. 神奇的 main开发过 iOS 应用中的朋友, 对 main.m 再也熟悉不过了, main 函数正是应用的入口函数. 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 我们将 return 代码分开写, 看看有什么蛛丝马迹可寻. 1234567891011int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int ret = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@&quot;veryitman--- UIApplicationMain end.&quot;); return ret; &#125;&#125; 无论如何你也看不到日志 veryitman--- UIApplicationMain end. 的打印, 这说明 UIApplicationMain 一直在呵护着 APP 的运行, 哈哈. 我们不妨再改一次, 如下: 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return 0; &#125;&#125; 再去运行 APP, 你会发现根本没有让 APP 运行起来, 再次说明没有了 UIApplicationMain 的呵护, APP 无法起死回生. 猜测在 UIApplicationMain 函数中，开启了和主线程相关的 RunLoop，使 UIApplicationMain 不会返回一直在运行中，从而保证了程序的持续运行, 最大的功臣就是 RunLoop. 普通线程一般我们开启的线程在执行完任务后, 就会结束该线程. 除非你写了类似下面的代码: 123while(1) &#123; // 业务处理&#125; 或者 123while (条件满足) &#123; // 业务处理&#125; 开启一个线程 123456789101112131415- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125; 执行对应的 asyncRun 函数, 如下: 123456789101112- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); // 执行其他逻辑 //... NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 可以发现 asyncRun 很快就可以执行完成 (End Run). 12veryitman--asyncRun. Current Thread: &lt;NSThread: 0x60000066c400&gt;&#123;number = 3, name = veryitman-thread&#125;veryitman--asyncRun. End Run. 子线程开启 RunLoop主线程是默认开启 RunLoop 的即 mainRunLoop 是系统默认开启的, 但是子线程中的 RunLoop 需要我们自己手动开启. 关于为什么子线程中需要手动开启, 后续文章结合源码给大家分析, 这里暂时可以理解为获取 RunLoop 对象是一种懒加载模式. 只不过主线程中, 系统帮我们开启了, 然而子线程中需要我们手动开启而已. 类似这样: 12345678910111213141516171819- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 在控制台可以看到输出: RunLoop 没有任何输入源(input source) 和定时器(timer), 这时即使开启了 RunLoop 也不会让其等待执行, 换句话说会立即结束当前的 RunLoop. 既然这样我们给子线程的 RunLoop 添加源或者定时器即可. 这里以添加 NSPort 为例. 1234567891011121314151617181920212223- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 添加 source NSPort *port = [NSMachPort port]; [runLoop addPort:port forMode:NSRunLoopCommonModes]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125; 再次运行, 你会发现 End Run 这个 Log 是不会打印出来的. 对应当前的 RunLoop 也有了源和定时器, 如图所示: 关于定时器和 RunLoop 的结合, 下篇再分享. 现在有这样一个需求, 需要在指定的线程中执行某项任务, 显然使用上面的方法来满足需求, 下面进入今天的正题. 验证常驻线程一定到 常驻 这个词, 就知道是能够让该线程随时待命, 保证其不挂掉. iOS 中默认就有个主线程即 main 线程, 我们的 UI 线程指的就是主线程, 一般都是在主线程中操作 UI, 从某个角度来说, 主线程就是一个常驻线程. 我们开启其他线程, 目的是为了异步完成一些任务, 这些任务一般都比较耗时, 如果放在主线程当中完成这些任务就会导致主线程的卡顿, 用户体验极其差. 说了这么多, 也许你会问, 为什么要常驻线程呢? 频繁的创建和销毁线程，会造成资源(主要是内存)的浪费, 我们为什么不让频繁使用的子线程常驻在内存中, 想用的时候就用, 不用的时候让他休眠呢?! 上面已经使用 RunLoop 来实现了让线程长时间存活而不被销毁了. 用 touchesBegan 来模拟在指定线程中再次执行任务(runAnyTime)的方法. 1234567891011- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (void)runAnyTime &#123; NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);&#125; 对应上面的 asyncRun 实现即可, 你会发现在当前页面每次点击屏幕都会执行 runAnyTime. 附录代码的完整实现 常驻线程, 可以参考具体的注释. MZCreatePermanentThreadController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@implementation MZCreatePermanentThreadController- (void)dealloc &#123; NSLog(@&quot;veryitman---MZCreatePermanentThreadController dealloc.&quot;);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; self.navigationItem.title = @&quot;创建常驻线程&quot;; // 启动线程 [self permanentThread];&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; // 取消线程 // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例 BOOL canCancel = YES; if (canCancel) &#123; [[self permanentThread] cancel]; &#125;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 模拟在指定线程上面再次执行方法 SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;); [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];&#125;- (NSThread *)permanentThread &#123; static NSThread *thread = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil]; [thread setName:@&quot;veryitman-thread&quot;]; // 同一个线程连续多次 start 会导致 crash [thread start]; &#125;); return thread;&#125;- (void)asyncRun &#123; @autoreleasepool &#123; NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 添加 source NSPort *port = [NSMachPort port]; [runLoop addPort:port forMode:NSRunLoopCommonModes]; NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop); // 执行其他逻辑 //... // 手动开启 RunLoop [runLoop run]; NSLog(@&quot;veryitman--asyncRun. End Run.&quot;); &#125;&#125;- (void)runAnyTime &#123; NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);&#125; 参考文档Toll-Free Bridging Run Loops]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop 常驻线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发人员需具备一点产品能力]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%8F%91%E4%BA%BA%E5%91%98%E9%9C%80%E5%85%B7%E5%A4%87%E4%B8%80%E7%82%B9%E4%BA%A7%E5%93%81%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[为了开始今天的话题, 我先来借助几个角色, 模拟一下工作中的某些场景. 设立人物小 A 是名刚入门的技术人员, 比较听话.小 B 是有工作经验的一名技术人员, 平时喜欢看看产品相关的书籍, 喜欢和产品经理撕逼.小 C 就厉害了, 不仅技术厉害, 也具有产品思维, 除了阅读产品类的书籍, 还写产品体验报告和体验竞品(和当前自己产品相关的产品).小 D 就是一名产品经理, 具有一定的产品能力, 数据分析能力和管理能力. 人物已经设立好了, 现在让他们登场. 情景再现: 需求评审这天风和日丽, 小 D(产品经理) 通知项目组的所有成员, 包括设计/开发/运营/测试等人员按时参加产品需求评审会议. 为了缓解大家的情绪, 小 D 买了很多零食和水果, 也算是犒劳一下大家. 小 D 开始给大家讲需求了, 像往常一样, 拿出精湛的原型, 口沫直飞的向大家展示其绵绵不绝的口才和产品思维. 小 A 一直在点头, 也不知道到底有没有听懂小 D 在说什么, 反正我看到有部分设计人员已经开始打瞌睡了. 突然, 小 C 中断了正在口述的小 D, 小 D 不慌不忙的停止了手中的一切动作, 聚精会神的听小 C 的意见和建议. 小 C 也有条不紊的将刚才的某项需求口述了一遍, 按照小 C 的逻辑, 目前的需求还是存在一些漏洞的, 这个时候, 小 D 开始认真的跟小 C 开始交流, 但是没有马上肯定小 C, 只是说我暂时记下这个点, 回头在思考一番. 产品小 D 稳如老狗, 继续自己的表演. 产品需求基本已经讲完了, 现在是大家提问题和交流的时间, 我看到有些同事揉了揉眼睛, 像是如梦初醒般的看着产品小 D, 不是旁边的同事拉住 Ta, 估计都能冲出会议室. 小 B 也不淡定了, 提出了不少问题, 并从技术的角度说明了实现的难度. 产品经理听的也是一脸懵逼, 心理想: “你实现是否有困难管我鸟事?”. 小 B 在产品小 D 那里并没有得到应有的表扬和鼓励, 反遭到同事小 C 的鄙视, 小 C 说, 你先不要告诉他实现方案, 先讨论这个需求的场景和真伪度. 小 D 默默的对小 C 投过赞赏的目光. 紧接着测试和其他人员提出了几个不痛不痒的问题, 都被老练的小 D 一一破解, 那气势, 啧啧! 势如破竹! 需求评审会议就这样结束了. 情景再现: 需求变更在产品进入开发和设计阶段, 按理说需求变更也算是比较正常的一件事情. 这年头, 唯一不变的就是变化. 小 B 正在聚精会神的写代码, 突然小 D 跟他说, 这个地方的需求需要修改一下, 你看改动有多大? 小 B 鄙视的看着产品经理小 D, 心理在说改动有多大你心里还没有点 B数嘛. 小 B 还是控制了自己的情绪, 接着说道, 你当初应该好好思考的, 你看我都快做完了, 你才告诉我需要改动. 噼里啪啦的说完, 估计小 B 心理也暗爽了不少, 最终还是接受了这次的变动. 小 A 负责的模块, 也被产品经理修改过, Ta 和产品经理小 D 的交流基本是, 哦, 恩, 好, 可以! 当小 C 找到小 D 的时候, 并没有直接告诉小 D 需要改东改西, 而是问问小 D, 你看这样会不会更好一些? 小 C 当然明白小 D 的目的了, 于是拿出自己看过的竞品, 并说出了自己的意见, 愉快的和小 D 交流后, 居然 TMD 的砍了一个需求. 这让旁边的小 A 和小 B 羡慕不已. 总结上面的两种情景, 我相信做过开发的同事应该都深有体会, 但是千万不要对号入座, 我只是打个比方. 从上面看出, 小 C 是一个很不错的角色, 无论是思维还是沟通能力都有别与他人, 最重要的是他没有仅仅把自己当做一名开发人员, 而是站在产品的角度去思考问题和解决问题. 需求变更是常态, 作为开发人员, 要最大限度的给产品以支持. 产品经理也是人, 当然有考虑不周的地方, 如果你不能想出更好更完美的解决方案, 请支持他的决定. 多站在别人的角度去思考问题, 换位思考, 才能保证有效的沟通. 作为一名技术人员, 尤其是在互联网行业, 多多少少都应该需要具备一定的产品思维.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>技术 生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不让 SIGPIPE signal 太嚣张]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%B8%8D%E8%AE%A9-SIGPIPE-signal-%E5%A4%AA%E5%9A%A3%E5%BC%A0%2F</url>
    <content type="text"><![CDATA[起因由于项目迭代比较快, 大家还没有来得及做自我调整和总结, 就需要投入到新版本当中开发新功能了. 在最近的一次版本测试和体验过程中, 很多内测用户反馈进入或者退出 App 的聊天室, 会莫名其妙的崩溃掉(Crash).对于 Crash 的问题, 我们开发同事绝对是零容忍, 于是就开始跟踪问题. 跟踪了很久, 发现这个 Crash 并不是那么的 ‘乖巧’, 很难复现!既然用户已经反馈了并且后台也有 Crash 上报, 这个问题肯定存在, 所以我们不能放弃. 好吧, 继续加班搞…苦逼中… 最终, 我们发现一个规律, 在日志后台, 看到很多类似下面的日志: 1Signal 13 was raised. SIGPIPE (_mh_execute_header + 420728) 很遗憾的是, 堆栈信息中没有提供给我们更有力的证据, 所以当时定位在 Signal 13 这个点上面. 也算是有了突破…这班没有白加… 排查问题既然所有的罪证都指向了 Signal 13, 我们就需要去跟踪它, 去调查它, 去研究它. 在 signal.h 文件中, 可以发现其定义如下: 12/* write on a pipe with no one to read it */#define SIGPIPE 13 用通俗的话来讲, 就是管道破裂. 管道破裂，这个信号通常在进程间通信产生，比如采用 FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到 SIGPIPE 信号.此外用 Socket 通信的两个进程，写进程在写 Socket 的时候，读进程已经终止.另外, 在 send/write 时会引起管道破裂，关闭 Socket, 管道时也会出现管道破裂.使用 Socket 一般都会收到这个 SIGPIPE 信号. 也就是说, 该信号是跟 Socket 的连接以及数据的读写相关联的. 这样的话，我们就知道为什么进退房间导致 Crash 了，我们的进退房间都和 Socket 有关联，这种 Crash 大都数是在用户网络不好的情况下发生的. 解决问题类似 signal 13 这种错误是系统发出来的, 和内存使用异常和野指针一样，由于是系统级别崩溃，所以不能通过 123456@try &#123;&#125;@catch(NSException *exception) &#123;&#125; 捕获到这类异常. 因此, try catch 是无法解决问题的. 目前有两个方案可用: 方案1. 忽略这类信号. 方案2. 修改源码, 在 IM 代码里面修改. 因为, IMSDK 我们是使用第三方的, 所以无法更改其源码, 所以采取了方案1: 忽略这类信号. 忽略的方案很简单, 在你连接或者初始化 IMSDK 之前, 只需要一行代码: 1signal(SIGPIPE, SIG_IGN); 示例代码: 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // ... signal(SIGPIPE, SIG_IGN); // ...&#125; 对于 方案2, 我查阅了一下 CocoaAsyncSocket 的源码: 1234// Prevent SIGPIPE signals int nosigpipe = 1;setsockopt(socketFD, SOL_SOCKET, SO_NOSIGPIPE, &amp;nosigpipe, sizeof(nosigpipe)); 所以对于 方案2, 就是增加上面的代码即可, 即设置 Socket 不发送 SIGPIPE 信号. 对于上面的两种方案, 苹果开发者文档 Avoiding Common Networking Mistakes 都有提及. 问题复现既然这个问题很难复现, 我们就想办法让他很容易复现. 可以采用手动发送 signal 的方式, 来复现这个问题. 先看一下 kill(3) - Linux man page 函数: The kill() function shall send a signal to a process or a group of processes specified by pid. The signal to be sent is specified by sig and is either one from the list given in or 0. If sig is 0 (the null signal), error checking is performed but no signal is actually sent. The null signal can be used to check the validity of pid. kill 函数是可移植操作系统接口 POSIX(Portable Operating System Interface of UNIX) 定义的, 可以参考 维基百科. 示例代码: 12345678910111213141516171819202122- (void)viewDidLoad&#123; [super viewDidLoad]; //获取进程 id pid_t cur_pid = getpid(); printf("current process's id: %i\n", cur_pid); //延时10s 为了让 Bugtags 有时间上报日志. dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; wpcSendSignal(cur_pid); &#125;);&#125;///手动发送信号int wpcSendSignal(int pid)&#123; int ret = kill(pid, SIGPIPE); return ret;&#125; 我们将 signal(SIGPIPE, SIG_IGN) 代码先注释. 运行 APP 到手机, 然后退出 Xcode 的连接. 注意: 这里如果连接 Xcode, 不会直接 Crash, 所以需要断开手机与 Xcode 的连接. 在后台可以看到类似的 Crash 日志: 除了上面使用 kill 函数外, 我们还可以使用 raise 函数来发送 signal. 关于 raise 函数, 可以查阅 手册. 或者直接问男人(man): 1man raise 问题再次来临: 与 Bugtags 的结合本以为采用上述方案就万事大吉了, 在第二次提测后, 还是有这种 Crash 的问题在后台上报. 排查了很久后才发现，问题的原因是 BugTags 也会控制这个开头，默认是不忽略，这样： 1234/** * 是否忽略 PIPE Signal (SIGPIPE) 闪退，默认 NO */@property(nonatomic, assign) BOOL ignorePIPESignalCrash; 这个默认设置为 NO, 即可以上报 PIPE Signal Crash 的问题. 这里也说明一个问题, 即使我们采用 方案1 解决 Crash 的问题了, Bugtags 还是会将这种 Crash 上报到后台. 示例代码: 12345bugtag.option.ignorePIPESignalCrash = YES;// ...signal(SIGPIPE, SIG_IGN); 对比一下测试的两张图, 第一张图到第二张图是增加了两次崩溃次数, 原因是故意设置了 bugtag.option.ignorePIPESignalCrash = NO, 也正好验证了我们的想法. 总结 Xcode 连接真机或者模拟器, 运行出现异常断点, 可能就是隐患点. 学会使用后台日志找到规律, 继而去思考并解决问题. 对 Crash 进行更深入的分析和总结, 不要轻易放弃. 后续研究 是否可以忽略其他的 signal, 来避免不必要的 Crash? 自定义一套关于 signal 捕获的跨平台库, 在开发阶段可以直接看到完整的日志. 推荐 Avoiding Common Networking Mistakes linux die Using Sockets and Socket Streams 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Crash linux signal SIGPIPE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这样学习你愿意吗?]]></title>
    <url>%2F2018%2F04%2F07%2F%E8%BF%99%E6%A0%B7%E5%AD%A6%E4%B9%A0%E4%BD%A0%E6%84%BF%E6%84%8F%E5%90%97%2F</url>
    <content type="text"><![CDATA[不得不承认, 学习确实是个「苦差事」, 这里说的学习不仅仅指伏案学习, 之乎者也等, 而是一种广泛的学习. 如何学习是始终要去探讨的一个话题, 时代在变, 环境在变, 学习当然也不能一成不变. 坚持学习是一辈子的事, 活到老学到老. 既然学习是一个漫长的马拉松, 那我们只有持之以恒的’跑’下去, 才能保持不掉队. 这样一来, 学习方法和学习技巧就是取胜的关键了. 世上没有绝对的学习妙招和学习宝典, 找到适合自己的就是最好的. 下面我结合自己的一些经历给大家分享在学习的道路上遇到的那些事. 不管怎样, 学习一定要带着目标, 结合理论再去实践, 事半功倍. 欢迎大家在评论区交流, 不喜勿喷~ 回忆当天事每晚躺在床上或者沙发上, 发发呆, 把当天做过的事情, 在脑海中统统的过一遍, 像放电影一样, 能有多详细就多详细, 也就是说尽量的回忆细节. 这种做法看似很简单, 其实很难坚持下去. 特别是中间几天, 很多人都会放弃, 再加上现在手机互联网的 “毒害”, 留给自己去真正学习的时间更少了. 但是只要你咬咬牙坚持一下, 把这个习惯养成, 就会终生受用. 我在初中时期已经养成了这个习惯, 直到大学都没有放弃. 大学里面每次期末考试, 看到很多人忙的不可开交, 我都是不慌不忙的, 悠闲自得, 室友问我怎么做到游刃有余, 我说你白天少睡点觉, 平时注意听讲, 晚上回忆一下就可以了, 从他迷茫的眼神中可以看出, 他当时并不完全相信我说的! 每次回忆结束, 有些东西还是比较模糊甚至一知半解, 没事, 你第二天去翻阅相关知识再去整理和理解一下就好了, 这种自我激励比任何鞭策都有用. 有些困难只是暂时的, 想办法 ‘挺’ 过去, 你就赢了. 很多时候不是困难吓到了我们, 而是我们放弃了自己. 多想多问和你身边兴趣相投或者比你有能力的人多交流, 交流的过程也是你练习自我表达能力的过程, 把自己的问题能够清楚的描述给别人听, 也是一种能力. 不知道大家有没有这样一种感觉, 在跟别人交流的过程中, 虽然别人没有直接帮你解决问题, 但是你突然有了解决问题的办法. 为什么会这样呢? 很简单, 因为这个问题你之前思考过, 只是在交流的过程中, 你的大脑专注在此, 聚精会神的在想这件事情. 问问题有一套门道. 在请教别人问题之前, 最好自己先尽力想一想, 不要遇到一点问题就去问东问西, 即使别人给你讲了, 你也只是当时明白了, 下次再遇到此类问题, 你依然懵逼. 还有就是会让你形成一种依赖心理, 反正有人能解决, 我问就可以了, 干嘛还有费时费力的去想?! 久而久之, 就破罐子破摔了. 另外一个要说的就是在请教或者交流问题的时候, 要对对方谦虚. 我很感激高中时代, 班主任很信任我, 让我当了三年班长, 那三年让我学到了很多书本之外的东西, 其中沟通和管理让我在今后的工作中受益匪浅. 阅读和写作 这里说的写作不是指专业的作家级的写作, 泛指任何文字的记录, 日记也算. 每天最幸福的时刻就是在 23:00 点之前坐在电脑前, 可以写自己心中要表达的内容, 任思绪飘摇. 只要有闲暇的时间, 我就会整理和总结这段时间发生的事情, 既有工作上的也有生活上的. 小的时候, 家里比较穷, 交学费都是问题, 更别说是买书了. 我记得初中一年级, 我很想要一本英语书籍, 那种渴望至今难忘! 后来, 我每天从自己的生活费里抠出一点钱(生活费本来就少), 就这样积攒了几个星期, 去新华书店买了一本英语书籍. 高中时期, 有同学不要的或者已经不读的书籍, 我都会借过来看, 沉浸在自己的幸福当中. 参加工作之后, 我也有写博客的习惯, 把自己工作中遇到的问题以及解决问题的思路和方式写出来, 分享给其他人, 快乐无比. 特别是收到文章的评论后, 心理美滋滋的. 在互联网的海洋里, 大家素不相识, 通过键盘上敲击的文字互相交流知识和想法, 彼此成长着, 也别具一番乐趣. 阅读和写作可以培养自己的专注力, 这么好的习惯你千万不要拒绝. 写作可以倒逼着你去阅读, 去关心生活里面的点滴, 阅读和生活中的体验又可以激发你写作的欲望, 两者相辅相成. 推荐给大家一本书: Google 工作整理术 谷歌前CIO（首席信息官）分享风靡谷歌的信息整理术，帮助现代人彻底告别无序工作，学会利用数字工具为大脑减压！信息太多、时间太少，整理信息已成为现代人急需掌握的必备技能。谷歌作为引领全球的信息搜索与整合巨头，拥有能够有序整理信息的独特方式，而谷歌首席信息官便是主导这一“信息工厂”的总工程师。如今，曾担任“总工程师”的道格拉斯梅里尔亲自将风靡谷歌的信息整理方式分享给大众读者，帮助现代人克服无序工作的通病。《Google工作整理术》告诉你：不要花太多时间给信息归档，用的时候学会去搜索；在数字信息文档中加上关键词，方便日后检索；从前，知识就是力量,现在，共享知识才是力量；把工作和生活融为一体，而不是力图在二者之间求平衡。这些实用 Tips 都揭示了：信息整理才是高效工作的关键，信息整理已是现代人的工作必备技能！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 感悟 学习 阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 总结消息转发中用到的知识点]]></title>
    <url>%2F2018%2F04%2F05%2FOC-RunTime-%E6%80%BB%E7%BB%93%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言OC-RunTime: 消息转发之实例方法的转发流程 OC-RunTime: 消息转发之实例方法的转发流程实例讲解 OC-RunTime: 消息转发之类方法的转发流程 在上面的几篇文章中我分享了关于消息转发相关的知识点，里面有很多细节没有阐述。 若在上面的文章中加入很多细节点的话，一是拉长了文章的内容, 二是对于刚接触 Runtime 的朋友来说不一定能接受, 于是就有了这篇文章的诞生. RunTime 的定义及使用场景苹果 开发文档 的这样解释 runtime 的： 1The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work 尽量将决定放到运行的时候，而不是在编译和链接过程中. RunTime 的应用场景: 1.面向切面编程 AOP.2.方法调配 method swizzling. 有些地方称之为”黑魔法”.3.消息转发.4.给分类添加属性(关联对象).5.动态获取 class 和 slector.6.KVO/KVC, 修改私有属性的值. 建议去阅读下面框架的源码，恕我没有加入链接: Aspects（AOP必备，“取缔” baseVC，无侵入埋点） MJExtension（JSON 转 model，一行代码实现 NSCoding 协议的自动归档和解档） JSPatch（动态下发 JS 进行热修复） NullSafe（防止因发 unrecognised messages 给 NSNull 导致的崩溃） UITableView-FDTemplateLayoutCell（自动计算并缓存 table view 的 cell 高度） UINavigationController+FDFullscreenPopGesture（全屏滑动返回） 思考问题在前面的文章中，很多次看到 IMP、SEL、selector 以及 Method 等关键字，相信大家随着对 RunTime 的逐步了解，慢慢会逐渐熟悉它们的，只是时间问题。很多概念上面的东西理解起来没那么简单，需要动手去写写代码。 在看下面内容之前, 先抛出一个问题: runtime 如何通过 selector 找到对应的 IMP 地址? 接下来分别说一下 IMP、SEL、selector 以及 Method. IMPIMP 保存的是 Method 的地址，本质是一个函数指针，由编译器生成。 IMP 在 objc.h 中的定义： 123456/// A pointer to the function of a method implementation. #if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif 向对象发送消息之后，是由这个函数指针 IMP 指定的, 即 IMP 函数指针就指向了方法的实现. IMP 函数指针最少包含 id 和 SEL 类型的两个参数，后面其他的参数是对应方法需要的参数。其中 id 代表执行该方法的 target(对象), SEL 就是对应的方法, 通过 id 和 SEL 参数就能确定唯一的方法实现地址. 那么我们如何获取方法的 IMP 呢？很简单. NSObject 提供了如下两个方法: 12- (IMP)methodForSelector:(SEL)aSelector;+ (IMP)instanceMethodForSelector:(SEL)aSelector; 对应的实现(源码 NSObject.mm), 如下: 1234567891011121314+ (IMP)instanceMethodForSelector:(SEL)sel &#123; if (!sel) [self doesNotRecognizeSelector:sel]; return class_getMethodImplementation(self, sel);&#125;+ (IMP)methodForSelector:(SEL)sel &#123; if (!sel) [self doesNotRecognizeSelector:sel]; return object_getMethodImplementation((id)self, sel);&#125;- (IMP)methodForSelector:(SEL)sel &#123; if (!sel) [self doesNotRecognizeSelector:sel]; return object_getMethodImplementation(self, sel);&#125; 大家可以看到，对应的 methodForSelector 既有实例方法又有类方法，而 instanceMethodForSelector 只有类方法。 在使用 methodForSelector 方法时，向类发送消息，则 SEL 应该是类方法, 若向实例对象发送消息，则 SEL 应该为实例对象方法. 而 instanceMethodForSelector 仅仅允许类发送该消息, 从而获取实例方法的 IMP. 该方法无法获取类方法的 IMP, 如果想获取类方法的 IMP 可以使用 methodForSelector 来获取。 函数文档原文解释如下: 12Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class method, send the methodForSelector: instance method to the class instead. 举个例子，或许更好理解。 下面两个方法, 一个是类方法(testClassMethod), 另一个是实例方法(testInstanceMethod). 12345+ (void)testClassMethod &#123;&#125;- (void)testInstanceMethod &#123;&#125; 分别使用上面提到的方法来获取 IMP 的几个方法. 123456789IMP imp = [[self class] instanceMethodForSelector:@selector(testClassMethod)];IMP imp2 = [[self class] instanceMethodForSelector:@selector(testInstanceMethod)];// 也可以改成 NSObject 调用的方式, 结果一样.// IMP imp = [NSObject instanceMethodForSelector:@selector(testClassMethod)];// IMP imp2 = [NSObject instanceMethodForSelector:@selector(testInstanceMethod)]; IMP imp3 = [[self class] methodForSelector:@selector(testClassMethod)];IMP imp4 = [self methodForSelector:@selector(testInstanceMethod)]; 调试器可以看出, 如下日志: 123456789101112Printing description of imp:(IMP) imp = 0x000000010d8455c0 (libobjc.A.dylib`_objc_msgForward)Printing description of imp2:(IMP) imp2 = 0x000000010cf19b90 (-[ViewController testInstanceMethod] at ViewController.m:94)Printing description of imp3:(IMP) imp3 = 0x000000010cf19b60 (+[ViewController testClassMethod] at ViewController.m:89)Printing description of imp4:(IMP) imp4 = 0x000000010cf19b90 (-[ViewController testInstanceMethod] at ViewController.m:94)(lldb) imp2、imp3、imp4 都是正常的，唯独 imp 不正常，也充分说明了 instanceMethodForSelector 无法获取类方法的 IMP. Method在源码 runtime.h 中, 定义 method, 其本质是一个结构体. 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 方法名 method_name 类型为 SEL. method_types 方法类型, 是一个 char 指针，存储着方法的参数类型和返回值类型。 方法实现 method_imp 的类型为 IMP. 可以看出, 有 SEL 和 IMP, method_types 是对应的方法返回值和参数类型, 如 v@:，是一个字符串。 runtime.h 中有两个方法，可以根据 SEL 直接获取实例方法和类方法的 Method，如下: 123Method class_getInstanceMethod(Class cls, SEL name);Method class_getClassMethod(Class cls, SEL name); SELselector, 称之为方法选择器，SEL 是 selector 的表示类型，也是方法的编号，是类成员方法的指针。 SEL 定义在源码 objc.h 中, 是一个结构体指针, 如下: 12/// An opaque type that represents a method selector.typedef struct objc_selector *SEL; 但是源码中查不到 objc_selector 具体的定义和实现. 获取 SEL 有三个方法: 123SEL sel = @selector(play:);SEL sel = sel_registerName("play:"); SEL sel = NSSelectorFromString(@"play"); SEL 表示一个 selector 的指针，无论什么类里，只要方法名相同，SEL 就相同，SEL 实际是根据方法名 hash 化了的字符串。而对于字符串的比较仅仅需要比较他们的地址就可以了，所以速度上非常快，SEL 的存在加快了查询方法的速度。 思考一个问题：为什么在同一个 OC 类中，不能存在同名的函数，即使参数类型不同也不行，换句话说 OC为什么没有重载？ 答案已经在上面说了，SEL 表示一个 selector 的指针，无论什么类里，只要方法名相同，SEL 就相同，相同的函数名，编译器无法编译通过。 dispatch table 存放 SEL 和 IMP 的对应关系，SEL 最终会通过 dispatch table 寻找到对应的IMP。 总之，Selector、Method 和 IMP 三者之间的关系可以这么解释，在类的(实例和类方法)调度表(dispatch table)中的每一个实体代表一个方法 Method，其名字叫做选择器 SEL，并对应着一种方法实现称之为 IMP，有了 Method 就可以使用 SEL 找到对应的 IMP，SEL 就是为了查找方法的最终实现 IMP。 class_addMethod查看源码 objc-runtime-new.mm 中该函数实现如下: 1234567BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)&#123; if (!cls) return NO; rwlock_writer_t lock(runtimeLock); return ! addMethod(cls, name, imp, types ?: "", NO);&#125; 开发文档中这样描述该函数: 1234Adds a new method to a class with a given name and implementation.class_addMethod will add an override of a superclass's implementation, but will not replace an existing implementation in this class. To change an existing implementation, use method_setImplementation. 解释一下，可以为类根据 SEL 和 IMP 动态添加一个新方法。class_addMethod 仅可以动态添加方法，不会替换。如果想达到方法替换的效果可使用 method_setImplementation 函数。 关于 method_setImplementation 和 method_exchangeImplementations 后面文章再做分析. 其实, method_exchangeImplementations 的内部实现相当于调用了 2 次 method_setImplementation 方法。 class_addMethod 不仅可以动态添加类方法, 也可以添加实例方法。 参数及返回值解释: 123456789返回值: 返回 YES 表示方法添加成功, 否则添加失败。参数 Class cls: 将要给添加方法的类, 即［类名 class］参数 SEL name: 将要添加的方法 SEL, 即 @selector(方法名)，如果已经存在，该方法返回失败，不存在就添加成功。参数 IMP imp：实现这个方法的函数. 有两种写法即 C 和 OC 的写法. 一个 IMP 最少包括两个参数, 上面已经说过。参数 const char *types: 实现方法的函数的返回和参数编码类型. 如 "v@:" 表示返回值为 void, 没有参数的一个函数, 其中 @和:分别代表 IMP 的默认两个参数即 id 和 sel. 关于 types，可以使用 method_getTypeEncoding 来获取。 更多关于 types 的内容可以参考开发者文档 Type Encodings. 解答问题读到这里, 大家对 IMP, SEL 以及 Method 应该有初步的了解了, 那么来解答一下刚才提出的问题: runtime 如何通过 selector 找到对应的 IMP 地址? 回答这个问题的关键是要知道消息调度表(dispatch table)，另外一个要回答的要点是 IMP 的实现和获取以及和 Method 之间的关系。 类对象中有类方法和实例方法的分发表，表中记录着方法的名字、参数和实现，selector 本质就是方法名称，runtime 通过这个方法名称就可以在列表中找到该方法对应的实现. 系统为我们提供了获取 IMP 指针的函数，无论是类方法还是实例方法我们都可以获取对应的 IMP. 而 Method 将 Selector 和 IMP 联系起来，可从源码中看出: 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; IMP 是函数的指针，它是由编译器编译生成的。当发一个消息时，它会找到那段代码执行，IMP 指向了这个方法的具体的实现，得到这个函数的指针可以直接执行。 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址，反之亦然。当发送消息给一个对象时，runTime 会在对象的类对象方法列表里查找，当我们发送一个消息给一个类时，这条消息会在类的 Meta Class 对象的方法列表里查找，直到超找到 NSObject 中为止。 消息传递的过程 1. 当消息被发送给一个对象，messaging function 跟随对象的 isa 指针找到它的 class structure，在 dispatch table 中寻找 method selector. 2. 如果没有找到 selector，objc_msgsend 跟随该类实例的 isa 找到父类，尝试在父类的 dispatch table 中寻找 selector. 3. 重复步骤 2，直到 isa 指向 NSObject Class 为止。 关于分发表和消息相关的知识可以参考开发文档 Messaging，讲得很清楚。 实际例子说了这么多理论知识，是时候举栗子了，方便大家更好的理解上面的内容。 1. 动态添加实例方法Student.m 除 init 外，Student 只有一个实例方法 studentWalkImp. 12345678910111213141516171819202122232425262728@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; SEL proxySelector = NSSelectorFromString(@"studentWalkImp"); IMP impletor = class_getMethodImplementation([self class], proxySelector); // 获取实例方法 Method method = class_getInstanceMethod([self class], proxySelector); const char *types = method_getTypeEncoding(method); SEL origSel = NSSelectorFromString(@"walk"); class_addMethod([self class], origSel, impletor, types); &#125; return self;&#125;- (void)studentWalkImp&#123; NSLog(@"---veryitman--- Student studentWalkImp");&#125;@end 调用测试一下. 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; Student *stud = [[Student alloc] init]; [stud performSelector:NSSelectorFromString(@"walk") withObject:nil];&#125; 这里 Student 并没有 walk 方法，故意为之，运行后控制台会打印: 1---veryitman--- Student studentWalkImp 成功的为 Student 添加了一个实例方法 walk 的实现 studentWalkImp. 上面的例子是使用 OC 的 IMP 方式来实现的，可以改为 C 实现版本的. 123456789101112131415161718@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; SEL origSel = NSSelectorFromString(@"walk"); class_addMethod([self class], origSel, (IMP)studentWalkImp, "v:@"); &#125; return self;&#125;void studentWalkImp()&#123; NSLog(@"---veryitman--- Student studentWalkImp");&#125; 2. 动态添加类方法动态添加类方法，和动态添加实例方法稍微有点不同。下面是改造后的 Student.m. Student.m 123456789101112131415161718192021222324252627282930@implementation Student- (instancetype)init&#123; self = [super init]; if (self) &#123; // 获取 MetaClass, 类方法不可以使用 [self class] Class metaCls = objc_getMetaClass([NSStringFromClass([self class]) UTF8String]); SEL proxySelector = NSSelectorFromString(@"clsImp"); IMP impletor = class_getMethodImplementation(metaCls, proxySelector); // 获取类方法 Method method = class_getClassMethod([self class], proxySelector); const char *types = method_getTypeEncoding(method); SEL origSel = NSSelectorFromString(@"walk"); class_addMethod(metaCls, origSel, impletor, types); &#125; return self;&#125;+ (void)clsImp&#123; NSLog(@"---veryitman--- Student clsImp");&#125; 注意：这里获取 Class 稍微不同的是使用了 objc_getMetaClass，这里关系到 Objective-C 中的类、Class、根类和元类的区别，可以参考 Class、isa、元类 这篇文章。 调用测试一下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; Student *stud = [[Student alloc] init]; [[stud class] performSelector:NSSelectorFromString(@"walk") withObject:nil];&#125; 控制台打印： 1---veryitman--- Student clsImp 成功地为类动态的添加了一个类方法 clsImp. 参考文档1. Objective-C 对象模型及应用 2. Apple RunTime 源码 objc4-723.tar.gz 3. Messaging 4. Objective-C 深入理解中的消息机制和方法调用 完整代码点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 消息转发之类方法的转发流程]]></title>
    <url>%2F2018%2F04%2F03%2FOC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本篇是「消息转发」系列的第三篇, 在 OC-RunTime: 消息转发之实例方法的转发流程 和 OC-RunTime: 消息转发之实例方法的转发流程[实例讲解] 中分享了实例方法的转发流程. 今天分享如何对类方法进行消息的转发. resolveClassMethodNSObject 提供了 resolveClassMethod 来让开发者在里面动态添加一个类方法. 类方法的转发流程和实例方法转发的流程大致一样, 唯独不同的是需要重写的方法(NSObject中)的不一样. 当时我在写 Demo, 以为只需要将 resolveInstanceMethod 改为 resolveClassMethod 就万事大吉了即重写下面几个方法就可以解决问题, 事实证明这样是不行的. +resolveClassMethod -forwardingTargetForSelector -methodSignatureForSelector -forwardInvocation -doesNotRecognizeSelector: 网上很多博文并没有深入的探讨关于类方法转发的流程, 只是在介绍实例方法转发的流程的同时, 一笔带过类方法转发机制和流程. 通过对 NSObject.mm 源码的查看, 可以看到对应上面的几个方法都有类方法. 如下: 123451. +resolveClassMethod2. +forwardingTargetForSelector3. +methodSignatureForSelector4. +forwardInvocation5. +doesNotRecognizeSelector: 重新这几个方法才是解决问题的关键. 现在我们重写 resolveClassMethod, 如下. ViewController.m 123456789101112131415161718192021222324252627282930313233#import &lt;objc/runtime.h&gt;static NSString * const sPerformClassMethodName = @"veryClassMethod";+ (BOOL)resolveClassMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveClassMethod"); NSString *methodName = NSStringFromSelector(sel); if ([sPerformClassMethodName isEqualToString:methodName]) &#123; // 获取 MetaClass Class predicateMetaClass = objc_getMetaClass([NSStringFromClass(self) UTF8String]); // 根据 metaClass 获取方法的实现 IMP impletor = class_getMethodImplementation(predicateMetaClass, @selector(proxyMethod)); // 获取类方法 Method predicateMethod = class_getClassMethod(predicateMetaClass, @selector(proxyMethod)); const char *encoding = method_getTypeEncoding(predicateMethod); // 动态添加类方法 class_addMethod(predicateMetaClass, sel, impletor, encoding); return YES; &#125; return [super resolveClassMethod:sel];&#125;+ (void)proxyMethod&#123; NSLog(@"---veryitman--- +proxyMethod of class's method for OC.");&#125; 模拟调用 12345678910- (void)viewDidLoad&#123; [super viewDidLoad]; // 运行类方法 SEL selector = NSSelectorFromString(sPerformClassMethodName); SuppressPerformSelectorLeakWarning( [[self class] performSelector:selector withObject:nil]; );&#125; 关于 SuppressPerformSelectorLeakWarning 可以参考 OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]. 将动态添加的方法让 proxyMethod 来执行, 显示结果达到预期. 12---veryitman--- 1--- +resolveClassMethod---veryitman--- +proxyMethod of class's method for OC. 创建被转发者MZTempObj.m 123456789@implementation MZTempObj/// 类方法+ (void)veryClassMethod&#123; NSLog(@"---veryitman--- veryClassMethod");&#125;@end 这里有类方法的一个实现 veryClassMethod. 重写转发消息的函数同理将 resolveClassMethod 修改一下, 为了保证流程继续. 示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115+ (BOOL)resolveClassMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveClassMethod. selector: %@", NSStringFromSelector(sel)); NSString *methodName = NSStringFromSelector(sel); // 这里故意将 sPerformClassMethodName 改为 @"", 为了流程往下走 if ([@"" isEqualToString:methodName]) &#123; // 获取 MetaClass Class predicateMetaClass = objc_getMetaClass([NSStringFromClass(self) UTF8String]); // 根据 metaClass 获取方法的实现 IMP impletor = class_getMethodImplementation(predicateMetaClass, @selector(proxyMethod)); // 获取类方法 Method predicateMethod = class_getClassMethod(predicateMetaClass, @selector(proxyMethod)); const char *encoding = method_getTypeEncoding(predicateMethod); // 动态添加类方法 class_addMethod(predicateMetaClass, sel, impletor, encoding); return YES; &#125; return [super resolveClassMethod:sel];&#125;+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- +forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); if ([sPerformClassMethodName isEqualToString:selectorName]) &#123; // 注意1: 也可在此转发实例方法#if 0 // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject;#endif // 转发类方法对应返回类对象 return [MZTempObj class]; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 3--- +methodSignatureForSelector"); // 找出对应的 aSelector 签名 NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; // 注意2: 也可以在此获取实例方法的签名#if 0 if (nil == signature) &#123; // 是否有 aSelector if ([MZTempObj instancesRespondToSelector:aSelector]) &#123; signature = [MZTempObj instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;#endif if (nil == signature) &#123; // 是否有 aSelector if ([MZTempObj respondsToSelector:aSelector]) &#123; //methodSignatureForSelector 可以获取类方法和实例方法的签名 //instanceMethodSignatureForSelector只能获取实例方法的签名 signature = [MZTempObj methodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@"---veryitman--- 4--- +forwardInvocation"); // 注意3: 也可以调用实例方法#if 0 if ([MZTempObj instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:[[MZTempObj alloc] init]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125; return;#endif if ([MZTempObj respondsToSelector:anInvocation.selector]) &#123; // 这里转发的是 MZTempObj Class, 不是对象 [anInvocation invokeWithTarget:[MZTempObj class]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;+ (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 5--- +doesNotRecognizeSelector: %@", NSStringFromSelector(aSelector));&#125; 执行后, 控制台输出日志: 123---veryitman--- 1--- +resolveClassMethod. selector: veryClassMethod---veryitman--- 2--- +forwardingTargetForSelector---veryitman--- veryClassMethod 这里注意一下 将代码中 注意1 注意2 等部分可以自行打开测试一下, 然后将 MZTempObj.m 中的类方法(+veryClassMethod)改为实例方法(-veryClassMethod), 也是可以的, 这样就达到了将类方法转发给实例方法的效果. 修改一下 forwardingTargetForSelector 中的实现, 可以看到 4, 5也会执行. 123456789101112131415161718192021222324+ (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- +forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); if ([@"" isEqualToString:selectorName]) &#123; // 注意1: 也可在此转发实例方法#if 0 // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject;#endif // 转发类方法对应返回类对象 return [MZTempObj class]; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125; 123456---veryitman--- 1--- +resolveClassMethod. selector: veryClassMethod---veryitman--- 2--- +forwardingTargetForSelector---veryitman--- 3--- +methodSignatureForSelector---veryitman--- 1--- +resolveClassMethod. selector: _forwardStackInvocation:---veryitman--- 4--- +forwardInvocation---veryitman--- veryClassMethod 同理我们可以得到类方法的消息转发流程图, 如下图所示: 推荐OC-RunTime: 消息转发之实例方法的转发流程 OC-RunTime: 消息转发之实例方法的转发流程实例讲解 OC-RunTime: 总结消息转发中用到的知识点 点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]]]></title>
    <url>%2F2018%2F04%2F01%2FOC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程 分享了消息转发的流程, 本次结合实际例子继续分析一下消息转发流程. 发送不存在的消息在 ViewController 的 viewDidLoad 中运行 veryTestMethod 方法. ViewController.m 12345678910111213static NSString * const sPerformInstanceMethodName = @"veryTestMethod";- (void)viewDidLoad &#123; [super viewDidLoad]; // 运行实例方法 SEL selector = NSSelectorFromString(sPerformInstanceMethodName); SuppressPerformSelectorLeakWarning( [self performSelector:selector withObject:nil]; );&#125; 其中, SuppressPerformSelectorLeakWarning 是定义的一个宏. 1234567#define SuppressPerformSelectorLeakWarning(Stuff) \do &#123; \ _Pragma("clang diagnostic push") \ _Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \ Stuff; \ _Pragma("clang diagnostic pop") \&#125; while (0) 在 ViewController 中我并没有写 veryTestMethod 这个函数, 只是借助 performSelector 动态执行, 如果编译运行直接会 crash. 可以查看 NSObject.mm 源码, 里面关于消息转发的几个重要函数都写着 _objc_fatal, 可谓是招招毙命. 紧接着, 我们可以借助 resolveInstanceMethod 来完成消息转发给 ViewController. resolveInstanceMethod 转发重写 NSObject 中的 resolveInstanceMethod 函数. +resolveInstanceMethod ViewController.m 1234567891011121314151617181920212223242526// 记得导入 RunTime 头文件#import &lt;objc/runtime.h&gt;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveInstanceMethod"); NSString *methodName = NSStringFromSelector(sel); if ([sPerformInstanceMethodName isEqualToString:methodName]) &#123; SEL proxySelector = NSSelectorFromString(@"proxyMethod"); IMP impletor = class_getMethodImplementation(self, proxySelector); // 获取实例方法 Method method = class_getInstanceMethod(self, proxySelector); const char *types = method_getTypeEncoding(method); // 添加 OC 的函数 class_addMethod([self class], sel, impletor, types); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; ViewController 中实现的 proxyMethod 12345// OC 实现- (void)proxyMethod&#123; NSLog(@"---veryitman--- -proxyMethod of instance's method for OC.");&#125; 在 resolveInstanceMethod 中动态添加了 veryTestMethod 方法, 并让 proxyMethod 函数来实现(IMP). 运行可以看到, 程序并没有 crash, 成功的执行了 proxyMethod. 12---veryitman--- 1--- +resolveInstanceMethod---veryitman--- -proxyMethod of instance&apos;s method for OC. 到此为止, 我们已经看到动态添加一个方法的实现并成功运行的完整例子. 接下来, 我们将转发给其他对象 MZTempObj 来执行. 自定义被转发的对象MZTempObj.m 123456@implementation MZTempObj- (void)veryTestMethod&#123; NSLog(@"---veryitman--- veryTestMethod");&#125; veryTestMethod 就是我们要转发对应的消息. 消息转发实践接下来我们把向 ViewController 发送 veryTestMethod 的消息转发给 MZTempObj 的 veryTestMethod 方法. 继续重写下面函数, 不过 resolveInstanceMethod 要稍微改造一下, 才能达到我们实践的目的. +resolveInstanceMethod -forwardingTargetForSelector -methodSignatureForSelector -forwardInvocation -doesNotRecognizeSelector: ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 记得导入 RunTime 头文件#import &lt;objc/runtime.h&gt;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@"---veryitman--- 1--- +resolveInstanceMethod: %@", NSStringFromSelector(sel)); NSString *methodName = NSStringFromSelector(sel); // 这里故意为之, 让流程往下走 if ([@"" isEqualToString:methodName]) &#123; SEL proxySelector = NSSelectorFromString(@"proxyMethod"); IMP impletor = class_getMethodImplementation(self, proxySelector); // 获取实例方法 Method method = class_getInstanceMethod(self, proxySelector); const char *types = method_getTypeEncoding(method); // 添加 OC 的函数 class_addMethod([self class], sel, impletor, types); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;/// 转发给对应的某个对象来执行 aSelector- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- -forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); if ([sPerformInstanceMethodName isEqualToString:selectorName]) &#123; // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 3--- -methodSignatureForSelector"); // 找出对应的 aSelector 签名 NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (nil == signature) &#123; // 是否有 aSelector if ([MZTempObj instancesRespondToSelector:aSelector]) &#123; signature = [MZTempObj instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@"---veryitman--- 4--- -forwardInvocation"); if ([MZTempObj instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:[[MZTempObj alloc] init]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;- (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 5--- -doesNotRecognizeSelector: %@", NSStringFromSelector(aSelector));&#125; 运行程序, 控制台打印结果如下: 123---veryitman--- 1--- +resolveInstanceMethod---veryitman--- 2--- -forwardingTargetForSelector---veryitman--- veryTestMethod 这里对照之前的流程图是完全符合的, 那么怎么让其执行 3 和 4 呢? 很简单, 修改一下 forwardingTargetForSelector 里面的实现即可. 12345678910111213141516171819- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@"---veryitman--- 2--- -forwardingTargetForSelector"); NSString *selectorName = NSStringFromSelector(aSelector); // 故意为之 if ([@"" isEqualToString:selectorName]) &#123; // 让 MZTempObj 去执行 aSelector, 实现消息的转发 MZTempObj *myobject = [[MZTempObj alloc] init]; return myobject; &#125; id obj = [super forwardingTargetForSelector:aSelector]; return obj;&#125; 再次执行看结果: 123456---veryitman--- 1--- +resolveInstanceMethod veryTestMethod---veryitman--- 2--- -forwardingTargetForSelector---veryitman--- 3--- -methodSignatureForSelector---veryitman--- 1--- +resolveInstanceMethod: _forwardStackInvocation:---veryitman--- 4--- -forwardInvocation---veryitman--- veryTestMethod 注意: 这里在 3后面会多了一个 1--- resolveInstanceMethod 的打印, 是系统调用的, 此时对应的 sel 是 _forwardStackInvocation. 如果不去重写 methodSignatureForSelector 打印结果如下: 123---veryitman--- 1--- +resolveInstanceMethod---veryitman--- 2--- -forwardingTargetForSelector---veryitman--- 5--- -doesNotRecognizeSelector: veryTestMethod 参考文档1.Apple RunTime 源码 objc4-723.tar.gz 2.Message Forwarding 推荐OC-RunTime: 消息转发之实例方法的转发流程 OC-RunTime: 消息转发之类方法的转发流程 OC-RunTime: 总结消息转发中用到的知识点 点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程]]></title>
    <url>%2F2018%2F03%2F31%2FOC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本篇只是从系统函数的实现上, 来分析消息转发的流程. 下一篇结合本篇的理论和实际的例子来分析一下消息转发. 需要明确的几个问题在往下看这篇博文之前, 有几个问题需要大家达成共识. 1.Objective-C 的特点按照是否需要编译的原理来说, 编程语言一般可以分为静态编译类型和动态解释类型. 如 Java/C/C++ 是属于编译类型的语言, Php/Python/Ruby 属于解释类型的语言. Objective-C 是基于 C 并具有自身特点的编译型语言, 再加上其 RunTime 机制, Objective-C 既是编译型又是动态的一门编程语言. 所谓的动态指的是在程序编译后运行中可以改变其结构. 2.函数调用在 Objective-C 中调用函数, 被解释为向一个对象发送消息, 该对象可以是类对象也可以是实例对象. 例如: 1[person play]; 意思是向实例对象 person 发送一个 play 的消息. 还有一个比较有意思的是, 向一个空对象(nil) 发送消息不会 crash, 如果在 Java 中这个是不行的.例如: 12person = nil;[person play]; 这个不会导致程序崩溃, 只是调用 play 函数没有任何反应罢了! 3.self在 C++/Java 语言中, 有 this 指针的概念, 在 Objective-C 中, 也有类似的 this 指针即 self. self 既可以是实例对象也可以是类对象. 这里举个例子, 下面两个同名函数, 一个是类方法(+)一个是实例方法(-).跟 Java 中的类似, 实例方法可以直接使用类方法, 但是类方法不可以直接使用实例方法. 123456789101112131415161718192021+ (void)testClassMethod&#123; [self sendMsg];&#125;- (void)testInstanceMethod&#123; [self sendMsg];&#125;// 类方法+ (void)sendMsg&#123; NSLog(@"+ sendMsg. self: %@", self);&#125;// 实例方法- (void)sendMsg&#123; NSLog(@"- sendMsg. self: %@", self);&#125; 在 ViewController 中分别调用两个 test 方法, 输出内容, 如下: 123+ sendMsg. self: ViewController- sendMsg. self: &lt;ViewController: 0x7fc64740a5e0&gt; 从结果可以看出类方法中的 self 代表的是该类, 实例方法中的 self 指的是类的一个实例即对象. 更多 self 的知识点，可以参考 OC: self 这篇文章。 关于 Message ForwardingMessage Forwarding 即消息转发. 关于消息转发, 官方文档 Message Forwarding 是这么解释的: 123Sending a message to an object that does not handle that message is an error. However, before announcing the error, the runtime system gives the receiving object a second chance to handle the message. 大概意思是这样的: 向一个对象发送消息, 该对象如果无法处理该消息, 系统就会报错, 但是在报错之前, 利用 Objective-C 提供的运行时机制可以防止报错的发生. 在 iOS 中类似这样的报错会导致程序直接 crash.这里的对象, 可以是实例对象又可以是类对象. 在开发过程中, 大家一般都会遇到类似的 crash: 123456789101112 *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Controller play]: unrecognized selector sent to instance 0x7ff779f322a0'*** First throw call stack:(CoreFoundation 0x000000010d89712b __exceptionPreprocess + 171libobjc.A.dylib 0x000000010cf2bf41 objc_exception_throw + 48CoreFoundation 0x000000010d918024 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132UIKit 0x000000010df48f51 -[UIResponder doesNotRecognizeSelector:] + 295CoreFoundation 0x000000010d819f78 ___forwarding___ + 1432CoreFoundation 0x000000010d819958 _CF_forwarding_prep_0 + 120) 这个 crash 很明显, Controller 中调用了一个不存在的函数 play. 这里可以看到一个被调用的系统函数 doesNotRecognizeSelector, 今天我们剖析一下消息转发的流程. 实例方法(消息)转发的流程在上面已经说过, OC 可以通过运行时来避免因为找不到方法而导致错误. 其实, 含义就是 OC 给了我们第二次机会来避免类似的错误. 我们重写 NSObject 中的 5 个方法, 分别是: +resolveInstanceMethod -forwardingTargetForSelector -methodSignatureForSelector -forwardInvocation -doesNotRecognizeSelector: 当无法找到对应的方法时, 调用的方法和顺序大致如下: 1234+resolveInstanceMethod-forwardingTargetForSelector-methodSignatureForSelector-doesNotRecognizeSelector: 当找到对应的方法时, 调用方法和顺序大致如下: 1234+resolveInstanceMethod-forwardingTargetForSelector-methodSignatureForSelector-forwardInvocation 根据实践结果, 画流程图如下: 下面分别解释一下这几个方法的作用和意义. + (BOOL)resolveInstanceMethod:(SEL)sel 解析对应的实例方法. 在该方法中允许增加一个方法的实现, 从而实现动态添加方法. 默认返回 NO. 在 NSObject.mm 中可以看到方法的实现: 123+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return NO;&#125; - (id)forwardingTargetForSelector:(SEL)aSelector 将对应的 selector 转发给指定的对象. 换句话说就是将之前没有实现的 selector 转交给另外一个可能实现了该 selector 的对象去处理. 默认返回 nil. - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 该方法返回对 selector 实现的方法签名. 默认实现如下: 1234- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; _objc_fatal("-[NSObject methodSignatureForSelector:] " "not available without CoreFoundation");&#125; - (void)forwardInvocation:(NSInvocation *)anInvocation 该方法是依赖第3个方法的, 如果第三个方法找到了对应的方法签名, 该方法就可以实现转向调用了. - (void)doesNotRecognizeSelector:(SEL)sel 如果前面几个方法都没有处理好, 系统会调用该方法, 直接导致程序 crash, 也称之为终极死亡方法. 源码实现如下: 1234- (void)doesNotRecognizeSelector:(SEL)sel &#123; _objc_fatal("-[%s %s]: unrecognized selector sent to instance %p", object_getClassName(self), sel_getName(sel), self);&#125; 总结, Objective-C 中给一个对象发送消息会经过如下几个步骤： 步骤1. 在类的调度表(dispatch table) 中找要执行的函数(消息), 如果找到了，到相应的函数 IMP 去执行. 每个类的结构体包含着两个必备的元素:[1]. 指向父类的指针[2]. class dispatch table(调度表). 调度表中包含了 method selectors 和特定 class 相应方法实现的地址. 步骤2. 如果没找到，运行时会调用 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试解析这个消息. 在该方法中, 允许动态添加一个方法的实现. 关于 resolveClassMethod 这个放在另一篇博客中讲解. 步骤3. 如果 resolveXX 返回 YES, 直接结束后面的流程, 执行解析得到的方法. 如果 resolveXX 返回 NO，运行时就发送 forwardingTargetForSelector 消息, 允许这个消息转发给另一个可能实现了对应 selector 的对象. 步骤4. 如果没有新的目标对象返回, 运行时就会发送methodSignatureForSelector 消息, 找到对应的方法签名.如果找到了, 会接着调用 forwardInvocation, 如果没有找到即返回 nil, 那么直接调用 doesNotRecognizeSelector. 下一篇结合实际例子分析一下整个实例方法的转发流程. 参考文档1.Apple 开发者文档 Message Forwarding 2.Apple RunTime 源码 objc4-723.tar.gz 推荐OC-RunTime: 消息转发之实例方法的转发流程实例讲解 OC-RunTime: 消息转发之类方法的转发流程 OC-RunTime: 总结消息转发中用到的知识点 点击下载文中完整的 Demo. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS RunTime MessageForward</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 文件大小的单位]]></title>
    <url>%2F2018%2F03%2F24%2FMacOS-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[缘由我一直以为文件大小都是按照 1024 为单位来计算的, 但是在 MacOS 上面是按照 1000 为单位计算的, windows 上面是按照 1024 为单位来计算的. 偶然的发现之前写代码, 需要用到获取文件大小的功能, 代码如下: 123456789101112131415// 读取文件大小long getFileSize(char *filename) &#123; FILE *fp = fopen(filename, &quot;r&quot;); if (!fp) &#123; return -1; &#125; fseek(fp, 0, SEEK_END); long size = ftell(fp); fclose(fp); return size;&#125; 文件名是 mm.aac, 一个音频文件, 获取到的文件大小是 76395 字节. 我无聊至极, 使用 du 命令来获取该文件的大小: 1du -sh mm.aac 显示文件大小是 76KB. MacOS 上面查看文件属性, 获取到的大小也是 76KB 二者获取的文件大小一致, 可以看出文件的大小是正确的. 于是我查了一下在 windows 上面的该文件的大小, 如下截图: 可以看出, MacOS 上面文件大小是按照 1000 单位来计算的, 而 windows 上面是按照 1024 单位来计算的. 1276395 / 1000 = 76.39576395 / 1024 = 74.604 按照 GNU 的习惯，单纯的 K M G T 分别指代 KiB MiB GiB TiB 以 1024 进制数据量单位，用 KB MB GB TB 以 1000 进制数据量单位. 所以, 在 windows 上面准确表示 76395bytes 应该是 74.6KiB. 推荐在线计算 单位换算.]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS C 文件大小单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO: 写第一个 GOLang 程序]]></title>
    <url>%2F2018%2F03%2F11%2FGO-%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA-GOLang-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本文分享在 MacOS 上面通过 pkg 的方式安装 GO 编程环境, 以及编译运行第一个使用 GOLang 编写的程序. 其他关于 GO 的安装方式, 如使用 Homebrew 安装或者使用源码安装的方式, 请自行尝试. 下载安装在 这里 下载 GO 的 pkg 安装包. 但是你需要科(fan)学(qiang)才能下载. 你也可以下载 Stable versions. 下载完成后, 直接双击安装即可. 配置环境变量安装完成后, GO 安装目录在 /usr/local 下面. 安装目录如下图所示: 需要将其设置到环境变量中, 才能在终端使用其相关的命令. 编辑 ~/.bash_profile, 增加下面几行即可. 12345# Golangexport GOROOT=/usr/local/goexport GOPATH=~/goworkexport PATH=$GOROOT/bin:$GOPATH:$PATH 记住, GOROOT 和 GOPATH 必须设置.gowork 是我自己新建的目录. GOPATH 可以理解为工作目录. 关于 GOPATH 可以参考这个文档 SettingGOPATH. 我刚开始没有配置 GOROOT 变量, 执行 go 命令会提示警告, 警告内容如下: 1warning: GOPATH set to GOROOT (/usr/local/go) has no effect 编辑保存, 然后使其立即生效. 1source ~/.bash_profile 检查环境变量是否生效. 1go version 对应输出 1go version go1.9.4 darwin/amd64 也可以使用 go env 来查看更加详细的内容. 编译运行 GOLang 程序1.编写代码 编辑一个 Hello GOLang 的程序. 在任意一个文件夹位置, 新建一个 go_hello.go 的文件. 1touch go_hello.go 写入如下程序: 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, GOLang!&quot;)&#125; 2.编译运行 使用 go build 命令编译. 1go build go_hello.go 编译成功后, 生成可执行文件 go_hello. 执行即可. 1./go_hello 或者直接运行, 执行下面的命令. 1go run go_hello.go 这个不会生成可执行文件. 至此, GO 的编程环境已经搭建完成, 比较简单. 卸载 GO如果你想卸载 GO 环境, 只需要三个步骤. 1.删除安装目录 1sudo rm -fr /usr/local/go 2.删除 go 文件 1sudo rm -f /etc/paths.d/go 3.删除环境变量 编辑 etc, 删除对应添加的 go 环境变量即可. 参考GO: Getting Started GO: DOC SettingGOPATH]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>GOLanguage Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 指针与 OC 对象之间的转换]]></title>
    <url>%2F2018%2F03%2F07%2FC-%E6%8C%87%E9%92%88%E4%B8%8E-OC-%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Core Foundation 框架Core Foundation 框架 (CoreFoundation.framework) 是一组 C 语言接口， 简称 CF. 它们为 iOS 应用程序提供基本数据管理和服务功能. 如 Core Graphics、Core Text，并且我们可能需要将 CF 对象和OC 对象进行相互转化，ARC 下，编译器不会自动管理 CF 对象的内存，我们需要手动管理. 创建一个 CF 对象使用后, 需要使用 CFRelease 将其手动释放, 换句话说, Core Foundation 对象类型不在 ARC 管理范畴内. 如何将 CF 和 OC 对象有效的结合起来, 在 ARC 环境下, 提供了 桥接 的技术, 即 ARC 下 OC 对象和 Core Foundation 对象之间的桥梁. ARC 桥接ARC 下 C 指针与 OC 指针(对象)之间转换, 一般会用到下面的方法. 12345__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;__bridge &lt;#type#&gt;)&lt;#expression#&gt; 也就是所谓的 桥接, 它是 Object-C 在 ARC 环境下开发出来的一种用作转换 C 指针跟 OC (类)指针的一种转换技术, 所以是 ARC 下的称谓, 在 MRC 下没有 桥接. 针对内存管理问题，ARC 可以管理 Objective-C 对象, 但不支持 Core Foundation 对象的管理，所以转换后要注意一个问题：谁来释放使用后的对象. 结合 ARC 和 内存管理, 下面分别介绍一下. Core Foundation 对象必须使用 CFRetain 和 CFRelease 来进行内存管理.当使用 Objective-C 和 Core Foundation 对象相互转换的时候，必须让编译器知道，到底由谁来负责释放对象，是否交给 ARC 处理, 只有正确的处理，才能避免内存泄漏和 double free 导致程序崩溃. __bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;__bridge_retained 等同于 CFBridgingRetain(). 将 Objective-C 对象转换为 Core Foundation 对象，把对象所有权桥接给 Core Foundation 对象，同时剥夺 ARC 的管理权，后续需要开发者使用 CFRelease 或者相关方法手动来释放 CF 对象. 示例: 12345678910void *cPointer;NSObject *objc = [[NSObject alloc] init];//将 OC 对象转换为 C 指针cPointer = (__bridge_retained void*)objc;//use cPointer ...//需要释放资源CFRelease(cPointer); 在 ARC 下, CFBridgingRetain 实现如下: 123NS_INLINE CF_RETURNS_RETAINED CFTypeRef _Nullable CFBridgingRetain(id _Nullable X) &#123; return (__bridge_retained CFTypeRef)X;&#125; 关于 CFTypeRef, 如下: 1typedef const CF_BRIDGED_TYPE(id) void * CFTypeRef; 所以 CFBridgingRetain 返回值是 const void * 类型的. 上面的示例可以改写为: 1234567const void *cPointer;const NSObject *objc = [[NSObject alloc] init];cPointer = CFBridgingRetain(objc); //use cPointer ... CFRelease(cPointer); __bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;__bridge_transfer 等同于 CFBridgingRelease(). 将非 OC 对象转换为 OC 对象，同时将对象的管理权交给 ARC，开发者无需手动管理内存. 示例: 12345678CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);CFStringRef strUUID = CFUUIDCreateString(kCFAllocatorDefault, uuid);NSString *str = (__bridge_transfer NSString *)strUUID;//无需释放 strUUID//CFRelease(strUUID);CFRelease(uuid); CFBridgingRelease 实现如下: 123NS_INLINE id _Nullable CFBridgingRelease(CFTypeRef CF_CONSUMED _Nullable X) &#123; return (__bridge_transfer id)X;&#125; 上面的示例可以改写为: 12345678CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);CFStringRef strUUID = CFUUIDCreateString(kCFAllocatorDefault, uuid);NSString *str = CFBridgingRelease(strUUID); //无需释放 strUUID//CFRelease(strUUID); CFRelease(uuid); __bridge__bridge 不改变对象所有权, 需要我们自己来管理内存, 它也是我们经常使用的方法, 从某种程度上来说, 它是上面两个方法的简化版本. __bridge 可以将 OC 对象 与 C 指针相互转换, 示例: 12345//CFString -&gt; OC 对象CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, "very", kCFStringEncodingUTF8);NSString *nsString = (__bridge NSString *)cfString;NSLog(@"CFString -&gt; NSString: %@", nsString);CFRelease(cfString); 如果将 CFRelease(cfString) 注释掉, Xcode 的静态检测器会告诉你有内存泄露的情况, 如图: 再来另外一个例子, 如下: 12345//OC 对象 -&gt; CFStringNSString *nstr = @"itman";CFStringRef cfStringRef = (__bridge CFStringRef)nstr;NSLog(@"NSString -&gt; CFString: %@", cfStringRef);CFRelease(cfStringRef); 无论是使用 CFRelease(cfStringRef), 还是注释掉 CFRelease(cfStringRef), 静态检测器都不会报错. 说明这种情况下, 当前的内存管理已经被 OC 对象管理. 经典例子NSString 与 CFString 转换1、NSString → CFString 123456789&#123; NSString *string = @"veryitman.com"; // 方法1: 不需要释放 CFStringRef cfStr = (__bridge CFStringRef)string; // 方法2: 需要释放, 这里 retain 了 CFStringRef cfStr2 = (__bridge_retained CFStringRef)string; CFRelease(cfStr2);&#125; 2、CFString → NSString 123456789CFStringRef cfStr = CFStringCreateWithCString(kCFAllocatorDefault, "veryitman", kCFStringEncodingUnicode); // 方法1: 需要释放NSString *string = (__bridge NSString *)cfStr;NSLog(@"OC string: %@", string);CFRelease(cfStr); // 方法2: 不需要释放, __bridge_transfer 自带 releasestring = (__bridge_transfer NSString *)cfStr; 野指针运行下面的示例: 1234567void *p;&#123; NSObject *objc = [[NSObject alloc] init]; p = (__bridge void*)objc;&#125; NSLog(@"mark: %@", (__bridge NSObject*)p); 会直接 crash, 如图: 当 objc 这个对象超出作用域范围，其内存就会被回收，接着在作用域范围外用 void *p 去访问 objc 的内存，就造成了野指针. 结合上面所说的, 我们可以让指针 p 对 objc 进行引用即 retain 操作, 修改如下: 1234567891011void *p;&#123; NSObject *objc = [[NSObject alloc] init]; //p = (__bridge void*)objc; p = (__bridge_retained void*)objc;&#125; NSLog(@"mark: %@", (__bridge NSObject*)p); // 一定要释放CFRelease(p); 可以正常的运行. 还可以修改为另一种方式: 123456789101112void *p;&#123; NSObject *objc = [[NSObject alloc] init]; //p = (__bridge void*)objc; //p = (__bridge_retained void*)objc; p = (void *)CFBridgingRetain(objc);&#125; NSLog(@"mark: %@", (__bridge NSObject*)p); // 一定要释放CFRelease(p); 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C ARC Foundation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: iOS 推流]]></title>
    <url>%2F2018%2F02%2F26%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E6%8E%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[本篇分享是基于 音视频编程: 构建 nginx 推流服务器 这篇文章的, 之前是使用 ffmpeg 命令进行推流并且都是在 macos 上面进行的操作. 现在在 iOS 平台上使用 LFLiveKit 进行推流, 然后使用 VLC 播放器播放流视频. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 音视频编程: iOS 推流 (本篇) 基本概念一般直播过程包括对音视频的采集、处理、编码、封包、推流、传输、转码、分发、解码、播放等. 推流, 指使用推流工具把直播内容传输到服务器的过程. 本篇分享使用 LFLiveKit 工具将 iPhone 摄像头和麦克风采集的数据推流到本地流服务器. 拉流, 指对服务器直播的内容，用指定地址进行拉取(播放)的过程, 本篇分享使用 VLC 充当拉流的角色. 集成 LFLiveKitLFLiveKit 是一个开源的推流 SDK, 支持 H264 and AAC 的硬编码, 支持美颜(集成了 GPUImage). 使用 LFLiveKit 比较简单, 按照其 demo 集成即可. 1.工程配置info.plist 需要访问相机和麦克风权限. 123Privacy - Camera Usage DescriptionPrivacy - Microphone Usage Description 2.请求相机和麦克风权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)requestAccessForVideo &#123; __weak typeof(self) _self = self; AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; switch (status) &#123; case AVAuthorizationStatusNotDetermined: &#123; [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123; if (granted) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_self.session setRunning:YES]; &#125;); &#125; &#125;]; break; &#125; case AVAuthorizationStatusAuthorized: &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_self.session setRunning:YES]; &#125;); break; &#125; case AVAuthorizationStatusDenied: case AVAuthorizationStatusRestricted: // 用户明确地拒绝授权，或者相机设备无法访问 break; default: break; &#125;&#125;- (void)requestAccessForAudio &#123; AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; switch (status) &#123; case AVAuthorizationStatusNotDetermined: &#123; [AVCaptureDevice requestAccessForMediaType:AVMediaTypeAudio completionHandler:^(BOOL granted) &#123; &#125;]; break; &#125; case AVAuthorizationStatusAuthorized: &#123; break; &#125; case AVAuthorizationStatusDenied: case AVAuthorizationStatusRestricted: break; default: break; &#125;&#125; 务必要调用 LFLiveSession 的 setRunning 方法. 完整的工程代码, 后续我会放到 Github 上面. 方便有需要的下载. 推流播放上面的基本配置完成后, 可以开始推流了. 1.启动 nginx 1sudo nginx 2.启动推流 1234567- (void)startLive &#123; LFLiveStreamInfo *streamInfo = [LFLiveStreamInfo new]; streamInfo.url = sRTMPUrl; [self.session startLive:streamInfo]; self.session.beautyFace = YES;&#125; 这里的 sRTMPUrl 是一个常量定义: 1static NSString * const sRTMPUrl = @&quot;rtmp://192.168.1.102:1935/rtmplive/channel&quot;; 192.168.1.102 是我的本机(mac) ip 地址. 如果一切正常的话, 你在手机上面可以看到自己的预览画面. 3.VLC 播放 使用 VLC 播放 rtmp 的流, 打开 VLC 播放器, 选择 File/Open Network, 输入 rtmp://192.168.1.102:1935/rtmplive/channel 这个地址即可实时播放了. 这里注意一定要使用本机的 ip 地址, 不要使用 localhost:1935 类似的地址, 否则无法播放和推流. 后续分享如何在 iOS 上面使用播放器来播放直播流.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 rtmp nginx 推流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: 构建 nginx 推流服务器]]></title>
    <url>%2F2018%2F02%2F25%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本篇分享的主要内容 如何在 macos 中构建本地的推流服务器(nginx + rtmp-nginx-module), 并使用 ffmpeg 命令进行视频推流, 然后使用 VLC 播放器播放视频. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 (本篇) 安装 rtmp-nginx-module之前在测试 php 程序的时候, 我已经安装过 nginx, 但是发现这样在配置 rtmp-nginx-module 的时候, 无法成功. 配置文件修改完成之后, nginx 总是无法识别 rtmp, 报错如下: 1[emerg] 30766#0: unknown directive &quot;rtmp&quot; in /usr/local/etc/nginx/nginx.conf:40 现在需要卸载原来已经安装的 nginx, 命令如下: 1brew uninstall nginx 再次安装: 1brew install nginx-full --with-rtmp-module 耐心等待一会 ~~ nginx 的版本(nginx -v): 1nginx/1.12.2 rtmp-nginx-module 版本: 11.1.7.11-dev_2 配置 rtmp编辑 nginx 的配置文件, 文件位置位于: 1/usr/local/etc/nginx/nginx.conf 在 http {} 后面写入如下内容: 123456789101112131415rtmp &#123; server &#123; #rtmp协议的默认端口号是 1935 listen 1935; #直播流配置, 访问 path 是 rtmplive application rtmplive &#123; #开启实时 live on; #设置 rtmp 引擎的最大连接数. 默认为off max_connections 1024; #不记录数据 record off; &#125; &#125;&#125; 注意: rtmplive 是固定的. 具体的 nginx 配置详见后面的附录内容. 推流1.安装 ffmpeg 即可. 1brew install ffmpeg 这个过程有点久, 如果你没有梯子基本安装不了 [大哭]~ 2.安装 VLC 直接去官网下载 dmg 包, 安装即可. 打开 VLC 然后选择从 File/Open Network 打开文件, 如下图所示: 在弹出的框中, 写入推流地址 rtmp://localhost:1935/rtmplive/channel, 如图所示: 直接点击 Open. 注意: 如果 localhost 无法播放, 请更换为你的本机 ip, 如我的本机 ip 是 192.168.1.122, 对应的播放地址为 rtmp://192.168.1.122:1935/rtmplive/channel.如果还是无法成功, 请关闭 macos 的防火墙. 3.启动 nginx 1sudo nginx 可以在浏览器访问如下地址, 看看 nginx 是否启动成功. 1http://localhost:8080/index.html 4.ffmpeg 推流 推流的命令如下: 1ffmpeg -re -i ~/Desktop/launcher.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmplive/channel 其中 launcher.mp4 是我自己从网络上面下载的一个视频文件, 时长大约是 5 分钟. 在 VLC 中, 就可以看到推流播放的视频了. [开心]~~ 附录nginx 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log debug;pid /usr/local/var/run/nginx.pid; events &#123; worker_connections 256;&#125; http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*; include /usr/local/etc/nginx/conf.d/*; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /Users/me/workspace/projs/phpwork/; #web的根目录 index index.php index.html index.htm; &#125; &#125;&#125;rtmp &#123; server &#123; #rtmp协议的默认端口号是1935 listen 1935; #直播流配置,访问路径是rtmplive application rtmplive &#123; #开启实时 live on; #为rtmp引擎设置最大连接数.默认为off max_connections 1024; #不记录数据 record off; &#125; &#125;&#125; 视频文件使用下载的 mp4 文件, 有些无法播放, 暂时估计应该是码率的问题, 大家在测试过程中, 发现视频无法播放, 最后试试其他视频文件. 另外, 视频文件不要太小, 尽量能让其播放时长在 3-5 分钟. brew install/uninstall 报错报错信息如下: 123456Error: undefined method `patch&apos; for #&lt;Resource:0x000001040877a8&gt;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/gcc@4.9.rb:55:in `block in &lt;class:GccAT49&gt;&apos;/usr/local/Homebrew/Library/Homebrew/resource.rb:49:in `instance_eval&apos;/usr/local/Homebrew/Library/Homebrew/resource.rb:49:in `initialize&apos;/usr/local/Homebrew/Library/Homebrew/software_spec.rb:111:in `new&apos;/usr/local/Homebrew/Library/Homebrew/software_spec.rb:111:in `resource&apos; 最终的解决方案是重新安装 Homebrew, 命令如下: 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 检查本机的 ip1ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 rtmp nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSLog 格式化输出 NSInteger/NSUInteger]]></title>
    <url>%2F2018%2F02%2F22%2FNSLog-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-NSInteger-NSUInteger%2F</url>
    <content type="text"><![CDATA[在 Xcode 中 使用 NSLog 打印 NSInteger/NSUInteger 数据, 经常会遇到类似的警告. 如下图所示: 但是在 iphone 4s(32位)机器上就没有任何警告, 只是在64位的机型上面有这样的警告. 在 NSObjCRuntime.h 里面定义 NSInteger 和 NSUInteger 如下: 1234567#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64typedef long NSInteger;typedef unsigned long NSUInteger;#elsetypedef int NSInteger;typedef unsigned int NSUInteger;#endif 也就是说 64 位下是 long 类型，32 位下是 int 类型. 所以, 上面的代码在 32 位机型上面不会有警告. 按照 Xcode 的提示, Fix it: 12345NSUInteger iun = 3;NSLog(@"iun: %lu", (unsigned long)iun); NSInteger nsi = 6;NSLog(@"nsi: %ld", (long)nsi); 这样无论在 32 位还是在 64 位机型上面, 都没有警告了. Twitter 帖子在 twitter 有个帖子 说了另一种解决办法, 原文如下: 1%zd, %tu, %tx (signed, unsigned, hex) currently format NSInteger and NSUInteger with no warnings. 意思是使用 zd 可以格式化有符号的如 NSInteger, 使用 tu 格式化无符号的如 NSUInteger. 而 tx 可以用来格式化输出 16 进制数据. 按照这个说法, 修改如下: 12345NSUInteger iun = 3;NSLog(@"iun: %zd", iun); NSInteger nsi = 6;NSLog(@"nsi: %td", nsi); 或者这样修改: 12345NSUInteger iun = 3;NSLog(@&quot;iun: %tu&quot;, iun); NSInteger nsi = 6;NSLog(@&quot;nsi: %td&quot;, nsi); 确实没有了警告的问题. 我在实践过程中发现一个问题: 使用 zu 来格式化输出 NSUInteger, 在 32 位机器上面, 仍旧会报警告. 12NSUInteger iun = 3;NSLog(@"iun: %zu", iun); 这就让我开始怀疑 z 和 t 的可靠性了. 下面接着了解一下它们. 关于 z t关于 z t 的说明可以参考 String Format Specifiers 可以说明: 格式化 z 可以用来代表 size_t.格式化 t 可以用来代表 ptrdiff_t. ptrdiff_t 是C/C++标准库中定义的一个与机器相关的数据类型.ptrdiff_t 类型变量通常用来保存两个指针减法操作的结果, 其定义在 C99 标准中. size_t 类型用于指明数组长度, 它必须是一个正数, 而 ptrdiff_t 类型则应保证足以存放同一数组中两个指针之间的差距, 它有可能是负数. 即: size_t 是 unsigned 类型, 而 ptrdiff_t 则是 signed 整型. 12printf("size_t bytes = %d\n" ,sizeof(size_t));printf("ptrdiff_t bytes = %d\n" ,sizeof(ptrdiff_t)); 在 32 位机型中输出结果: 12size_t bytes = 4ptrdiff_t bytes = 4 在 64 位机型中输出结果: 12size_t bytes = 8ptrdiff_t bytes = 8 这说明, sizet_t 和 ptrdiff_t 是和机器类型相关的跨平台的. 系统定义: 12typedef __SIZE_TYPE__ size_t;typedef __PTRDIFF_TYPE__ ptrdiff_t; 32 位机型定义: 12#define __SIZE_TYPE__ long unsigned int#define __PTRDIFF_TYPE__ int 64 位机型定义: 12#define __SIZE_TYPE__ long unsigned int#define __PTRDIFF_TYPE__ long int 终极解决方案既然在 Xcode 里面提示 Fix it 可以使用, 那么为了提高代码的健壮性和可维护性, 可以定义宏定义来解决. 宏定义如下: 1234567#if __LP64__#define MZNSI @"ld"#define MZNSU @"lu"#else#define MZNSI @"d"#define MZNSU @"u"#endif //__LP64__ 使用方法, 如下: 1234NSInteger nsi = 6;NSUInteger iun = 3;NSLog(@"NSInteger nsi = %"MZNSI, nsi);NSLog(@"NSUInteger iun = %"MZNSU, iun); 附录给出常用的格式化打印输出字符串中的格式符, 如下所示: 1）%c：对应参数是一个 int 类型，但实际运行时会将该 int类型对象转换为 unsigned char 类型. 2）%d 或者 %i：对应参数是一个 int 类型. 只不过, %d 一般用于十进制, %i 可以对应各种进制的数据. 二者在打印输出上面没有什么太大的差别. 但是在接收输入(scanf)上, %d 用于十进制, %i 对应各种进制的数据. 可以参考 Difference between %d and %i format specifier in C language 这篇文章. 3）%f：对应参数是一个 double 类型. 4）%ld：对应参数是一个 long int 类型. 5）%s：对应参数是一个 const char* 类型，表示输出一个字符串. 6）%u：对应参数是一个 unsigned int 类型. 7）%zu：对应参数是一个 size_t 类型. 8）%td：对应参数是一个 ptrdiff_t 类型. 9）%x（或 %X）：对应参数是一个 int 类型，不过会以十六进制形式输出，其中大于 9 的数字根据字母 x 大小写进行转换，如果是 %x，则大于 9 的数用 a～f 表示；如果是 %X，则用 A～F 表示. 10）%%：输出一个 % 符号. 推荐Apple：String Format Specifiers 扫码关注，期待与你的交流~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSLog printf scanf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: iOS 使用 faad2]]></title>
    <url>%2F2018%2F02%2F20%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2%2F</url>
    <content type="text"><![CDATA[本次分享使用 faad2 解码 AAC 音频文件, 将 AAC 文件转换为 WAV 文件并使用 AVAudioPlayer 进行播放. 在博文 音视频编程: 简单分析 WAV 文件 给大家简单的分析了一下 WAV 的数据头协议, 其实也是为了这篇博文来服务的, 所以阅读本文之前, 建议先看上文. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 (本篇) 音视频编程: 构建 nginx 推流服务器 例子简介本文以一个实际的例子, 使用 faad2的各个函数来解码 AAC 数据. 主要有以下几个步骤: 获取输入文件 获取 faad 解码器句柄 初始化 faad 解码器 根据文件解析文件帧, 并写入输出文件中 写入文件头将其封装为 WAV 格式的音频文件 关闭 faad 解码器句柄 工程实战引入 faad2将编译好的 faad2 导入工程即可. 其中关键的 API 在 neaacdec.h 中有描述. 工程效果图: 编码实现在 音视频编程: 简单分析 WAV 文件 中已经定义了 WAV 的数据头. 12345678910111213141516struct MZWavAudioFileHeader&#123; char riff[4]; // 字符串 &quot;RIFF&quot; uint32_t totalLength; // 文件总大小, 包括PCM 数据大小和该文件头大小 char wave[4]; // 字符串 &quot;WAVE&quot; char fmt[4]; // 字符串 &quot;fmt &quot; uint32_t format; // WAV 头大小, 固定为值 16 uint16_t pcm; // PCM 编码方式, 固定值为 1 uint16_t channels; // 声道数量, 为 2 uint32_t frequency; // 采样频率 uint32_t bytes_per_second; // 每秒字节数(码率), 其值=采样率x通道数x位深度/8 uint16_t bytes_by_capture; // 采样块大小 uint16_t bits_per_sample; // 采样点大小, 这里是 16 位 char data[4]; // 字符串 &quot;data&quot; uint32_t bytes_in_pcmdata; // pcm 数据长度&#125;; 现在实现写入数据头的方法 mz_write_wav_header 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 写入 wav 头数据. * * @param file wav 文件指针. * @param total_samples_per_channel 每个声道的采样数. * @param samplerate 采样率. * @param channels 声道数. */void mz_write_wav_header(FILE *file, int total_samples_per_channel, int samplerate, int channels) &#123; if (NULL == file) &#123; return; &#125; if (total_samples_per_channel &lt;= 0) &#123; return; &#125; printf(&quot;FAAD. total_samples_per_channel: %i, samplerate: %i, channels: %i\n&quot;, total_samples_per_channel, samplerate, channels); struct MZWavAudioFileHeader wavHeader; // 写入 RIFF strcpy(wavHeader.riff, &quot;RIFF&quot;); wavHeader.bits_per_sample = 16; wavHeader.totalLength = (total_samples_per_channel * channels * wavHeader.bits_per_sample/8) + sizeof(wavHeader) - 8; // 写入 WAVE 和 fmt strcpy(wavHeader.wave, &quot;WAVE&quot;); strcpy(wavHeader.fmt, &quot;fmt &quot;); wavHeader.format = 16; wavHeader.pcm = 1; wavHeader.channels = channels; wavHeader.frequency = samplerate; // 每秒的字节数(码率)=采样率x通道数x位深度/8 wavHeader.bytes_per_second = wavHeader.channels * wavHeader.frequency * wavHeader.bits_per_sample/8; wavHeader.bytes_by_capture = wavHeader.channels*wavHeader.bits_per_sample/8; wavHeader.bytes_in_pcmdata = total_samples_per_channel * wavHeader.channels * wavHeader.bits_per_sample/8; // 写入 data strcpy(wavHeader.data, &quot;data&quot;); fwrite(&amp;wavHeader, 1, sizeof(wavHeader), file);&#125; 解码主要用到了 FAAD2 中的 NeAACDecDecode 函数. 函数原型如下: 1234void* NEAACDECAPI NeAACDecDecode(NeAACDecHandle hDecoder, NeAACDecFrameInfo *hInfo, unsigned char *buffer, unsigned long buffer_size); 对应帧定义的结构体: NeAACDecFrameInfo, 定义如下: 123456789101112131415161718192021222324252627typedef struct NeAACDecFrameInfo&#123; unsigned long bytesconsumed; unsigned long samples; unsigned char channels; unsigned char error; unsigned long samplerate; /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */ unsigned char sbr; /* MPEG-4 ObjectType */ unsigned char object_type; /* AAC header type; MP4 will be signalled as RAW also */ unsigned char header_type; /* multichannel configuration */ unsigned char num_front_channels; unsigned char num_side_channels; unsigned char num_back_channels; unsigned char num_lfe_channels; unsigned char channel_position[64]; /* PS: 0: off, 1: on */ unsigned char ps;&#125; NeAACDecFrameInfo; 具体的解码实现, 我放到了 Github 上面了, 大家可以去 这里 查看. 麻烦 解码 aac, 解决采样频率和通道数不对的问题 1234//防止采样频率加倍NeAACDecConfigurationPtr conf = NeAACDecGetCurrentConfiguration(decoder);conf-&gt;dontUpSampleImplicitSBR = 1;NeAACDecSetConfiguration(decoder, conf); 123456//从双声道的数据中提取单通道 for(i=0,j=0; i&lt;4096 &amp;&amp; j&lt;2048; i+=4, j+=2) &#123; frame_mono[j]=pcm_data[i]; frame_mono[j+1]=pcm_data[i+1];&#125; 具体可以查阅 FAAD2 的源码. 感谢 使用FAAD库解码AAC实例及 及 faad解码后的通道数不正确的问题 提供.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 wav pcm faad2 aac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: 简单分析 WAV 文件]]></title>
    <url>%2F2018%2F02%2F20%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[这篇分享是下篇 音视频编程: iOS 使用 faad2 的预备知识, 如果要解码 WAV 文件, 首先需要了解一下 WAV 音频文件的格式. 今天说的是 线性 PCM 对应的 WAV 格式的数据. PCM 的种类 线性化 PCM A律量化的 PCM U律量化的 PCM AD PCM GSM 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件(本篇) 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 WAV 简介WAV 只是该音频文件的后缀名, 其完整名称缩写是 WAVE. WAVE(Waveform Audio File Format), 采用RIFF（Resource Interchange File Format）文件格式结构. WAV 格式的音频文件通常用来保存 PCM 格式的原始音频数据，通常被称之为无损音频. WAV 音频文件, 粗略来说是 WAV 数据头 + PCM 数据组成的. 裸数据 PCM 外面包了一层文件头，WAV 实质为一个 RIFF 文件. WAV 数据头关于 WAV 音频文件的数据头定义如下图所示: 最前面的4个字节用来标示是 RIFF 字符串. 可以看出, 一般的 WAV 文件的数据头为 44 个字节, 其后面跟的是 PCM 数据. 分析 WAV 数据头使用 hexdump 来看一下 WAV 文件的数据头. 在当前路径下, 有个 wav 格式的音频文件 m.wav, 使用 hexdump 分析一下. 1hexdump -n 44 m.wav 其中, -n 44 表示查看前 44 个字节. 按字节分组的图, 如下所示: 152 49 46 46 分别是 RIFF 的 ASCII 码. 跟在 RIFF 后面的四个字节是文件的大小信息, 我们先使用 ls 命令看一下该文件的大小. 1ls -al 输出文件大小为(字节数): 1080808 1staff 1080808 Jan 25 15:44 m.wav RIFF 后面的四个字节分别是: e0 7d 10 00, 由于该存储使用了小端序(Little-Endian 存储，也就是说对其中的数据，低位字节在前，高位字节在后), 所以16进制表示为: 0x00107de0, 对应的字节大小是 1080808. 上面说到, 线性 PCM, 其实在该文件头中, 第17到第第22个字节(上图红色的5和6组合)标示了 PCM 的类型, 即: 110 00 00 00 01 00 其他类型的 PCM 类型定义为: A律量化的PCM: 12 00 00 0006 00U律量化的PCM: 12 00 00 00 07 00AD PCM: 32 00 00 00 02 00GSM: 14 00 00 00 31 00 最后4个字节表示真正 PCM 数据的文件大小, 即: 0x00107dbc, 其10进制大小为: 1080764, 用总文件大小减去 1080764, 就是文件头的大小, 如下: 11080808 - 1080764 = 44 其他对应的数据, 大家可以对照表自行分析. 定义数据头 数据类型 char 占用 1 个字节 uint32_t 占用 4 个字节 uint16_t 占用 2 个字节 这里使用结构体定义 WAV 文件头, 其定义如下: 12345678910111213141516struct MZWavAudioFileHeader&#123; char riff[4]; // 字符串 &quot;RIFF&quot; uint32_t totalLength; // 文件总大小, 包括PCM 数据大小和该文件头大小 char wave[4]; // 字符串 &quot;WAVE&quot; char fmt[4]; // 字符串 &quot;fmt &quot; uint32_t format; // WAV 头大小, 固定为值 16 uint16_t pcm; // PCM 编码方式, 固定值为 1 uint16_t channels; // 声道数量, 为 2 uint32_t frequency; // 采样频率 uint32_t bytes_per_second; // 每秒字节数(码率), 其值=采样率x通道数x位深度/8 uint16_t bytes_by_capture; // 采样块大小 uint16_t bits_per_sample; // 采样点大小, 这里是 16 位 char data[4]; // 字符串 &quot;data&quot; uint32_t bytes_in_pcmdata; // pcm 数据长度&#125;; 可以使用下面代码来计算该结构体所占的字节数(结果是44): 1int wav_header_size = sizeof(struct MZWavAudioFileHeader);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 wav pcm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: iOS 使用 faac 编码]]></title>
    <url>%2F2018%2F02%2F16%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[简介本文分享如何将 WAV 格式的音频文件转换(编码)为 AAC 格式的音频文件并使用 AVAudioPlayer 播放编码后的文件. 这里的编码功能使用 faac 这个库来实现. 该系列博文: 音视频编程: 编译 faac/faad2 音视频编程: iOS 使用 faac 编码(本篇) 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 函数介绍 获取 faac 的版本 1int FAACAPI faacEncGetVersion(char **faac_id_string, char **faac_copyright_string); 示例: 1234char *version;char *copyright;faacEncGetVersion(&amp;version, &amp;copyright);printf(&quot;FAAC version: %s, copyright: %s&quot;, version, copyright); 打印结果: 1234FAAC version: 1.28, copyright: FAAC - Freeware Advanced Audio Coder (http://www.audiocoding.com/)Copyright (C) 1999,2000,2001 Menno BakkerCopyright (C) 2002,2003 Krzysztof NikielThis software is based on the ISO MPEG-4 reference source code. 打开并初始化 faac 编码器 12345678// sampleRate: 采样率// numChannels: 通道数量，1-单声道 2-立体声// inputSamples: 编码后的数据长度// maxOutputBytes: 编码后的信息最大长度faacEncHandle FAACAPI faacEncOpen(unsigned long sampleRate, unsigned int numChannels, unsigned long *inputSamples, unsigned long *maxOutputBytes); 该函数返回一个 faac 编码器句柄. 其很多函数都需要这个句柄. 关闭 faac 编码器 1int FAACAPI faacEncClose(faacEncHandle hEncoder); 将开启 faac 编码器返回的句柄传入即可. 获取配置和设置配置 123456faacEncConfigurationPtr FAACAPI faacEncGetCurrentConfiguration(faacEncHandle hEncoder);int FAACAPI faacEncSetConfiguration(faacEncHandle hEncoder, faacEncConfigurationPtr config); faac 的配置被定义为了一个结构体 faacEncConfiguration, 大家可以看源码. 编码(编码一帧音频数据) 12345678// hEncoder: faacEncOpen 返回的编码器句柄// inputBuffer: 输入信息缓冲区// samplesInput: faacEncOpen编码后的数据长度，即缓冲区长度// outputBuffer: 编码后输出信息缓冲区// bufferSize: 输出信息长度int FAACAPI faacEncEncode(faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput, unsigned char *outputBuffer, unsigned int bufferSize); 实例可以自己新建一个 iOS 工程. 准备好一个 wav 格式的音频文件. 效果如下图所示: 新建一个 C++ 文件, MZCodec. MZCodec.hpp 12345678#ifndef MZCodec_hpp#define MZCodec_hpp#include &lt;stdio.h&gt;int codeWAV(const char *srcFilePath, const char *destPath);#endif /* MZCodec_hpp */ MZCodec.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &quot;MZCodec.hpp&quot;#include &quot;faac.h&quot;#include &lt;stdio.h&gt;int codeWAV(const char *srcFilePath, const char *destPath) &#123; unsigned long nSampleRate = 44100;//采样率 unsigned int nChannels = 2;//声道数 unsigned int nPCMBitSize = 16;//单样本位数 unsigned long nInputSamples = 0; unsigned long nMaxOutputBytes = 0; int nRet; faacEncHandle hEncoder; faacEncConfigurationPtr pConfiguration; size_t nBytesRead; unsigned long nPCMBufferSize; unsigned char *pbPCMBuffer; unsigned char *pbAACBuffer; FILE *fpIn; // WAV file for input FILE *fpOut; // AAC file for output /// 获取 faac 版本信息 &#123; char *version; char *copyright; faacEncGetVersion(&amp;version, &amp;copyright); printf(&quot;FAAC version: %s, copyright: %s&quot;, version, copyright); &#125; fpIn = fopen(srcFilePath, &quot;rb&quot;); if (NULL == fpIn) &#123; return -2; &#125; fpOut = fopen(destPath, &quot;wb&quot;); /// 1. 打开 FAAC hEncoder = faacEncOpen(nSampleRate, nChannels, &amp;nInputSamples, &amp;nMaxOutputBytes); if (NULL == hEncoder) &#123; printf(&quot;[ERROR] Failed to call faacEncOpen()\n&quot;); return -1; &#125; nPCMBufferSize = nInputSamples * nPCMBitSize / 8; pbPCMBuffer = new unsigned char[nPCMBufferSize]; pbAACBuffer = new unsigned char[nMaxOutputBytes]; /// 2.1. 获取当前的编码器配置 pConfiguration = faacEncGetCurrentConfiguration(hEncoder); pConfiguration-&gt;inputFormat = FAAC_INPUT_16BIT; // 对象类型只有为 LOW, iOS 的 AVAudioPlayer 才能播放 pConfiguration-&gt;aacObjectType = LOW; // 0 = Raw; 1 = ADTS pConfiguration-&gt;outputFormat = 1; pConfiguration-&gt;mpegVersion = MPEG4; pConfiguration-&gt;useTns = 1; pConfiguration-&gt;bitRate = 30; /// 2.2. 配置编码器 nRet = faacEncSetConfiguration(hEncoder, pConfiguration); //是wav格式, 先读取前面的 fseek(fpIn, 58, SEEK_SET); do &#123; //读入的实际字节数，最大不会超过 nPCMBufferSize nBytesRead = fread(pbPCMBuffer, 1, nPCMBufferSize, fpIn); //输入样本数，用实际读入字节数计算 //一般只有读到文件尾时才不是 nPCMBufferSize/(nPCMBitSize/8) nInputSamples = nBytesRead / (nPCMBitSize / 8); /// 3. 编码 nRet = faacEncEncode(hEncoder, (int *)pbPCMBuffer, (unsigned int)nInputSamples, pbAACBuffer, (unsigned int)nMaxOutputBytes); fwrite(pbAACBuffer, 1, nRet, fpOut); printf(&quot;FaacEncEncode returns %d\n&quot;, nRet); &#125; while (nBytesRead &gt; 0); /// 4. 关闭 FAAC nRet = faacEncClose(hEncoder); delete[] pbPCMBuffer; delete[] pbAACBuffer; fclose(fpIn); fclose(fpOut); return 0;&#125; 使用 MZCodec 的 Controller 需要命名为 .mm 文件. ViewController.mm 12345678910111213141516NSBundle *bundle = [NSBundle mainBundle];NSString *resPath = [bundle pathForResource:@&quot;m&quot; ofType:@&quot;wav&quot;];NSLog(@&quot;The path of wav file: %@&quot;, resPath); NSArray&lt;NSString *&gt; *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *destPath = [[docPath lastObject] stringByAppendingString:@&quot;/out.aac&quot;];NSLog(@&quot;The path of aac file: %@&quot;, destPath); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; codeWAV([resPath UTF8String], [destPath UTF8String]); dispatch_async(dispatch_get_main_queue(), ^&#123; //转换完成. &#125;);&#125;); 编码过程需要点时间, 如果文件很大, 时间越久. 所以, 新开线程来进行编码. 编码完成后, 可在对应的沙盒目录找到 out.aac 文件. 具体代码在 Github 上面, 感兴趣的可以点击 前往. 注意事项这个 aacObjectType 需要注意, 之前我在这里折腾了很久. 1pConfiguration-&gt;aacObjectType = LOW; 如果设置为其他三种, 编码后的 aac 文件, AVAudioPlayer 播放不了, 初始化 AVAudioPlayer 就会报错, 报错信息如下:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 faac faad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音视频编程: 编译 faac/faad2]]></title>
    <url>%2F2018%2F02%2F14%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2%2F</url>
    <content type="text"><![CDATA[本文分享如何在 MacOS 上面编译 faac 和 faad2, 编译后的库文件可以直接在 iOS 上面使用. 后续会分享如何编译给 Android 使用的库文件的方法以及实战. 该系列博文: 音视频编程: 编译 faac/faad2(本篇) 音视频编程: iOS 使用 faac 编码 音视频编程: 简单分析 WAV 文件 音视频编程: iOS 使用 faad2 音视频编程: 构建 nginx 推流服务器 简介faad 是 AAC 格式文件的音频解码库. 相对于 FFmpeg 来说比较轻量和简单. 编译出来全平台静态库文件较小, API 也比较简单, 缺点是功能单一, 只能处理 AAC 格式的音频文件. faac 是与之对应的 AAC 音频编码库. 支持 MPEG-4 和 MPEG-2 的AAC 编码，其特性包括：可移植性好，快速，支持LC/Main/LTP，通过 Dream 支持 DRM. 这两个库虽然很久没有更新了, 但是其功能已经满足很多业务场景了, 并且很好用. 下载源码点击 源码链接 即可下载源码. 编译 faac下载完成后, 解压, 将 faac-1.28 放到新建目录 src 下面即可, 目录结构如下: 修改 build_faac.sh 权限: 1chmod +x build_faac.sh 编辑 build_faac.sh 内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/bin/sh # http://www.linuxfromscratch.org/blfs/view/svn/multimedia/faac.html # ftp://mirror.ovh.net/gentoo-distfiles/distfiles/ major=1 minor=28 micro= XCD_ROOT=&quot;/Applications/Xcode.app/Contents/Developer&quot; TOL_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain&quot; #修改为最新的 sdk 版本SDK_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.2.sdk&quot; SDK_SML_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk&quot; export PATH=$TOL_ROOT/usr/bin:$PATH work=`pwd` srcs=$work/src buid=$work/build insl=$buid/install name=faac-$&#123;major&#125;.$&#123;minor&#125; pakt=$&#123;name&#125;.tar.gz dest=$work/faac-iOS-$&#123;major&#125;.$&#123;minor&#125;.$&#123;micro&#125;.tgz rm -rf $srcs $buid $dest &amp;&amp; mkdir -p $srcs $buid archs=&quot;i386 x86_64 armv7 armv7s arm64&quot; for a in $archs; do case $a in arm*) sys_root=$&#123;SDK_ROOT&#125; host=arm-apple-darwin ;; i386|x86_64) sys_root=$&#123;SDK_SML_ROOT&#125; host=$a-apple-darwin ;; esac prefix=$insl/$a &amp;&amp; rm -rf $prefix &amp;&amp; mkdir -p $prefix rm -rf $srcs &amp;&amp; mkdir -p $srcs &amp;&amp; cd $work &amp;&amp; tar xvzf $pakt -C $srcs &amp;&amp; cd $srcs/$name export CC=&quot;$TOL_ROOT/usr/bin/clang -arch $a -isysroot $sys_root&quot; export CXX=&quot;$TOL_ROOT/usr/bin/clang++ -arch $a -isysroot $sys_root&quot; export CXXFLAGS=&quot;-arch $a -isysroot $sys_root&quot; export CFLAGS=&quot;-arch $a -isysroot $sys_root&quot; export LDFLAGS=&quot;-isysroot $sys_root&quot; export LIBS=&quot;-L$&#123;sys_root&#125;/usr/lib&quot; chmod +x bootstrap ./bootstrap \ &amp;&amp;./configure \ --host=$host \ --with-sysroot=$sys_root \ --prefix=$prefix \ --disable-shared \ --enable-static \ --disable-faac \ --with-mp4v2 \ &amp;&amp;make &amp;&amp; make install lipo_archs=&quot;$lipo_archs $prefix/lib/libfaac.a&quot; echo &apos;continue any key pressed..&apos; read -n 1done univ=$insl/universal &amp;&amp; mkdir -p $univ/lib cp -r $prefix/include $univ/ lipo $lipo_archs -create -output $univ/lib/libfaac.a ranlib $univ/lib/libfaac.a strip -S $univ/lib/libfaac.a cd $univ &amp;&amp; tar cvzf $dest * 执行 ./build_faac.sh, 开始编译. 编译成功后, 生成 build 目录. 其中, universal 生成的库是通用库. 编译 faad2解压后, 将 faad2-2.7 改名为 faad. 编写编译的脚本文件, 这里取名为 build_fadd2.sh 1touch build_fadd2.sh 编辑 build_fadd2.sh 文件. 写入如下内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/bin/shCONFIGURE_FLAGS=&quot;--enable-static --with-pic&quot;ARCHS=&quot;arm64 armv7s armv7 x86_64 i386&quot;# directoriesSOURCE=&quot;faad&quot;FAT=&quot;fat-faad&quot;SCRATCH=&quot;scratch-faad&quot;# must be an absolute pathTHIN=`pwd`/&quot;thin-faad&quot;COMPILE=&quot;y&quot;LIPO=&quot;y&quot;if [ &quot;$*&quot; ]thenif [ &quot;$*&quot; = &quot;lipo&quot; ]then# skip compileCOMPILE=elseARCHS=&quot;$*&quot;if [ $# -eq 1 ]then# skip lipoLIPO=fififiif [ &quot;$COMPILE&quot; ]thenCWD=`pwd`for ARCH in $ARCHSdoecho &quot;building $ARCH...&quot;mkdir -p &quot;$SCRATCH/$ARCH&quot;cd &quot;$SCRATCH/$ARCH&quot;if [ &quot;$ARCH&quot; = &quot;i386&quot; -o &quot;$ARCH&quot; = &quot;x86_64&quot; ]thenPLATFORM=&quot;iPhoneSimulator&quot;CPU=if [ &quot;$ARCH&quot; = &quot;x86_64&quot; ]thenSIMULATOR=&quot;-mios-simulator-version-min=7.0&quot;HOST=&quot;--host=x86_64-apple-darwin&quot;elseSIMULATOR=&quot;-mios-simulator-version-min=5.0&quot;HOST=&quot;--host=i386-apple-darwin&quot;fielsePLATFORM=&quot;iPhoneOS&quot;if [ $ARCH = &quot;armv7s&quot; ]thenCPU=&quot;--cpu=swift&quot;elseCPU=fiSIMULATOR=HOST=&quot;--host=arm-apple-darwin&quot;fiXCRUN_SDK=`echo $PLATFORM | tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;`CC=&quot;xcrun -sdk $XCRUN_SDK clang -Wno-error=unused-command-line-argument-hard-error-in-future&quot;AS=&quot;$CWD/$SOURCE/extras/gas-preprocessor.pl $CC&quot;CFLAGS=&quot;-arch $ARCH $SIMULATOR&quot;CXXFLAGS=&quot;$CFLAGS&quot;LDFLAGS=&quot;$CFLAGS&quot;CC=$CC CFLAGS=$CXXFLAGS LDFLAGS=$LDFLAGS CPPFLAGS=$CXXFLAGS CXX=$CC CXXFLAGS=$CXXFLAGS $CWD/$SOURCE/configure \$CONFIGURE_FLAGS \$HOST \--prefix=&quot;$THIN/$ARCH&quot; \--disable-shared \--without-mp4v2make clean &amp;&amp; make &amp;&amp; make install-stripcd $CWDdonefiif [ &quot;$LIPO&quot; ]thenecho &quot;building fat binaries...&quot;mkdir -p $FAT/libset - $ARCHSCWD=`pwd`cd $THIN/$1/libfor LIB in *.adocd $CWDlipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIBdonecd $CWDcp -rf $THIN/$1/include $FATfi 给予执行权限: 1chmod +x build_fadd2.sh 此时目录结构如下: 执行编译脚本, 在当前目录生成 scratch-faad 和 fat-faad 以及 thin-faad 目录, 如下: 使用 fat-faad 里面的库和文件即可. 可以使用下面的命令查看对应的 .a 文件所支持的架构: 1lipo -info libfaad.a 会得到对应的输出: 1Architectures in the fat file: libfaad.a are: i386 armv7 armv7s arm64 同样可以查看 libfaac.a. 后记编译好的文件, 已经放到 github 上面了, 有需要的可以下载使用, 点击 下载链接 进入. 感谢 fflydev/faac-ios-build 提供编译 faac 的 shell, 只需要将里面对应的 SDK 改为本机最新的 SDK 即可. 参考文章 faac 1.28的交叉编译与问题解决 使用FAAD库解码AAC实例 在Linux上使用FDK AAC將音樂轉成M4A(AAC、HE-AAC、HE-AACv2)格式 aac文件转码为wav文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>音视频 faac faad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程: 初步认识]]></title>
    <url>%2F2018%2F02%2F12%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[几乎每个编程语言或者平台都会遇到多线程的问题, 说明多线程是一个非常重要且开发者必须了解和掌握的. 多线程也是面试官比较喜欢问的问题, 例如: 进程和线程的区别, Android 是否支持多进程? 线程池如何实现的? 锁机制? 多线程之间如何通信? 谈及 iOS 中的多线程，一般说的是 pthread，NSthread，GCD，NSOperation 这四种, 用的最多也最方便的就是 GCD 了. 关于这四者, 后续会为大家一一分享. phtread 是跨平台的, C/C++ 中都有它的声影, GCD 和 NSOperation 都是常用的，NSOperation 是基于 GCD 的. GCD 的核心概念是将一个任务添加到队列，指定任务执行的方法，然后执行, NSOperation 则是直接将一个操作添加到队列中. 该系列文章来跟大家分享关于 iOS 中的多线程. iOS 多线程: 初步认识(本篇) 进程和线程进程和线程的定义, 大家可以自行到维基百科上面去查. 这里只说二者的区别. 一个程序至少有一个进程, 一个进程至少有一个线程如主线程. 多线程程序的并发性高. 进程在执行过程中拥有独立的内存单元，而多线程是共享内存的，从而极大地提高了程序的运行效率. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口. 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制. 操作系统并没有将多个线程看做多个独立的应用, 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行, 从而实现了进程的调度和管理以及资源分配. 队列iOS 中, 队列主要分为: 全局队列 主队列. 串行队列. 并发队列. Concurrent:tasks are dequeued in FIFO order, but run concurrently and can finish in any order. Serial: .tasks execute one at a time in FIFO order 并发: 任务以 FIFO 从序列中移除，然后并发运行，可以按照任何顺序完成. 串行: 任务以FIFO从序列中一个一个执行. 一次只调度一个任务. 在 iOS 中, 并发不一定会开启多个线程, 串行也不一定只开启一个线程. 因为这里会牵扯到是异步还是同步执行. 主队列, 即 mainQueue. Returns the default queue that is bound to the main thread. 会关联主线程. 全局队列, 即 globalQueue. The well-known global concurrent queues may not be modified. 全局队列中执行不一定会开启新线程. 同步和异步在 iOS 的 GCD 中, 还有同步和异步执行的区别. 同步 同步执行代码块, 诸如 dispatch_async 中执行的. 异步 异步执行代码块, 诸如 dispatch_sync 中执行的. 创建队列的方法创建主队列 1dispatch_queue_t dispatch_get_main_queue(void); 创建全局队列 1dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags); 参数 identifier 用来表示优先级. 对应的优先级为: DISPATCH_QUEUE_PRIORITY_HIG DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW DISPATCH_QUEUE_PRIORITY_BACKGROUND 如果传入 0 标示 DISPATCH_QUEUE_PRIORITY_DEFAULT. 参数 flags 是一个保留参数, API 文档要求传入 0, 非0值可能会导致返回结果为 NULL. 自定义队列 dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr); 参数 label 是一个字符串. 参数 attr 用来标示是串行还是并行队列. 可以从 DISPATCH_QUEUE_SERIAL, DISPATCH_QUEUE_CONCURRENT 二者中取值. 如果该参数传入 NULL, 默认是 DISPATCH_QUEUE_SERIAL 串行队列. 串行队列中的线程串行队列到底是开了一个线程, 还是开了多个线程, 我们一探究竟. 先看例子1 12345678dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL); for (int i=0; i&lt;10; i++) &#123; dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]); &#125;);&#125; 可以看出, 只开启一个新线程. 再看例子2 12345678910dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]); sleep(2);&#125;);dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);&#125;); 可以看出, 也只开启一个新线程. 改造一下例子2, 将其中的一个异步改为同步 12345678910dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]); sleep(2);&#125;);dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);&#125;); 可以看出, 同步的执行在主线程, 二者并不是在一个线程中执行. 所以, 串行队列中执行的代码, 不一定都在子线程中, 如果是异步都是同一个线程中执行.如果是同步的话, 会在主线程中执行. 同理, 并行队列中的异步执行会开启多个线程来执行. 执行方式和队列这里的执行方式指的是同步或者异步执行. 先看异步执行 12345678910111213141516171819202122232425/// 异步全局队列和主队列 &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 1 NSLog(@&quot;dispatch_async. mainQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 0 NSLog(@&quot;dispatch_async. globalQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; /// 异步串行和并行队列 &#123; dispatch_async(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; // 0 NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); dispatch_async(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123; // 0 NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_CONCURRENT. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; 再看同步执行 12345678910111213141516171819202122232425262728/// 同步全局队列和主队列 &#123; #if 0 // 会死锁 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;dispatch_sync. mainQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); #endif dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; // 1 NSLog(@&quot;dispatch_sync. globalQueue. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; /// 同步串行和并行队列 &#123; dispatch_sync(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; // 1 NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); dispatch_sync(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123; // 1 NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_CONCURRENT. isMainThread: %i&quot;, [NSThread isMainThread]); &#125;); &#125; 得出结论 任何队列的同步执行, 都没有开启新线程, 在主线程中执行. 主队列的同步执行会造成死锁. 主队列的异步执行, 没有开启新线程. 在主线程中执行. 串行和并行以及全局队列的异步执行, 都会开启新线程. 参考 进程和线程的区别 进程与线程的一个简单解释]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 多线程 进程 GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++: 如何相互调用]]></title>
    <url>%2F2018%2F02%2F12%2FC-C-%E5%A6%82%E4%BD%95%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++ 中调用 C 比较简单. 但是 C 调用 C++ 稍微复杂一些. C 调用 C++ 分为可以调用 C++ 类中的函数和普通 cpp 中的函数. 无论是哪种函数, 我们都可以使用封装了 C++ 的文件作为适配供给 C 来使用. 下面看具体的例子. C++ 调用 C首先创建 CFile.h 和 CFile.c 文件. CFile.h 12345678#ifndef CFile_h#define CFile_h#include &lt;stdio.h&gt;extern void start_c(int cmd);#endif /* CFile_h */ CFile.c 123456#include &quot;CFile.h&quot;void start_c(int cmd) &#123; printf(&quot;start_c by cmd: %i\n&quot;, cmd);&#125; 在 C++ 文件中调用 C 代码, 示例如下: main.cpp 12345678910extern &quot;C&quot; &#123;#include &quot;CFile.h&quot;&#125;int main(int argc, const char * argv[]) &#123; start_c(1); return 0;&#125; 这里可以看到导入 C 文件的方式: 123extern &quot;C&quot; &#123;#include &quot;CFile.h&quot;&#125; 如果直接导入, 如: 12345678#include &quot;CFile.h&quot;int main(int argc, const char * argv[]) &#123; start_c(1); return 0;&#125; 编译报错: 1234Undefined symbols for architecture x86_64: &quot;start_c(int)&quot;, referenced from: _main in main.old: symbol(s) not found for architecture x86_64 这里的 extern &quot;C&quot; 告诉编译器, 要按照 C 的链接约定，而不是 C++ 的链接约定. C 编译器不支持 extern &quot;C&quot;. C 调用普通 C++ 的函数C 调用 C++ 有点曲折. CPPFile.hpp 123456#ifndef CPPFile_hpp#define CPPFile_hppvoid start_cpp(int cmd);#endif /* CPPFile_hpp */ CPPFile.cpp 123456789#include &quot;CPPFile.hpp&quot;#include &lt;iostream&gt;using namespace std;void start_cpp(int cmd) &#123; cout &lt;&lt; &quot;start_cpp by cmd: &quot; &lt;&lt; cmd &lt;&lt; endl;&#125; 这里需要写一个中间的 cpp(CPPAdapter.cpp)文件, 提供方法给 C 来使用. 注意: 这里没有 CPPAdapter.hpp 头文件. CPPAdapter.cpp 123456789101112131415#include &quot;CPPFile.hpp&quot;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif void adapter_start_cpp(int cmd) &#123; //调用 CPPFile 中的方法 start_cpp(cmd); &#125; #ifdef __cplusplus&#125;#endif 然后在 C 中调用 C++ 的代码: CFile.c 12345678910#include &quot;CFile.h&quot;//声明函数extern void adapter_start_cpp(int cmd);void start_c(int cmd) &#123; //调用 c++ 代码 adapter_start_cpp(5);&#125; C 调用 C++ 类中的方法和上面例子的原理一样的. CPPClassFile.hpp 1234567891011121314151617181920#ifndef CPPClassFile_hpp#define CPPClassFile_hpp#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;private: string name; public: Person(); ~Person(); int setName(string name);&#125;;#endif /* CPPClassFile_hpp */ CPPClassFile.cpp 1234567891011121314151617181920#include &quot;CPPClassFile.hpp&quot;Person::Person() &#123; cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;&#125;Person::~Person() &#123; cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;&#125;int Person::setName(string name) &#123; this-&gt;name = name; cout &lt;&lt; &quot;Set name: &quot; &lt;&lt; name &lt;&lt; endl; return 0;&#125; CPPAdapter.cpp 12345678910111213141516171819202122232425#include &quot;CPPFile.hpp&quot;#include &quot;CPPClassFile.hpp&quot;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif void adapter_start_cpp(int cmd) &#123; //调用 CPPFile 中的方法 start_cpp(cmd); &#125; int adapter_set_name(const char *cName) &#123; Person *person = new Person(); int ret = person-&gt;setName(cName); delete person; return ret; &#125; #ifdef __cplusplus&#125;#endif 在 C 中可以调用了, 如下代码: CFile.c 123456789101112131415161718#include &quot;CFile.h&quot;///声明 CPPFile 中的方法extern void adapter_start_cpp(int cmd);///声明 CPPClassFile 中的方法extern int adapter_set_name(const char *cName);void start_c(int cmd) &#123; printf(&quot;start_c by cmd: %i\n&quot;, cmd); //调用 CPPFile 中的方法 adapter_start_cpp(5); //调用 CPPClassFile 中的方法 adapter_set_name(&quot;www.veryitman.com&quot;);&#125; extern “C”extern &quot;C&quot; 中的 “C” 并不表示 C 语言，”C” 表示的是一种链接约定. extern &quot;C&quot; 指令描述的是一种链接约定，它并不影响调用函数的定义，即使做了该声明，对函数类型的检查和参数转换仍要遵循 C++ 的标准，而不是 C 的标准. 不同的编程语言(编译型)链接特性是不同的，这也决定了它们编译后的链接符号的不同. 如函数 void function(int d)，C 语言会把它编译成类似 _function 这样的符号，C 链接器只要找到该函数符号就可以链接成功. C++ 会把这个函数编译成类似 _function_int 或 _xxx_functionIntxxx 这样的符号，即在符号上增加了类型信息，这也解释了为什么 C++ 可以实现函数重载了. 那么，对于用 C 编译器编译成的库，用 C++ 直接链接势必会出现不能识别符号的问题，用 extern &quot;C&quot; 就可以解决, 正如上面的例子. 简单来说, extern &quot;C&quot; 的作用就是让编译器知道要以 C 语言的方式编译和链接函数. __cplusplus 宏__cplusplus 宏是 C++ 编译器默认定义的. 类似如下的代码: 123456789#ifdef __cplusplusextern &quot;C&quot;&#123;#endifvoid fun(int, size_t);#ifdef __cplusplus&#125;#endif 在 C++ 中, 编译器将 fun 按照 C 的链接约定来编译, 而如果是 C 编译器, 直接按照 C 的链接约定来编译即可. __cplusplus 是在 C++ 编译器中默认定义的,Ｃ语言不支持 extern &quot;Ｃ&quot;. 上面的代码很实用, 也是一种编程技巧.]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C C++ 编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: Background Fetch]]></title>
    <url>%2F2018%2F02%2F08%2FiOS-APNs-Background-Fetch%2F</url>
    <content type="text"><![CDATA[在前面的几篇文章中, 给大家介绍了跟推送相关的内容. 今天跟大家聊一聊 iOS7 新加入的 Background Fetch 功能. 该系列博客: iOS APNs: 远程推送iOS APNs: 本地推送iOS APNs: 处理数据iOS APNs: 静默推送iOS APNs: Background Fetch(本篇) 简介从 Background Fetch 字面上来看, 大致意思是可在后台获取数据. 在 iOS7 中，Apple 为开发者提供了可以在后台更新应用程序界面和内容的 API, 即 Background Fetch. 该特性允许开发者在一个周期间隔后进行特定的动作，如获取网络内容, 更新 UI 操作等. 同时在 iOS7 中, 也加入了另一个特性, 就是博文 iOS APNs: 静默推送 里面说的静默推送. 这些都是对 iOS 后台多任务的补充和完善, Apple 一直在优化系统从而增强用户体验. 开启 Background Fetch1.需要 APP 支持 如下图所示, 勾选即可. 2.设置 fetch 时间间隔 在 AppDelegate 中设置. 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 设置 fetch 时间间隔 [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];&#125; UIApplicationBackgroundFetchIntervalMinimum 是系统自定义的时间. 如果不设置, 默认是 UIApplicationBackgroundFetchIntervalNever, 这样就不会让 Background Fetch 生效了. 可以查看对 UIApplicationBackgroundFetchIntervalNever 的官方解释. 123UIApplicationBackgroundFetchIntervalNeverA fetch interval large enough to prevent fetch operations from occurring. 当然, 你也可以设置自己定义的时间的间隔, 但是基本没有什么作用, 因为这个时间间隔完全由系统来决定, 系统会根据你的电量以及使用频率来决定. 所以, 可以理解为 setMinimumBackgroundFetchInterval 方法只是开启了 Background Fetch 功能. 3.开启了系统后台更新功能 在 iOS 系统中, 设置/通用/后台应用刷新中一定要开启对应 APP 的功能. 判断是否已经开启该功能的示例代码: 1234if ([[UIApplication sharedApplication] backgroundRefreshStatus] != UIBackgroundRefreshStatusAvailable) &#123; //不可用提示用户&#125; 处理回调在实际的应用环中，Background Fetch 事件是由系统管理的，我们开发者是无法预先知道 Fetch 事件达到的时机的. 网上很多说可以使用 Xcode 模拟这个事件, 估计也是之前的系统和 Xcode 版本, 现在的 Xcode9 貌似不行了. 但是, 你的手机在后台等几分钟, 有时候会被系统触发该事件, 触发后, 对应的系统回调(在 AppDelegate 中)会被调用. 12345678910// Background fetch 回调- (void)application:(UIApplication *)applicationperformFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler &#123; MZLOG(@&quot;AppDelegate. Background fetch.&quot;); //可进行对应的耗时操作, 如下载等. completionHandler(UIBackgroundFetchResultNoData);&#125; Background Fetch 会为我们的 App 争取更多的后台时间, 但是一般是几十秒左右, 不会太多. 所以, 不要在回调中做太多耗时的操作.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 远程推送 BackgroundFetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 静默推送]]></title>
    <url>%2F2018%2F02%2F06%2FiOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[今天跟大家介绍一下 ios 的静默推送功能. 静默推送, 简单来说就是通过推送实现用户无感知的消息通知. 该系列博文: iOS APNs: 远程推送iOS APNs: 本地推送iOS APNs: 处理数据iOS APNs: 静默推送(本篇) 普通推送例如微信, 好友给你发送了一条消息, 你的微信APP 在后台, 此时会收到带声音的一个消息提示. 这条推送机油有文字又有声音, 点开这个推送可以直接打开 APP. 从程序的角度来讲, 进入 App 后会调用下面的方法: iOS10.0.x 和其之前的系统调用下面的方法: 1- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo iOS10.0.x 之后的系统, 会调用如下的方法: 123- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler 静默推送的异同1.没有弹出框 没有推送的弹框出现, 用户毫无感知的接收到了这个推送消息. 有 润物细无声 的感觉. 该推送既没有文字又没有声音. 2.需要用户授权允许推送 这个跟普通推送一样, 都需要用户授权才可以推送. 3.会执行代理方法 静默推送来的时候, 也能执行上面的回调方法. 执行上面方法的场景如下:: 1.App 在前台.2.App 在后台, 但是没有被 kill 掉. 4.iOS7 以后才有的 对于 iOS 之前是没有静默推送的. 5.可以延长后台时间 收到静默推送后, 在应用程序挂起之前有 30 秒左右可以执行相关的操作. 6.推送频率的控制 静默的推送是苹果推送服务器控制推送频率的. 苹果推送服务根据后台推送任务的能耗(用电量,接收情况)来控制后台推送的推送频率和延迟时间. 总之, 静默推送是普通推送的一种变种而已. 无论是静默推送还是普通推送, 开发者证书里面必须开通 push 相关的功能, 并且也需要用户开启允许推送的授权. 这个在 iOS APNs: 远程推送 里面已经介绍过, 不在这里赘述. 推送的格式普通推送的格式, 大致是这个样子: 12345678&#123; &quot;aps&quot;: &#123; &quot;alert&quot;:&quot;Testing.. (15), &quot;badge&quot;:1, &quot;sound&quot;:&quot;default&quot; &#125;&#125; 静默推送是不允许带 alert badge sound 等字段的. 但是必须包含 &quot;content-available&quot;:1. 例如下面的形式都可以: 形式1 123456&#123; &quot;aps&quot;: &#123; &quot;content-available&quot;:1 &#125;&#125; 形式2 1234567&#123; &quot;aps&quot;: &#123; &quot;custom&quot;:&quot;open_profile_page&quot; &quot;content-available&quot;:1 &#125;&#125; 其中, custom 是自己定义的, 大家根据需求自行扩展即可. 形式3 1234567&#123; &quot;aps&quot; : &#123; &quot;content-available&quot; : 1 &#125;, &quot;acme1&quot; : &quot;bar&quot;, &quot;acme2&quot; : 42&#125; 这个来自苹果开发者 文档. 使用场景具体的使用场景, 需要结合本身的业务和功能特点来说. 静默推送的前提是 APP 没有被杀死, 可以通过回调函数来执行相关的代码. 另外, 静默推送不会打扰用户, 比如用户正在游戏中战斗, 你频繁的使用普通推送给他, 估计他都要疯了. 我个人使用静默推送的场景大致是这样的, APP 将要挂起的时候, 请求服务器去发一条静默推送, 然后使用本地通知的方式唤起用户来打开 APP, 从而保证 APP 处于保活的状态, 至少静默推送可以增加后台挂起的时间. 关于本地通知的内容, 可以参考之前的文章 iOS APNs: 本地推送. 更多的使用场景等大家在业务中去挖掘.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hi 2018, 我又来了]]></title>
    <url>%2F2018%2F02%2F02%2FHi-2018-%E6%88%91%E5%8F%88%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[好久没有更新自己的博客了, 以前坚持一周至少两三篇博文的我, 从 2017 年 10 月份到现在居然停止了. 其实, 这是有原因的… 数据丢了2017 年 10 月 15 日晚, 我亲手把自己的之前写的文章(原数据)给弄丢了. 我自己搭建的博客系统是使用 GitHub + Hexo 部署和发布的. 事情大致经过是这样的… Mac 操作系统提示, 有更新的系统可以使用了, 问是否立即安装, 在公司的时候, 我心想, 更新后, 自己安装的一些库, 估计也要重新安装, 嫌麻烦就直接跳过了. 过了几天, 我晚上下班回家, 系统又提示我更新. 当时, 我就没有忍住, 直接更新了, 毕竟早晚都要更新的, 再说了 MacOS 还是比较让人放心的. 趁电脑更新系统的时候, 我就去洗了澡, 回来发现系统更新已经完成了. 心中想正好可以把之前没有完成的博客去完善一下, 谁知道…天不遂我愿呀! 再去使用 Hexo 的时候, 提示我失败, 居然无法使用了. 这可把我急的够呛, 一气之下(脑子估计当时进水了), 直接删了 Hexo 目录, 是那种程序员式的毫不留情的删除. rm -fr ./hexo 潇洒的操作后, 重新安装 Hexo, 又折腾了两个晚上, 最终也是安装好了, 可以写东东了. 但是发现从 Github 上面 clone 后的文件, 无法还原成自己当初的 MarkDown 文件了. 雪花那个飘啊飘, 北风那个萧呀萧… 一切都晚了! ^^ 唯一值得庆幸的是, 原来自己的网站博文还在那里. 还原数据从哪里跌倒, 就从哪里爬起来, 我决定把之前的数据使用 人工智能 的方式还原回来. 😆我就是那个 人工, 手动的将 HTML 转换为 MarkDown 文档, 压根没有什么 智能. 好歹那也是自己熬过多少个日夜的成果呀, 没有功劳也有苦劳, 我不忍心就这样让它丢掉, 含着泪也要把它们给找回来! 自己下半年也比较忙, 周末都在加班, 只能每天晚上回家抽些时间还原一点, 有时候太困, 就推迟到下个晚上. 大概用了 3 个月左右的时间, 基本还原回来了. 每篇文章基本都有配图, 都有跳转链接, 恢复起来, 还是需要一点时间和毅力的, 中途我也放弃过, 但是想想它们就要这样的被我抹杀了, 实在太可怜了, 就坚持下来了. 反思和总结还原之前的数据, 比写新文章还累, 主要是心累. 刚开始的时候, 我每篇都想一步到位的还原, 发现坚持几个晚上, 效率很低, 很容易放弃. 最后, 我调节了一下心态, 分 迭代 去做. 第一个阶段, 把 HTML 文章拷贝到 MarkDown 工具中, 不做任何的修饰和修改. 第二个阶段, 梳理 MarkDown 文档, 把缺失的图片补上去. 第三个阶段, 把文章中的链接尽量补全. 经过这三个阶段后, 文章基本已经复原了, 只是格式上看起来有点糟糕. 第四个阶段, 整理文章的排版, 对比已经发布的文章, 查漏补缺. 第四个阶段结束后, 文章基本都复活了, 接下来就是部署和发布了. 第五个阶段, 整理 Hexo, 配置相关的主题. 第六个阶段, 本地预览和再次校验文章, 统一发布. 每个阶段, 我都给自己一个小目标, 不断的去完善, 最后将各个阶段的成果串联起来, 就完成了. 当自己遇到困难的时候, 不妨分解一下任务, 不断的去完成每个小任务, 每个完成的小任务都是对自己最大的奖励. 整个还原的过程, 又让我重新梳理了一下之前的文章, 包括目录规划和文章中的措辞, 也对图片进行了压缩和处理. 收获颇多. 如果当初自己不那么冲动, 如果当初自己备份了文件, 应该就不会有这么一个艰辛的历程了. 数据备份很重要, 冲动是要付出代价的. 现在我把原数据保存在云盘中, 本地也保留一份, 定期更新到云盘中. 这样就可以防止数据丢失了. 祝大家在 2018 发发发, 身体健康, 幸福安康! 推荐推荐给 Mac 用户一个图片压缩工具 imageoptim.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学习 生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: 静态库]]></title>
    <url>%2F2017%2F10%2F08%2FGCC-%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[概要如果你对 GCC 的编译 C语言的流程不清楚, 建议在阅读本文之前先去看一下 GCC: 编译C语言的流程 这篇文章, 篇幅短小精悍, 阅读后, 至少可以扫扫盲😜. 本篇博文用到的一些基础知识点: 1.GCC gcc -c 选项含义: 1Only run preprocess, compile, and assemble steps 是 -c 选项只是进行了预处理, 编译, 汇编的阶段, 不会进行链接的操作. 2.静态库 Linux 上的静态库，本质是一些目标文件的归档文件. 3.静态库和共享库区别 [1].使用共享库可以节省内存. 比如 libc，系统中几乎所有的进程都映射 libc 到自己的进程地址空间，而 libc 的只读部分在物理内存中只需要存在一份，就可以被所有进程共享，这就是“共享库”这个名称的由来了. [2].使用共享库可以很方便地升级库文件而不需要重新编译应用程序. [3].共享库占用更少的体积. 在运行时做动态链接.而在链接静态库时, 链接器会把静态库中的目标文件取出来和可执行文件真正链接在一起. 创建步骤创建静态库的步骤如下: [1]. 写源文件.[2]. 通过 gcc -c x.c 生成目标文件.[2]. 归档. 用 ar 归档目标文件，生成静态库.[3]. 写头文件, 便于使用者知道怎么使用该静态库. 使用静态库时，在源码中包含对应的头文件，链接时记得链接自己的库. 下面结合具体例子, 展开讲. 写源文件目录结构 示例文件都是很简单的代码, 附录可以查看完整示例. 生成目标文件将 libs 目录下面的(c)源文件进行预处理, 编译和汇编.注意这里没有进行链接. 1gcc -c libs/person.c libs/eat.c libs/play.c libs/sleep.c 执行城后, 会生成对应的 .o 文件. 归档libperson.a 是要生成的库文件. 库文件都以 lib 开头, 静态库以. a 为后缀. 所以一般是 lib+ 名字.a 1ar rs libperson.a person.o sleep.o play.o eat.o ar: 类似于 tar, 用来对文件进行库打包. r 选项: 将其后面的文件列表添加到文件包(libperson.a)中, 如果 libperson.a 不存在就创建它, 如果 libperson.a 已经存在且里面有同名的目标文件就进行替换操作. s 选项: 为静态库创建索引.这个索引会被链接器使用. ranlib 命令也可以为静态库创建索引. 所以上面的命令可以等效为下面的两个命令. 12ar r libperson.a person.o sleep.o play.o eat.oranlib libperson.a 写头文件写一个 person.h 文件, 便于调用者查看库如何使用. person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif 使用静态库 1gcc main.c -L. -lperson -Ilibs -o main -L 选项: 告诉编译器去哪里找库文件, 这里的 _L. 表示在当前目录.如果不用 -L 选项, 即使库文件在当前目录, 编译器也不会去找, 所以该选项不能少. 报错信息如下: 12ld: library not found for -lpersonclang: error: linker command failed with exit code 1 (use -v to see invocation) -lperson: 告诉编译器要链接 libperson.a 库. -I: 告诉编译器到哪里找头文件.如果不指定头文件的查找目录, 也会报错: 1234main.c:2:10: fatal error: &apos;person.h&apos; file not found#include &quot;person.h&quot; ^~~~~~~~~~1 error generated. 此时的目录结构: 链接成功后, 可以执行生成的 main (可执行)文件. 1./main 123uid: 101 eatinguid: 101 playinguid: 101 has sleep 有趣的实验猜想一下如果有两个库一个是共享库, 一个是静态库, 而且二者除了后缀不一样, 名字都一样如 libperson.a 和 libperson.so, 那么调用方如何来选择对应的库文件呢? 我们把 GCC: 共享库 里面生成的共享库 libperson.so 放到当前的目录, 重新编译链接 main.c 文件. 1gcc main.c -L. -lperson -Ilibs -o main 再次执行 ./main, 得到结果是这样的: 123From sharedlib.uid: 101 eatingFrom sharedlib.uid: 101 playingFrom sharedlib.uid: 101 has sleep 以上的结果, 说明链接器会优先选择共享库其次才是静态库. Linux(MacOS 也一样) 的 GCC 默认链接动态库，只有当动态库不存在时，才去链接静态库.若是需要强制指定静态库需要指定选项 -static.但是在 MacOS 上面不支持该选项. 1gcc -static main.c -L. -lperson -Ilibs -o main 附录示例完整代码 main.c 12345678#include &lt;stdio.h&gt;#include &quot;person.h&quot;int main() &#123; init(101); eat(); play(); sleep();&#125; person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif person.c 1234int uid;void init(int pUid) &#123; uid = pUid;&#125; eat.c 12345#include &lt;stdio.h&gt;extern int uid;void eat() &#123; printf(&quot;uid: %i eating\n&quot;, uid);&#125; play.c 12345#include &lt;stdio.h&gt;extern int uid;void play() &#123; printf(&quot;uid: %i playing\n&quot;, uid);&#125; sleep.c 12345#include &lt;stdio.h&gt;extern int uid;void sleep() &#123; printf(&quot;uid: %i has sleep\n&quot;, uid);&#125; GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>GCC 编译器 静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: 共享库]]></title>
    <url>%2F2017%2F10%2F07%2FGCC-%E5%85%B1%E4%BA%AB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[基本概念共享库: 在程序执行期间需要调用到共享库的时候才加载到内存里面，可以被多个程序共享使用. 在 MacOS 上面创建和使用共享库要比在 Linux 上面简单.在 Linux 上面还会牵扯到共享库路径问题, 在 Mac 上面就没有这样的问题. 在 MacOS 上面使用的 GCC 其本质是 LLVM. 你可以在命令行: 1gcc -v 可以看到对应的输出结果: 12345Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1Apple LLVM version 9.0.0 (clang-900.0.37)Target: x86_64-apple-darwin16.7.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 创建共享库步骤[1].写源文件.这里以 C文件为基础.[2].将源文件生成目标文件.[3].创建共享库.[4].写头文件, 供调用方使用. 下面结合实例来分享一下如何在 Mac 上面创建共享库. 写源文件目录结构: 对应的完整代码可以看文末的附录. 生成目标文件执行如下命令: 1gcc -Wall -c -fPIC libs/eat.c libs/play.c libs/sleep.c libs/person.c 注意: -fPIC 选项一定要加. PIC(position independent code), 产生位置无关码 生成共享库这里把共享库暂且称之为 libperson.so. 执行下面命令创建: 1gcc -shared -fPIC eat.o play.o sleep.o person.o -o libperson.so 写头文件这里头文件主要是 person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif 使用共享库main.c 是使用方, 编译链接即可. 1gcc main.c -L. -lperson -Ilibs -o main 生成可执行文件 main, 执行结果: 123From sharedlib.uid: 101 eatingFrom sharedlib.uid: 101 playingFrom sharedlib.uid: 101 has sleep 注意:-L 选项, 告诉编译器去哪里找库文件, 这里的 _L. 表示在当前目录. -lperson, 表示 libperson.so 库. -Ilibs 告诉编译器头文件所在的目录. 附录示例完整代码 main.c 12345678#include &lt;stdio.h&gt;#include &quot;person.h&quot;int main() &#123; init(101); eat(); play(); sleep();&#125; person.h 1234567#ifndef _PERSON_H#define _PERSON_Hextern void init(int pUid);extern void eat();extern void play();extern void sleep();#endif person.c 1234int uid;void init(int pUid) &#123; uid = pUid;&#125; eat.c 12345#include &lt;stdio.h&gt;extern int uid;void eat() &#123; printf(&quot;From sharedlib.uid: %i eating\n&quot;, uid);&#125; play.c 12345#include &lt;stdio.h&gt;extern int uid;void play() &#123; printf(&quot;From sharedlib.uid: %i playing\n&quot;, uid);&#125; sleep.c 12345#include &lt;stdio.h&gt;extern int uid;void sleep() &#123; printf(&quot;From sharedlib.uid: %i has sleep\n&quot;, uid);&#125; GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>GCC 编译器 共享库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: Homebrew 安装 GCC 和 Binutils]]></title>
    <url>%2F2017%2F10%2F07%2FGCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils%2F</url>
    <content type="text"><![CDATA[文章背景前段时间，有个博客上面的小伙伴给我发来邮件，问我关于 GCC 相关的知识，对于 GCC 我也只是凭着之前的了解，回复他了。书到用时方恨少呀！ 这位小伙伴还在读大学，自学能力比较强，自己出了完成课时之外，还会在网上找资料自学。 我记得自己在大学的时候，对 GCC 一窍不通，只知道 Turbo-C 和那些被强制记住的关键字。 最后告诉他, 我会坚持把自己以前学习过相关 GCC 的知识，以博客的形式输出。于是。就有了 GCC 系列 的文章，希望能够帮到大家。 概要这篇博客主要分享 macOS 下安装 GCC 和 Binutils 工具。 macOS 终端下输入 gcc -v, 其实是链接指向了 LLVM 编译器, 不是 GNU 的 GCC. 12345Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1Apple LLVM version 9.0.0 (clang-900.0.37)Target: x86_64-apple-darwin16.7.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 安装 GCC关于 GCC, 可以参考 维基百科. 执行下面命令, 即可开始安装: 1brew tap homebrew/versions 然后搜索 gcc 1brew search gcc 搜索结果中会显示 gcc 的版本，可以选择安装一个，建议安装最新版。 这里以安装 gcc49 为例。 1brew install gcc49 brew 会自动为你安装相关依赖，如 gmp4、mpfr2、libmpc08、isl011、cloog018. 这里安装需要等待一段时间… 看到下面的内容, 表示安装完毕. 123Pouring gcc49-4.9.2_1.yosemite.bottle.1.tar.gz/usr/local/Cellar/gcc49/4.9.2_1: 1138 files, 164M 安装成功后, 安装目录在: 1/usr/local/Cellar/gcc49/4.9.2_1 你在终端直接输入 gcc -v，其实还是 LLVM，那么如何使用我们 刚安装的 gcc? 123cd /usr/local/Cellar/gcc49/4.9.2_1/binls -l 可以看到: 123456789101112131415c++-4.9cpp-4.9g++-4.9gcc-4.9gcc-ar-4.9gcc-nm-4.9gcc-ranlib-4.9gcov-4.9x86_64-apple-darwin14.3.0-c++-4.9x86_64-apple-darwin14.3.0-g++-4.9x86_64-apple-darwin14.3.0-gcc-4.9x86_64-apple-darwin14.3.0-gcc-4.9.2x86_64-apple-darwin14.3.0-gcc-ar-4.9x86_64-apple-darwin14.3.0-gcc-nm-4.9x86_64-apple-darwin14.3.0-gcc-ranlib-4.9 Ok，你应该明白了, 在命令行输入 gcc-4.9 -v 就可以使用我们刚安装的 GCC 了，包括 g++ 等工具. 以后使用 GNU 的 GCC 输入 gcc-4.9 就好了。 安装 Binutils关于 Binutils 可以参考 维基百科. 执行下面命令, 直接安装: 1brew install binutils 同理: 1cd /usr/local/Cellar/binutils/2.25/bin 可以看到你需要的工具: 1234567891011121314151617181920gaddr2linegargc++filtgcoffdumpgdlltoolgdllwrapgelfeditgnlmconvgnmgobjcopygobjdumpgranlibgreadelfgsizegsrconvgstringsgstripgsysdumpgwindmcgwindres 个人感受在 macOS 上面，即使安装了 GNU 的 GCC，也没有在 Linux 上面用的那么爽，很多 GCC 的命令选项在 macOS 上面无法使用，但不得不承认 LLVM 是比较优秀的编译器。 遇到问题gcc-4.9 编译代码报错，报错内容如下： 1234main.c:9:19: fatal error: stdio.h: No such file or directory #include &lt;stdio.h&gt; ^compilation terminated. 卸载 gcc 重新安装最新版本的 gcc 即可，如果你不知道最新的 gcc 版本是哪个，可以 search 一下。 1brew search gcc 显示结果大致如下： 123456gcc gcc@5 gcc@7gcc@4.9 gcc@6 i386-elf-gcc 这里以安装 gcc@7 为例，命令如下： 12345// 卸载原来的brew uninstall gcc// 安装最新版本brew install gcc@7 GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>brew GCC C 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC: 编译C语言的流程]]></title>
    <url>%2F2017%2F10%2F03%2FGCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[再看下文之前，先普及一下 Linux 和 gcc 的历史，下面的这段内容来自于网络。 早在 20 世纪 70 年代，UNIX 系统是开源而且免费的。但是在 1979 年时，AT&amp;T 公司宣布了对 UNIX 系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。 于是在 1984 年，Richard Stallman 面对于如此封闭的软件创作环境，发起了 GNU 源代码开放计划并制定了著名的 GPL 许可协议。 1987 年时，GNU 计划获得了一项重大突破—gcc编译器发布，这使得程序员可以基于该编译器编写出属于自己的开源软件。 随之，在 1991 年10 月，芬兰赫尔辛基大学的在校生 Linus Torvalds 编写了一款名为 Linux 的操作系统。该系统因其较高的代码质量且基于 GNU GPL 许可协议的开放源代码特性，迅速得到了 GNU 计划和一大批黑客程序员的支持。 随后 Linux 系统便进入了如火如荼的发展阶段。 1994 年 1 月，Bob Young 在 Linux 系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了 Linux 系统的普及。 1998 年以后，随着 GNU 源代码开放计划和 Linux 系统的继续火热，以 IBM 和 Intel 为首的多家 IT 企业巨头开始大力推动开放源代码软件的发展。 到了 2017 年年底，Linux 内核已经发展到了 4.13 版本，并且 Linux 系统版本也有数百个之多，但它们依然都使用 Linus Torvalds 开发、维护的Linux 系统内核。RedHat 公司也成为了开源行业及 Linux 系统的带头公司。 声明这篇博文 makefile: gcc 工作流程 早期被我放在 CSDN 上面过.时隔多年, 仍不能忘怀, 现乔迁至此. 本文比较简单, 比较适合初学者.我只是试图以实例的方式给大家讲解一下 GCC 编译链接 C语言程序的流程, 并没有高深的知识. 编译流程C 语言经过预处理、编译、连接最后生成可执行文件. 在 Linux 的 GCC 下面，看看其工作流程. 流程图如下： 预处理，将包含的 .h 文件或者一些预处理语句（如 #define）处理一下，然后将 .c 文件生成 *.i 的中间文件. 注意了 GCC 不会自动生成这样一个文件，如果需要，自己加 -E 参数即可. 编译、汇编阶段生成 *.o 目标文件，最后经过链接生成可执行文件. 注意：可执行文件不一定是 exe 文件. 实例下面以一个实例 hello.c，说明这个过程. 源文件很简单，这里只是为了说明问题. 在命令行，执行下面命令完成预处理： 1gcc -E hello.c -o hello.i 执行之后，你可以打开 hello.i 文件，可以看到很多 extern 以及将 MAX 解释为 20： 在命令行，执行下面命令, 完成编译阶段: 1gcc -S hello.i -o hello.s 这时可以生成 *.s 文件，其实就是一些汇编语句，如下所示： 那麽，我们就可以进入汇编阶段了，执行： 1gcc -c hello.s -o hello.o 打开这个 hello.o 文件，都是一些机器码. 最后一个连接生成可执行文件： 1gcc hello.o -o hello 在当前目录就可以生成 hello 这个可执行文件. 执行 ./hello，就会输出： 到此，GCC 编译连接生成可执行文件完毕！ 当前目录下面的文件： 以上的步骤，其实一句命令即可： 1gcc hello.c -o hello 此时目录内容如下： 自己动手感受一下，你会收获更多！ GCC 系列博文GCC: 编译 C 语言的流程 GCC: Homebrew 安装 GCC 和 Binutils GCC: 共享库 GCC: 静态库]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>GCC C 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 处理数据]]></title>
    <url>%2F2017%2F08%2F07%2FiOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[简介博文: iOS 细说推送: 远程推送 和 iOS 细说推送: 本地推送分别介绍了 iOS 的两种典型推送, iOS 还有很多类型的推送, 如静默推送, VOIP 推送(iOS8)等, 后面会慢慢介绍给大家. 今天跟大家聊聊关于如何处理推送的数据(payload). 该系列博客: iOS APNs: 远程推送iOS APNs: 本地推送iOS APNs: 处理数据(本篇)iOS APNs: 静默推送iOS APNs: Background Fetch 推送的代理回调时机还记得 AppDelegate 里面关于推送的几个代理方法吧.~ 估计你也忘记了, 没关系, 我们再一起整理一下. 123456- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123; MZLOG(@&quot;markApp push. RemotePush userInfo: %@&quot;, userInfo); // 可以根据推送内容决定下一步的行为&#125; 该方法在接收到 RemotePush 的时候, 调用时机: 1.APP 在前台运行的, RemotePush 被推送过来了.2.APP 在后台运行, 无论是否被挂起只要没有被杀死, 点击推送内容. 以上两种情况均可以进入 didReceiveRemoteNotification 方法. 123456- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123; MZLOG(@&quot;App push. LocalPush notification: %@&quot;, notification); // 可以根据推送内容决定下一步的行为&#125; 该方法接收到 LocalPush 的时候, 调用时机: 1.APP 在前台运行的, LocalPush 被推送过来了.2.APP 在后台运行, 无论是否被挂起只要没有被杀死, 点击推送内容. 以上两种情况均可以进入 didReceiveLocalNotification 方法. 这两个回调方法, 分别接收 RemotePush 和 LocalPush 的推送消息. 有些人会问了, 假如这个时候我的应用在后台, 被系统杀死了或者被用户双击 Home 键杀死了, 此时远程推送过来了, 或者状态栏里面有本地推送的消息, 我点击推送消息, 这两个方法会被调用吗? 类似这种效果, 上面是 RemotePush, 下面是 LocalPush. 我肯定的告诉大家, 应用被杀死的情况下, 点击推送内容, didReceiveRemoteNotification 和 didReceiveLocalNotification 都不会被调用. 这个时候, AppDelegate 中的另一个方法上场了. 12- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 看一下 didFinishLaunchingWithOptions 的具体实现, 示例代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; /// 将应用图标的 badge 清零 &#123; [[UIApplication sharedApplication] setApplicationIconBadgeNumber:1]; [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0]; [[UIApplication sharedApplication] cancelAllLocalNotifications]; &#125; if (nil != launchOptions) &#123; /// 处理 LocalPush &#123; // 这里可以得到 UILocalNotification 对象 id localPushNotify = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey]; MZLOG(@&quot;AppDelegate localPush: %@&quot;, localPushNotify); if (nil != localPushNotify) &#123; if ([localPushNotify isKindOfClass:[UILocalNotification class]]) &#123; // 获取 userinfo 数据 NSDictionary *userInfo = [(UILocalNotification *)localPushNotify userInfo]; MZLOG(@&quot;AppDelegate localPush of UILocalNotification: %@&quot;, userInfo); // 根据 userInfo 的内容处理如页面跳转等 &#125; &#125; &#125; /// 处理 RemotePush &#123; NSDictionary *remotePushNotify = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; MZLOG(@&quot;AppDelegate remotePush: %@&quot;, remotePushNotify); if (nil != remotePushNotify) &#123; NSDictionary *remoteAps = [remotePushNotify objectForKey:@&quot;aps&quot;]; MZLOG(@&quot;AppDelegate remotePush. The aps&apos; info, alert: %@, badge: %@, sound: %@&quot;, [remoteAps objectForKey:@&quot;alert&quot;], [remoteAps objectForKey:@&quot;badge&quot;], [remoteAps objectForKey:@&quot;sound&quot;]); // 根据推送的内容处理如页面跳转等 &#125; &#125; &#125; MZLOG(@&quot;AppDelegate. launchOptions: %@&quot;, launchOptions); return YES;&#125; 对应的打印输出内容, 如下 本地推送的内容: 123 AppDelegate localPush of UILocalNotification: &#123; &quot;user_info_key&quot; = &quot;user_info_value_json_str&quot;;&#125; 远程推送的内容: 1234567aps = &#123; alert = &quot;Testing.. (2)&quot;; badge = 1; sound = default; &#125;; The aps&apos; info, alert: Testing.. (19), badge: 1, sound: default 自定义推送内容 对于推送的数据格式, 是苹果规定的格式, 我们可以在其基础上添加我们需要的数据. 在介绍下面内容之前, 先了解一下什么是 payload. payload 是推送通知的一部分，每一条推送通知都包含一个 Payload.它包含了系统提醒用户通知到达的方式，还可以添加自定义的数据, 即通知主要传递的数据为 payload. Payload 本身为 JSON 格式的字符串，它内部必须要包含一个键为 aps 的字典.也就是说 payload 是整个字符串. 关于 payload 的限制 在早期的推送中, payload 不能超过 256bytes, 中间还经历过推送的 payload 最大为 2KB.现在苹果支持最大为5KB(VOIP 推送), 官方文档有说, 如下: 1234For regular remote notifications, the maximum size is 4KB (4096 bytes)For Voice over Internet Protocol (VoIP) notifications, the maximum size is 5KB (5120 bytes)NOTEIf you are using the legacy APNs binary interface to send notifications instead of an HTTP/2 request, the maximum payload size is 2KB (2048 bytes) 上面是 官方文档 的原文, 大概意思是: 现在 APNs 支持 payload 为 4KB, 如果是 VoIP 推送的话, 支持 5KB. 但是, 如果你使用传统的 APNs 而不是使用 HTTP/2 的话, 最大支持 2KB. 也就是说, 推送的 payload 大小和 iOS 系统无关, 而是和协议有关. 可以使用下面代码, 查看 payload 长度 1payload.getBytes().length 我们正常的推送内容是这样的, 正常格式: 1&#123;&quot;aps&quot;:&#123;&quot;alert&quot;:&quot;Testing.. (21)&quot;,&quot;badge&quot;:1,&quot;sound&quot;:&quot;default&quot;&#125;&#125; 如果想对推送内容做自定义, 可以自己添加额外的数据, 如: 1&#123;&quot;aps&quot;:&#123;&quot;alert&quot;:&quot;Testing.. (21)&quot;,&quot;badge&quot;:1,&quot;sound&quot;:&quot;default&quot;&#125;, &quot;ext&quot;:&#123;&quot;key&quot;:&quot;value&quot;&#125;&#125; 其中, ext 就是额外添加的数据模型. 在 APP 收到这样的数据模型时, 可以对应不同的行为. 大家可以根据自己的业务需求, 自行定义数据格式. 自定义的数据格式, 注意内容的长度, 在不同的 iOS 系统上面, 对于推送的内容是有长度限制的. 再唠叨几句关于 iOS7 以后添加的方法 123- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler 这个方法也是在 AppDelegate 中实现的. 12- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo 这个方法在 iOS3 就已经有了, 可谓是历史悠久.我姑且称之为该方法为 FatherMethod, 上面那个新加入的称之为 SonMethod. 注意事项: [1]. 实现了 FatherMethod, 即使你实现了 SonMethod, SonMethod 也不会被调用.[2]. SonMethod 比 FatherMethod 多了一个参数 completionHandler, 这个在后面会说到.主要用于 Background Mode 中的 Background Fetch.[3]. 推送被调用的时机, 除了 FatherMethod 的时机外, 还多了一种时机, 就是在 APP 被杀死后, 点击推送内容打开 APP, 此时 APP 再次回到前台的时候, 该方法也会被调用(didFinishLaunchingWithOptions也会调用), 所以在处理远程推送内容的时候, 要注意这一点. 针对注意事项[3], 目前我能给出的有两种解决方案: 第一, 判断是否是第一次启动 APP, 如果是第一次启动 APP, 统一在didFinishLaunchingWithOptions 中处理, 不在 SonMethod 中处理. 第二, 远程推送统一在 SonMethod 中处理, didFinishLaunchingWithOptions 中只处理在 APP 被杀死的情况下, 用户点击推送本地的内容. 我个人采用的是第二中方案. 感谢在推送工具 NWPusher 和 Xcode 的 Window/Devices/Console 帮助下, 才得以完善博文. NWPusher 用来发送推送内容. Window/Devices/Console 用于查看输出日志. 必看文档Creating the Remote Notification Payload Payload Key Reference]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 本地推送]]></title>
    <url>%2F2017%2F08%2F06%2FiOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[概括iOS APNs: 远程推送 说过远程推送(RemotePush). 今天说说本地推送, 本地推送也就是平时所说的 LocalPush. 该系列博客: iOS APNs: 远程推送 iOS APNs: 本地推送(本篇) iOS APNs: 处理数据 iOS APNs: 静默推送 iOS APNs: Background Fetch 业务场景在具体实现之前, 先说一下业务场景. 假如你的 APP 具有 IM(即时通讯) 功能, 这个时候, 你可以根据连接来判断用户是否在线, 如果不在线, 可以使用远程推送将推送内容告知用户.如果在线, 可以通过 IM 把内容告诉 APP, APP 收到这个消息后, 可以使用本地推送告知给用户. 据说 APNs 每天要处理的推送在亿级别, 所以如果可以使用 LocalPush 完成的业务, 我建议大家还是不要使用远程推送, 况且苹果并不一定保证远程推送一定成功, 如果网络或者 APNs 压力大, 推送也会延时. 给苹果减少点压力吧, 哈哈! 再说一个业务场景, 你的 APP 在后台运行时间快到要被系统挂起的时候了, 你可以发送一个 LocalPush 来提示用户或者刺激用户, 再次将 APP 拉回前台运行. 这样可以保证 APP 可以正常运行了. 上面说的第二个业务场景, 是今天例子的基础, 你也可以根据自己的实际业务场景来使用 LocalPush 功能. LocalPush 简介LocalPush 允许 APP 向用户发送通知, 对于用户来说, 就跟远程推送是一样的, 基本没有感知, 开发者也不希望用户有感知. 推送效果图: 注意: 如果你的 APP 在前台, 发送 LocalPush 是不会要上述效果的.如果在前台, 可以使用自定义的弹框来提示用户. LocalPush 同样需要用户授权推送的权限, 否则也无法发送成功.这个跟远程推送是一样的. 另外, LocalPush 需要 APP 在后台没有被挂起的情况下, 才能发送, 否则无法启用. 发送 LocalPush 的一个好处是不需要用户连接网络, 这个是区别于远程推送的, 因为远程推送必须要求用户连接网络的.很多单机游戏或者弱联网的游戏, 发送的推送都是 LocalPush, 而非远程推送. 在阅读下面内容之前, 建议大家先看看 iOS 后台模式 这篇文章.本篇也是基于这个为基础的. 实现这个示例, 实现的场景如下: 用户打开 APP, 授权了推送的权限, 用户试玩一会之后, 将 APP 退到了后台, APP 监听退到后台之后, 延时一定时间发送 LocalPush 给用户. AppDelegate.m 中使用后台模式 关于 MZBackgroundTask 的实现, 附录给出. 1234- (void)applicationDidEnterBackground:(UIApplication *)application &#123; [[MZBackgroundTask sharedTask] startTask];&#125; ViewController.m 1234567891011121314151617181920212223242526272829303132333435- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil];&#125;- (void)onDidEnterBackground:(NSNotification *)notification &#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;); // 等待 6s 后, 这个时间可以根据具体情况去修改, 这里只是模拟 int delta = 6; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;); if (UIApplicationStateBackground == [UIApplication sharedApplication].applicationState) &#123; UILocalNotification *notification = [UILocalNotification new]; notification.alertBody = @&quot;走, 去high吧!&quot;; notification.soundName = UILocalNotificationDefaultSoundName; // 应用图标上面显示的数字 notification.applicationIconBadgeNumber = notification.applicationIconBadgeNumber + 1; // 可以自定义数据 notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;; [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125; else &#123; // 显示自定义弹框等 &#125; &#125;);&#125; 将 APP 点击 Home 键退到后台, 6s 后可以看到推送的效果. 点击推送的提示框, 再次打开了 APP, 会执行 AppDelegate 中的方法, 如下: 1234- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123; MZLOG(@&quot;App push. notification: %@&quot;, notification);&#125; 打印出来的 notification, 如下图所示: 其中, user_info 是我们自定义的数据部分. 附录 MZBackgroundTask 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#import &quot;MZBackgroundTask.h&quot;@implementation MZBackgroundTask+ (instancetype)sharedTask &#123; static MZBackgroundTask *_task; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _task = [[self alloc] init]; &#125;); return _task;&#125;- (void)startTask &#123; if (![self _checkSupportBackgroundTask]) &#123; MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;); return; &#125; UIApplication *application = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier taskId; /// 申请后台执行 /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟 &#123; taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123; MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining); [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;]; &#125; if (UIBackgroundTaskInvalid == taskId) &#123; MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;); return; &#125; /// 可以监控后台任务剩余的时间, 针对业务可以去处理 &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (true) &#123; // 剩余可以后台执行的时间 NSTimeInterval remainedTime = application.backgroundTimeRemaining; MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime); if (remainedTime &lt; 2) &#123; // 可以告诉其他业务, 后台任务即将结束了 break; &#125; // 睡眠(延时)1s [NSThread sleepForTimeInterval:1.f]; &#125; /// 这里可以做一些清除工作 &#123; // clean up &#125; [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;); &#125;&#125;#pragma mark - Private./** * 当前设备是否支持后台任务. * * @return YES, 支持后台任务. 否则, 不支持后台任务. */- (BOOL)_checkSupportBackgroundTask &#123; SEL sel = @selector(isMultitaskingSupported); BOOL supportBTask = [[UIDevice currentDevice] respondsToSelector:sel]; return supportBTask;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>APNs 远程推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNs: 远程推送]]></title>
    <url>%2F2017%2F08%2F06%2FiOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[概要本篇博文, 你首先需要知道的内容: 1.了解过 Push.2.阅读过 [iOS 后台模式] 这篇文章.3.申请过苹果证书或者知道如何申请和制作证书.4.iOS 开发基本知识. 你在这篇博文将会学到: 1.Push 的发展历程.2.开源推送工具 NWPusher 的使用.3.Push 的基本原理. 简介APNs, 苹果推送通知服务. 全称是: Apple Push Notification Service. 推送指的是由 APNs 服务器、ProviderService、iOS 系统、App 构成的通讯系统，也是移动互联网与传统的 Web 最明显不同的. 官方有比较详细的文档介绍, 可以戳这里 官方文档 查看. 苹果的文档写的确实好, 但是作为程序员, 最重要的还是要结合理论去实践. 本篇结合自己的实践和对推送的理解, 跟大家分享一下推送相关的知识. Push 发展历程iOS 历经很多版本, 一直在优化或者说是进化推送相关的内容, 无论是从实用性和技术上来看, 推送是至关重要的. 看一下 push 发展历程 iOS 3 - 引入推送通知 UIApplication 的 registerForRemoteNotificationTypes 与 UIApplicationDelegate 的 application(:didRegisterForRemoteNotificationsWithDeviceToken:)，application(:didReceiveRemoteNotification:) iOS 4 - 引入本地通知 scheduleLocalNotification，presentLocalNotificationNow:， application(_:didReceive:) iOS 5 - 加入通知中心页面 iOS 6 - 通知中心页面与 iCloud 同步 iOS 7 - 后台静默推送 application(_:didReceiveRemoteNotification:fetchCompletionHandle:) iOS 8 - 重新设计 notification 权限请求，Actionable 通知 registerUserNotificationSettings(:)，UIUserNotificationAction 与 UIUserNotificationCategory，application(:handleActionWithIdentifier:forRemoteNotification:completionHandler:) 等 iOS 9 - Text Input action，基于 HTTP/2 的推送请求 UIUserNotificationActionBehavior，全新的 Provider API 等 iOS 10- 支持Images, GIFs, Audio and Video类型, 并且有 Notification Service Extension 与 Notification Content Extension，可以实现推送数据在展示前进行下载更新、定制通知 UI, 并且统一了通知类型，具有时间间隔通知、地理位置通知和日历通知. 该系列博客共分为几个部分: iOS APNs: 远程推送(本篇) iOS APNs: 本地推送 iOS APNs: 处理数据 iOS APNs: 静默推送 iOS APNs: Background Fetch 如果需要完整源码的, 可以通过邮件联系我(veritman@126.com), 后续完成后会上传到 github. 原理先看官方的流程图, 如下所示: 该流程图, 主要说明的是自己 业务服务器(Provider) 推送消息到用户(Client APP) 的流程. 注意: 这里说的以及本文后面说的 业务服务器, 统一指的是可以向 APNs 发送推送消息的服务器. 下面这张图是比较完整的一张流程图, 自己画的, 凑合看吧! 大概流程, 我详细说一下. 1.iOS 设备启动后连接网络, 会与苹果服务器建立一个安全的长连接.这个是系统维护的, 这也是推送的关键.2.用户打开 app, 授权了推送通知的权限.3.授权成功后, APNs 会将 deviceToken 返回给 iOS 终端.4.终端将该 deviceToken 返回给指定的 APP.5.APP 拿到 deviceToken 上传给我们自己的业务服务器.6.业务服务器向 APNs 发送推送请求, 带上 deviceToken.7.APNs 推送内容到指定的 iOS 终端.8.iOS 终端将内容推送给用户. 关于 deviceToken 后面会讲. 关于 deviceToken这里简单介绍一下 deviceToken. deviceToken 是 NSData 类型的数据, 是苹果服务器根据 设备,证书等信息和一定算法生成的.需要将这个 deviceToken 传送给我们的服务器端, 这样一个用户对象就绑定了一个 deviceToken.当需要给用户推送消息, 通过自己的业务服务器, 找用户对应的 deviceToken 和要发送的推送内容, 发送到苹果的 APNs, 然后 APNs 将消息推送到该 deviceToken 对应的手机上. 关于 deviceToken 是否可变的问题 网上有些人说, deviceToken 是可变的, 有些人说, deviceToken 是不可变的, 我也不知道他们到底有没有实践过, 今天我要告诉大家的是, deviceToken 是可变的. 如卸载重装 app, deviceToken 会变. 我的设备 iphone6, iOS10.3. 下面是我实验的数据: 1234第一次安装运行得到的 deviceToken&lt;4e0f2928 5be0700c=&quot;&quot; 296bf7f1=&quot;&quot; 3b0837e4=&quot;&quot; bc9da6d1=&quot;&quot; 9fdb672e=&quot;&quot; f87446be=&quot;&quot; 1c098431=&quot;&quot;&gt;卸载后, 第一次安装运行得到的 deviceToken 这说明, deviceToken 是可变的. 代码实现上面基本都是一些理论知识, 下面结合代码, 具体实现. 工程配置在写代码之前, 需要配置一下工程.关于如何创建带有 push 功能的苹果证书的操作, 大家自行去网上学习, 这里不赘述. 不过这里要提醒一点, 创建的证书一定要和自己项目的 appid 保持一致, 否则无法推送. 这个 Demo 工程的名字是 MZPush. 安装好证书, 打开工程, 并能让工程识别到. 切换到 Target, 点击 Capabilities 选项. 步骤1: 配置 Push, 打开开关即可. 配置后台模式, 打开开关, 选中Remote notifications. 不过这一步, 不是必须的, 如果你不配置, 工程会有警告.我建议是选上, 在后面的博文中, 再仔细说说这个东西的好处. 警告信息如下: 12You&apos;ve implemented -[&lt;UIApplicationDelegate&gt; application:didReceiveRemoteNotification:fetchCompletionHandler:], but you still need to add &quot;remote-notification&quot; to the list of your supported UIBackgroundModes in your Info.plist. 步骤2: 配置完这一步后,在 Info.plist 中可以看到多了一项内容: 步骤3: 配置工程最小兼容版本 因为我要兼容 iOS7, 所以在 Xcode8 中, 自己手动改为了 7.0. 步骤4: 关闭 Bitcode(可选操作) 步骤5: 配置支持 HTTP(可选操作) 在 Info.plist 中, 添加如下: 用户授权询问用户授权的实现 该实现兼容了 iOS7. 1234567891011121314+ (void)applyPushPermission &#123; UIApplication *application = [UIApplication sharedApplication]; if (MZSysVersion &lt;= 7.0) &#123; UIRemoteNotificationType nType = UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound; [application registerForRemoteNotificationTypes:nType]; &#125; else &#123; UIUserNotificationType nType = UIUserNotificationTypeBadge|UIUserNotificationTypeSound|UIUserNotificationTypeAlert; UIUserNotificationSettings *nSettings = [UIUserNotificationSettings settingsForTypes:nType categories:nil]; [application registerUserNotificationSettings:nSettings]; &#125;&#125; 关于用户授权, 分几种情况来看待. 情景一. 用户不允许 APP 推送, 即不授权. Appdelegate 代理调用 123456- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123; MZLOG(@&quot;App push. notificationSettings: %@&quot;, notificationSettings); [application registerForRemoteNotifications];&#125; 1- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error error 信息大概如下: 12Error Domain=NSCocoaErrorDomain Code=3000 &quot;未找到应用程序的“aps-environment”的授权字符串&quot;UserInfo=&#123;NSLocalizedDescription=未找到应用程序的“aps-environment”的授权字符串&#125; 情景二. 用户允许授权了, 又分为两种情况 1.使用具有 push 功能的证书 一定要有带有 push 功能的证书. 代理调用 123456- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123; MZLOG(@&quot;App push. notificationSettings: %@&quot;, notificationSettings); [application registerForRemoteNotifications];&#125; 这个方法大概在上面回调 1s 后才会调用. 12345678910111213- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123; MZLOG(@&quot;App push. deviceToken: %@&quot;, deviceToken); // 格式化该数据 NSString *deviceTokenStr = [NSString stringWithFormat:@&quot;%@&quot;, deviceToken]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; MZLOG(@&quot;App push. deviceToken string: %@&quot;, deviceTokenStr); // 可以上传该 token 到自己的业务服务器&#125; 在 didRegisterForRemoteNotificationsWithDeviceToken 方法中可以得到 deviceToken 信息: 注意: 代码中将 NSData 的 deviceToken 转换为了 NSString 类型的数据类型. 2.使用一般的证书, 没有 push 功能的证书 这种情况和 情景一 一样. 推送万事俱备, 只欠东风了. 今天没有准备搭建一个自己的业务服务器去推送, 可以使用推送工具来替代. 安装 NWPusher 这个工具, 可以进行推送测试. 安装成功后, 打开这个 Mac APP, 填写相关信息. 点击 push 即可推送. 在 Appdelegate 中的代理回调中, 可以打印推送内容. 1234- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123; MZLOG(@&quot;App push. userInfo: %@&quot;, userInfo);&#125; 推送的内容, 如下图所示. 1234567&#123; aps = &#123; alert = &quot;Testing.. (6)&quot;; badge = 1; sound = default; &#125;;&#125; 推荐1.活久见的重构 - iOS 10 UserNotifications 框架解析 2.国内 90%以上的 iOS 开发者，对 APNs 的认识都是错的]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>推送 APNs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 后台模式]]></title>
    <url>%2F2017%2F07%2F30%2FiOS-%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[应用状态来自苹果开发者文档 The App Life Cycle 的图. 下面这张图说明了应用程序的状态, 如下所示: 具体的说一下这5中状态: 1.Not running 未运行, 程序没启动或者被系统被用户杀死 2.Inactive 未激活, 程序在前台运行，不过没有接收到事件.在没有事件处理情况下程序通常停留在这个状态. 3.Active 激活, 程序在前台运行而且接收到了事件.这也是前台的一个正常的模式 4.Backgroud 后台, 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会.时间到之后会进入挂起状态(Suspended). 有的程序经过特殊的请求后可以长期处于 Backgroud 状态. 5.Suspended 挂起, 程序在后台不能执行代码.系统会自动把程序变成这个状态而且不会发出通知.当挂起时, 程序还是停留在内存中的, 当系统内存低时, 系统就把挂起的程序清除掉, 为前台程序提供更多的内存. 关于 Backgroud 状态, 是我们今天要说的重点部分. 多任务介绍iOS 的多任务是在 iOS4 的时候被引入的，在此之前 iOS 的 APP 都是按下 Home 键就被干掉了.iOS4 虽然引入了后台和多任务，但是实际上是伪多任务，一般的 APP 后台并不能执行自己的代码，只有少数几类服务在通过注册后可以真正在后台运行，并且在提交到 AppStore 的时候也会被严格审核是否有越权行为，这种限制主要是出于对于设备的续航和安全两方面进行的考虑.之后经过iOS5 和 iOS6 的逐渐发展，后台能运行的服务的种类虽然出现了增加，但是 iOS 后台的本质并没有变化.在iOS7之前，系统所接受的应用多任务可以大致分为几种： 后台完成某些花费时间的特定任务. 后台播放音乐等. 位置服务. IP电话(VOIP). Newsstand. iOS7 后台任务申请的最长时间 10分钟.iOS8+ 后台任务申请最长时间 3分钟. 示例: APP 退到后台会被挂起今天跟大家分享的是一般应用如何在后台延长生命周期的知识, 关于其他特殊的 App 如上面提到的5中情况, 不是今天讨论的重点. 我们先看一个例子, 例子很简单. 这里要说明一下概念, 直接锁屏和点击 Home 键, 都会导致应用处于后台模式, 这里为了说明问题, 统一点击 Home 作为代名词. 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil];&#125;- (void)onDidEnterBackground:(NSNotification *)notification &#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;); int delta = 1; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;); UILocalNotification *notification = [UILocalNotification new]; notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3]; notification.alertBody = @&quot;走, 去high吧!&quot;; notification.soundName = UILocalNotificationDefaultSoundName; // 可以自定义数据 notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;; [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125;);&#125; UIApplicationDidEnterBackgroundNotification 可以监听到用户将 APP 退到后台. 当 APP 退到后台, 会调用 onDidEnterBackground 这个方法. 在 onDidEnterBackground 这个方法中, 我故意延时执行代码, 这里使用的是 dispatch_after. 编译运行这个工程, 运行成功后, 可以点击 Home 键将应用退到后台. 可以在 Xcode 的控制台看到 App Background. Enter onDidEnterBackground. 的打印信息, 但是迟迟不见 dispatch_after 里面的代码执行. 这里说明, APP 退到后台后被系统挂起了. 另外一个例子就是使用 NSTimer, 在 APP 退到后台后, 也会被终止. 完整例子, 一会在文章后台附录给出. 通过后台模式延长 APP 运行上面的例子充分说明了, 在我们没有做任何处理的情况下, iOS 系统在 APP 退到后台的情况下, 会被系统挂起, 从而终止 APP 的代码行为. 下面通过实例, 来开启后台任务, 让 APP 尽可能的延长声明周期. 在工程的基础上, 新建一个文件 MZBackgroundTask 1234@interface MZBackgroundTask : NSObject+ (instancetype)sharedTask;- (void)startTask;@end 具体实现, 只给出关键代码. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677- (void)startTask &#123; if (![self _checkSupportBackgroundTask]) &#123; MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;); return; &#125; UIApplication *application = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier taskId; /// 申请后台执行 /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟 &#123; taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123; MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining); [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;]; &#125; if (UIBackgroundTaskInvalid == taskId) &#123; MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;); return; &#125; /// 可以监控后台任务剩余的时间, 针对业务可以去处理 &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __block NSTimeInterval remainedTime; while (true) &#123; // 剩余可以后台执行的时间 dispatch_async(dispatch_get_main_queue(), ^&#123; // application.backgroundTimeRemaining 必须在主线程获取 remainedTime = application.backgroundTimeRemaining; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime); if (remainedTime &lt; 10) &#123; // 可以告诉其他业务, 后台申请的时间即将结束了 &#125; if (remainedTime &lt; 2) &#123; /// 这里可以做一些清除工作 &#123; // clean up &#125; [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; return; &#125; // 睡眠(延时)1s [NSThread sleepForTimeInterval:1.f]; &#125;); &#125;); &#125; &#125;); &#125;&#125; startTask 开启后台任务. 在 AppDelegate 中, 调用这个方法. 1234- (void)applicationDidEnterBackground:(UIApplication *)application &#123; [[MZBackgroundTask sharedTask] startTask];&#125; 再次运行工程, 可以根据日志看出, 之前的 dispatch_after 和 timer 可以运行了, 并且可以运行3分钟(180s). 根据 backgroundTimeRemaining 这个属性, 可以看出具体的后台可执行的剩余时间. 注意: 我测试的时候使用的是 iOS10 设备. 后记除了苹果规定的几种类型(如定位, 录音, VOIP 等)的应用外, 其他 APP 想申请更多的后台驻留时间, 就需要一些 旁门左道 的方法了. 苹果对后台操作做了这么多限制, 也是从用户的角度出发, 如安全, 省电, 省流量等. 比如, 在后台播放没有声音的音乐. 再比如, 申请定位服务的权限, 这样也可以保持 APP 在后台不被挂起.但是, 依照苹果一贯的审核做法来看，如果声明了需要某项后台权限，你却没有相关实现的话，会直接被拒掉的. 这些是技术上的实现, 我没有推荐大家这么干, 现在苹果审核比以前还要严格, 大家还是悠着点干吧.如果你的 APP 不需要上架到 AppStore 的话, 就尽情的放纵吧… 推荐博文1.iOS实现无限后台background的方法 2.WWDC 2013 Session笔记 - iOS7中的多任务 iOS 在后台的时候如果不使用后台模式, socket 也会被系统关闭连接, 比如我们使用的 IM 功能.使用后台模式后, 向系统申请的时间(3分钟内), socket 还是没有被关闭的, 除非断网或者被路由器给断开了, 在申请的这段时间内, socekt 还是可以使用的, 如果想持续的保持 socket 连接, 就需要去了解一下 VOIP Socket 相关的知识了, 实践过后, 分享给大家. 附录下面是具体的实现代码. ViewController.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@interface ViewController ()@property (nonatomic, strong) NSTimer *timer;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil]; // 每隔一秒执行一次 _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(onTimerDidRun:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;#pragma mark - Callback.- (void)onTimerDidRun:(id)sender &#123; MZLOG(@&quot;App Background. Timer Running.&quot;);&#125;- (void)onDidEnterBackground:(NSNotification *)notification &#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;); int delta = 1; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;); UILocalNotification *notification = [UILocalNotification new]; notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3]; notification.alertBody = @&quot;走, 去high吧!&quot;; notification.soundName = UILocalNotificationDefaultSoundName; // 可以自定义数据 notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;; [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125;);&#125;#pragma mark - SetupViews.- (void)_setupViews &#123; self.view.backgroundColor = [UIColor purpleColor]; &#125; MZBackgroundTask.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#import &quot;MZBackgroundTask.h&quot;@implementation MZBackgroundTask+ (instancetype)sharedTask &#123; static MZBackgroundTask *_task; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _task = [[self alloc] init]; &#125;); return _task;&#125;- (void)startTask &#123; if (![self _checkSupportBackgroundTask]) &#123; MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;); return; &#125; UIApplication *application = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier taskId; /// 申请后台执行 /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟 &#123; taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123; MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining); [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; &#125;]; &#125; if (UIBackgroundTaskInvalid == taskId) &#123; MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;); return; &#125; /// 可以监控后台任务剩余的时间, 针对业务可以去处理 &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __block NSTimeInterval remainedTime; while (true) &#123; // 剩余可以后台执行的时间 dispatch_async(dispatch_get_main_queue(), ^&#123; // application.backgroundTimeRemaining 必须在主线程获取 remainedTime = application.backgroundTimeRemaining; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime); if (remainedTime &lt; 10) &#123; // 可以告诉其他业务, 后台申请的时间即将结束了 &#125; if (remainedTime &lt; 2) &#123; /// 这里可以做一些清除工作 &#123; // clean up &#125; [application endBackgroundTask:taskId]; taskId = UIBackgroundTaskInvalid; return; &#125; // 睡眠(延时)1s [NSThread sleepForTimeInterval:1.f]; &#125;); &#125;); &#125; &#125;); &#125;&#125;#pragma mark - Private./** * 当前设备是否支持后台任务. * * @return YES, 支持后台任务. 否则, 不支持后台任务. */- (BOOL)_checkSupportBackgroundTask &#123; SEL sel = @selector(isMultitaskingSupported); BOOL supportBTask = [[UIDevice currentDevice] respondsToSelector:sel]; return supportBTask;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>后台模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Charles]]></title>
    <url>%2F2017%2F07%2F23%2F%E4%BD%BF%E7%94%A8-Charles%2F</url>
    <content type="text"><![CDATA[概要Charles 是 Mac 上面比较好用的抓包工具. 在使用微信登录 SDK 的时候, 我想看看微信请求的内容, 以及其授权过程, 发现只要连接 Charles, 跳转到微信之后无法打开微信的授权登录页面, 提示网络不可用. 经过研究, 是需要使用 Charles 配置 HTTPS, 配置完成后, 就可以随心所欲了. 所以, 今天跟大家分享一下 Charles 使用的两个点: Charles 的 HTTPS 配置. 使用 Charles 模拟(慢)网络. 工具和系统 iPhone: iOS 10.3. Mac OS: 10.12.5. Charles: 4.0.2. 抓取 HTTPS 请求1.Mac 安装证书 打开 Charles, 在 Help 选项中选择 SSL Proxying, 如下图所示: 2.Mac 信任证书 打开 Keychain Access (钥匙串), 找到刚才安装的证书, 信任证书, 如图: 3.给 iPhone 安装证书 打开 Charles, 在 Help 选项中选择 SSL Proxying, 操作如图: 在弹出的对话框中, 可以看到 chls.pro/ssl 手机设置代理, 连接 Charles 一定要记住: 手机一定要设置代理, 否则安装证书会失败. 打开手机的 Safari 浏览器, 输入 chls.pro/ssl 这个地址. 设置信任证书, 如下图: 模拟任意网络Charles 给我们提供了可以模拟任何网速的网络环境的条件. 打开 Throttle Settings, 然后 Enable Throttling 可以看到很多类型的网络供你选择. Add Preset 可以自己自定义一个网络环境. 这个功能非常实用, 可以让我们模拟慢网络环境, 更好地调试自己的程序. 遇到麻烦1.抓取 HTTPS 的请求出现错误 错误日志如下: 123SSLHandshake: Received fatal alert: unknown_caCharles Proxy will even offer a helpful suggestion:You may need to configure your browser or application to trust the Charles Root Certificate. See SSL Proxying in the Help menu. 这种错误一般是出现在 iOS10 上面. 请在关于本机里面再设置一次 证书信任设置, 即可. 2.系统升级后, 设置的 HTTPS 抓包失效 按照上述方法, 重新设置一次即可.]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Charles MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2d-js: 在 iOS 上运行]]></title>
    <url>%2F2017%2F07%2F23%2FCocos2d-js-%E5%9C%A8-iOS-%E4%B8%8A%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在我的博文 Cocos2d-js: 首次在 Mac 上面运行 这篇文章中, 介绍了 Cocos2d 相关的知识, 并且使用Cocos2dx 创建了一个 JS 的简单游戏项目. 今天跟大家分享一下, 如何在 ios 设备上面运行一个 JS 游戏项目. 该游戏项目(贪吃蛇)来自网络资源, 只供演示使用, 不提供任何关于游戏的资源. 当初的想当然在 Mac 上面 so easy 的编译并运行了 JS 游戏, 我想在 iOS 设备上应该也很简单的就可以运行起来, 但是我发现我简单不加思考的想法, 是行不通的. 博文 Cocos2d-js: 首次在 Mac 上面运行 在 FireFox 浏览器上面可以直接运行 index.html, 但是在 Chrome 浏览器上面就没那么顺利. 想到这里, 我就受到了启发, 莫非 iOS 设备上面需要自己搭建一套 Web Server? 搭建 Web Server既然想到了这一步, 接下来就是找方案实施了. CocoaHTTPServer 这个可以满足我的需求, 于是, 我就直接拿来使用了. 项目中, 我使用了 Cocoapods 来管理第三方库.在 podfile 中直接添加下面的代码: 1pod &apos;CocoaHTTPServer&apos;, &apos;~&gt; 2.3&apos; 然后 pod install 即可. 1.在 ViewController 中导入头文件 1234567891011#import &lt;HTTPServer.h&gt;ViewController 声明部分@interface ViewController () &lt;WKNavigationDelegate&gt;@property (nonatomic, strong) WKWebView *webView;@property (nonatomic, strong) HTTPServer *localHttpServer;@property (nonatomic, strong) WKWebViewConfiguration *wbConfig;//用于调试的 UILabel@property (nonatomic, strong) IBOutlet UILabel *loadingLb;@property (nonatomic, assign) BOOL startServerSuccess;@end 2.配置 Web Server 核心实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940 - (void)_configLocalHttpServer&#123; NSString *webPath = [[NSBundle mainBundle] pathForResource:@&quot;crazySnake&quot; ofType:nil]; _localHttpServer = [[HTTPServer alloc] init]; [_localHttpServer setType:@&quot;_http.tcp&quot;]; NSFileManager *fileManager = [[NSFileManager alloc] init]; NSLog(@&quot;%@&quot;, webPath); if (![fileManager fileExistsAtPath:webPath]) &#123; NSLog(@&quot;File path error!&quot;); &#125; else &#123; NSString *webLocalPath = webPath; [_localHttpServer setDocumentRoot:webLocalPath]; NSLog(@&quot;webLocalPath:%@&quot;, webLocalPath); [self _startWebServer]; &#125;&#125;- (void)_startWebServer&#123; self.loadingLb.hidden = NO; NSError *error; if ([_localHttpServer start:&amp;error]) &#123; NSLog(@&quot;Started HTTP Server on port %hu&quot;, [_localHttpServer listeningPort]); self.port = [NSString stringWithFormat:@&quot;%d&quot;, [_localHttpServer listeningPort]]; self.loadingLb.text = @&quot;Start Server Successfully.&quot;; _startServerSuccess = YES; &#125; else &#123; NSLog(@&quot;Error starting HTTP Server: %@&quot;, error); self.loadingLb.text = @&quot;Start Server failed.&quot;; _startServerSuccess = NO; &#125;&#125; _configLocalHttpServer 是配置 HTTPServer 的方法, _startWebServer 是开启 Web Server 的方法. 这样调用 _configLocalHttpServer 就可以开启在设备上面开启一个 Web Server 了. Xcode 导入 JS 游戏项目首先看一下我的工程和资源目录结构, 如图: 仔细看一下, crazySnake 这个文件夹是蓝色的, 不是黄色的. 这里特别注意, 导入这个 crazySnake 文件夹的时候, Options 一定要选择 Create folder reference. 为什么要这么做? 细心的朋友可以发现, 使用 Create folder reference导入的文件夹, 在项目打包生成的 archive 的文件中(自己可以解压看)是可以看到 crazySnake 这个文件夹的, 如果不是这种方式, 而是使用 Create groups 方式(在 Xcode 中显示黄色), 在 archive 中是看不到 crazySnake 这个文件夹的, 而是将里面的文件打散放在 archive 的根目录下面了. 总之, 一句话, Create folder reference 方式导入的文件夹在打包后还是原来的文件夹, 不会将文件夹里面的文件打散. 试想一下, 如果多加入几个这样的目录, 都打散在根目录下面, 我们就不好管理这个文件夹里面的文件了. 配置 WKWebView 这里我使用了 WKWebView 而不是 UIWebView 作为加载 HTML 的容器.当然, 你也可以使用 UIWebView. 主要的核心代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (void)viewDidLoad&#123; [super viewDidLoad]; self.navigationController.navigationBarHidden = YES; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.loadingLb.text = @&quot;Config server...&quot;; [self _configLocalHttpServer]; &#125;); /// 增加的调式方法: 可以重新启动 web server. &#123; SEL sel = @selector(_configLocalHttpServer); UITapGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:sel]; [self.loadingLb addGestureRecognizer:gesture]; self.loadingLb.userInteractionEnabled = YES; &#125;&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; // 配置 WKWebView dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; _wbConfig = [[WKWebViewConfiguration alloc] init]; self.wbConfig.userContentController = [[WKUserContentController alloc] init]; _webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:self.wbConfig]; _webView.frame = self.view.bounds; _webView.scrollView.showsHorizontalScrollIndicator = NO; _webView.scrollView.showsVerticalScrollIndicator = NO; [self.view addSubview:self.webView]; self.webView.frame = self.view.bounds; self.webView.navigationDelegate = self; if (self.startServerSuccess) &#123; self.loadingLb.hidden = YES; NSString *gameUrl = [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot; inDirectory:@&quot;crazySnake&quot;]; NSURL *url = [NSURL fileURLWithPath:gameUrl]; url = [NSURL URLWithString:[NSString stringWithFormat:@&quot;http://127.0.0.1:%@/index.html&quot;, self.port]]; [self.webView loadRequest:[NSURLRequest requestWithURL:url]]; &#125; &#125;);&#125; 代码很简单, 就是使用 WKWebView 加载一个 HTML 文件并启动 Web Server. 运行项目接下来, 就是见证奇迹的时刻了… 上面配置了 Web Server 和 加载 html 的 WKWebView, 现在可以直接运行项目看效果了. 无论你是在模拟器还是在真机上面都可以运行这个 JS 游戏项目了. 写在最后上面的例子本人亲自实践过的, 给大家提供了一个实现思路, 算是抛砖引玉. 如果想做好这个模式, 还需要很多工作要做, 这里列出来给大家分享一下. 1.游戏资源包管理和下载.2.游戏中需要和 Native 的交互逻辑.3.数据加密.4.移动端游戏本身的加载优化. 如果你有更好的方案和想法, 我很乐意邮件 (veryitman@126.com) 与你沟通, 非常感谢! 代码示例我放在了 GitHub, 点击 MZMWPlay 前往下载体验.]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>cocos Cocos2d-js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: Chrome 调试 WEB 页面]]></title>
    <url>%2F2017%2F06%2F01%2FAndroid-Chrome-%E8%B0%83%E8%AF%95-WEB-%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[引言在 Mac OS 上面通过 Safari 调试 iOS 设备或者模拟器的 WEB 页面, 比较方便. 关于具体如何使用 Safari 来调试 iOS 设备, 可以参考 [Safari 的开发者模式] 这篇文章. 自从踏上开发的道路, 电脑上就安装了 Chrome 浏览器, 并且一直保持着更新, Chrome 以其简单设计和高效的用法吸引了大批开发者. 使用 Chrome 调试 Android 设备的 WEB 页面, 易如反掌. Chrome 调试条件使用这项技能的条件如下: 1.Android 设备系统最低为4.4, 也就是 android-19 2.Chrome 最好使用最新版本的, 以前的版本不支持, 最低兼容版本目前尚不清楚. 3.配置 Android WebView, 使其支持 Debug 和使能 JavaScript 功能. 4.设备和 PC 通过 USB 连接正常, 且支持 USB 调试的. 我目前使用的设备和 Chrome 版本信息如下: Android 设备: 5.1.1版本Chrome: Version 58.0.3029.110 (64-bit) 我们在地址栏中输入: 1chrome://inspect 就可以打开设备列表界面. 可以看到我的 Android 设备已经显示出来了. 下面举个例子说明该调试工具的使用. 简单的 Android 工程示例该工程只有一个 Activity, 使用 WebView 加载本地 HTML 文件. 1. 创建 assets 目录工程切换到 Project Files 视图 这样就可以在 src/main 目录下新建了 assets 文件夹了. 2. 创建 HTML 文件 该 HTML 文件, 命名为 local.html, 放在 assets 目录下面. local.html 源文件: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;p&gt;A function is triggered when the button is clicked.&lt;/p&gt;&lt;script&gt; function myFunction() &#123; console.log(&apos;js console.&apos;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.在 Activity 中配置 WebView.Activity.java 源文件 12345678910111213141516171819202122232425262728public class MZWebPage extends AppCompatActivity &#123; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_mzweb_page); webView = (WebView) this.findViewById(R.id.ui_web_view); // 设置 WebView 的 Debug 为可用状态 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; WebSettings settings = webView.getSettings(); // 设置 JavaScript 可以使用, 否则在 HTML 中无法调用 JavaScript 代码 settings.setJavaScriptEnabled(true); // 本地文件 String url = &quot;file:///android_asset/local.html&quot;; webView.loadUrl(url); webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; return super.shouldOverrideUrlLoading(view, request); &#125; &#125;); // 设置渲染视图 webView.setWebChromeClient(new WebChromeClient()); &#125;&#125; 对应的 xml 布局文件: 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;demo.droidsdk.near.idreamsky.com.nearsdk.MZWebPage&quot;&gt; &lt;WebView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/ui_web_view&quot;&gt; &lt;/WebView&gt;&lt;/LinearLayout&gt; 4. 运行程序在 Chrome 中输入 chrome://inspect 打开, 可以看到正在运行的 local.html. 点击 inspect, 进入调试界面. 在调试界面, 点击页面的 Click me, 按钮, 对应的会有 log 输出. 5.调试出错的 HTML修改一下 local.html 文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;p&gt;A function is triggered when the button is clicked.&lt;/p&gt;&lt;script&gt; function myFunction() &#123; console.log(&apos;js console.&apos; + var_error); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里可以看出 var_error 是一个不存在的变量. 重新运行, 点击 Click me, 可以看到右侧的 error: 关于 Chrome 开发者工具的更多使用, 可以参考官方文档 Chrome 开发者工具.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Chrome Web Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持你的好习惯]]></title>
    <url>%2F2017%2F05%2F29%2F%E4%BF%9D%E6%8C%81%E4%BD%A0%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[明天就是传统的端午节了, 提前祝大家端午安康! 今天老婆让我帮忙把粽叶子洗洗, 说要包粽子, 我听话地把刚买来的粽叶子洗了个干净, 那都是带有绿色的叶子, 生机勃勃, 让我从指尖中感到无比的温馨和无尽的希望. 小的时候, 我很享受妈妈为我们包粽子的过程, 说实话, 我不是很喜欢吃粽子, 但是特别喜欢粽子锅里面的煮鸡蛋, 特别美味. 老家的粽子没有什么特色, 就是简简单单的糯米被包在叶子中, 然后放在锅里慢慢的煮, 熟了之后, 蘸点白糖就可以吃了. 到了南方之后, 我才发现世界上原来有各种各样的粽子, 红枣的, 绿豆的, 猪肉馅的, 鸡肉馅的…等等! 这些都是偶发的回忆, 和今天的推文没有关系, 不信, 你接着往下看. 养成阅读的习惯我不是一个聪明的孩子, 直到小学三年级, 我才真正的开始明白学习到底是怎么一回事, 用老家人的话说算是开窍了. 后来我很顺利的上了初中, 家里的大部分收入要靠庄家, 一年四季能够风调雨顺的话, 也能过个不错的年, 至少能把学费给交上. 初中二年级的时候, 我辍学了, 也许是命运的安排吧, 当时自己也没有多想, 毅然决定下学去寻找另一种人生. 于是, 我选择了理发这个行业. 和师傅在风风雨雨中度过了一年多的时间, 在当时的农村, 不上学有门手艺也算是对自己和父母有个交代. 我的内心仍然渴望去上学, 虽然不知道为什么要去上学也不知道上学后能干什么, 但是心里面总是觉得自己不能放弃学业.在理发的一年多时间里, 我没有放弃过学习.冥冥之中自有安排, 妈妈有次问我: “还想去上学不?”, 我想都没想就情不自禁的点头了, 妈妈又说:”我就知道你没有放弃, 去继续上学吧, 不要留下遗憾!”.当时的我甭提有多高兴了. 再次回到校园的我比以前更加努力和拼命了, 更加懂得如何珍惜这来之不易的学习机会了. 直到大学毕业, 参加工作以及有了孩子后, 我也能保持自我学习和自我激励的状态, 保持好的阅读习惯, 让我受益终身. 有次孩子早晨起床忙完后, 就开始坐在那里看书, 有好几次晚上, 我也发现他洗完澡后, 坐在那里看书, 或者是做手工, 或是画画. 我感到很好奇, 决定找个机会问问他. 有一个周末的上午, 早餐过后, 我就把他拉到身边, 和他一起看儿童读物, 问他:”宝贝, 你为什么喜欢看书呢?”, 他说:”爸爸, 是你影响了我, 你喜欢看书, 我也喜欢看书.”, 看着他一副天真的样子, 我真的不敢相信几岁的孩子能说出这样的话, 但我内心感到无比的欣慰.原来好的习惯会传染给自己身边的人, 并且能让你感到自豪. 坚持写博客写博客或者是生活日记, 确实很”浪费”时间, 甚至会占用你任何休息的时间, 写博客偶尔也会让你抓耳挠腮, 感叹:”书到用时方恨少”! 所以, 读, 写不能分家, 更应该是将二者紧密的联合在一起.多阅读多写, 才会让你更加的通透, 当然了, 我只是喜欢写, 写的质量也很一般, 只是为了满足内心的那一点点对知识的渴望. 写的多了, 你就更加愿意去思考了, 思考多了, 很多事情你就看开了, 对你的生活和工作都有好处. 从09年到现在我一直坚持写博客, 刚开始也是无从下笔, 不知道自己到底该写一写什么东西, 写了之后, 是不是别人看了会嘲笑我, 诸如此类的担心太多太多, 后来我也想明白了, 你写的再好也有人比你写得好, 也会有人说你写的不好.那我何必去计较这么些个事儿了, 只管动手写吧! 然后, 就在博客网站上面耕耘, 技术的, 吐槽的, 生活的我都喜欢写, 不管你喜不喜欢看, 它都在那里, 哈哈! 我把博客当做自己的朋友, 心情好亦或是不好的时候, 我都会向他倾诉, 希望自己写下的东西或多或少能帮助一些人, 这也许是我坚持写博客的最大动力了. 如果你也喜欢写博客或者是准备写博客, 就开始动手写吧, 不要再犹豫了. 最后这个世界上, 没多少人喜欢听别人啰嗦, 即使听了你的啰嗦, 也不一定会付出实践, 即使你是长者或者是智者, 况且我只是一介平民. 但是我还是要啰嗦一句:”保持持续学习的习惯, 会消耗你的勤奋, 但会让你受益终生”, 信不信由你!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考 生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Safari 的开发者模式]]></title>
    <url>%2F2017%2F05%2F15%2FSafari-%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设置 Safari1.打开 Safari 的 Preference 2.切换到 Advanced 选项 将 Show Develop menu in menu bar 选中. 可以看到 Safari 多了 Develop 选项 设置设备或者模拟器在 iphone或者模拟器 中设置 Safari打开 Safari 的高级选项 打开 Web 检查器 上面设置完毕后, 运行你的程序, 在 Safari 的 Develop 中可以看到对应设备, 从而可以调试 HTML 页面了. 在调试窗口中，可以看到当前正在加载网页的各种信息，如源码、请求头、图片、加载的资源与脚本、控制台输出等. 也可以直接修改网页的 CSS 样式和布局等进行修改，而不用重新运行 App. 使用 Safari 的开发者模式, 可以帮助我们调试前端页面, 解决一些问题, 比较方便.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS Safari</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 自定义 UIWebView 和 WKWebView 的 UserAgent]]></title>
    <url>%2F2017%2F05%2F14%2FiOS-%E8%87%AA%E5%AE%9A%E4%B9%89-UIWebView-%E5%92%8C-WKWebView-%E7%9A%84-UserAgent%2F</url>
    <content type="text"><![CDATA[导言在 iOS8, 苹果推出了 WKWebView, 目的很明显: 取代 UIWebView. 随着时间的推移, 越来越多的应用开始最低版本支持为 iOS8, 大家也纷纷的开始使用 WKWebView 组件. 在 iOS10.x 版本上, UIWebView 的表现不尽如人意, 在我们的后台日志和用户反馈, 存在很多莫名其妙的 crash 以及卡顿现象, 内存飙升等问题. 针对不同的 JS 游戏引擎, UIWebView 表现也不够好, 所以是时候使用 WKWebView 了. 但是话又说回来, 如果你最低版本支持 iOS8, 也不能完全放弃 UIWebView, WKWebView 有一部分 API 只有 iOS9+ 才有, 如果你的应用在 iOS8 运行而使用 iOS9 的 API, 肯定会 crash. 例如: 1.清除缓存.2.设置 user-agent. 今天要说的是关于设置自定义 UIWebView 和 WKWebView 的 UserAgent 问题. WKWebView UserAgent默认的 UserAgent使用下面的代码, 可以输出 WKWebView 的默认 UserAgent. 12345678910- (void)viewDidload &#123; [self.wkWebView evaluateJavaScript:@&quot;navigator.appName&quot; completionHandler:^(id __nullable appName, NSError * __nullable error) &#123; NSLog(@&quot;navigator.appName: %@&quot;, appName); &#125;]; [self.wkWebView evaluateJavaScript:@&quot;navigator.userAgent&quot; completionHandler:^(id __nullable userAgent, NSError * __nullable error) &#123; NSLog(@&quot;navigator.userAgent: %@&quot;, userAgent); &#125;];&#125; navigator.appName 无论在 iOS8, iOS9 还是 iOS10, 输出结果都是一致的. navigator.userAgent 在不同的 iOS 系统上面输出结果略有不同. 123456// iOS 8.3// Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12F70// iOS 9.0// Mozilla/5.0 (iPhone; CPU iPhone OS 9_0 like Mac OS X) AppleWebKit/601.1.32 (KHTML, like Gecko) Mobile/13A4254v// iOS 10.x//Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E269 自定义 UserAgent修改默认的 UserAgent, 需要使用下面的方法. 1self.wkWebView.customUserAgent = @&quot;CustomUserAgent&quot; 这样, 就改变了其默认的 UserAgent 值了. 特别需要注意: customUserAgent 是 iOS9 之后才有的字段. 123/*! @abstract The custom user agent string or nil if no custom user agent string has been set.*/@property (nullable, nonatomic, copy) NSString *customUserAgent API_AVAILABLE(macosx(10.11), ios(9.0)); 所以在 iOS8.x, 如果你想改变 UserAgent, 还是要使用 UIWebView. HTML 使用 UserAgentHTML 中可以根据自定义的 UserAgent, 做出不同的行为, 如自定的 UserAgent 可以包括应用的版本号, HTML 可以根据不同的版本来做版本区分等逻辑. 在 HTML 中, 可以使用 JS 来获取 UserAgent 的值. Demo.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;user-agent&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function getUserAgent() &#123; var ug = navigator.userAgent; document.getElementById(&quot;mySpan&quot;).innerHTML = ug; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;显示 user-agent&lt;/h1&gt; &lt;p&gt;&lt;span style=&quot;font-size:30px&quot; id=&quot;mySpan&quot;&gt;..&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;点击显示 user-agent&quot; onclick=&quot;getUserAgent()&quot; class=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/body&gt; &lt;style&gt; .button &#123; background-color: #4C0950; border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 40px; margin: 20px 200px 100px 300px; cursor: pointer; border-radius: 15; &#125; &lt;/style&gt;&lt;/html&gt; 使用 WKWebView 加载该 Demo.html 文件, 效果图如下: UIWebView UserAgent默认的 UserAgent使用下面的代码, 可以输出 UIWebView 的默认 UserAgent. 12345NSString *appName = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.appName&quot;];NSLog(@&quot;navigator.appName: %@&quot;, appName); NSString *userAgent = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];NSLog(@&quot;navigator.userAgent %@&quot;, userAgent); 打印输出结果和 WKWebView 的结果一致. 设置自定的 UserAgent设置一个 key 为 @”UserAgent” 的本地存储即可. 1234567[[NSUserDefaults standardUserDefaults] registerDefaults:@&#123;@&quot;UserAgent&quot;:@&quot;CustomUserAgent-UIWebView&quot;&#125;]; NSString *appName = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.appName&quot;];NSLog(@&quot;navigator.appName: %@&quot;, appName); NSString *userAgent = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];NSLog(@&quot;navigator.userAgent %@&quot;, userAgent); 这样就改变了 UIWebView 的默认 UserAgent 了. 小结应用最低版本支持 iOS7/8 的开发者们, 可以考虑 UIWebView 和 WKWebView 并存的开发模式. iOS9及以上的开发者你们, 可以完全放弃 UIWebView, 大胆的拥抱 WKWebView 了. 移植 UIWebView 到 WKWebView 的成本不算大.如果你现在有时间, 可以开始着手做这些事了.前端和客户端需要考虑之前交互那部分的逻辑, 即 JS 调用 Native 或者 Native 调用 JS 的需要做些调整, 因为 WKWebView 的调用方式和 UIWebView 不一样了, 前端页面要考虑版本兼容性. 新的 WKWebView 虽然存在一些坑, 但是使用它亦是大势所趋, 正所谓 存在即合理, 你没有理由拒绝它. 后续, 我会写一写在 WKWebView 上面遇到的一些问题, 分享给大家. 之前我也写过一篇文章, 是关于 UIWebView 缓存的, 不妨, 你也瞅瞅 [iOS: 聊聊 UIWebView 缓存].]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIWebView WKWebView UserAgent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos2d-js: 首次在 Mac 上面运行]]></title>
    <url>%2F2017%2F05%2F14%2FCocos2d-js-%E9%A6%96%E6%AC%A1%E5%9C%A8-Mac-%E4%B8%8A%E9%9D%A2%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Cocos2d-js 介绍如果你是刚接触 Cocos2d-js 开发的人, 一定会被 Cocos2d-js 和 Cocos2d-HTML5 以及 Cocos2d-x 搞得晕头转向. 下面简单介绍一下 Cocos2d-js 的前世今生. 目前 Cocos2d-x 支持使用 C++、Lua、Javascript 语言来进行开发，且内置 JavaScript 引擎，通过 C++ 解析 Javascript 去执行. Cocos2d-HTML5 是使用 JavaScript 进行开发，最终运行在浏览器里的. v3.0 后，Cocos2d-HTML5 和 Cocos2d-x JSBinding 被合到了一起，称作 Cocos2d-JS. 与 Cocos2d-HTML5 不同的是，Cocos2d-js 开发的程序不仅能运行在浏览器里，还能编译运行在 Mac OSX, Windows, iOS, Android 平台上. 从 Cocos2d-x v3.7 版本之后, js 版本被合并到 Cocos2d-x 中了. 具体可以看 Release Note 这个说明. 这个版本的发布日期是在2015年7月21. 原来的 Cocos2d-js 版本在 [GitHub] 上面已经停止更新了. 说明如下: 2/27/2016 - This repository is no longer active.Cocos2d-JS was merged with Cocos2d-x starting at version 3.7. 可以看出, Cocos2d-js 原来独立的项目被合并到了 Cocos2d-x 中了. 现在使用 Cocos2d-x 不仅可以创建 cpp 项目和 lua 项目, 也可以创建 js 项目了. 官方有说明的: Cocos2d-JS is Cocos2d-x engine’s JavaScript version that includes Cocos2d-html5 and Cocos2d-x JavaScript Bindings. 至于什么是 Cocos2d-x JavaScript Bindings, 大家自行 google, 这里不赘述. 关系图大概如下: Cocos2d-x 框架图 搭建 Cocos2d-js 开发环境1.下载 Cocos2d-x可以在官网下载最新的 Release 包, 点击 下载地址, 我下载的最新包是 cocos2d-x-3.15. 下载解压即可, 这里我把 cocos2d-x-3.15 修改为 cocos2d-x. 设置环境变量在 cocos2d-x 目录, 执行 1python setup.py 执行完毕后, 可以看到 ‘~/.bash_profile` 的内容 123456# Add environment variable COCOS_CONSOLE_ROOT for cocos2d-xexport COCOS_CONSOLE_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/tools/cocos2d-console/binexport PATH=$COCOS_CONSOLE_ROOT:$PATH# Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-xexport COCOS_TEMPLATES_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/templatesexport PATH=$COCOS_TEMPLATES_ROOT:$PATH 这里, 没有看到我的 ANT_ROOT 路径, 其实该脚本智能的找到 /usr/local/Cellar/ant/1.9.7/bin, 但是我不想使用这个 ant, 想使用自己下载的 ant, 修改该文件如下: 123456789# Add environment variable COCOS_CONSOLE_ROOT for cocos2d-xexport COCOS_CONSOLE_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/tools/cocos2d-console/binexport PATH=$COCOS_CONSOLE_ROOT:$PATH# Add environment variable ANT_ROOT for cocos2d-xexport ANT_ROOT=/Users/mark/developer/apache/apache-ant-1.10.1/binexport PATH=$ANT_ROOT:$PATH# Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-xexport COCOS_TEMPLATES_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/templatesexport PATH=$COCOS_TEMPLATES_ROOT:$PATH 最后执行: 1source ~/.bash_profile 使环境变量立即生效. 创建 js 工程cd 到任意目录, 执行: 1cocos new HelloJs -l js -d . new HelloJs 表示工程名字为 HelloJs-l js 表示创建 js 工程.-d . 表示在当前路径创建该工程 可以看到下面创建工程的过程: 123456789Copy template into /Users/mark/workspace/mzProjs/c2dx/works/HelloJsCopying directory from cocos root directory...Copying files from template directory...Copying Cocos2d-x files...Rename project name from &apos;HelloJavascript&apos; to &apos;HelloJs&apos;Replace the project name from &apos;HelloJavascript&apos; to &apos;HelloJs&apos;Replace the project package name from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;Replace the Mac bundle id from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;Replace the iOS bundle id from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos; 工程目录: 工程发布将上面的工程编译发布. 编译发布: 1cocos compile -p web -m release -p web 表示编译 web 平台.-m release 表示编译为 release 模式. 编译输出: 12345678Building mode: releaserunning: &apos;/Users/mark/developer/apache/apache-ant-1.10.1/bin/ant -f /Users/mark/workspace/mzProjs/c2dx/works/HelloJs/publish/html5/build.xml&apos;Buildfile: /Users/mark/workspace/mzProjs/c2dx/works/HelloJs/publish/html5/build.xmlcompile: [jscomp] Compiling 156 file(s) with 42 extern(s) [jscomp] 0 error(s), 0 warning(s)BUILD SUCCESSFULTotal time: 8 seconds 如果你在这一步编译报错, 或者执行不下去, 一般都是没有在环境变量中配置好 ant. 编程成功后, 会多出 publish 目录: 运行执行 cocos run 命令来在系统默认的浏览器上面运行. cd 到工程目录, 执行: 1cocos run -p web -s . --port 9009 这样会帮我们在本地启动一个 webServer 来运行示例, 直接打开了默认使用的浏览器. -s: 表示当前需要执行的源码路径–port: 指定端口, 如果不指定端口, 默认在 8000 端口执行. 更多 cocos run 命令可以, 使用下面的命令来查看帮助: 1cocos run --help 本地运行 index.html 的问题你可以用火狐浏览器(FireFox)打开本地工程目录中的 index.html, 即可看到运行效果了.FireFox 应该是在本地启动了一个 WebServer 来运行. 在 chrome 中直接运行 index.html, 无法看到最终效果, 一直卡在 loading 界面. 打开 inspect, 可以看到报错信息: 12XMLHttpRequest cannot load file:/xx/publish/html5/project.json.Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 网上有人讨论过过问题, 说是 chrome 跨域不支持 file 协议，那么即使你允许 chrome 跨域支持, 直接运行本地的 index.html 还是报错: 1game.min.js:54 Uncaught TypeError: Cannot read property &apos;modules&apos; of null 在 MacOS 上面允许 chrome 跨域访问文件的方法: 1open /Applications/Google\ Chrome.app --args --allow-file-access-from-files 可以看出, 在这方面, FireFox 做的比 chrome 好. 更新 更新时间 2017-10-15 在微信公众号上面看到 一招教你辨别 Cocos、Cocos2d、Cocos2d-x 这篇文章, 大家可以看看, 对 cocos 会有更加深入的了解.]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>cocos cocos2d-js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小篮球队]]></title>
    <url>%2F2017%2F04%2F29%2F%E5%B0%8F%E5%B0%8F%E7%AF%AE%E7%90%83%E9%98%9F%2F</url>
    <content type="text"><![CDATA[篮球, 我最喜欢的一项体育运动, 大学的业余时间基本都”泡”在球场, 压根不知道什么是累. 毕业后的第一份工作, 做的比较开心, 大家年龄相仿, 兴趣相投. 小小的团队, 没有任何纷争, 大家互相学习, 氛围及其融洽. 每个周五我们几个人都会提前下班去打一场篮球, 完事后, 一起喝点小酒, 那日子甭提有多他NND的惬意. 公司解散后, 大家各奔东西, 事过境迁, 各有各的工作和生活, 聚在一起的日子也是少之又少, 以前的日子只能怀念了. 人总需要一些非工作之外的兴趣, 整天围绕着工作, 早晚都会疯掉. 有些人喜欢泡泡图书馆, 有些人喜欢打打游戏, 有些人喜欢跑跑步, 有些人喜欢唱唱歌… 不管怎么样, 你需要某种爱好, 来润色一下你的生活, 我选择了篮球运动. 下面, 来说说篮球队中典型的几种人, 大家结合自己的工作和生活, 思考一下吧~ 单打独斗篮球运动是一项集体运动, 需要每个人发挥自己应有的水平, 才能发挥团队的力量. 有些人喜欢单打独斗, 完全不考虑团队中其他成员的感受, 只要球到了他手中, 其他人只能看他的表演, 任凭你喊破嗓子, 他也不会理你. 这种人, 其实是有一定能力的人, 不然也不会也不可能这么做, 只是他们觉得凭一己之力就可以让大家高正无忧了, 自己没有思考过这样做是不是最合适的. 久而久之, 大家看着他的”表演”, 再也不想发挥了, 单打独斗的人慢慢的也累了, 最后大家都身心疲惫, 球队被对方轻而易举地打败. “指挥官”球队中有一种人, 自己不努力, 总是喜欢颐指气使, 经常听到他们说这样的话: 你快点跑呀, 积极点…死死地防着他, 不要让他进攻, 快…你传球给我呀, 让你别着急, 好了吧, 输了吧…输了, 都怪你… 听到这些话, 再好脾气的人估计都难以接受, 脾气不好的直接开始打他了吧! 这种人最不受待见, 也最遭人唾骂, 这种人在实际工作中, 可能是你的领导. 偷懒的篮球运动的确很消耗体力, 如果在万箭齐发的时刻, 有人故意掉链子, 那将是功亏一篑. 大家在打球的时候, 都在为”荣誉”而战, 但是偏偏有人会使点小心眼, 能少跑一步就少跑一步, 能放对方走就放对方走, 绝对不伤害对方一毛一线. 明明可以稍微努力一下, 就可以拿到篮板, 偏偏让对方比自己还矮小的轻而易举的拿走了篮板. 要知道比自己矮小的那个人, 只是努力的跳了一下. 球场上虽然不是让你拼个你死我活, 不要求你全力以赴, 但是尽力而为总是要有的, 这是一种态度. 在实际工作中, 这种”队友”比比皆是, 但是不一定遭人恨, 有些还是很招人喜欢的, 毕竟他们没有抢你的功劳, 处处让着你, 没有他们的这些所谓的付出, 哪能衬托出你的光芒. 鼓励你的上面说的都是一些”负能量”, 大家一笑而过吧.下面说点正能量的. 在球队中, 还有一种这样的人, 他会察言观色, 觉得你累了, 就告诉大家: “我们应该节奏慢一点, 缓冲一下.”, 当你手感不好的时候, 他会告诉你, 没事, 多来几次就好了, 不要有压力. 当你防守遇到困难时, 他会默默的给你补防, 给你接力, 最大程度的给你信心. 当大家士气不高的时候, 他会站出来投几个漂亮的球, 抑或给对方一个完美的盖帽, 并且鼓励大家不要放弃, 给大家信心, 做大家坚固的后盾. 这种人除了自己有一定的能力外, 还能顾全大局, 并且可以帮助队友, 帮助团队渡过难关, 确实难得. 渴望进步的球队中, 存在一些新人, 或者是渴望自己能投出漂亮弧线球的人, 他们比不上那些资历老且经验丰富的前辈, 但是他们内心有一份信念: “我要变强!”. 这种人, 跟你讨论球技, 虚心向你学习一切可以提高球技的方法, 即使在观众席上, 他们也能聚精会神的观看, 自己领悟其中的奥妙. 只要你约他出来打球, 他都在第一时间出现在球场, 因为他不想放弃学习的机会. 久而久之, 这些人会变得越来越厉害, 通过不断的学习和摸索, 有了一套自己的打法, 步伐稳健, 再也不是那种接球不稳, 传球频频失误的”毛头小子”了. 这种人, 值得我们去挖掘和鼓励, 如果你正好是那个资历老且经验丰富的前辈, 就传授”真经”给他们吧.对于你来说, 有人愿意跟你学习, 跟你分享, 也是美事一桩. 何乐而不为呢? 最后不管你遇到什么样的队友, 如果你愿意, 请胸怀宇宙(当然不是 孙连城 那种啊). 万事万物皆有联系, 愿你能偶尔放下手中的工作, 去选择和爱上另一种乐趣. 五一放假了, 祝大家节日快乐!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 应用内打开 AppStore]]></title>
    <url>%2F2017%2F04%2F15%2FiOS-%E5%BA%94%E7%94%A8%E5%86%85%E6%89%93%E5%BC%80-AppStore%2F</url>
    <content type="text"><![CDATA[应用场景我们的 App 需要在 AppStore 上面打开某个 App 或者游戏, 目的最常见的有: 1.评分评论.2.推荐下载(App 或者游戏). 很多开发者知道打开 AppStore 只需要一句代码: 1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itunes app url&quot;]]; 这样就很简单的打开 AppStore 了, 但是产品经理问了, 能在我们应用内打开 AppStore 吗? 你当时懵逼了吗? 不要懵逼, 以后只要遇到类似这种问题, 你就问产品经理哪个 APP 这样做了?然后, 他就给你看别人家的效果, 你就理直气壮地说: “别人可以做到的, 我们也可以做到!”. 应用内打开 AppStore 也很简单.在 iOS6之后, 苹果已经给我们提供了 SKStoreProductViewController, 大家看一下文档, 你就笑了. 12SKStoreProductViewController/* View controller to display iTunes Store product information */ 应用内打开 AppStore这里我以在应用内打开 微信 为例子. 效果图如下: 从效果图可以看出, 用户在自己的应用内打开 AppStore 后, 不仅可以下载或者打开微信, 还可以直接评论评分, 简直爽(也难怪产品经理这么干). 那我们说一下如何实现上面的效果. 实现方案和步骤 1.包含头文件 #import &lt;StoreKit/StoreKit.h&gt; 2.实现 SKStoreProductViewControllerDelegate 具体代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)openAppFromAppStore:(NSString *)appid&#123; if (nil == appid || appid.length &lt;= 0) &#123; return; &#125; // 加个 loading SKStoreProductViewController *store = [[SKStoreProductViewController alloc] init]; store.delegate = self; NSDictionary&lt;NSString *, id&gt; *parameters = @&#123;SKStoreProductParameterITunesItemIdentifier: appid&#125;; [store loadProductWithParameters:parameters completionBlock:^(BOOL result, NSError *error) &#123; // 结束 loading if (error) &#123; NSLog(@&quot;error %@ with userInfo %@&quot;, error, [error userInfo]); // 提示用户发生了错误 // 或者通过 URL 打开 AppStore App. // NSString *url = @&quot;https://itunes.apple.com/in/app/wechat/id414478124?mt=8&quot;; //[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; &#125; else &#123; [self presentViewController:store animated:YES completion:^&#123; &#125;]; &#125; &#125;];&#125;/// 用户点击取消会执行该方法- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController&#123; [viewController dismissViewControllerAnimated:YES completion:^&#123; &#125;];&#125; 调用(@”414478124” 是 微信 的)方式: 1[self openAppFromAppStore:@&quot;414478124&quot;]; 修改 AppStore 的导航栏产品经理说, 既然你已经实现了上面的功能, 看看能不能把 AppStore 的导航栏改一个牛逼的颜色, 就像上面的大红色. ~ 可以, 干! 直接上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)openAppFromAppStore:(NSString *)appid&#123; if (nil == appid || appid.length &lt;= 0) &#123; return; &#125; // 加个 loading // 导航栏上面的文字和图片颜色变了 [[UINavigationBar appearance] setTintColor:[UIColor greenColor]]; // 导航栏的大红色出来了 [[UINavigationBar appearance] setBarTintColor:[UIColor redColor]]; [UINavigationBar appearanceWhenContainedIn:[SKStoreProductViewController class], nil]; SKStoreProductViewController *store = [[SKStoreProductViewController alloc] init]; store.delegate = self; NSDictionary&lt;NSString *, id&gt; *parameters = @&#123;SKStoreProductParameterITunesItemIdentifier: appid&#125;; [store loadProductWithParameters:parameters completionBlock:^(BOOL result, NSError *error) &#123; // 结束 loading if (error) &#123; NSLog(@&quot;error %@ with userInfo %@&quot;, error, [error userInfo]); // 提示用户发生了错误 // 或者通过 URL 打开 AppStore App. &#125; else &#123; [self presentViewController:store animated:YES completion:^&#123; &#125;]; &#125; &#125;];&#125; 注意事项1.打开 SKStoreProductViewController 目前只能使用 present 方式, 不可以使用 push 的方式. 否则会报错: 12//Terminating app due to uncaught exception &apos;SKUnsupportedPresentationException&apos;,//reason: &apos;SKStoreProductViewController must be used in a modal view controller&apos; 2.加入 loading 在应用内打开 AppStore, 为了不让用户傻等(网络不好的时候, 打开很慢), 可以加入 loading, 缓解一下用户急躁的心情.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找合伙人, 不易]]></title>
    <url>%2F2017%2F03%2F26%2F%E6%89%BE%E5%90%88%E4%BC%99%E4%BA%BA-%E4%B8%8D%E6%98%93%2F</url>
    <content type="text"><![CDATA[早在高中时期, 读过 &lt;三言&gt; 中的 &lt;警世通言&gt;, 第一章写的是 俞伯牙摔琴谢知音, 讲的是钟子期和俞伯牙的故事. 读完之后, 整个人都觉得难受, 心理有说不出的滋味, 眼泪竟夺眶而出. 流传的这首诗, 可以感受下. 摔碎瑶琴凤尾寒，子期不在对谁弹！春风满面皆朋友，欲觅知音难上难。势利交怀势利心，斯文谁复念知音！伯牙不作钟期逝，千古令人说破琴。 自己工作之后, 对 欲觅知音难上难 这句话尤为赞同. 年少轻狂的你, 藏着要改变世界的心, 残酷的现实会抹去你凸起的棱角, 岁月和环境会让你变得越发不安. 不安的世界, 让你茫然. 于是, 点上一支烟, 回顾折腾的人生, 笑叹: 别人笑我太疯癫, 我笑他人看不穿. 可惜, 我们不是唐寅, 没有这份洒脱和奔放, 毕竟时代也大相径庭. ~ 好了, 回到现实中来. 刚毕业, 你会把主要精力放在如何把工作做好, 维持自己的生计上面, 如果能跟身边的大牛学到一些专业知识, 再苦再累, 你都是开心的. 渐渐地, 你发现知识(专业的和非专业的知识)真是要活到老学到老, 永无止境, 无法像武侠片里面演得那样移花接木, 斗转星移. 呜呼, 脚踏实地的做好本职工作, 顺便能拓展一下自己的交际圈, 扩大自己的知识面, 还是很有必要的. 各行各业都有非常突出的人才, 很多时候, 我们只能望洋兴叹. 如果你能遇到一个肯与你分享和交流, 或者是愿意将自己的实践分享给你的人, 那你算是上辈子积了大德了. 阿弥陀佛! 我把这样的人称之为 恩人, 也算是 知音. 以前, 很多朋友会问如果将来自己开公司, 是否愿意接受现在的自己, 我的回答是一定接受. 如果还有人问这个问题, 我会另外再追加一个问题: 如果你开公司, 你是否愿意接受和你现在一起工作的同事?或者说你是否愿意让他成为你的合伙人? 这些问题, 看似玩笑, 实则很现实很残酷, 一旦你决定要去做成某件事情, 立志要实现自己的抱负和理想的时候, 你的立场会和其他人千差外别.首先要考虑的是要和谁一起共谋事, 才能真正的帮到自己, 并且也能帮到别人.因为选择是双向的, 能找到和你一拍即合的人, 也确实不易.但愿任何一个渴望成功并付出行动的人, 能找到自己的合伙人, 找到自己的知音. 真正的成功者, 不是沉浸在多少人让你成功的喜悦中, 而是你让多少人和你一起分享了成功的喜悦的人. 说到这里, 本人只是想说明白一个道理, 送给即将或者已经在职场奋斗的人: 踏踏实实的做事并没有错, 但是找到值得 “托付终身” 的人确实不易, 你现在能做的只有用知识来武装自己, 让自己变强. 在职场中, 你会遇到很多让你不爽的人或者事. 记住, 要做到 对事不对人, 不要太委屈自己, 大丈夫能屈能伸, 该出手时就出手, 没有什么大不了. 如果真的觉得有些人或者有些事不值得你浪费时间, 就离它们远点. 惹不起但可以躲得起, 你说呢? 酌一壶小酒, 老夫聊发少年狂!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考 生活 合伙人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让自己变强]]></title>
    <url>%2F2017%2F03%2F10%2F%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%8F%98%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[当你读到这篇文章的时候, 我其实还不知道『怎么让自己变强』.具体说, 就是没有一套让你或者让他变强的武林秘籍. 只能结合自己经历的事, 分享给大家, 希望能感同身受! 这几天加班加地有点猛, 浑然不知周末轮回了.心理总是在念叨, 好久没有在公众号涂鸦了, 手痒痒了.趁今晚回来早(22:30回到家), 就动笔了. 『让自己变强』, 这句话说着很简单, 但不是任何人都能意识到这几个字带来的力量. 在「明朝那些事儿」中有这么一段: 我们经常会产生一个疑问，那就是怎样才能获得其他国家及其人民的尊重，在世界上风光自豪一把，其实答案很简单——国家强大。 看到这里, 感触颇深. 在团队中成长团队成长的主观条件是团队的成员要成长, 不然团队哪里来的成长. 如果你是作为一个团队或者小组的负责人, 会面临各种各样的问题, 比如需要跟团队以外的部门谈合作, 需要跟老板汇报工作, 还要处理内部的问题等等诸如此类! 我觉得安邦需安内, 也就是说要先搞定团队内部的各种事物, 人是比较复杂的感情动物, 你不好也不能控制别人的情绪. 所以, 需要对事不对人!你不能说, 你看他长得不好看, 就知道工作做不好类似的话. 这样一说, 基本两个人就结下了梁子.迟早会爆发. 首先, 要给团队成员希望, 让大家都认识到有统一的目标. 其次, 让每个人给出工作和实行计划, 制定自己的考核目标.对做出突出贡献的成员奖励, 每个人都需要得到尊重, 而奖励是最大的尊重. 最后, 加强与团队成员之间的沟通, 互相帮助, 让大家能够相互信任和鼓励, 良好有效的沟通, 事半功倍. 作为团队负责人, 肯定希望手下的人各个骁勇善战, 百战百胜, 但是现实中很难做到, 其实也没有必要.西游记告诉我们, 唐僧带领的团队才是最好的团队. 少埋怨多给予帮助每个人生活和工作的环境不一样, 在不同的地点不同的时间面对不同的事情, 都会有不同的看法. 世界上任何一种选择, 都是命中注定的, 没有人能强迫你去做出任何错误的选择, 除了你自己. 在自己所处的环境中, 要么你能改变环境使其来适应自己, 要么就离开这个自己不适应的环境, 不要去抱怨. 唉声叹气, 不仅仅影响自己的工作效率和生活质量, 还会影响到别人.成天在抱怨, 觉得谁谁都不行, 自己才是最牛逼的, 日行见久, 你就是那个充满负能量的人, 当别人觉悟到的时候, 就会离你而去, 岂不咎由自取?!我想这也是微信朋友圈只有点赞没有非点赞的原因吧! 如果觉得自己的同事或者朋友有所欠缺, 就想办法去帮助他, 鼓励他, 把你认为一些好的方式和方法传授给他. 说不定哪天因为你的一句话或者一个方法, 他就走上人生巅峰了, 哈哈! 从现在开始, 忘记埋怨, 给予别人更多的帮助和鼓励. 培养自己的专注力专注力, 是一个很神奇的东西. 如果一个人没有专注力, 很难再有所突破, 据说牛顿是在做梦的时候, 发明了很多折磨广大青少年的牛顿定律的. 每个人在自己的行业上, 多少都有短板. 有短板是情有可原的, 但是首先你得认识到自己的短板, 然后再指定计划去突破他. 要想进步, 必须面对自己的不足. 比如, 工作上需要你学会某种技术, 如果在某个时间点, 你没有学会, 可能就会丢掉饭碗, 你就会不顾一切的去学习, 直到学会会用为止. 这个过程, 你就是在专注这件事情, 回头想想咬咬牙, 还是可以办到的, 没有什么大不了的. 每天给自己一点时间, 专注去做一件事情, 坚持下来, 你会发现, 学习和进步就是 feel feel 倍儿爽. 最后分享给大家一句话: 不能改变别人的时候, 试着改变一下自己或许就能把事情变通了.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔 生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat8 配置 HTTPS]]></title>
    <url>%2F2017%2F02%2F15%2FTomcat8-%E9%85%8D%E7%BD%AE-HTTPS%2F</url>
    <content type="text"><![CDATA[博客 [Tomcat8 域名配置] 介绍了如何在本地配置 Tomcat8 的域名以及通过域名来访问对应的资源. 今天继续跟大家分享如何配置 Tomcat8 的 HTTPS (单向认证), 本篇博客的主要内容如下: 1.配置 Tomcat 的 HTTPS.2.通过 HTTPS + ip 的方式来访问资源.3.通过 HTTPS + 域名 的方式来访问资源. 配置要求1.安装了 JDK, 并配置了其相关的环境变量.可参考 Mac 配置 JDK1.8. 2.安装了 Tomcat8, 并配置了其相关的环境变量.可参考 Mac 配置 Tomcat8. 生成证书 获取证书可以去购买, 这里是在本地机器搭建, 使用 JDK 自带的工具 keytool 生成即可. 打开 mac 终端, 执行: 1keytool -v -genkey -alias tomcat -keyalg RSA -keystore ~/Desktop/tomcat.keystore 紧接着, 会出现一些让你输入信息的交互信息, 第一个是让你输入 密钥库密码(口令), 我输入的是 1234567, 其他信息可以任意输入内容, 在最后一步, 问你生成的 密钥口令 和 密钥库的口令 是否相同, 如果相同就直接回车, 我这里是直接回车的, 即密码相同, 都是 1234567. 这样就生成了所谓的证书. 配置 HTTPS 通过修改 server.xml 来配置. 将 tomcat.keystore 文件复制到 Tomcat 的 conf 目录. 修改 server.xml 文件, 增加一个 Connector, 内容如下: 123&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;conf/tomcat.keystore&quot; keystorePass=&quot;1234567&quot;/&gt; 注意, keystoreFile 是证书文件, keystorePass 是密码, 这里配置一定要正确. 配置 HTTPS + IP配置一个虚拟主机, 修改 server.xml 文件, 增加 Host: 1234&lt;Host name=&quot;192.168.1.103&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 配置 name=”192.168.1.103” 是你本机的 ip 地址. 这个在博客 [iOS: 聊聊 UIWebView 缓存] 中有详细的介绍, 这里不再赘述. 启动 Tomcat, 进行测试. 这里需要到 Tomcat 的 bin 目录下, 执行: 1sudo startup.sh 启动成功后, 打开浏览器, 输入: https://192.168.1.103:8443/test.html, 这个时候, 会弹出如下的警告(提示不安全): 直接点击 Advanced 后再点击 Proceed to 192.168.1.103:8443(unsafe) 处理即可看到页面内容. 配置 HTTPS + 域名修改 server.xml, 增加 Connector: 123&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;conf/tomcat.keystore&quot; keystorePass=&quot;1234567&quot;/&gt; 修改 server.xml, 增加 Host: 1234&lt;Host name=&quot;www.mark.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 修改 /etc/host 文件, 增加: 1127.0.0.1 www.mark.com 启动 Tomcat, 在 bin 目录, 执行: 12shutdown.shsudo startup.sh 启动成功后, 打开浏览器, 输入 https://www.mark.com:8443/test.html, 如果弹出警告, 可以像如上处理来显示页面内容. 如果你这里配置失败了, 请修改一下端口号, 如将 8443 改为 8433.重启 Tomcat 在试一下. 参考Apache 官方文档: ssl-howto]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tomcat Java Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat8 域名配置]]></title>
    <url>%2F2017%2F02%2F13%2FTomcat8-%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[博客 [Mac 配置 Tomcat8] 介绍了在 Mac 下安装和启动 Tomcat. 接下来介绍, 如何在本地配置 Tomcat8 的域名. 网上有很多关于 Tomcat 如何配置单域名或者多域名的文章, 很多都是翻译或者复制别人的, 根本没有实践过, 害人不浅! 结合自己的实践, 把配置的整个过程分享给大家, 希望能帮到你. 下面进入正题. 修改端口在 Tomcat 的安装(其实是解压的)目录 /conf 下有 server.xml 文件. 将下面内容: 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改为: 123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 添加 web 项目 这一步主要是为了后面测试. 很简单, 在 Tomcat 的安装目录 webapps 下面新建 test 文件夹, 里面创建一个 html 文件即可.这里将其命名为 test.html. test.html 内容见后面的附录即可. 配置域名 增加虚拟主机配置.还需要修改 server.xml 文件. 在 server.xml 文件中, 在标签 和 之间增加下面的内容: 1234&lt;Host name=&quot;www.mark.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 其中, www.mark.com 是我自己任意取的一个域名, docBase=”test” 是指向上面新建的 test 目录. 配置域名解析由于部署在本地, 需要修改 host. 修改 /etc/host 文件, 需要 sudo 权限: 1sudo vim /etc/host 增加如下内容: 1127.0.0.1 www.mark.com 验证配置 这一步, 验证配置是否生效. 启动 Tomcat, 这里的操作比较特殊, 需要 sudo 权限来启动 Tomcat, 否则会报下面的错误: 12org.apache.coyote.AbstractProtocol.init Failed to initialize end point associated with ProtocolHandler [&quot;http-nio-80&quot;] java.net.SocketException: Permission denied 因为, 只有 root 用户才可以使用 1024 以下的端口号. 正确姿势: cd 进入 Tomcat 的 bin 目录 1cd ~/Tomcat/bin 执行: 1sudo startup.sh 成功后, 打开浏览器, 输入 http://www.mark.com/test.html, 即可看到页面内容. 配置另一个域名可以配置另外的一个域名, 比如 www.ithome.com, 即多增加一个虚拟主机配置. 在 server.xml 增加: 1234&lt;Host name=&quot;www.ithome.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 配置 DNS, 同理修改 etc/host 文件: 1127.0.0.1 www.ithome.com 可以看出, 在浏览器输入 http://www.ithome.com/test.html 和 http://www.mark.com/test.html 效果是一样的. 附录test.html 文件内容 123456789101112131415161718192021222324252627282930313233343536&lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy&lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy &lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt; mark.zhang is an itman.&lt;/p&gt;&lt;style&gt;.button &#123; background-color: #4CAF50; border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 86px; margin: 50px 200px 100px 300px; cursor: pointer; border-radius: 15;&#125;&lt;/style&gt;&lt;p&gt; &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot; class=&quot;button&quot;&gt;Try it&lt;/button&gt;&lt;/p&gt;&lt;script&gt; function myFunction() &#123; alert(&quot;Blog: www.veryitman.com&quot;); &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tomcat Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATS: HTTPS 认证]]></title>
    <url>%2F2017%2F02%2F08%2FATS-HTTPS-%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[在 ATS: HTTP/HTTPS 协议介绍 中介绍了一些关于 HTTP/HTTPS 的概念以及相关的基本知识. 今天来聊聊关于 HTTPS 的认证方式和过程. 说 HTTPS 认证前, 先了解几个概念. 关于加密的几个概念1. SSL 协议加密方式 SSL 既用了对称加密, 也用了非对称加密(公钥加密). 在建立传输链路时, SSL 首先对对称加密的密钥使用公钥进行非对称加密, 链路建立好之后，SSL 对传输内容使用对称加密. 下面是两种加密方式的对比: 1.对称加密 对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，这种方法在密码学中叫做 对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，而且对计算机功能要求也没有那么高.IDEA 加密标准由 PGP（Pretty Good Privacy）系统使用. 该加密方式, 速度快, 可加密内容较大, 用来加密会话过程中的消息. 2.公钥加密(非对称加密) 1976年，美国学者 Dime 和 Henman 为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”.相对于 对称加密算法 这种方法也叫做 非对称加密算法.与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）. 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密.因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 该加密方式, 速度较慢, 能提供更好的身份认证技术, 用来加密对称加密的密钥. 2. 数字证书一种文件的名称，好比一个机构或人的签名，能够证明这个机构或人的真实性. 其中包含的信息，用于实现上述功能. 3. 加密和认证加密是指通信双方为了防止铭感信息在信道上被第三方窃听而泄漏，将明文通过加密变成密文，如果第三方无法解密的话，就算获得密文也无能为力. 认证是指通信双方为了确认对方是值得信任的消息发送或接受方，而不是使用假身份的非法者，采取的确认身份的方式. 只有同时进行了加密和认证才能保证通信的安全，因此在 SSL 通信协议中这两者(加密和认证)都被使用. 加密一般使用 对称加密算法 和 不对称加密算法，不对称加密最常见的算法就是 RSA. 4. 消息摘要这个技术主要是为了避免消息被篡改. 消息摘要是把一段信息, 通过某种算法, 得出一串字符串.这个字符串就是消息的摘要，如果消息被篡改(发生了变化), 那么摘要也一定会发生变化(如果2个不同的消息生成的摘要是一样的，那么这就叫发生了碰撞). 消息摘要的算法主要有 MD5 和 SHA，在证书领域，一般都是用 SHA(安全哈希算法). 数字证书、加密和认证、消息摘要三个技术结合起来，就是在 HTTPS 中广泛应用的证书(certificate), 证书本身携带了加密/解密的信息，并且可以标识自己的身份，也自带消息摘要. HTTPS 认证方式分为单向和双向认证. 单向认证 单向认证较简单, 只需要服务端校验服务端的证书的合法性. 该认证过程使用下面的流程图来表示: 双向认证双向认证和单向认证原理基本一致，但是需要双方都校验对方的证书的合法性. 该认证过程使用下面的流程图来表示: 随机数的产生不管是单向认证, 还是双向认证, 都有随机数的产生和发送. 下图是随机数的产生流程图: 生成对话密钥, 一共需要三个随机数. 推荐推荐在线流程图工具: ProcessOn. 推荐博文: 1.图解SSL/TLS协议 2.HTTPS的七个误解(译文) 3.对称加密和非对称加密介绍和区别 本文中参考了上面文章的部分内容, 感谢这些作者.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>HTTP HTTPS TLS SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATS: HTTP/HTTPS 协议介绍]]></title>
    <url>%2F2017%2F02%2F06%2FATS-HTTP-HTTPS-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[苹果在2017年要求 App 必须支持 HTTPS, 不过, 这个要求, 最后又被苹果自己延期了. 我只能说, 苹果的开发哥哥们真会玩… 该系列博客介绍 iOS 上面的 ATS 以及相关的 HTTPS 知识, 分为三篇来分享. 本篇是第一篇. 第二篇: ATS: HTTPS 认证 今天先简单了解一下 HTTPS 以及相关的知识. 相关名词先了解一下相关的常用名词. 1.HTTPHyperText Transfer Protocol, 超文本传输协议. 2.HTTPSHyper Text Transfer Protocol over Secure Socket Layer, 安全的超文本传输协议. 3.SSLSecure Socket Layer, 安全套接字层. 4.TLSTransport Layer Security, 传输层安全.其前身就是 SSL. 5.ATSApp Transport Security, 应用传输安全. 协议介绍HTTPHyperText Transfer Protocol, 超文本传输协议，是互联网上使用最广泛的一种协议，所有 WWW 文件必须遵循的标准. HTTP 协议传输的数据都是未加密的, 也就是明文的, 因此使用 HTTP 协议传输隐私信息非常不安全. 默认使用 TCP 端口为 80. HTTPS安全的超文本传输协议, Hyper Text Transfer Protocol over Secure Socket Layer, 网景公式设计了 SSL(Secure Socket Layer) 协议用于对 HTTP 协议传输的数据进行加密，保证会话过程中的安全性. 默认使用 TCP 端口为 443. 拆分 HTTPSSSL 协议加密方式SSL 协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL 对传输内容使用对称加密. 1.对称加密速度高，可加密内容较大，用来加密会话过程中的消息. 2.公钥加密加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥. HTTP+SSLHTTPS, 可以看做是 HTTP+SSL, 所以重点在 SSL 上面. HTTPS在 HTTP (超文本传输协议)基础上提出的一种安全的 HTTP 协议，因此可以称为安全的超文本传输协议。 HTTP 协议直接放置在 TCP 协议之上，而 HTTPS 提出在 HTTP 和 TCP 中间加上一层加密层. 从发送端看，这一层负责把 HTTP 的内容加密后送到下层的 TCP，从接收方看，这一层负责将 TCP 送来的数据解密还原成 HTTP 的内容. SSL(Secure Socket Layer)是 Netscape 公司设计的主要用于 WEB 的安全传输协议.它在 HTTPS 协议栈中负责实现上面提到的加密层. 一个 HTTPS 协议栈大致是这样的： TLSHTTPS，也称作 HTTP over TLS. TLS(传输层安全, Transport Layer Security) 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3. 苹果 ATS(App Transport Security), 要求支持 HTTPS 的 TLS 版本最低为 V1.2. 下图描述了在 TCP/IP 协议栈中 TLS(各子协议）和 HTTP 的关系: 其中 Handshake protocol，Change Ciper Spec protocol 和 Alert protocol 组成了 SSL Handshaking Protocols. SSL 和 TLS 的发展历史: 1994年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布. 1995年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞. 1996年，SSL 3.0 版问世，得到大规模应用. 1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版. 2006年和2008年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版.最新的变动是2011年 TLS 1.2 的修订版. TLS 1.3 改动会比较大，目前还在草案阶段. HTTP 和 HTTPS 区别HTTPS 和 HTTP 的区别主要为以下四点: HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费. HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SLL/TLS 加密传输协议(非对称加密). HTTP 和 HTTPS 不同的连接方式，用的端口也不一样，前者是 80，后者是 443. HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ATS HTTP HTTPS SSL TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: Yarn]]></title>
    <url>%2F2017%2F02%2F05%2FRN-Yarn%2F</url>
    <content type="text"><![CDATA[React Native 正式版已经更新到 0.41.1 了. 最近使用 react-native-cli 来创建 React Native 工程, 提示如下信息: 123This will walk you through creating a new React Native project in /Users/mark/workspace/mzProjs/ReactNative/LatestRNInstalling react-native...Consider installing yarn to make this faster: https://yarnpkg.com 其实 Yarn 也一直在更新, 最新版本 v0.20.0. 官网对应的有中文版本和中文文档, 可以 点此进入. Yarn 简介一句话介绍: A new package manager for JavaScript Yarn 是一个依赖管理工具，它能够管理你的代码，并与全世界的开发者分享你的代码. Yarn 是高效、安全和可靠. 1.高效: 使用了缓存, 可以很快的获取已经 download 的包.2.安全: 在代码被执行之前，会使用CheckSum算法验证每一个依赖包的完整性.3.可靠: 在不同平台(windows/mac/linux)只要是同一份配置文件, 执行结果是一样的. 还有很多特性: 123456789101112Offline ModeIf you&apos;ve installed a package before, you can install it again without any internet connection.DeterministicThe same dependencies will be installed the same exact way across every machine regardless of install order.Network PerformanceYarn efficiently queues up requests and avoids request waterfalls in order to maximize network utilization.Same PackagesInstall any package from npm and keep your package workflow the same.Network ResilienceA single request failing won&apos;t cause an install to fail. Requests are retried upon failure.Flat ModeResolve mismatching versions of dependencies to a single version to avoid creating duplicates. Yarn 能够让你使用其他开发者开发的代码，让你更容易的开发软件. 代码是通过依赖包 (有时也被称为组件). 在每一个依赖中会定义一个 package.json 文件，用来描述这个依赖包中所有要被分享的代码. Yarn 是开源的, 点击 Github 了解更多. 对比 npm 和 yarn, 可以阅读文章:Yarn vs npm: Everything You Need to Know 中文版:译 Yarn vs npm: 你需要知道的一切 安装 Yarn具体安装的教程, 可以参考官网的 安装教程. 在 MacOS 上面使用 Homebrew 安装很方便, 两个命令即可完成. 下面具体说说操作步骤. 强烈开发同事购买一个 VPN, 这个年头没有 VPN, 日子不好过. 1.更新 brew 1brew update --verbose 最后加上参数 --verbose, 不然等待的过程很煎熬, 没有任何提示信息. 2.安装 yarn 1brew install yarn 在安装过程中, 如果提示如下信息: 12345Please note by default only English locale support is provided. If you needfull locale support you should either rebuild with full icu: `brew reinstall node --with-full-icu`or add full icu data at runtime following: https://github.com/nodejs/node/wiki/Intl#using-and-customizing-the-small-icu-build 可以重新安装已经安装的 node, 执行命令: 1brew reinstall node --with-full-icu 在执行上面安装命令的时候, 如果卡住不动或者很久, Ctrl+C 终止当前的操作, 重新操作一遍即可. 安装成功后, 可以查看安装的版本信息, 执行 1yarn --verbose 会显示如下信息: 12345yarn install v0.20.0verbose Performing &quot;GET&quot; request to &quot;https://yarnpkg.com/latest-version&quot;.[1/4] 🔍 Resolving packages...success Already up-to-date.✨ Done in 0.29s. 使用 brew 安装 Yarn 后, 不需要设置环境变量. Yarn 与 React Native在 React Native 0.37 版本中已经加入了对 Yarn 的支持. 可以在 React Native 的官方的这篇 Blog 找到更多信息. 用 Yarn 创建 React Native 工程 既然 RN 已经支持了 Yarn, 那么就可以使用 Yarn 来管理和创建 RN 工程了. 使用 Yarn, 必须满足几个条件: 1.react-native-cli 的版本不能小于 1.2.0 版本.2.React Natvie 必须是 0.37 及以上的版本. 1react-native init MZLatestRN 当你安装好 Yarn 后, 执行上面的命令可以出现提示信息: 123This will walk you through creating a new React Native project in ~/workspace/Projs/ReactNative/MZLatestRNUsing yarn v0.20.0Installing react-native... 可以看出, RN 会使用 Yarn 来创建工程. 其中, ~/workspace/Projs/ReactNative 是我本地的工作目录. MZLatestRN 是要创建的 RN 工程名称. 如果你的网络好的话, 大概1分钟就可以创建成功. 工程目录: 可以看出多了 yarn.lock 文件. Yarn 还在茁壮成长, 希望它越来越好, 更多的使用和工作原理可以参考 官方 Doc, 介绍的很详细.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative iOS Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 PHP 遇到的问题]]></title>
    <url>%2F2017%2F02%2F02%2F%E5%AE%89%E8%A3%85-PHP-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简介在博客 PHP 开发准备 介绍了安装并部署 PHP 程序到 Nginx. 今天分享在安装中遇到的问题和其他工具的安装, 以及常用的操作, 包括 MySQL, Nginx 等. pecl 安装 PEAR 是 PHP 扩展与应用库(PHP Extension and Application Repository) 的缩写。它是一个 PHP 扩展及应用的一个代码仓库，简单地说，PEAR 就是 PHP 的 CPAN. PECL (PHP Extension Community Library)，PHP 的扩展库，它提供了一系列已知的扩展库，由 C++ 等其他语言编写而成，以 .so 形式出现，.so 为共享库, 是 shared object, 用于动态连接的, 和 dll 差不多，为比 PEAR 更快，但是与 PEAR 不同的是，PECL 需要在服务器上配置并被注册到主机中. 最直接的表述: PEAR 是 PHP 的上层扩展，PECL 是 PHP 的底层扩展. 下面说如何安装 pecl 和 pear. 1.下载 pear 1curl -O http://pear.php.net/go-pear.phar 2.安装 pear 1sudo php -d detect_unicode=0 go-pear.phar 3.执行以上命令后会进行安装过程，会有一些配置选项 输入1，回车，配置 pear 路径为：/usr/local/pear输入4，回车，配置命令路径为：/usr/local/bin 4.回车两次，其他让其默认，安装完成. 5.可以通过命令检查 pear 是否安装成功 1pear version 或者执行: 1pecl version 可以看到类似信息: 123PEAR Version: 1.10.1PHP Version: 5.6.27Zend Engine Version: 2.6.0 常用操作MySQL 操作基本操作： 1234mysql.server start #启动mysql.server stop #停止mysql -u root -p #用 user 和 pwd 连接php-fpm 相关操作 1.运行 php-fpm 1sudo php-fpm -D 2.关闭 php-fpm 1sudo killall php-fpm 3.查看 php-fpm 运行状态 1sudo lsof -Pni4 | grep LISTEN | grep php 可以看到 (fpm 默认在 9000 端口) 1234php-fpm 84200 root 8u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 84201 _www 0u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 84202 _www 0u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 84203 _www 0u IPv4 0x91959c43a1ea5abd 0t0 TCP 127.0.0.1:9000 (LISTEN) 4.php-fpm 开机启动 12ln -sfv /usr/local/opt/php56/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.php56.plist Nginx1.测试配置是否有语法错误 1nginx -t 2.启动 nginx 1sudo nginx 3.重新加载配置|重启|停止|退出 nginx 1nginx -s reload|reopen|stop|quit 4.开机启动： 12ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist 5.nginx 监听 80 端口： 12sudo chown root:wheel /usr/local/Cellar/nginx/1.6.0_1/bin/nginxsudo chmod u+s /usr/local/Cellar/nginx/1.6.0_1/bin/nginx 常用目录因为使用了 Homebrew 安装的 PHP, 配置文件的目录不是常规的 /etc 这里有几个目录需要知道, 如下: 123/private/etc/usr/local/etc/php/5.6/usr/local/var/www 遇到问题1.执行 sudo php-fpm -D 报 php56-intl/intl.so 加载问题 warning 的内容大致如下: 123456789NOTICE: PHP message: PHP Warning: PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found in Unknown on line 0&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;: PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;Unknown(0) : Warning - PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found[31-Dec-2016 22:40:38] NOTICE: PHP message: PHP Warning: PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match in Unknown on line 0 解决方案: 执行下面的命令, 即可解决.方案来源 Github. 1brew reinstall --build-from-source php56-intl 2.执行 sudo php-fpm -D 报 PHP Startup: mcrypt: Unable to initialize module 12345678910111213141531-Dec-2016 22:56:51] NOTICE: PHP message: PHP Warning: PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match in Unknown on line 0&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;: PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;Unknown(0) : Warning - PHP Startup: mcrypt: Unable to initialize moduleModule compiled with build ID=API20131226,NTSPHP compiled with build ID=API20131226,NTS,debugThese options need to match 解决方案: 1brew reinstall --build-from-source php56-intl 3.连接 mysql 使用 mysql -u root -p 连接 mysql, 提示 Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock 错误. 解决方案: 启动 mysql 1mysql.server start 重新连接即可.]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>PHP MySql nginx php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 开发准备]]></title>
    <url>%2F2017%2F02%2F02%2FPHP-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[注意：这篇文章是基于 Homebrew 安装 php5.6 以及 nginx 和 mysql 的介绍，安装高版本的 php 请绕行。 简介亲自实践在 MacOS 上面安装 PHP5.6+MySQL+Nginx. 将自己遇到的问题和对应的解决方案, 分享出来, 希望能帮到你. MacOS 上面搭建 PHP 开发环境, 使用 Homebrew 来安装对应的开发套件, 就更加简单了. 这篇博客的目的就是安装 PHP 开发环境, 并将第一个 PHP 程序部署在 Nginx 上面. 如果在安装和使用过程中遇到问题, 可以查看这篇博客: Mac PHP 安装遇到的问题. 下面开始介绍具体的安装步骤. 一. 安装 Homebrew这个大家可以自行访问 Homebrew 了解, 这里不再涉及具体的安装过程和方法. 二. 安装 php56 1.加入官方源 123brew tap homebrew/dupesbrew tap homebrew/versionsbrew tap homebrew/php 2.安装 PHP 默认安装会运行在 Apache 下.而我们要使它运行在 PHP-fpm 下，所以要增加参数: 1--with-fpm --without-apache 查看所有安装参数可以输入: 1brew option php56 进行查看，参考安装指令： 123456789101112brew install php56 \--without-snmp \--without-apache \--with-debug \--with-fpm \--with-intl \--with-homebrew-curl \--with-homebrew-libxslt \--with-homebrew-openssl \--with-imap \--with-mysql \--with-tidy 这里使用了下面的选项: 1with-homebrew-curl 我试过不带此选项, 安装 PHP56 会失败, 找不到 curl. 安装成功后, 可以查看版本信息: 12php -vphp-fpm -v 此时看到是的系统自带的版本. 下面一步是增加环境变量, 完成后在看版本信息, 即可. 3.配置 PHP 环境变量 配置环境变量的目的是要使用 brew 安装的 PHP 和 PHP-fpm, 不使用 MacOS 自带的 PHP 版本. /usr/local/sbin/ 下面是我们 brew 安装的 PHP, 其实他是一个软连接指向:/usr/local/Cellar/php56/5.6.27_4/sbin /usr/local/bin/ 下面也是 brew 安装的 PHP, 指向:/usr/local/Cellar/php56/5.6.27_4/bin vim ~/.bash_profile 增加 1export PATH=&quot;/usr/local/sbin:$PATH&quot; 使其立即生效, 执行 1source ~/.bash_profile 或者重启终端. 如果想看系统的 PHP 版本可以这样: 1/usr/bin/php -v 4.配置 php-fpm 1sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf 1sudo vi /private/etc/php-fpm.conf 找到 error_log 项，添加下面配置： 12error_log = /usr/local/var/log/php-fpm.logpid = /usr/local/var/run/php-fpm.pid 否则会报: 1FPM initialization failed 三. 安装 nginx1brew install nginx 创建文件 12345mkdir -p /usr/local/var/logs/nginxmkdir -p /usr/local/etc/nginx/sites-availablemkdir -p /usr/local/etc/nginx/sites-enabledmkdir -p /usr/local/etc/nginx/conf.dmkdir -p /usr/local/etc/nginx/ssl 1234567sudo mkdir -p /var/wwwsudo chown :staff /var/wwwsudo chmod 775 /var/wwwvi /var/www/info.phpvi /var/www/index.htmlvi /var/www/403.htmlvi /var/www/404.html 改变 nginx.conf 配置文件 该配置文件在 /usr/local/etc/nginx/nginx.conf 下面. 我的配置: 1234567891011121314151617181920212223242526272829303132333435363738worker_processes 1; error_log /usr/local/etc/nginx/logs/error.log debug;pid /usr/local/var/run/nginx.pid; events &#123; worker_connections 256;&#125; http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*; include /usr/local/etc/nginx/conf.d/*; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php &#125; &#125;&#125; 注意: 1234location / &#123; root ~/projs/phpdev/nginx/nginx_sites/; #web的根目录 index index.php index.html index.htm; #加index.php&#125; 配置了我的 web 目录和支持的文件. 四. 运行 PHP创建 index.php 启动 PHP-fpm 1sudo php-fpm 或者以守护进程的方式来启动 PHP-fpm 1sudo php-fpm -D 启动 Nginx 1sudo nginx 编辑 index.php 在 web 目录(我配置的) /Users/mark/workspace/mzProjs/phpdev/nginx/nginx_sites/ 新建文件 index.php. index.php 里面可以编写代码: 12345678910&lt;!-- lang: php --&gt;&lt;!-- ~/nginx_sites/index.php --&gt;&lt;?php echo &quot;Hello PHP&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;学习 php&quot;; echo &quot;&lt;/br&gt;&quot;; echo phpinfo();?&gt; 打开浏览器, 你会看到下面的页面: 也可以在该目录下创建其他 php 文件, 如 mark.php 文件. 浏览器中输入:http://localhost:8080/mark.php 可以执行相对应的文件. 这里的 mark.php 是自己新建的 php 文件. 五. 安装 MySQL1brew install mysql 等待安装成功后，直接启动和连接数据库。 启动 mysql 1mysql.server start 连接 mysql 1mysql -u root -p]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>PHP MySql nginx php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过年回家这几天]]></title>
    <url>%2F2017%2F01%2F31%2F%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6%E8%BF%99%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[从放假回家到现在已经一个多星期了, 感触颇多. 主要有以下几个感触: 1.健康最重要.2.坚持做好一件事情.3.感恩. 健康前两年回家, 还能见着很多长辈, 互相嘘寒问暖, 家长里短的闲聊, 如今有些已离我远去. 无情的疾病夺走了尚未花甲的他们, 让人不禁感叹生命的脆弱. 我小的时候, 很喜欢和长辈们聊天. 主要是他们讲, 我做一个小小的听众, 觉得他们懂得特别多, 从天文到地里, 从文学到艺术, 讲的有声有色.每逢夏季, 我都会搬着小板凳, 在屋前的老树下, 纠缠他们, 逼着嚷着让他们给我讲故事, 甭提有多高兴. 如今, 老树犹在, 他们已不在人世.睹物思人. 农村大部分人, 不太关注自己的健康, 唯一衡量自己身体状况的标准就是 米饭馒头能吃多少. 很多人, 明明已经感觉到身体不适, 也不愿意去医院做检查, 就这样日积月累成疾.等实在忍受不了才去医院检查, 为时已晚. 平时不注意自己的身体, 身体早晚都会让你注意. 无论平时工作再忙, 也要坚持锻炼, 没有健康的体魄, 其他的都是扯淡. 坚持农村这几年鼓励年轻人在家创业, 搞养殖. 有很多人放弃了打工, 回家拿着补贴开始有模有样的创业. 前几年回老家, 看到各种搞养殖的, 有养鸡养鸭养鹅的, 有养羊养猪养牛的, 如雨后春笋, 遍地开花. 但是今年回家, 看到很多荒凉的房子, 无人问津. 我问过几个小伙子(之前在家搞养殖的人, 最后放弃了的).他们跟我说的基本都一样, 太累了, 收益慢!搞养殖, 的确很累, 也很枯燥无味, 每天和这些不会说话的动物们待在一起, 喂它们吃喝, 管他们温饱, 实在乏味. 另外有两个年轻人, 从开始养殖到现在已经坚持五六年了, 搞得风生水起, 家里盖起了楼房, 取了巧媳妇, 生了胖小子, 一家人其乐融融.他们跟我说的基本一样, 只要坚持, 就有收获! 这两个坚持下来的年轻人, 他们相信自己能够把这份事业做好, 他们把别人眼中的脏活累活当做一种快乐, 一种享受! 刚开始, 很艰难, 他们也想过放弃, 但是又舍不得这几年的付出, 于是就坚持下来了, 并且收获了不少意想不到的知识, 不管是物质上还是精神上都得到了满足. 世上, 没有一帆风顺的事业. 只要自己喜欢, 感兴趣的行业, 就值得你去坚持.如果你从内心都不感兴趣, 趁早放弃, 因为你很难坚持下来. 想投机取巧的成就一份事业, 只有神话故事里有吧! 不经一番寒彻骨, 哪得梅花扑鼻香! 感恩小的时候, 家里很拮据, 我能够把大学念完, 简直就是天意. 父母永远只会对我说一句话, 只要你想上学, 我们就支持到底. 我知道家里的经济情况, 所以在学习上也是不遗余力, 每次放学除了帮爸爸妈妈干农活, 就是完成家庭作业, 练字背书. 那个时候, 不知道哪来的狠劲, 即使是寒冬腊月, 也要坚持写作业, 即使是手都冻肿了, 也要练字. 当我接到重点高中通知书的那天, 父亲高兴的合不拢嘴, 心理充满了骄傲. 我能感觉到…… 然而考上高中, 接下来就是凑钱交学费, 隔壁有个伯伯, 他说学费不够, 算他的.那个时候, 大家家里都不宽裕, 能借钱给你的, 简直就是大恩人.一直到现在, 我都很感激他, 每年过年回家, 我都会给伯伯买点礼物, 给个红包, 陪他聊聊天.他还开玩笑的说, 当年自己的投资, 算是有了回报了. 这辈子, 我们最应该感谢的是我们自己的父母, 养育我们成人, 送我们读书上学. 过年回家, 要多陪陪他们, 珍惜和他们在一起的每一刻.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习杂谈]]></title>
    <url>%2F2017%2F01%2F27%2F%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[今天是中国传统节日, 大年三十, 祝大家新年快乐, 身体健康, 幸福美满. 引子最近无论是朋友还是同事或者博友, 都问过我关于学习方面的事情. 探讨的问题大概分为如下几种: 怎么有效的学习新知识?怎么快速掌握新知识?是否有必要每天学习?如何坚持学习?谈到关于学习的话题, 我也不是什么专家, 更不是心理咨询师, 只是谈谈个人的一些看法和经历, 希望能给大家带来一点点的帮助. 不要只是嘴上说 我感兴趣, 如果没有驱动和目标, 兴趣永远都只是兴趣. 你为什么学习它学习知识之前, 问问自己为什么要学它? 大部分人学习新东西都是为了工作或者为了更好的工作或者为了转行或者其他目的, 也有一部分人是为了兴趣爱好. 这里我只谈为了工作而去学习新知识的内容, 其他方面的我自己也没有什么心得体会, 不能乱说. 既然为了工作或者更好的工作来学习, 那么我们就明确了目标, 如果你已经有了目标, 恭喜你, 你即将成功了. 有一些人说, 我学习它, 这个东西不一定哪天就有用了, 我怕将来失业.这中担心不是在杞人忧天, 特别是在互联网的时代, 如果不学习很容易就落伍啦, 君担心完全在理! 但是, 当下你最应该考虑的是目前掌握的技能是否已经熟练了, 是否是能够独当一面了, 如果深学下去会不会更有前途? 如果是, 请你深入去学习, 不要太杞人忧天了! 在精钻一门学问的情况下, 可以扩大自己的知识面, 而不是 吃着碗里看着锅里 的, 要脚踏实地的大步向前. 坚持学习上面的扯淡有点多啊.回正题. 既然搞清楚了为什么学习它, 接下来就是搞定它. 你需要有坚持学习的态度和行动, 不然一切都会成为云烟. 那么当初咬牙切齿的抱负, 结果都是冲动的惩罚. 学习新知识的前期是很累的, 但是只要你意志足够坚定, 一定可以克服种种困难. 记得当初接手一个二手项目, 项目也是足够复杂, 并且有很多引擎之前都没有用过, 上面领导逼得比较紧, 没办法, 只能将其拿下, 每天晚上挑灯夜战, 在 log 的海洋里遨游. 很快自己掌握了新的知识, 结合项目, 不断的去调试和总结, 最终按期完成需求, 回过头想想, 想要坚持做好一件事情, 除了自身的自我约束, 还需要外界环境的 倒逼. 当你坚持不住的时候, 问问自己, 是否已经到了极限, 如果感到累了, 适当的放松一下, 比如出去跑个步, 打个球或者找朋友叙叙旧. 适当的给自己一点压力, 事半功倍. 学习的渠道刚开始学习新知识, 大家都渴望有一些大牛能够指导自己, 或者能够从前辈那里获取一些武林秘籍, 这些都是学习的渠道. 有些小伙伴在学习的过程中, 会遇到各种各样的困难, 比如在学习一门知识的时候, 发现竟然还需要学习另一门新知识, 真是日了狗了!到这里, 可能有些人就会情不自禁的选择了放弃, 嘴上说还在学习, 其实心里已经疲倦. 还有一些初学者, 他们没有什么经验, 如果主动性再差点, 动辄遇到问题就问, 根本没有过思考, 哪怕是一点点的思考都没有.其实他们不是不想搞, 就怕搞错了.仅仅是因为怕, 就戛然而止了!这种人, 确实可惜, 所以他们需要更多的指导和教育.这里提醒大家, 学习知识, 不要怕犯错, 大胆的去试错, 在错误中成长, 这样你才能有所收获. 记得以前为了安装 linux, 我把办公室的办公电脑都格式化了, 组长差点要开除我了, 现在想想虽然挨了骂, 但是挺值得. 现在互联网很发达, 想学习的东西基本网上都有, 你可以没有智商, 没有情商, 但是你一定要有 搜商 (搜索能力).当你自己经过思考, 无法解决问题, 就去搜索相关的知识, 如果搜索也失败了, 再去请教别人, 这样你就可以从中收获意外的惊喜. 所以, 学习渠道的重要来源之一就是在互联网搜索, 培养自己的搜索能力很重要, 我建议大家使用谷歌浏览器, 然后使用 google 的搜索引擎, 搭建一套翻墙的 VPN, 这样你可以在知识的海洋里爽翻. 另外一个比较重要的学习渠道就是你认为的牛人, 向他们学习相关的学习方法, 问他们是怎么学习的, 然后结合自己的实际情况加以运用, 跟他们多交流. 对自己’狠’一些我之前有个坏习惯, 喜欢晚上躺在床上看视频, 这些视频可能是优酷或者腾讯视频客户端的, 也有可能是新闻类的 app 来源的视频.视频只要看起来, 时间就不受控制了.第二天早晨起床也很困难. 最后自己把视频类和新闻类 app 全部卸载掉了, 然后把目标转移到 stackoverflow 和 github 上面.那里才是程序员的世界, 只有你想不到的, 没有做不到的. 为了学习新知识, 你需要对自己狠一点, 每天拿点时间出来总结和学习, 一个月一个季度一年下来, 你比别人都进步了很多. 养成一个好习惯, 终生受益.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学习 生活 反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 聊聊 UIWebView 缓存]]></title>
    <url>%2F2017%2F01%2F15%2FiOS-%E8%81%8A%E8%81%8A-UIWebView-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[前言在开发项目过程中, 一些若交互的页面会使用 HTML 展示. 在 iOS 中, 使用 UIWebView 的频率还是比较高的. 今天跟大家聊聊 UIWebView 缓存相关的话题. 准备工作我今天使用 Tomcat 来作为 web 容器, 在本机搭建一个 web 服务器, 然后使用 iPhone 访问该 web 页面, 展示和梳理 UIWebview 关于缓存的问题. 如果你对 Tomcat 还不熟悉, 希望你可以先去大概了解一下, 如何在 Mac os 上面安装和使用 Tomcat, 可以参考我的博文: [Mac 配置 Tomcat8]. Tomcat 是一个开放源代码、运行 servlet 和 JSP Web 应用软件的基于 Java 的 Web 应用软件容器.Tomcat Server 是根据 servlet 和 JSP 规范执行的，因此可以说 Tomcat Server 实行了 Apache-Jakarta 规范，且比绝大多数商业应用软件服务器要好.但是 Tomcat 对静态文件、高并发的处理比较弱. 写这篇文章的时候, 我使用的版本分别是 apache-tomcat-8.5.8, jdk1.8. 配置 Tomcat修改 server.xml 文件文件在 Tomcat 的根目录的 conf 目录下, 如我的文件在这个目录: 1apache-tomcat-8.5.8/conf/server.xml 增加如下内容: 1234&lt;Host name=&quot;&lt;your local ip&gt;&quot; debug=&quot;0&quot; appBase=&quot;&lt;base dir&gt;&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;&lt;html file path&gt;&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;&lt;/Host&gt; 注意:1.将上述内容放到 &lt;/Host&gt; 和 &lt;/Engine&gt; 节点中间.2.将 name=&quot;&lt;your local ip&gt;&quot; 中的 改为你本机的 ip 地址.查看本机的 ip 地址方法很简单: 1ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 3.将 appBase=”“ 中的 改为你的 web 目录.4.将 docBase=”“ 中的 改为你的 html 目录. 我的配置如下(部分): 1234567891011121314151617181920212223 &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; &lt;/Host&gt; &lt;!--mark 配置静态网页. [BEGIN] --&gt; &lt;Host name=&quot;192.168.1.103&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt; &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt; &lt;/Host&gt; &lt;!--mark 配置静态网页. [END] --&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 搞定上面的配置, 接下来可以配置相关目录了. 在 Tomcat 的根目录有个文件夹 webapps, 在 webapps 目录下新建目录 test 即可. 构建 HTML 页面在 test 目录, 新建一个 html 文件 1touch test.html 文件内容如下: 123456789101112131415161718192021222324252627282930313233343536 &lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy&lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;&lt;p&gt;Now I input another line, with fancy &lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;.&lt;/p&gt;&lt;p&gt; mark.zhang is itman.&lt;/p&gt;&lt;style&gt;.button &#123; background-color: #4CAF50; border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 86px; margin: 50px 200px 100px 300px; cursor: pointer; border-radius: 15;&#125;&lt;/style&gt;&lt;p&gt; &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot; class=&quot;button&quot;&gt;Try it&lt;/button&gt;&lt;/p&gt;&lt;script&gt; function myFunction() &#123; alert(&quot;Blog: www.veryitman.com&quot;); &#125;;&lt;/script&gt; 搭建完成后, 启动 Tomcat 服务器. 1startup.sh 在浏览器里面通过 ip:port/test.html 的方式来访问该页面. 看到类似下面的效果即表示搭建成功: 客户端访问客户端访问该页面, 使用 UIWebview 来请求(HTTP 协议)页面内容. 一般请求会使用下面的方法: 1+ (instancetype)requestWithURL:(NSURL *)URL; 该方法的描述如下: 12Creates and returns a URL request for a specified URL with default cache policy and timeout value.The default cache policy is NSURLRequestUseProtocolCachePolicy and the default timeout interval is 60 seconds. 大概意思是使用的缓存策略是根据协议来的, 即 NSURLRequestUseProtocolCachePolicy. 超时时间默认是60s. 也就是说类似如下的请求: 1NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60.f]; 如果协议支持缓存的话, UIWebview 请求到的数据就是缓存数据.该缓存是需要 WEB 服务器支持的. 这里我没有配置 Tomcat 的缓存.可以抓包看下: 后续博客会分别为大家介绍在 Tomcat 和 Nginx 配置缓存下, 客户端 UIWebview 请求的相关问题. 客户端显示页面效果: ViewController 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#import &quot;ViewController.h&quot;static NSString * const H5Url = @&quot;http://192.168.1.104:8080/test.html&quot;;@interface ViewController () &lt;UIWebViewDelegate&gt;@property (nonatomic, strong) UIWebView *webView;@property (nonatomic, strong) UIButton *refBtn;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; _webView = [[UIWebView alloc] init]; CGSize boundsSize = self.view.bounds.size; self.webView.frame = CGRectMake(0, 20, boundsSize.width, boundsSize.height); self.webView.backgroundColor = [UIColor whiteColor]; self.webView.scrollView.showsHorizontalScrollIndicator = NO; self.webView.scrollView.showsVerticalScrollIndicator = NO; self.webView.scalesPageToFit = YES; self.webView.delegate = self; [self.view addSubview:self.webView]; UIButton *refreshBtn = [UIButton buttonWithType:UIButtonTypeCustom]; [self.view addSubview:refreshBtn]; [refreshBtn addTarget:self action:@selector(onRefreshWebView) forControlEvents:UIControlEventTouchUpInside]; refreshBtn.backgroundColor = [UIColor redColor]; refreshBtn.layer.masksToBounds = YES; refreshBtn.layer.cornerRadius = 5.f; refreshBtn.frame = CGRectMake(50, 250, 200, 50); [refreshBtn setTitle:@&quot;刷新页面&quot; forState:UIControlStateNormal]; _refBtn = refreshBtn; [self loadDataUsingCache];&#125;- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error&#123; NSLog(@&quot;didFailLoadWithError: %@&quot;, error); [self hideLoading];&#125;- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSLog(@&quot;shouldStartLoadWithRequest: %@&quot;, request); return YES;&#125;- (void)webViewDidStartLoad:(UIWebView *)webView&#123; NSLog(@&quot;webViewDidStartLoad&quot;);&#125;- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; NSLog(@&quot;webViewDidFinishLoad&quot;); [self hideLoading];&#125;//刷新页面.- (void)onRefreshWebView&#123; // 方式1: 不使用缓存请求数据 //[self loadDataNoUsingCache]; // 方式2: 清除 NSCache 缓存, 再请求数据 [self clearAllCache]; [self loadDataUsingCache];&#125;- (void)loadDataUsingCache&#123; [self showLoading]; NSURL *url = [NSURL URLWithString:H5Url]; NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataDontLoad timeoutInterval:10.f]; [self.webView loadRequest:urlReq];&#125;- (void)loadDataWithProtocol&#123; [self showLoading]; NSURL *url = [NSURL URLWithString:H5Url]; [NSURLRequest requestWithURL:url]; NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60.f]; [self.webView loadRequest:urlReq];&#125;- (void)loadDataNoUsingCache&#123; [self showLoading]; NSURL *url = [NSURL URLWithString:H5Url]; NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:20.0]; [self.webView loadRequest:urlReq];&#125;- (void)clearAllCache&#123; // remove cache rsp [[NSURLCache sharedURLCache] removeAllCachedResponses]; [[NSURLCache sharedURLCache] setDiskCapacity:0]; [[NSURLCache sharedURLCache] setMemoryCapacity:0];&#125;- (void)showLoading&#123; [self.refBtn setTitle:@&quot;刷新中...&quot; forState:UIControlStateNormal];&#125;- (void)hideLoading&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [self.refBtn setTitle:@&quot;刷新页面&quot; forState:UIControlStateNormal]; &#125;);&#125;@end 这里注意下面的 三个方法 : 123456789// 使用缓存数据, 如果有缓存的话// 使用这个方法, 改变 HTML 或者 JS 代码// 页面不会拉取最新数据, 还是使用之前请求到的数据.// 除非重新刷新- (void)loadDataUsingCache;// 使用协议缓存, 需要 web 服务器支持.- (void)loadDataWithProtocol;// 不使用缓存, 加载数据- (void)loadDataNoUsingCache; 另外, 刷新 UIWebview 的方式如下, 有 两种方式 来刷新页面: 123456789101112/** * 刷新页面. */- (void)onRefreshWebView&#123; // 方式1: 不使用缓存请求数据 //[self loadDataNoUsingCache]; // 方式2: 清除 NSCache 缓存, 再请求数据 [self clearAllCache]; [self loadDataUsingCache];&#125; 这种刷新方式, 会重新加载数据.但是不适合多层级的 HTML 页面, 比如你的 HTML 页面有很多层, 想刷新当前页面, 可以使用下面的方式: 12// 重新加载当前页面[self.webView reload]; 附加查看本机 IP 的 shell 12#!/bin/shifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 停止 Tomcat 的运行 1shutdown.sh]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS UIWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[f8app]]></title>
    <url>%2F2017%2F01%2F01%2Ff8app%2F</url>
    <content type="text"><![CDATA[本文主要探讨的是如何编译和运行 f8app. 介绍f8app 是 Facebook 开源的, 基于 React Native 开发的一款 App. 代码基本都是 js 的, 很少有原生的代码. f8app 是借鉴和学习 React Native 的上好资料. 原文介绍: This is the entire source code of the official F8 app of 2016, available on Google Play and the App Store. 项目开源地址: Github 编译运行环境要求 安装和配置了 React Native 开发环境. Xcode 7.3 + CocoaPods (only for iOS) 1.0+ MongoDB (needed to run Parse Server locally) 源码构建下载源码 1git clone https://github.com/fbsamples/f8app.git 下载完成后, 进入下载的 f8app 目录 12cd f8appnpm install 如果是 iOS 的话, 需要进入 iOS 目录执行 pod install 12cd iospod install 在项目 f8app 目录下运行: 1npm start 打开浏览器输入地址 http://localhost:8080, 可以看到 graphql 的界面. 安装 MongoDB使用 Homebrew 来安装. 1brew install mongodb 导入数据导入例子数据. 注意:在源码的路径即 ~/yourpath/f8app 下面执行, 下面操作没有特殊说明都是在源码根目录下面操作.你可以多开几个终端端口来进行操作. 1npm run import-data 导入例子数据, 会报下面的 错误: 123456error: Uncaught internal server error. &#123; [MongoError: connect ECONNREFUSED 127.0.0.1:27017]name: &apos;MongoError&apos;,message: &apos;connect ECONNREFUSED 127.0.0.1:27017&apos; &#125; Error: connect ECONNREFUSED 127.0.0.1:27017at Object.exports._errnoException (util.js:893:11)at exports._exceptionWithHostPort (util.js:916:20)at TCPConnectWrap.afterConnect as oncomplete 需要安装 mongodb-runner 安装方法如下: 1sudo npm install -g parse-server mongodb-runner 运行 mongodb-runner: 1mongodb-runner start 这里执行完毕后, 需要等待一会. 你会看到如下信息: 1Starting a MongoDB deployment to test against... 上面运行结束后, 你可以查看 MongoDB 是否在运行: 1lsof -iTCP:27017 -sTCP:LISTEN 会显示当前正在运行的信息: 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmongod 86824 mark 7u IPv4 0x91959c43a65644ed 0t0 TCP *:27017 (LISTEN) 停止 mongodb 运行的方式如下: 1mongodb-runner stop 查看数据Parse Dashboard GraphiQL 启动 react-native1react-native start 运行 f8appAndroid: 123react-native run-androidadb reverse tcp:8081 tcp:8081 # required to ensure the Android app canadb reverse tcp:8080 tcp:8080 # access the Packager and GraphQL server iOS: 1react-native run-ios 如果出现红色背景的 error 提示, 可以不管, 直接 Dismiss 即可. 然后可以看到如下界面: 问题1.在运行后关闭登录按钮, 报错: 1AppEventsLogger.logEvent 解决方案: 在 /js/store/track.js 文件的第 43 行, 注释掉 log, 如下: 123case &apos;SKIPPED_LOGIN&apos;: //AppEventsLogger.logEvent(&apos;Skip login&apos;, 1); break; 在模拟器上面重新 Reload 即可.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS Android JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见 2016]]></title>
    <url>%2F2016%2F12%2F31%2F%E5%86%8D%E8%A7%81-2016%2F</url>
    <content type="text"><![CDATA[今天是2016年的最后一天，正好赶上放假，给自己的这一年做个小结。 2016，继续做项目，作为一名软件工程师，不停地在学习。 2016，学习到了很多关于产品和运营相关的知识。知道了 倒逼 的作用. 2016，读了20本非技术类书籍，养成了读书的习惯，并把读书的好处讲给身边的人听。 2016，开始减肥，注意锻炼身体，几乎每周都有一次从公司到家的步行，一次篮球或者跑步运动。 2016，购买了域名，建立了自己的 博客网站。 2016，儿子大了一岁，自己老了一岁，家庭依旧幸福着。渐渐地理解了做父亲的责任。 2016，对自己影响最大的几句话，分享给大家: 1. 技术要给产品提供最大的自由度. 2. 不要轻易的说 NO. 3. 要不断的让自己值钱, 而不是简单的为了金钱而跳槽. 4. 不要总是抱怨你的产品设计是狗屎, 学会和产品沟通更优的方案. 5. 关注细节, 把产品做好. 6. 多关注别人的优点. 7. 让对方把话说完. 8. 多看书, 多思考. 感谢所有陪伴和支持我的朋友，同事，亲人！ 祝愿所有人2017幸福、健康、快乐！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 配置 Tomcat8]]></title>
    <url>%2F2016%2F11%2F26%2FMac-%E9%85%8D%E7%BD%AE-Tomcat8%2F</url>
    <content type="text"><![CDATA[Tomcat 简介Tomcat 是一个 Web 服务器. Web 服务器是指为特定组件提供服务的一个标准化的运行时的环境.可为组件提供事务处理, 数据访问, 安全性和持久性等服务. Tomcat 是免费且开源的, 他是 Apache 软件基金会 Jakarta 项目中的其中一个子项目.由 Apache, Sun 和其他一些公司及个人共同开发完成. Tomcat 也是使用最为广泛的 JSP 服务器. JSP 是 Java Server Pages 的简称, 是在传统的 HTML 文件中插入 Java 程序段和 JSP 标记的一种动态网页技术. 下载 Tomcat前往 这里 可以下载 Tomcat. 我目前安装的是 8.5.8 版本的. 安装先安装 JDK, 安装教程可以参考 Mac 配置 JDK1.8 这篇文章. 解压下载的 tar.gz 即可. 最好解压到自己的工作目录, 如: 1~/workspace/developr/ 配置环境变量编辑 /etc/profile 文件 1sudo vim /etc/profile 添加如下变量: 12345JRE_HOME=$JAVA_HOMETOMCAT_HOME=/Users/mark/developer/apache/apache-tomcat-8.5.8PATH=$JAVA_HOME/bin:$TOMCAT_HOME/bin:$PATHexport JRE_HOMEexport PATH 其中的 JAVA_HOME 是 Mac 配置 JDK1.8 这篇文章里面设置的 JDK 的环境变量. 配置环境变量的目的, 可以让我们方便的使用 Tomcat 的命令. 检验安装是否成功使 /etc/profile 配置文件立即生效. 1source /etc/profile 如果没有生效, 重启终端即可. 开启 Tomcat 服务, 执行下面的命令: 1startup.sh 该命令在 Tomcat 的安装目录的 bin 目录下面. 执行后, 可以看到: 123456Using CATALINA_BASE: /Users/mark/developer/apache/apache-tomcat-8.5.8Using CATALINA_HOME: /Users/mark/developer/apache/apache-tomcat-8.5.8Using CATALINA_TMPDIR: /Users/mark/developer/apache/apache-tomcat-8.5.8/tempUsing JRE_HOME: /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/HomeUsing CLASSPATH: /Users/mark/developer/apache/apache-tomcat-8.5.8/bin/bootstrap.jar:/Users/mark/developer/apache/apache-tomcat-8.5.8/bin/tomcat-juli.jarTomcat started. 在浏览器里面打开: http://localhost:8080/ 即可看到一只可爱的 Tom 猫. 执行 shutdown.sh 可以关闭 Tomcat.]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tomcat Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装和使用 infer]]></title>
    <url>%2F2016%2F11%2F26%2FMac-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-infer%2F</url>
    <content type="text"><![CDATA[介绍infer 是 Facebook 开源的一款代码静态检查工具, 源码可以在 Github 上面获取. 支持 Java/C/OC 等语言, 支持 Gradle, Buck, Maven, Xcodebuild, Make 等. 我一般用来分析 iOS 和 Android 工程. 可以在 这里 查看 Start. 安装 infer只要你用 Homebrew, mac 下安装 infer 很简单: 12brew updatebrew install infer 在早期版本, infer 不支持 brew 安装. 安装起来各种问题, 现在 infer 支持了 brew 安装, 很方便. 这里我使用的 infer 版本是 0.9.4. 安装成功后, 可以查看安装版本: 1infer -version 可以看到如下信息: 12345Infer version v0.9.4Copyright 2009 - present Facebook. All Rights Reserved.Mac:public mark$ infer --versionInfer version v0.9.4Copyright 2009 - present Facebook. All Rights Reserved. 这里有个问题, 有时候 brew 无法更新最新的 infer, 我目前的解决方案是先卸载之前安装的 infer, 然后再重新安装. 卸载 infer 1brew uninstall infer 安装 xcprettyxcpretty 是一款格式化 xcodebuild 输出结果的工具. 123456▸ Building X/N [(Release)]▸ Check Dependencies▸ Copying Info.plist▸ Running script &apos;[CP] Check Pods Manifest.lock&apos;▸ Running script &apos;Replace PaySdk&apos;▸ Compiling User.m 从0.9.4版本后, infer 默认使用了 xcpretty. 可以使用 gem 安装 xcpretty 工具: 1gem install xcpretty 如果没有安装成功, 或者提示权限不够, 那就这样折腾: 1sudo gem install xcpretty 想了解更多关于 xcpretty 的使用可以去 github. 使用 inferiOS 项目使用 inferinfer 的文档写的也较全面. 可以在 这里 查看使用方法. 1.分析 Cocoapods 项目 1infer -- xcodebuild -workspace N.xcworkspace -scheme NSchema 其中 N.xcworkspace 是你的 workspace 名称, NSchema 是你需要检查的 Schema 名称. 2.分析 .xcodeproj 1infer -- xcodebuild -target targetName -configuration Debug -sdk iphonesimulator 其中 targetName 是项目的 target 名称, 必须指定. 分析成功后, infer 会有输出报告. 该报告在你的项目目录下, 名称是 infer-out. bug.txt 是以文本方式输出的 issue 文档.另外还有 csv 格式的 issue 文档. Android Gradle 工程使用 infer12gradle cleaninfer -- gradle build 其他用法infer 还有很多高级的用法, 比如可以增量检查. 增量检查的功能依赖于你的编译器是否支持. infer 增量检查的选项是 –reactive. 之前的版本是 –incremental 选项.自从 v0.8.0 版本后使用了 –reactive 选项. 可以这样来进行增量检查: 1infer --reactive -- xcodebuild -workspace N.xcworkspace -scheme NSchema infer 还有很多高级用法, 可以在 Advanced usage 中去查阅和使用. 再使用过程中, 随着 MacOS, Xcode 的升级, infer 会面临更多的挑战, 如果遇到问题, 第一时间去 GitHub 上面提 issue.]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS infer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 配置 JDK1.8]]></title>
    <url>%2F2016%2F11%2F26%2FMac-%E9%85%8D%E7%BD%AE-JDK1-8%2F</url>
    <content type="text"><![CDATA[下载 JDK在 这里下载 jdk. 下载版本是 1.8u112, 信息如下: 安装 JDK下载完成后, 直接双击安装即可. 配置 Path成功安装后, 目录/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/ 就会存在. 编辑 /etc/profile 文件: 1sudo vim /etc/profile 添加如下代码: 123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/HomeCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOMEexport CLASSPATHexport PATH 保存文件. 使这个文件立即生效.可以 source 一下 1source /etc/profile 检验执行下面命令来检验 jdk 是否安装成功. 1java -version 输出如下信息, 标示配置 JDK 成功. 123java version “1.8.0_112”Java(TM) SE Runtime Environment (build 1.8.0_112-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode) 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MacOS java jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameDevelopment: 与 Cocos2d 的再相逢]]></title>
    <url>%2F2016%2F11%2F12%2FGameDevelopment-%E4%B8%8E-Cocos2d-%E7%9A%84%E5%86%8D%E7%9B%B8%E9%80%A2%2F</url>
    <content type="text"><![CDATA[认识 Cocos2d相信很多人听说过 cocos2d-x 这个引擎, 但听过 cocos2d-objc 的人应该不多. cocos2d-objc 是 cocos 系列的 objective-c 版本.开发语言是 OC.在 iOS 上面使用该版本的引擎, 基本是无缝连接(写的没有什么障碍). 欣赏一下 cocos2d-objc 的 logo, 如图: 如果你对 OC 版感兴趣, 可以通过博文 coco2d-iphone: 环境搭建 去了解. cocos2d-x 目前支持 JavaScript, lua, c++ 等主流语言来开发.cocos 还在迅猛发展中, 不断的完善开发工具, 广大游戏开发者依然热力贡献, 程序猿们在游戏的战场挥洒青春. 现在 cocos 的开发者会得到更多的支持. 下面给张图来展示 cocos 家族及其发展: 由 libgdx 转向 Cocos2d几年前, 那个时候还在开发棋牌游戏, 当时自己也是刚刚接触游戏开发这个「高逼格」的行业, 之前自己是个纯 App 开发者. 内心还是蛮激动的, 心想可能要走上人生巅峰了… 棋牌游戏, 当时使用的是 java 的游戏引擎 libgdx 0.X.X 的版本, 该引擎和 Android 基本也是无缝连接, Api 设计的很好. 现在 libgdx 也发展到了1.6.x 版本了, 工具也完善了很多. 虽然 libgdx 也可以跨平台, 但是最终我们还是选择了 cocos2d-x 来移植该游戏.其中原因是因为 cocos2d-x 太火了, 人也好找. 改为 cocos2d-x 的版本之后, 我就被安排到了另外一个项目, 也是一个棋牌游戏, 该游戏现在在腾讯的微信游戏里面运营. 这个游戏是 cocos2d-objc 的引擎写的, 自己也不会 objc, 于是硬着头皮学习, 很快的就上手了这个项目.写的也是风生水起. cocos2d-objc, 现在也支持跨平台, 并且有 xcode 的插件, 可以在 xcode 里面写 Android 的代码, 调试开发等. 因为接触 cocos2d, 后面就直接开搞 iOS 开发了. 再次使用 Cocos2d互联网 IT 业的发展, 刺激了各个行业的发展, 也促进和激发了新生的技术, 在这个行业, 每个人都能体会 活到老学到老 这句话的含义. 这两年, HTML5 的发展, 让很多程序员重新认识了 JavaScript 的重要性. 特别是最近 ReactNative 的发展, jsPacth 的开源, 微信小程序的推出, 让 JavaScript 火得不要不要的. 说实话, 是时候开始学习前端相关的技术了, 至少你需要去了解. cocos2d-js 的发展, 给 HTML 游戏开发带来了很多便利. 最近我们需要开发 H5 的游戏, 直接拿起 coco2d-x(支持 JavaScript) 就撸起. 去 GitHub 上面直接 clone 最新版就可以, 按照 README.md 来搭建环境就好了. 后记这篇博客也是有感而发, 没有实质性的内容. 主要目的是想告诉大家, 技术的发展日新月异, 想在这里大展拳脚, 你需要保持一颗年轻的心, 不怕苦, 勇往直前的精神. 我们需要学习的技术有很多, 我认为, 要根据项目本身的发展来适度的学习, 切记盲目的学习, 学习一门新技术之后, 要及时的运用在项目当中, 并分享给你身边的人. 不拒绝不排斥新技术, 坚持学习和乐于分享, 应该是必备的技能.]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Cocos2d Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac install Cocoapods]]></title>
    <url>%2F2016%2F11%2F08%2FMac-install-Cocoapods%2F</url>
    <content type="text"><![CDATA[声明这篇博客原本被我发表在 CSDN . 那里不再更新, 现在在这里做持续更新. 导引如果你的 Mac OSX 升级到 10.11.x+, 并且需要安装 Cocoapods, 可以参考本博客. 安装 rubyMac 系统自带了 ruby, 但是建议大家使用 Homebrew 安装 ruby. 因为 Cocoapods 升级需要对应的 ruby 版本也要升级, 使用 Homebrew 比较方便. 安装 ruby: 1brew install ruby 查看当前安装的 ruby 版本: 1ruby -v 会得到类似下面的信息: 1ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin15] gem 是管理 Ruby 库和程序的标准包.安装了 ruby, 自带了 gem 工具. 可以使用 gem -v 查看 gem 版本. 安装 Cocoapods1.移除原来的源, 不管以前是否安装过 Cocoapods. 1gem sources --remove http://ruby.taobao.org/ 2.重新添加源, 注意是 https. 1gem sources -a https://gems.ruby-china.org/ 之前 taobao 的源 好像已经不行了. 注意：添加源之前在浏览器打开 https://gems.ruby-china.org/ 这个地址看一看是否能访问，如果不能访问就修改一下为 https://gems.ruby-china.com 这个地址。 3.查看是否添加成功, 该步骤可选. 1gem sources -l 安装, 使用 root 权限安装. 1sudo gem install -n /usr/local/bin cocoapods 这种安装方式, 会安装最新的 release 版本. 你也可以使用下面两种方式来安装. 指定版本安装: 1sudo gem install -n /usr/local/bin cocoapods -v 1.0.0 安装最新的 release beta 版本: 1sudo gem install -n /usr/local/bin cocoapods --pre 卸载 Cocoapods卸载 Cocoapods 只需执行: 1sudo gem uninstall cocoapods 如果想删除本地的 pod repo, 可以这样: 1rm -fr ~/.cocoapods/ 建立本地 repo安装完 Cocoapods 后, 需要建立本地的 repo. 1pod setup 即使你现在不执行 pod setup, 后面进行 pod install 或者 pod update 的时候, 也会自动的进行 pod setup. 执行 pod setup 的目的是将所有第三方的 podspec 索引文件更新到本地的 ~/.cocoapods/repos 目录中. 安装使用中遇到的问题问题1: 命令行执行 pod 发生: pod command not found, 但是 sudo pod 却可以执行. 解决方案即如下步骤: [1].卸载原有的 Cocoapods 1sudo gem uninstall cocoapods [2].重新安装 Cocoapods 1sudo gem install -n /usr/local/bin cocoapods [3].赋予/usr/local/bin给予执行与读取权限: 1sudo chmod -R +rx /usr/local/bin/ 建议最好使用代(fanq)理(qiang). 问题2: 更新 gem 过程中, 遇到 1Operation not permitted - /usr/bin/update_rubygems 可以通过通过 brew 安装 ruby 解决. 1brew install ruby 问题3: pod setup 失败 失败提示信息类似: 12345Cloning into &apos;master&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案: 更新 gem 1sudo gem update --system 问题4: 添加源, 提示如下问题 1source https://gems.ruby-china.org/ already present in the cache 这个说明你已经添加过该源, 可以使用 1gem sources -l 来查看已经添加的源. 常用操作1.更新 gem 1sudo gem update --system 2.pod repo update 更新本地仓库. 3.pod search xxx 搜索 cocoapods 项目. 4.pod list 列出所有可用的库. 5.pod install 根据 podfile 和 podfile.lock来安装库. 默认会执行 pod repo update. 可以加入参数 –no-repo-update 不执行 pod repo update. 6.pod update 更新已安装的库到最新版本, 并且创建新的 Podfile.lock 文件. 该命令也会默认会执行 pod repo update. 可以加入参数 –no-repo-update 不执行 pod repo update. 更新记录2017-01-04 更新 升级 ruby 到 2.4 版本后, cocoapods 无法使用了. 升级的 ruby 版本信息: 1ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-darwin15] 12345使用任何 pod 命令都报错:/usr/local/Cellar/ruby/2.4.0/lib/ruby/2.4.0/rubygems.rb:270:in `find_spec_for_exe&apos;: can&apos;t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)from /usr/local/Cellar/ruby/2.4.0/lib/ruby/2.4.0/rubygems.rb:298:in `activate_bin_path&apos;from /usr/local/bin/pod:22:in `&lt;main&gt;&apos; 查找各种解决方案, 最终还是没有解决. 你可以在 这里 下载 Cocoapods 的 Mac 版本 App 使用. 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>CocoaPods, iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 问题集锦]]></title>
    <url>%2F2016%2F11%2F08%2FCocoapods-%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[承诺本文会持续更新, 分享在使用 cocoapods 过程中遇到的问题和解决方案. 欢迎大家补充. 安装问题可以阅读博客 Mac 安装 Cocoapods. pod search 问题 pod search 无法搜索到指定的项目 问题描述: 执行 pod search [Name], 出现类似下面的提示: 1[!] Unable to find a pod with name, author, summary, or description matching `[Name]` 解决方案: 删除 search_index.json 文件 1rm ~/Library/Caches/CocoaPods/search_index.json 然后, 重新执行: 1pod search 项目名称 如果这样行不通的话, 可以这样: 123rm -rf ~/.cocoapodsrm ~/Library/Caches/CocoaPods/search_index.jsonpod setup 如果你的网络不好, 需要漫长的等待… 这个时候, 可以去抽半盒烟了. Orz… pod setup 问题 pod setup 卡死 问题描述: pod setup 会在本地建立 cocoapods 仓库. 在执行的过程中, 你可以在 ~/.cocoapods/repos 使用du -sh * 来看 repos 目录的大小变化. 如果观察好久, 大小没有变化, 最终会出现类似下面的错误: 12345Cloning into &apos;master&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案，如下： 先更新 gem 1sudo gem update --system 再重新执行 1pod setup pod install 问题无法使用，报类似下面的两种错误信息： 1can&apos;t find gem cocoapods (&gt;= 0.a) with executable pod (Gem::GemNotFoundException) 12While executing gem ... (TypeError) no implicit conversion of nil into String 解决方案，如下： 1. 重新安装 ruby 1brew reinstall ruby 2. gem 更新 123rm /usr/local/bin/update_rubygemssudo gem update --system 3. 重新安装 Cocoapods 并重新添加源 12345sudo gem uninstall cocoapodssudo gem install -n /usr/local/bin cocoapodsgem sources -a https://gems.ruby-china.org/ 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>CocoaPods, iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 管理开源项目]]></title>
    <url>%2F2016%2F11%2F01%2FCocoapods-%E7%AE%A1%E7%90%86%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[准备工作在进行下面工作之前，请确保你做了下面三件事情： 1. 创建或者已经有了 github 账号.2. 了解和熟悉如何在 github 上面创建 Repository.3. MacOS 上面安装了 Cocoapods. 如果你还没有使用 Cocoapods, 建议看看 Mac OSX 10.11.1+ 安装 Cocoapods 这篇博客. 在博客 iOS 项目: 打造本地 pod 库 里面有介绍如何打造本地的 pod 库，不需要借助任何仓库就可以完成，操作简单，适合项目组内使用。 今天给大家分享如何将代码开源并放到 pod 库中，供别人使用。这种方式属于打造公共（Public repo）仓库， 任何人都可以搜索到你贡献的库并使用你的库。后面会跟大家分享如何打造私有（Private repo），敬请期待。 这篇博客是基于一个实际例子 MZInsetLabel 来说明的，期待与优秀的你交流讨论。 创建 Repository 并完善项目1. 在 Github 上面创建 Repository，取名为 MZInsetLabel. 2. 将该工程 clone 到本地磁盘. 3. 写代码，这里我只写了 MZInsetLabel.h | .m 文件. 4. 创建 podspec 文件. 使用下面命令，即可产生该文件。 1pod spec create MZInsetLabel 在当前目录会生成 MZInsetLabel.podspec 文件。按照文件规范和实际情况填写即可，如果不知道怎么填写，可以在 Github 上面找一个开源项目参考即可。 注意: Tag 版本号不要错误. 最终内容如下: 12345678910111213141516Pod::Spec.new do |s| s.name = &quot;MZInsetLabel&quot; s.version = &quot;0.2.0&quot; s.summary = &quot;MZInsetLabel is subClass of UILabel.&quot; s.description = &lt;&lt;-DESC MZInsetLabel is a sub class of UILabel that can be set insets. DESC s.homepage = &quot;http://www.veryitman.com&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;veryitman&quot; =&gt; &quot;veryitman@126.com&quot; &#125; s.platform = :ios, &quot;7.0&quot; s.source = &#123; :git =&gt; &quot;https://github.com/veryitman/MZInsetLabel.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; s.source_files = &quot;*.&#123;h,m&#125;&quot; s.framework = &quot;UIKit&quot; s.requires_arc = trueend 项目检测检查该 podspec 文件，执行下面命令 1pod lib lint MZInsetLabel.podspec –verbose 可以输出更加详细的内容 1pod lib lint MZInsetLabel.podspec --verbose 正确的话, 你可以看到下图如所示的内容： 在检测的过程中，如果有一些警告导致无法验证通过，可以使用 --allow-warnings 参数规避这些 warning，但我还是建议大家尽量将 warning 修改好。 1pod lib lint --allow-warnings pod lib lint *.podspec 是只从本地验证你的 pod 能否通过验证. pod spec lint*..podspec 是从本地和远程验证你的 pod 能否通过验证. 大家可自行选择这两种方式。 添加项目到 Github Repository将本地的代码 push 到 Github 的 Repository, 就是刚才创建的 MZInsetLabel. 12345git add `文件`或者`文件夹`git commit -m &quot;Init&quot;git push 在你的 Github Repository 上面创建一个 Release 作为 Tag（0.1.0版本），如图所示: 推送到 cocoapods1. 注册 trunk pod trunk register 你的邮箱 ‘用户名’ –description=’简单描述’ 完整命令如下: 1pod trunk register veryitman@126.com &apos;veryitman&apos; --description=&apos;mark&apos; 2. 打开邮箱, 激活邮件, 点击链接激活 3. 检查注册信息 执行命令如下： 1pod trunk me 4.添加到 cocoapods 执行下面命令, 即可. 1pod trunk push MZInsetLabel.podspec 成功的效果图: 验证使用1. 检查是否可以搜索到 1pod search MZInsetLabel 如果搜索不到, 请执行 1pod setup 2. 在项目中可以使用该项目 1pod &apos;MZInsetLabel&apos;, &apos;~&gt; 0.1.0&apos; 然后在你的测试项目中，执行 pod install 即可。 可能遇到的麻烦1. 执行 pod trunk push *.podspec 时, 好久没反应? 这种情况, 大多数都是因为你的网络不给力造成的, 如果你确定你的网络没问题, 那么请翻墙. 2. 执 行 pod trunk push *.podspec 时报错? 报错信息: 1ERROR | [iOS] unknown: Encountered an unknown error (Simulator iPhone 4s is not available.) during validation. 这个错误是因为, 更新了 xcode8 之后不再支持 ios7 的缘故. 解决方案(我的), 升级 cocoapods. 1sudo gem install -n /usr/local/bin cocoapods 3. pod trunk push 失败 失败提示信息类似: 12345Cloning into &apos;master&apos;...error: RPC failed; curl 56 SSLRead() return error -36fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决方案: 更新 gem 1sudo gem update --system Git 命令行操作1. 向远程 Repository 添加 tag 123git tag -m &quot;注释&quot; 0.0.1git push --tags 执行后，可以看到 Github Repository 上会多一个对应的 tag 版本。 2.删除本地 Tag 1git tag --delete [TagName] 如: 1git tag --delete 0.0.1 3. 删除远程 Tag 1git push --delete origin [TagName] 如: 1git push --delete origin 0.0.1 在 Github 上面如果你不小心打错了 Release, 然后删除该 Release.你会发现, tag 无法删除.使用上面方式妥妥的解决. 如果你删除 tag，想重新打一个相同的 tag，需要先删除本地的 tag，否则会失败。 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 谈谈 frame 和 bounds]]></title>
    <url>%2F2016%2F10%2F22%2FiOS-%E8%B0%88%E8%B0%88-frame-%E5%92%8C-bounds%2F</url>
    <content type="text"><![CDATA[起因大家知道, 我们可以设置 view 的四个角或者其中一个或者几个为圆角. 使用的方法: 123+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; 拖好界面元素之后, 在代码中来修改其为圆角, 居然失败了. 想要的效果是这样的: 但是最终是这样的: 于是总结了一下, 分享给大家. 设置圆角这里分两种情况. 第一种: 只放置控件, 不设置约束. 1.storyboard 中拖好控件. 注意: 这里我并没有设置任何约束. 2.vc 代码 123456789101112131415161718192021222324252627@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *lb;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; [self changeLbCorner];&#125;- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.frame byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125;@end 代码编译运行到模拟器(iphone6), 看不到任何东西. log 日志显示 lb 的信息如下: 123[ViewController viewDidLoad]:lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; 位置信息是正确的, 咨询检查发现是参数传入错误, 修改 changeLbCorner 方法: 12345678910- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125; 这里只是将 self.lb.frame 改成了 self.lb.bounds. 再次运行可以看到效果: 第二种: 放置控件并设置约束. 1.设置 lb 距离父 view 左边和上边的约束.2.运行上面的代码, 发现, lb 并没有被设置为圆角.并且 lb 的宽度和高度变小了, 变成了文字的实际的宽高. 看 log: 123[ViewController viewDidLoad]:lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; 其实这个时候, (从上面图中可以看出) 这里的信息是错误的. 正确的信息应该是这样的(在 viewDidAppear 中)打印信息: 123[ViewController viewDidAppear]:lb.bounds: &#123;&#123;0, 0&#125;, &#123;58.5, 19.5&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;58.5, 19.5&#125;&#125; 于是, 将 1[self changeLbCorner]; 放到 viewDidAppear 中, 圆角就正常了. 接下来, 我们把 lb 的宽高(136*39)约束也加上. 看一下, viewDidLoad 和 viewDidAppear 方法中打印的信息: 123456[ViewController viewDidLoad]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewDidAppear:]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; 可以看出, viewDidLoad 中错的一塌糊涂. 这里也说明一个问题: xib 或者 storyboard 中设置过约束(现实开发中, 基本都会设置约束)的组件, 在 viewDidLoad 中并没有完全 layout, 只是预加载了这些组件.想获取组件如 frame 何 bounds 信息, 在 viewDidLoad 中是不合适甚至是错误的. 那么, 问题来了, 哪里合适哪里正确. 上面如果你认真看了, 在 viewDidAppear 中是可以正确获取的, 那么还有没有其他方法可以获取呢? VC 生命周期函数要回答上面的问题, 大家要知道 vc 的生命周期函数. 上面的例子, 可以看出: 当函数 ViewDidLoad 被调用的时候，IBQutlets 已经被连接，但View 还没有被加载出来，无法获取 frame 等信息.可以在 viewDidLoad 中完成在 IB 中不能完成的 view 的自定义。 关于 loadView 和 viewDidLoad 在后面博客跟大家分享. 今天要说的是 1viewDidLayoutSubviews viewDidLayoutSubviews 在 VC 子视图位置或者尺寸 (position|size) 被改变的时候被调用. 直到 AutoLayout 已经完成工作的时候才会被确定，所以在执行完 AutoLayout 之后会调用此方法. 换句话说, view 的 frame 和 bounds 这个时候是正确可以获取的. viewDidLayoutSubviews 这个方法在 viewDidAppear 之前被调用, 有可能会被调用多次. 即依赖 bounds 或者 frame 的操作，都应该放在viewDidLayoutSubviews 中，而不是 viewDidLoad 或 viewWillAppear 中. 改变后的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;ViewController.h&quot;#define MZLog(fmt, ...) NSLog((@&quot;%s\n&quot; fmt), __FUNCTION__, ##__VA_ARGS__)#define MZLogLbInfo \MZLog(@&quot;lb.bounds: %@ \nlb.frame: %@&quot;, NSStringFromCGRect(self.lb.bounds), NSStringFromCGRect(self.lb.frame))@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *lb;@property (strong, nonatomic) IBOutlet UILabel *displayedText;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; MZLogLbInfo;&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; MZLogLbInfo;&#125;- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; MZLogLbInfo;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; MZLogLbInfo; [self changeLbCorner];&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; MZLogLbInfo;&#125;#pragma mark Callback.- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125;@end 打印的 log 如下: 123456789101112131415161718192021[ViewController viewDidLoad]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewWillAppear:]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewWillLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;[ViewController viewDidLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;[ViewController viewWillLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;[ViewController viewDidLayoutSubviews]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;[ViewController viewDidAppear:]lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125; frame 和 bounds上面的例子, 大家看到由于传入了 frame 而不是 bounds 造成设置圆角失败. 下面说说 frame 和 bounds. 概念从网上”偷”过来的图 1.frame 该 view 在父 view 坐标系统中的位置和大小(参照点是，父坐标系统). 2.bounds 该 view 在本地坐标系统中的位置和大小(参照点是，本地坐标系统，就相当于 view 自己的坐标系统，以(0,0)点为起点).其实本地坐标系统的关键就是要知道的它的原点(0,0). bounds 默认值是(0, 0, width, height).除非手动改变 bounds 的值. 单纯的从概念上面, 很难理解二者的区别. 提供一个例子, 例子大概是这样的:redView 是 yellowView 的父视图, yellowView 是 blueView 的父视图. 通过改变 redView 的 bounds 会影响子视图的位置(不是frame).将 redView 的 bounds 起点设为(-20, -20), 子视图相对于 redView 的本地坐标(0, 0), 也就需要往下增加20, 这样, yellowView 就往下移动了. 效果图: 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#import &quot;ViewController.h&quot;#define MZLog(fmt, ...) NSLog((@&quot;%s\n&quot; fmt), __FUNCTION__, ##__VA_ARGS__)#define MZLogLbInfo \MZLog(@&quot;lb.bounds: %@ \nlb.frame: %@&quot;, NSStringFromCGRect(self.lb.bounds), NSStringFromCGRect(self.lb.frame))@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *lb;@property (strong, nonatomic) IBOutlet UILabel *displayedText;@end@implementation ViewController&#123; UIView *redView; UIView *yellowView; UIView *blueView;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; MZLogLbInfo; // 将 redView 添加到 self.view &#123; redView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 120, 120)]; redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; &#125; // 将 yellowView 添加到 redView &#123; yellowView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 90, 90)]; yellowView.backgroundColor = [UIColor yellowColor]; [redView addSubview:yellowView]; &#125; // 将 blueView 添加到 yellowView &#123; blueView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 60, 60)]; blueView.backgroundColor = [UIColor blueColor]; [yellowView addSubview:blueView]; &#125; [self logViewInfo];&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; MZLogLbInfo;&#125;- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; MZLogLbInfo;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; MZLogLbInfo; [self changeLbCorner];&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; MZLogLbInfo;&#125;#pragma mark Callback.- (void)changeLbCorner&#123; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight cornerRadii:CGSizeMake(7, 7)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = _lb.bounds; maskLayer.path = maskPath.CGPath; self.lb.layer.mask = maskLayer;&#125;- (IBAction)doResetAction:(id)sender&#123; [UIView animateWithDuration:1.0f animations:^&#123; [redView setBounds:CGRectMake(0, 0, 120, 120)]; [yellowView setBounds:CGRectMake(0, 0, 90, 90)]; &#125; completion:^(BOOL finished) &#123; [self logViewInfo]; &#125;];&#125;- (IBAction)doChangeRedViewBounds:(id)sender&#123; [UIView animateWithDuration:1.0f animations:^&#123; [redView setBounds:CGRectMake(-20, -20, 120, 120)]; &#125; completion:^(BOOL finished) &#123; [self logViewInfo]; &#125;];&#125;- (IBAction)doChangeYellowViewBounds:(id)sender&#123; [UIView animateWithDuration:1.0f animations:^&#123; [yellowView setBounds:CGRectMake(-20, -20, 90, 90)]; &#125; completion:^(BOOL finished) &#123; [self logViewInfo]; &#125;];&#125;#pragma mark Display Debug Info.- (void)logViewInfo&#123; NSString *log4rView = [NSString stringWithFormat:@&quot;RedView\nframe:%@ \nbounds:%@&quot;, NSStringFromCGRect(redView.frame), NSStringFromCGRect(redView.bounds)]; NSString *log4yView = [NSString stringWithFormat:@&quot;YellowView\nframe:%@ \nbounds:%@&quot;, NSStringFromCGRect(yellowView.frame), NSStringFromCGRect(yellowView.bounds)]; NSString *log4bView = [NSString stringWithFormat:@&quot;BlueView\nframe:%@ \nbounds:%@&quot;, NSStringFromCGRect(blueView.frame), NSStringFromCGRect(blueView.bounds)]; NSString *log = [NSString stringWithFormat:@&quot;%@\n%@\n%@&quot;, log4rView, log4yView, log4bView]; [self display:log];&#125;- (void)display:(NSString *)content&#123; self.displayedText.text = content;&#125;@end 总结 frame, 描述的是当前视图在其父视图中的位置和大小.bounds, 描述的是当前视图在其自身坐标系统中的位置和大小. 所以, bounds 默认是 (0, 0, frame.size.width, frame.size.height) 另外, 还有一个 center 描述的是当前视图的中心点在其父视图中的位置. bounds 和 frame 是两个不等同的概念, 改变 bounds 会影响子视图的位置(人眼看到其改变了位置), 设置 bounds 可以修改自己坐标系的原点位置. 但是不会改变子视图的 bounds 和 frame. 明白上面的道理很重要, iOS 中滚动视图能让你看到其中的内容, 正是利用了 contentoffset 和 bounds 属性. 这里以 tableView 为例子, 当我们向上滚动 tableView, tableView 的 contentOffset 和 bounds 的坐标都是正数, 相当于其本地坐标(0, 0)改变了即增加了(坐标系往下为增加), 那么其子视图就会向上去. 向下滑动时, 也是同一个道理.可以通过运行 完整 Demo 中[查看 TableView]按钮来打开例子, 看日志. 改变子视图所有父视图的 bounds, 子视图的位置是累加改变的.如上面改变 redView 和 yellowView 的 bounds, blueView 的位置相对 redView 往下移动了 40. 当同一个视图的 bounds 大于 frame, 会导致 frame 被撑大，frame 的 x, y, width, height 都会被改变. 反之, bounds 小于 frame, frame 也会变小. 附录 GitHub 上面可以下载 完整 Demo 推荐之前写在 CSDN 上的博文: iOS UI 技巧: 视图无法被点击 可关注我的微信公众号:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS frame bounds</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 模拟 Mobx]]></title>
    <url>%2F2016%2F10%2F11%2FRN-%E6%A8%A1%E6%8B%9F-Mobx%2F</url>
    <content type="text"><![CDATA[前言看过 [React Native 使用 Mobx] 这篇博客的同学, 对 Mobx 应该有了一个简单直观的认识. 其实, 我们完全可以使用 RN 中的 State 来达到同样的效果. 今天的主要内容是使用 State 来模拟 Mobx, 也算是对 Mobx 的进一步认识. 效果 实现效果和 [React Native 使用 Mobx] 中的效果一致, 只是代码没有使用 Mobx 框架. 实现LegacyCounter.js Add 和 Minus 两个按钮分别触发各自的回调, 来更新 state.使用 state 的变化来到达更新 View (计数的 Text 会相应的做出变化)的目的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 模拟 Mobx 在 ReactNative 上的一个小例子. * * state -&gt; view */&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableHighlight&#125; from &apos;react-native&apos;;class LegacyCounter extends Component &#123; //构造方法 constructor(props) &#123; super(props); this.state = &#123; //计数 counter: 0 &#125;; &#125; render () &#123; return ( &lt;View style = &#123;styles.container&#125;&gt; &#123;/*加一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.setState(&#123; counter: ++this.state.counter &#125;)&#125;&#125;&gt; &lt;Text&gt;Add&lt;/Text&gt; &lt;/TouchableHighlight&gt; &#123;/* 显示处理结果 */&#125; &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt; &#123;this.state.counter&#125; &lt;/Text&gt; &#123;/*减一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.setState(&#123; counter: --this.state.counter &#125;)&#125;&#125;&gt; &lt;Text&gt;Minus&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;export default class LegacyComponent extends Component &#123; render () &#123; return ( &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt; &lt;LegacyCounter/&gt; &lt;/View&gt; ); &#125;&#125;/* 样式定义 */const styles = StyleSheet.create(&#123; container: &#123; flexDirection: &apos;row&apos;, justifyContent: &apos;space-around&apos; &#125;, resultTxtStyle: &#123; fontSize: 22, color: &apos;red&apos; &#125;&#125;); index.ios.js 这个文件很简单, 只是调用 LegacyCounter 中的组件. 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;//引入自定义模块import LegacyComponent from &apos;./js/Mobx/LegacyCounter&apos;import &#123; AppRegistry&#125; from &apos;react-native&apos;;class RNMobxDemo extends Component &#123; render() &#123; return( &lt;LegacyComponent/&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;RNMobxDemo&apos;, () =&gt; MZRNTutorial); 后记如果你想了解更多关于 RN 中 State 的知识, 请移步官方文档查阅 State 的用法. 后续会给大家带来更多关于 RN 这些方面的东西.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS Android ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 使用 Mobx]]></title>
    <url>%2F2016%2F10%2F06%2FRN-%E4%BD%BF%E7%94%A8-Mobx%2F</url>
    <content type="text"><![CDATA[来由在 JSFiddler 上面看到 React 结合 Mobx 的一个小例子. 爱不释手, 遂拿来改造一下, 让其能在 RN 上面一展雄风. 之前听过 Mobx, 说是要替代 Redux, 反正我是不知道这些东东, 第一次听说没有什么感觉!如今又再次偶遇 Mobx, 决定认真学习一下它. Mobx 简介Mobx 的 github 地址.目前关于他和 React Native 的(中文)资料不多, 大多数是关于 React 的. 看来想学好 React Native, 还是要做好 React 的功课呀! 官网给了一个 Mobx 的图: 我也是刚接触这个「牛逼闪闪」的 Mobx, 共勉! 效果图今天的例子很简单, 效果图如下 点击 Add 点击 Minus 下面具体说说如何搞定这个 Demo. 准备「材料」这里假设你已经具备 React Native 的基本开发环境, 至少成功运行过一次 React Native 的程序. 1.创建 React Native 项目1react-native init RNMobxDemo 你也可以给你的工程取一个你喜欢的名字.这里姑且称之为 RNMobxDemo 2.安装 mobx 和 mobx-react1npm i mobx mobx-react --save 3.Counter.js 该文件使用了 mobx 和 mobx-react 的组件. 具体代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableHighlight&#125; from &apos;react-native&apos;;import &#123; observer &#125; from &apos;mobx-react/native&apos;;import &#123; observable &#125; from &apos;mobx&apos;;// 被观察者, 观察 counter 变量 const storer = observable(&#123; counter: 0&#125;);//---------------------------------// ES6 写法: Arrow Function//---------------------------------storer.plus = () =&gt; &#123; storer.counter ++;&#125;;storer.minus = () =&gt; &#123; storer.counter --;&#125;;class Counter extends Component &#123; render () &#123; return ( &lt;View style = &#123;styles.container&#125;&gt; &#123;/*加一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.props.store.plus()&#125;&#125;&gt; &lt;Text&gt;Add&lt;/Text&gt; &lt;/TouchableHighlight&gt; &#123;/* 显示处理结果 */&#125; &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt; &#123;this.props.store.counter&#125; &lt;/Text&gt; &#123;/*减一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;storer.minus()&#125;&#125;&gt; &lt;Text&gt;Minus&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;// 使用 observer 创建const CounterComponent = observer(Counter);export default class ReactionsComponent extends Component &#123; render () &#123; return ( &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt; &lt;CounterComponent store = &#123;storer&#125; /&gt; &lt;/View&gt; ); &#125;&#125;/* 样式定义 */const styles = StyleSheet.create(&#123; container: &#123; flexDirection: &apos;row&apos;, justifyContent: &apos;space-around&apos; &#125;, resultTxtStyle: &#123; fontSize: 22, color: &apos;red&apos; &#125;&#125;); 4.index.ios.js 该文件使用自定义的组件 ReactionsComponent 具体代码如下: 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;//引入自定义模块import ReactionsComponent from &apos;./js/Mobx/Counter&apos;import &#123; AppRegistry&#125; from &apos;react-native&apos;;class RNMobxDemo extends Component &#123; render() &#123; return( &lt;ReactionsComponent/&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;RNMobxDemo&apos;, () =&gt; MZRNTutorial); Mobx 支持「注解」. 这里的注解就是 ES7 中的 decorators (装饰者模式). 下面代码是使用注解的方式来声明, 但是你需要安装相关的插件(babel plugin)来支持. 安装该插件很简单, 在项目根目录按照下面步骤即可: Step 1: 创建 .babelrc 文件 1touch .babelrc Step 2: 编辑 .babelrc 文件 1234&#123; &apos;presets&apos;: [&apos;react-native&apos;], &apos;plugins&apos;: [&apos;transform-decorators-legacy&apos;]&#125; Step 3: 安装插件 1npm i babel-plugin-transform-decorators-legacy babel-preset-react-native-stage-0 --save-dev 修改「Counter.js」, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, View, Text, TouchableHighlight&#125; from &apos;react-native&apos;;import &#123; observer &#125; from &apos;mobx-react/native&apos;;import &#123; observable &#125; from &apos;mobx&apos;;// 被观察者, 观察 counter 变量 const storer = observable(&#123; counter: 0&#125;);//---------------------------------// ES6 写法: Arrow Function//---------------------------------storer.plus = () =&gt; &#123; storer.counter ++;&#125;;storer.minus = () =&gt; &#123; storer.counter --;&#125;;@observer //使用@方式来前置声明class Counter extends Component &#123; render () &#123; return ( &lt;View style = &#123;styles.container&#125;&gt; &#123;/*加一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;this.props.store.plus()&#125;&#125;&gt; &lt;Text&gt;Add&lt;/Text&gt; &lt;/TouchableHighlight&gt; &#123;/* 显示处理结果 */&#125; &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt; &#123;this.props.store.counter&#125; &lt;/Text&gt; &#123;/*减一*/&#125; &lt;TouchableHighlight onPress = &#123;() =&gt; &#123;storer.minus()&#125;&#125;&gt; &lt;Text&gt;Minus&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125;export default class ReactionsComponent extends Component &#123; render () &#123; return ( &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt; &lt;Counter store = &#123;storer&#125; /&gt; &lt;/View&gt; ); &#125;&#125;/* 样式定义 */const styles = StyleSheet.create(&#123; container: &#123; flexDirection: &apos;row&apos;, justifyContent: &apos;space-around&apos; &#125;, resultTxtStyle: &#123; fontSize: 22, color: &apos;red&apos; &#125;&#125;); 从例子可以看出, storer 相当于 state, 当 state 发生改变了, 视图 View 也跟着变化.也就是状态驱动. Android 开发的同学应该知道 Adapter 和 notifyDatasetChanged 的机制, 当数据源发生变化的时候, 可以通知视图进行刷新操作. 这里的 Mobx 也可以这么简单的理解. Mobx 的强大之处还有很多, 需要慢慢学习和挖掘.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS Android ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 0.34 运行在 Android 的问题]]></title>
    <url>%2F2016%2F09%2F26%2FRN-0-34-%E8%BF%90%E8%A1%8C%E5%9C%A8-Android-%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天闲来无事, 想使用 RN 工程在 Android 设备上面跑跑. 想看看运行效果怎么样?! 适合读者 有 Android 开发基础. 会使用 Android Studio. 初级 React Native 的开发者. 开发环境和工具 Android Studio 2.2 ReactNative 0.34 Android 模拟器 Mac 操作系统 预期效果不出所料, 真的不能一帆风顺的 Run. 在我的博客 ReactNative: 不一样的 HelloWorld 中展示了 RN 在 iOS 上面的运行情况. 今天还是这个例子, 部署和运行到 Android 上面. 效果如下: 在这个过程中, 遇到几个问题. 特此记录. 问题描述和解决问题1: 直接运行 crashlog 描述(部分) E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.mzrntutorial, PID: 5849java.lang.RuntimeException:Unable to start activity ComponentInfo{com.mzrntutorial/com.mzrntutorial.MainActivity}: java.lang.ClassCastException: android.app.Application cannot be cast to com.facebook.react.ReactApplicationat android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2416)at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2476) 解决方案:Manifest.xml 配置 Application 名称 android:name=”.MainApplication” 问题2:1could not get batchedbridge make sure your bundle is packaged correctly 解决问题1后, 再次运行, 会报问题2.该问题是因为没有启动本地的 server. 使用 Xcode 可以自动运行本地 server.可以参考博客 React Native 如何启动 local server 解决方案:手动启动 server. cd 项目根目录 1react-native start 问题3: 模拟器没有 menu 按键, 无法 Reload 这个其实不是什么大问题, 但是对于初学者, 也算是一个问题. 新版的 Android SDK 创建的模拟器没有 menu 按键了 解决方案:连续按两次字母 r 即可刷新. 这些问题, FB 后面肯定会解决的.阿门! 附录(代码)index.ios.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import React, &#123; Component &#125; from &apos;react&apos;;import &#123;getPlatformString, isIOS&#125; from &apos;./js/Generals/Utils/IDSRNPlatformUtil&apos;;import MZButton from &apos;./js/ReactUIKit/MZButton&apos;import &#123; AppRegistry, StyleSheet, Text, View, Platform, TouchableOpacity, TouchableHighlight&#125; from &apos;react-native&apos;;// 调用其他模块方法var os = getPlatformString();var iosPlatform = isIOS();//when run on &apos;ios&apos; trueclass MZRNTutorial extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;status:1&#125;; &#125; customPressHandler = () =&gt; &#123; alert(&apos;当前状态: &apos; + this.state.status); this.state.status = 2; &#125; render() &#123; console.log(&apos;render ...&apos;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Near use React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Press &apos;R&apos; twice to reload,&#123;&apos;\n&apos;&#125; or shake for dev menu &lt;/Text&gt; &#123;/* 显示当前平台信息*/&#125; &lt;Text style=&#123;styles.welcome&#125;&gt; current os: &#123;Platform.OS&#125; &lt;/Text&gt; &#123;/* &lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;this.customPressHandler&#125; &gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;确定&lt;/Text&gt; &lt;/TouchableOpacity&gt; */&#125; &lt;MZButton text=&quot;确定?&quot; bgColor=&quot;green&quot; dianjishijian=&#123;()=&gt;&#123;alert(&apos;居然点击确定?!&apos;)&#125;&#125;&gt; &lt;/MZButton&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; button: &#123; height: 40, width: 150, borderRadius: 20, justifyContent: &apos;center&apos;, backgroundColor: &apos;green&apos;, overflow: &apos;hidden&apos; &#125;, buttonText: &#123; textAlign: &apos;center&apos;, color: &apos;white&apos; &#125;, container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;, flowRight: &#123; flexDirection: &apos;row&apos;, alignItems: &apos;center&apos;, alignSelf: &apos;stretch&apos; &#125;,&#125;);AppRegistry.registerComponent(&apos;MZRNTutorial&apos;, () =&gt; MZRNTutorial); MZButton.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet, Text, View, Platform, TouchableOpacity&#125; from &apos;react-native&apos;;//-----------------------------------------------------//外部使用该模块, ES6需要使用关键字 export default//-----------------------------------------------------export default class MZButton extends Component&#123; constructor(props) &#123; super(props); this.state = &#123;status:1&#125;; &#125; costumPressHandler = () =&gt; &#123; alert(&apos;当前状态:&apos; + this.state.status); const &#123;dianjishijian&#125; = this.props; dianjishijian(); &#125;; // 使用属性值设置背景颜色 // style=&#123;[styles.button], &#123;backgroundColor:this.props.beijingyanse&#125;&#125; render() &#123; //解构 const &#123;text, bgColor&#125; = this.props; return ( &lt;TouchableOpacity style=&#123;[styles.button], &#123;backgroundColor:bgColor&#125;&#125; onPress = &#123;this.costumPressHandler&#125; &gt; &lt;Text style=&#123;styles.buttonText&#125;&gt; &#123;/* 使用属性值 */&#125; &#123;this.props.text&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; button: &#123; height: 40, width: 150, borderRadius: 20, justifyContent: &apos;center&apos;, backgroundColor: &apos;green&apos;, overflow: &apos;hidden&apos; &#125;, buttonText: &#123; textAlign: &apos;center&apos;, color: &apos;white&apos; &#125;&#125;); IDSRNPlatformUtil.js 123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Platform&#125; from &apos;react-native&apos;;export function getPlatformString()&#123; console.log(Platform.OS); return Platform.OS;&#125;export function isIOS()&#123; return Platform.OS === &apos;ios&apos;;&#125;export function isAndroid()&#123; return Platform.OS == &apos;android&apos;;&#125;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>Android ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 项目: 打造本地 pod 库]]></title>
    <url>%2F2016%2F09%2F25%2FiOS-%E9%A1%B9%E7%9B%AE-%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0-pod-%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本篇的姊妹篇 Cocoapods 管理开源项目 已准备完毕，直戳 链接 即可达到。 Cocoapods 管理代码的必要性项目到了一定规模, 代码组织和结构显得尤为重要. 重构项目结构，可以从分离代码开始，代码分离，可以把常用稳定的组件封装抽离出来. 分离代码, 常用的有几种方式: 放到不同的文件夹, 管理和组织代码. 使用 framework 的方式, 提供给项目使用. 工具管理如 Cocoapods. 这几种方式, 各有所长, 各有优劣, 无所谓好与坏, 根据自己的项目特点来组织即可. 我的做法是使用 cocoapods 来管理. 下面进入今天的主题: 使用 cocoapods 管理自己的本地代码. 博客 Mac OSX 10.11.1+ 安装 Cocoapods介绍了如何在最新版 MacOS 中安装 Cocoapods 以及注意事项, 并且作者保证持续「更新, 更正」内容. 创建工程使用 Xcode 创建一个工程, 工程名就起为 TestPods 吧. 工程目录可以防止在桌面或者你喜欢的目录下面都可以. 在 TestPods 下面创建 LocalLib 目录, 用来放置分离的代码.当然, 你也可以将 LocalLib 这个目录放到其他目录. 在 LocalLib 下面, 我的 pod 库代码名称为 download. 可以新建这个目录. 目录如下: 创建 podspec 文件在 download 目录下面, 创建 podspec 文件 1pod spec create download 创建完成后, 会生成 download.podspec 文件. 具体内容, 创建后, 大家可以自行查看. 修改 podspec 文件修改 download.podspec, 主要修改几个关键地方: 源码位置源码版本 123456789101112131415――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――# # # Specify the location from where the source should be retrieved. # Supports git, hg, bzr, svn and HTTP. # s.source = &#123; :git =&gt; &quot;&quot;, :tag =&gt; &quot;0.0.1&quot; &#125; # ――― Source Code ――――――――――――――――――――――――――――――――――――――――――――# # # CocoaPods is smart about how it includes source code. For source files # giving a folder will include any swift, h, m, mm, c &amp; cpp files. # For header files it will include any header in the folder. # Not including the public_header_files will make all headers public. # s.source_files = &quot;Source&quot;, &quot;Source/**/*.&#123;h,m&#125;&quot; s.exclude_files = &quot;Source/Exclude&quot; 另外, 配置好相关描述信息, 不要包含 ‘Example’ 的字样, 不然, 新版的 Cocoapods 执行 pod install 时候, 会报出警告和错误. 这样, 工程可以使用 pods 库了. 工程使用 pod 库将 TestPods 改为 cocoapods 项目. 在 TestPods 目录, 执行 1pod init 会生成 Podfile 等文件. 修改 Podfile 文件 123456789101112# Uncomment this line to define a global platform for your project# platform :ios, &apos;7.0&apos;# Uncomment this line if you&apos;re using Swift# use_frameworks!target &apos;TestPods&apos; dopod &apos;download&apos;, :path =&gt; &apos;./LocalLib/download/&apos;#pod &apos;core_lib_spec&apos;, :svn =&gt; &apos;http://svn.ids111.com/o2o/client/ios/trunks/master/Frameworks/CoreLibrary&apos;endtarget &apos;TestPodsTests&apos; doendtarget &apos;TestPodsUITests&apos; doend 关键是指明 pod 库的位置.路径一定要正确.否则无法找到该库. 1pod &apos;download&apos;, :path =&gt; &apos;./LocalLib/download/&apos; 在 TestPods 下面, pod install 即可. 如果, pod install 报错, 一般都是你的 pod 库的配置文件(.podspec)里面写的不符合要求. 根据报错信息, 加以修改即可. xcode 打开工程. 示例下载工程示例代码, 可以 戳这里下载 玩耍! 扫码关注，你我就各多一个朋友~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 如何启动 local server]]></title>
    <url>%2F2016%2F09%2F22%2FRN-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8-local-server%2F</url>
    <content type="text"><![CDATA[使用 react-native init 创建的工程, 在 xcode 中运行会自动启动一个 RN 的本地 Server. 像下面图片展示这样: 那么, 这里问题来了. 比如, 我想暂时不启动这个本地 Server, 那么如何关闭呢? 下面跟大家一起探讨和追究一下. 找到启动的根源启动这个终端的是在一个 React.xcodeproj 工程的 「Build Phases」中脚本里面配置的. 脚本内容如下: 12345678if nc -w 5 -z localhost 8081 ; then if ! curl -s &quot;http://localhost:8081/status&quot; | grep -q &quot;packager-status:running&quot; ; then echo &quot;Port 8081 already in use, packager is either not running or not running correctly&quot; exit 2 fielse open &quot;$SRCROOT/../packager/launchPackager.command&quot; || echo &quot;Can&apos;t start packager automatically&quot;fi 真正起作用的是: 1open &quot;$SRCROOT/../packager/launchPackager.command&quot; 解决方案这样我们就可以关闭这个自启动了, 示例代码如下: 123456789if nc -w 5 -z localhost 8081 ; then if ! curl -s &quot;http://localhost:8081/status&quot; | grep -q &quot;packager-status:running&quot; ; then echo &quot;Port 8081 already in use, packager is either not running or not running correctly&quot; exit 2 fielse#open &quot;$SRCROOT/../packager/launchPackager.command&quot; || echo &quot;Can&apos;t start packager automatically&quot; echo &quot;Nothing...&quot;fi 看看 launchPackager.command这个文件在「node_modules/react-native/packager/」下面. 该文件是启动另外一个脚本 packager.sh, 核心代码: 1source ./packager.sh 最终执行: 1node &quot;$THIS_DIR/../local-cli/cli.js&quot; start &quot;$@&quot; 大家有兴趣可以去看看源码, 一探究竟.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative iOS Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: 创建iOS工程代码的indent问题]]></title>
    <url>%2F2016%2F09%2F19%2FRN-%E5%88%9B%E5%BB%BAiOS%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%9A%84indent%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起因使用最新版RN(0.33)来创建工程, 大家可以发现, OC 代码的退格变成了两个空格.如下: 12345678910111213141516- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSURL *jsCodeLocation; jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;Mark&quot; initialProperties:nil launchOptions:launchOptions]; rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *rootViewController = [UIViewController new]; rootViewController.view = rootView; self.window.rootViewController = rootViewController; [self.window makeKeyAndVisible]; return YES;&#125; 无论你回车或者 tab 或者格式化(右键/Structure/Re-Indent)代码, 会发现, 都是这种调调. 面对这突如其来的变化, 我开始觉得有点淡淡的忧伤. 对于一直使用 tab width = 4 的我来说, 无法忍受. 必须改过来. 思考打开 Xcode 的 preferences, 看到其『设置』正常的不要不要的. 所以可以断定不是 Xcode 的问题. 因为升级了 Xcode 到最新版 Xcode8, 还以为是 Xcode8 的 bug, 打开之前的 React Native 工程或者其他 Xcode 工程, 就没有这个「蛋疼」的问题. 最终猜想是工程配置文件引起的… 解决既然和 Xcode 没有关系, 那么问题就一定出现在配置文件上面. 罪魁祸首 project.pbxproj 123indentWidth = 2;sourceTree = &quot;&lt;group&gt;&quot;;tabWidth = 2; 修改为: 123indentWidth = 4;sourceTree = &quot;&lt;group&gt;&quot;;tabWidth = 4; 或者直接删除: 12indentWidth = 2;tabWidth = 2; 关闭工程, 重启 Xcode 就可以了.]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative iOS Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN: Mac 配置 ES6 简易开发环境]]></title>
    <url>%2F2016%2F09%2F16%2FRN-Mac-%E9%85%8D%E7%BD%AE-ES6-%E7%AE%80%E6%98%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[创建文件夹 ES6123ES6-lib-src 你可以任意取一个你喜欢的目录名称. 初始化项目1npm init 填写项目信息. 查看一下 package.json 1cat package.json 123456789101112131415&#123; &quot;name&quot;: &quot;es6tutorials&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Tutorial&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ &quot;es6&quot;, &quot;.etc&quot; ], &quot;author&quot;: &quot;mark.zhang&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 目录结构如下 安装 babel-cli1npm install --save-dev babel-cli 也可以全局安装 1npm install babel-cli -g 全局安装上后，会安装如下四个程序到全局环境中： 1234babelbabel-nodebabel-doctorbabel-external-helpers 安装 babel-core1npm install babel-core --save 安装 ES2015 插件1npm install babel-preset-es2015 编写配置文件 .babelrc 注意该文件有个点符号. 在工程目录下新建该文件 1touch .babelrc 写入如下内容 123456&#123; &quot;presets&quot;: [ &quot;es2015&quot;, ], &quot;plugins&quot;: []&#125; 编写测试代码 tutorials.js 12345678910111213141516171819202122function test()&#123; console.log(a); var a = 0;&#125;test();var a = [];for (var i = 0; i &lt; 10; i++) &#123; var c = i; a[i] = function () &#123; console.log(c); &#125;;&#125;a[6](); // 9var b = [];for (var i=0; i&lt;10; i++) &#123; let c = i; //let 是 es6中的关键字 b[i] = function() &#123; console.log(c) &#125;;&#125;b[6](); 编译 1babel src/tutorials.js 运行 1babel-node src/tutorials.js 这里可以下载 工程源码. 其他操作1.将 ES6 语法的文件转换为 ES5 的语法1babel -d lib/ src/ 在 lib 目录下会生成 src 目录中对应的文件. 2.进入交互模式1babel-node 两次 ctrl+c 退出 3.检查babel状况1babel-doctor 检查以下内容 配置文件.babelrc 是否有重复的babel安装包，比如说安装了5和6 babel安装包是否已经升级到了最新版 npm &gt;= 3.3.0 4.卸载全局的 babel-cli1npm uninstall --global babel-cli 感谢 Babel comes with a built-in CLI which can be used to compile files from the command line. 阮一峰老师的 ECMAScript 6入门]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS: 手机是否设置网络代理]]></title>
    <url>%2F2016%2F09%2F16%2FiOS-%E6%89%8B%E6%9C%BA%E6%98%AF%E5%90%A6%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[情景项目开发过程中, 会遇到下面这样一种情景: 产品或者设计同事需要体验目前产品开发的进度, 然后要求开发人员, 将现在的版本给他们体验.做过程序开发的人都知道, 开发版本会有不少问题.这时, 产品和设计同事就会抱怨, 怎么登录不了, 这里没有数据了!有个小伙伴被折腾的实在受不了, 连网页都打不开了.最后找到原因:他手机被之前的程序猿设置了网络代理, 代理到程序猿哥哥的电脑上来抓包调试问题, 忘记取消设置了. 假如可以判断当前手机是否设置了网络代理, 就可以很好地解决上面情景中提到的问题了. 找到线索在 ASIHttpRequest 中找到如下方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243- (BOOL)configureProxies&#123; // Have details of the proxy been set on this request if (![self isPACFileRequest] &amp;&amp; (![self proxyHost] &amp;&amp; ![self proxyPort])) &#123; // If not, we need to figure out what they&apos;ll be NSArray *proxies = nil; // Have we been given a proxy auto config file? if ([self PACurl]) &#123; // If yes, we&apos;ll need to fetch the PAC file asynchronously, so we stop this request to wait until we have the proxy details. [self fetchPACFile]; return NO; // Detect proxy settings and apply them &#125; else &#123;#if TARGET_OS_IPHONE NSDictionary *proxySettings = [NSMakeCollectable(CFNetworkCopySystemProxySettings()) autorelease];#else NSDictionary *proxySettings = [NSMakeCollectable(SCDynamicStoreCopyProxies(NULL)) autorelease];#endif proxies = [NSMakeCollectable(CFNetworkCopyProxiesForURL((CFURLRef)[self url], (CFDictionaryRef)proxySettings)) autorelease]; // Now check to see if the proxy settings contained a PAC url, we need to run the script to get the real list of proxies if so NSDictionary *settings = [proxies objectAtIndex:0]; if ([settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]) &#123; [self setPACurl:[settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]]; [self fetchPACFile]; return NO; &#125; &#125; if (!proxies) &#123; [self setReadStream:nil]; [self failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileBuildingRequestType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to obtain information on proxy servers needed for request&quot;,NSLocalizedDescriptionKey,nil]]]; return NO; &#125; // I don&apos;t really understand why the dictionary returned by CFNetworkCopyProxiesForURL uses different key names from CFNetworkCopySystemProxySettings/SCDynamicStoreCopyProxies // and why its key names are documented while those we actually need to use don&apos;t seem to be (passing the kCF* keys doesn&apos;t seem to work) if ([proxies count] &gt; 0) &#123; NSDictionary *settings = [proxies objectAtIndex:0]; [self setProxyHost:[settings objectForKey:(NSString *)kCFProxyHostNameKey]]; [self setProxyPort:[[settings objectForKey:(NSString *)kCFProxyPortNumberKey] intValue]]; [self setProxyType:[settings objectForKey:(NSString *)kCFProxyTypeKey]]; &#125; &#125; return YES;&#125; 踏破铁鞋无觅处… 判断 iphone 是否设置网络代理的示例代码如下: 12345678910111213141516171819202122+ (BOOL)hasSetProxy&#123; BOOL proxy = NO; NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings()); NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef)(url), (__bridge CFDictionaryRef)(proxySettings))); MZLOG(@&quot;proxies:%@&quot;, proxies); NSDictionary *settings = proxies[0]; MZLOG(@&quot;kCFProxyHostNameKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyHostNameKey]); MZLOG(@&quot;kCFProxyPortNumberKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyPortNumberKey]); MZLOG(@&quot;kCFProxyTypeKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyTypeKey]); if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@&quot;kCFProxyTypeNone&quot;]) &#123; proxy = NO; &#125; else &#123; proxy = YES; &#125; return proxy;&#125; 用户体验判断如果设置了代理, 提示用户, 帮他直接跳到 wifi 设置界面. 下面说说如何跳到系统的 wifi 设置界面. 1.配置 URL TYPES 注意这里的配置是 prefs. 2.openURL 1234567891011121314NSString * urlString = @&quot;prefs:root=WIFI&quot;;NSURL *url = [NSURL URLWithString:urlString];UIApplication *app = [UIApplication sharedApplication];if ([app canOpenURL:[NSURL URLWithString:urlString]]) &#123; if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0) &#123; [app openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; [app openURL:url]; &#125;&#125; 另外, 跳转到系统其他界面的 URL 如下: 123456789101112131415161718192021222324252627281.系统设置prefs:root=INTERNET_TETHERING2.WIFI设置prefs:root=WIFI3.蓝牙设置prefs:root=Bluetooth4.系统通知prefs:root=NOTIFICATIONS_ID5.通用设置prefs:root=General6.显示设置prefs:root=DISPLAY&amp;BRIGHTNESS7.壁纸设置prefs:root=Wallpaper8.声音设置prefs:root=Sounds9.隐私设置prefs:root=privacy10.打开 APP Storeprefs:root=STORE11.打开 Notesprefs:root=NOTES12.打开 Safariprefs:root=Safari13.打开 Musicprefs:root=MUSIC14.打开 photoprefs:root=Photos]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与 CSDN 的诀别]]></title>
    <url>%2F2016%2F09%2F10%2F%E4%B8%8E-CSDN-%E7%9A%84%E8%AF%80%E5%88%AB%2F</url>
    <content type="text"><![CDATA[写这个话题, 内心还是蛮沉重的. 几年前与 CSDN 不期而遇, 在里面各种折腾, 翻阅大牛们的博客, 写评论, 甚至打印出来. 在技术论坛不停地”灌水”, 订阅 CSDN 杂志, 准备练就一身武艺. 互联网的蓬勃发展, 让我原来不安的心有了更加狂躁的冲动. 在某个夜深人静的夜晚, 开启了奋笔疾书的历程, 踏上了 CSDN 的博客之旅.这么多年以来, CSDN 就像我的一个朋友, 不管是家长里短, 还是技术讨论, 各种心酸, 我都会记录在那里. 一坚持就是几年… 如今, 要离开 CSDN 的博客了, 不准备在那里继续’耕耘’了.总结起来有如下几个原因: 文章被任意的转载, 没经过本人的允许.我在论坛也问过该事, 没有任何回应, 很失望! 广告越来越多. 相比以前, 很难找到让人满意的有质量的文章. 再见, CSDN! 请原谅我的不辞而别!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活 写作</tag>
      </tags>
  </entry>
</search>
