<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Wireshark：抓取 HTTP 包]]></title>
      <url>/2018/09/01/Wireshark%EF%BC%9A%E6%8A%93%E5%8F%96-HTTP-%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="开篇简要"><a href="#开篇简要" class="headerlink" title="开篇简要"></a>开篇简要</h2><p><a href="http://www.veryitman.com/2018/08/20/%E5%88%9D%E8%AF%86-Wireshark/" target="_blank" rel="noopener">初识 Wireshark</a> 简单介绍了强大的 <code>Wireshark</code> 工具，想用好或者是说想发挥 <code>Wireshark</code> 的巨大威力，还有很长的路要走（对我来说）。学习 <code>Wireshark</code> 的成本要比其他网络抓包工具的成本高，所以请做好学习的准备。</p>
<p>我身边很多开发同事，甚至包括一些刚入职的测试工程师都不喜欢使用抓包工具，遇到问题凭着自己的感觉在那里侃侃而谈，既耽误时间又没有解决问题，有时候还伤了和气，明明可以使用工具可以解决的问题，偏偏要各抒己见。</p>
<p>说到 <code>Wireshark</code> 更是很少人使用，至少我身边的同事是这样。如果让你一直去看那些 RFC 等网络协议，不到半小时估计你就会感到疲惫，但是结合 <code>Wireshark</code> 来理解网络协议就会感到无比的快乐，何乐而不为呢？！</p>
<p>继续阅读下去，你可以了解到如下几个知识：</p>
<p><strong>1. 如何抓取 PC 端、iOS 设备的网络包？</strong><br><strong>2. 使用一些过滤条件如何查看包的内容？</strong><br><strong>3. 如何在 <code>Wireshark</code> 中显示域名？</strong></p>
<h2 id="PC-端的-HTTP-请求"><a href="#PC-端的-HTTP-请求" class="headerlink" title="PC 端的 HTTP 请求"></a>PC 端的 HTTP 请求</h2><p>打开 <code>Wireshark</code>，选择对应的网口，因为我使用的是无线网络（WiFi），所以选择 <code>Wi-Fi：en0</code> 这个网口，你可以根据你的网络使用情况来选择对应的网口，如下图：</p>
<p><img src="/upload/images/2018/09/01/1.jpg" alt=""></p>
<p>可以看到对应有网络数据的网口，<code>Wireshark</code> 还在右侧显示对应的波浪，很人性化的设计。双击对应的网口，就可以使用 <code>Wireshark</code> 来抓包看数据了。</p>
<p>下面我就以 PC 端访问 <code>www.veryitman.com</code> 来演示 HTTP 请求的抓包情况。</p>
<p>查看本机的 ip 地址，我的是 <code>10.4.17.7</code>, 再来看一下 <code>www.veryitman.com</code> 对应的 ip 地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping ww.veryitman.com</div></pre></td></tr></table></figure>
<p>显示结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">64 bytes from 185.199.110.153: icmp_seq=0 ttl=52 time=317.074 ms</div></pre></td></tr></table></figure>
<p>那么， <code>185.199.110.153</code> 就是其对应的 ip 地址。总的来说，对于 PC 端，源地址是 <code>10.4.17.7</code>，目的地址是 <code>185.199.110.153</code>，对于服务器来说，正好反过来。</p>
<p>首先在过滤器中输入 <code>http</code>, 如下图所示：</p>
<p><img src="/upload/images/2018/09/01/2.jpg" alt=""></p>
<p>然后打开浏览器，我使用的是 Chrome，打开 <code>http://www.veryitman.com/2018/08/20/%E5%88%9D%E8%AF%86-Wireshark/</code> 网站站点，<code>Wireshark</code> 显示如下（部分截图）：<br><img src="/upload/images/2018/09/01/3.jpg" alt=""></p>
<p>改变一下过滤语句，将之前的 <code>http</code> 改为 <code>ip.src==10.4.17.7 &amp;&amp; http &amp;&amp; ip.dst==185.199.109.153</code>， 显示如下：<br><img src="/upload/images/2018/09/01/4.jpg" alt=""></p>
<p>可以选择任何一个请求，展示区域如下：<br><img src="/upload/images/2018/09/01/5.jpg" alt=""></p>
<p>上图中的三个区域分别对应的是 <code>View</code> 中的 <code>Packet List</code>， <code>Packet Details</code>，<code>Packet Bytes</code> 三个视图。<br><img src="/upload/images/2018/09/01/6.jpg" alt=""></p>
<p>选择任何一个请求，在对应的 <code>区域2</code> 可以看到该请求的详情。</p>
<p>刚才使用的过滤条件只看到 PC（客户端）的请求，没有看到服务器返回信息，我们修改一下过滤条件为 <code>ip.src==185.199.109.153 &amp;&amp; http &amp;&amp; ip.dst==10.4.17.7</code>，这样就看以看到服务器的回包信息了，如下图所示：<br><img src="/upload/images/2018/09/01/7.jpg" alt=""></p>
<p>双击进入该响应，就可以看到对应的响应数据详情了。</p>
<h2 id="iOS-设备的-HTTP-请求"><a href="#iOS-设备的-HTTP-请求" class="headerlink" title="iOS 设备的 HTTP 请求"></a>iOS 设备的 HTTP 请求</h2><p>跟查看 PC 端的 HTTP 请求方式基本一致，只是此时的本机 ip 地址是手机端的而不是 pc 端的。</p>
<p><a href="http://www.veryitman.com/2018/08/20/%E5%88%9D%E8%AF%86-Wireshark/" target="_blank" rel="noopener">初识 Wireshark</a> 中已经跟大家分享过如何去连接 iOS 设备到 <code>Wireshark</code> 抓包了，这里不再赘述。</p>
<p>至于查看 iOS 设备的 ip 地址，就很简单了，打开 <code>设置/wifi</code> 看一下详情就知道了。</p>
<h2 id="显示域名"><a href="#显示域名" class="headerlink" title="显示域名"></a>显示域名</h2><p>如果你经常使用 <code>Charles</code> 抓包，就可以发现 <code>Charles</code> 展示的请求中都是以域名来显示的，但是在 <code>Wireshark</code> 都是显示 ip 地址，或许因此感到不适，那么，<code>Wireshark</code> 能否展示域名呢？</p>
<p><code>Wireshark</code> 是可以像 <code>Charles</code> 那样展示域名的，只是它默认显示 ip 地址罢了。</p>
<p>打开 Preferences，如图：<br><img src="/upload/images/2018/09/01/8.jpg" alt=""><br><img src="/upload/images/2018/09/01/9.jpg" alt=""></p>
<p>这样 <code>Wireshark</code> 的显示就是另一番景象了如下图所示：<br><img src="/upload/images/2018/09/01/10.jpg" alt=""></p>
<p>当然，你也看出来了，过滤条件还是可以使用的。</p>
<p>你还可以使用其他的过滤条件，如下面的一些过滤条件，能帮你快速定位你要的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http.host == &quot;veryitman.com&quot;</div><div class="line"></div><div class="line">http.host contains &quot;veryitman.com&quot;</div><div class="line"></div><div class="line">http contains &quot;HTTP/1.1 200 OK&quot;</div></pre></td></tr></table></figure>
<hr>
<p><strong>扫码关注，你我就各多一个朋友~</strong></p>
<p><img src="/upload/me/qrcode_wx.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Wireshark tcp ip udp http https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[卖废品的一次经历]]></title>
      <url>/2018/08/26/%E5%8D%96%E5%BA%9F%E5%93%81%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/</url>
      <content type="html"><![CDATA[<h2 id="偶遇"><a href="#偶遇" class="headerlink" title="偶遇"></a>偶遇</h2><p>这两天在收拾屋子，本来想把一些不重要的物品直接卖掉，省得给自己增加运输成本。但是又有些不舍，毕竟跟自己在一起生活了这么多年，每一本书，每对桌椅，每件衣服都是我和老婆努力挣钱买回来的，里面都包含着奋斗的故事。</p>
<p>话又说回来，无舍无得。于是，我就开始将物品分类，按照优先级挑选，重要的东西就放到箱子中，次要的就放到沙发上，不重要的就扔到大厅里，最后再来审视一遍这些不重要的物品是否还有留下来的必要，最终我把不重要的东西放到一个大袋子中，准备把它们卖给废品站。</p>
<p>在百度上面找了好几家附近收废品的，打电话过去都要求卖家自己把东西拿过去，态度十分不友好，我也就没再多问，就挂掉了电话。</p>
<p>无独有偶，中午下楼去买东西回来的时候，正好看到一个大爷骑着三轮车在我前面驰骋，大爷的车技贼溜，在小巷子中开出了赛车的感觉。还没等我张嘴，他就即将要离开我的视线，急中生智，我看到他车子后面留有电话，于是我就急忙的努力的追赶着去记住他的电话，最后迫不及待的放下手中的东西，拿出手机拨打了他的电话。</p>
<p>大爷办事利落，不一会就到了楼下，三下五除二的把废品收拾了一番，像是收获了一批战利品一样。他很惊诧为什么我知道他的电话，我说我看到了你车上的电话号码了，就记下来了。</p>
<p>大爷说：“小伙子，你的记性还真好，不愧是上过大学的人。“，我说：“是呀，我过目不忘！哈哈！”。</p>
<p>那天中午，我把东西半卖半送的都给这位大爷了，谁叫他夸我呢！</p>
<h2 id="思量"><a href="#思量" class="headerlink" title="思量"></a>思量</h2><p>上面这件事算不上什么大事，顶多也就算个鸡毛蒜皮的小事，但是给了我很多回忆和思考。</p>
<p>很多高中生也包括他们的家长们，都经常会说等上了大学就好了，不用那么累了，在大学的殿堂里可以无忧无虑的 <code>享受</code> 了。在我看来这是不对的，高中之所以累是因为有连绵不绝的作业和没有尽头的考试，当然还有班主任喋喋不休的教导，让你的神经时长处于紧绷的状态。高中是人生中必经的一个过程，至少我觉得它锻炼了我的意志和耐力，包括对心理上的考验，我很感激高中三年的生活。</p>
<p>大学生活和学习的确是一个值得向往和想象的，你可以吊儿郎当的过完几年大学生活，也可以努力拼搏过来，没有人逼你去怎么做，完全取决于你自己。</p>
<p>我大学的成绩算是优异，每次看到奖学金名单上有自己的名字，同学们都会说你真厉害，居然考这么好的成绩。我会说，如果你再努力一下肯定比我考的更好，就像那个大爷说我好记性一样，其实并不是我过目不忘，而是自己努力的结果，因为我知道自己并不是天才。</p>
<p>很多人进入社会参加工作后，发现工作并不是想象中的那般一帆风顺，自己一起进公司的同事，明明能力和自己相当甚至还不如自己，为什么别人就升职加薪，马上就要走上人生巅峰了，自己却还是原地踏步或者举步维艰呢？总是想不明白这是为什么，那是因为你自己没有看到别人比你更加努力。</p>
<p>还有不少人会抱怨为什么别人能力没有我强，领导偏偏把一些重要的事情交给了他，开始怀疑对方是不是对领导施了什么魔法，而自己从来都没有想过怎么去向对方请教，或者思考自己是不是真的做好了本职工作。</p>
<p><strong><em>这件小事给了我几个启发：</em></strong></p>
<p><strong>1. 一定要给自己树立一个长远目标和短期目标，不断的完成短期目标，向长远目标前进。</strong></p>
<p><strong>2. 对于别人的赞美或是诋毁，要保持一颗平常心，戒骄戒躁。</strong></p>
<p><strong>3. 不要总是夸你的孩子聪明，要夸他比别人更努力，因为努力比聪明更重要。</strong></p>
<p><strong>4. 不要总是抱怨命运的不公，多去审视自己的不足，想办法去补全。</strong></p>
<p><strong>5. 有个可以交心的朋友尤为重要，可以让彼此敞开心扉，无所顾忌的交谈。</strong></p>
<p>这个世上没有免费的午餐，一切都要靠你自己去奋斗去争取，机会总是留给有准备的人，坚持自己的目标一直前行，相信自己，机会总有一天会和你不期而遇。</p>
<p>相信总有一天，你会感激正在努力的自己！</p>
<hr>
<p><strong>扫码关注，你我就各多一个朋友~</strong></p>
<p><img src="/upload/me/qrcode_wx.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 感悟 学习 阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 Wireshark]]></title>
      <url>/2018/08/20/%E5%88%9D%E8%AF%86-Wireshark/</url>
      <content type="html"><![CDATA[<p><a href="http://www.veryitman.com/2017/07/23/%E4%BD%BF%E7%94%A8-Charles/" target="_blank" rel="noopener">使用 Charles</a> 介绍了在 MacOS 上面的使用 <code>Charles</code> 工具, 虽然 <code>Charles</code> 很不错, 但是其只能抓 HTTP/HTTPS 的包, 对 TCP、UDP 等其他协议的网络包, 爱莫能助。</p>
<p>今天给大家分享强大的网络抓包工具 <code>Wireshark</code>，算是初步认识一下这个工具，后续分享更多关于 <code>Wireshark</code> 的内容。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Wireshark</code> 是免费的，支持 Windows、MacOS 和 Linux，提供丰富的 GUI 交互，能分析所有的网络协议，并且是开源的。</p>
<p><img src="/upload/images/2018/08/20/1.jpg" alt=""></p>
<p>掌握好 <code>Wireshark</code>，能对绝大部分的网络协议进行分析了，所以学习它的使用对你的工作不无裨益。</p>
<p>关于 <code>Wireshark</code> 本身 UI（展示的界面内容） 的部分不在本文的讨论范围内，更多关于 <code>Wireshark</code> 的介绍和特性，可以去 <a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark 官网</a> 查阅。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我的 MacOS 版本:<br><img src="/upload/images/2018/08/20/2.jpg" alt=""></p>
<p>点击 <code>Wireshark</code> 的 <a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">下载地址</a>, 可以去下载对应的平台版本。</p>
<p><img src="/upload/images/2018/08/20/3.jpg" alt=""></p>
<blockquote>
<p>注意: 之前的 Mac 系统版本可能需要安装 <code>x11</code>, 现在新系统不需要安装了.</p>
</blockquote>
<h2 id="抓-iOS-设备的数据包"><a href="#抓-iOS-设备的数据包" class="headerlink" title="抓 iOS 设备的数据包"></a>抓 iOS 设备的数据包</h2><p>想抓 iOS 设备的网络数据，需要让 iOS 设备数据通过 MacOS 才行，因为 <code>Wireshark</code> 是针对网口进行抓包的。</p>
<p>当然了，你的 iOS 设备不需要越狱.</p>
<p>通过 usb 连接 iOS 设备后，接下来创建远程虚拟接口，在终端执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvictl -s 设备id(udid)</div></pre></td></tr></table></figure>
<blockquote>
<p>rvictl 即 Remote Virtual Interface Tool。它可以通过 iOS 设备的 UDID 创建一个虚拟网卡，然后通过这个虚拟网卡监听设备上所有的网络流量。</p>
</blockquote>
<p>执行成功后，Mac 会出现一个对应的虚拟网络接口，名字是 rvi0（如果有多个 iOS 设备， 则累加，rvi1，rvi2…），如下图所示：<br><img src="/upload/images/2018/08/20/4.jpg" alt=""></p>
<p>只要启动 <code>Wireshark</code>，监听 rvi0 接口就能抓到 iOS 设备的数据了。</p>
<blockquote>
<p>关于获取 iOS 设备 ID(UDID)，可以使用 Xcode, 在 <code>Window/Devices and Simulators</code> 中选择相应设备，右面设备信息的 identifier 里就是对应的 UDID. 也可以通过 iTunes 或者第三方工具如 iTools 获取.</p>
</blockquote>
<p>你可以安装 <code>ideviceinstaller</code> 来查看设备 ID.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ideviceinstaller</div></pre></td></tr></table></figure>
<p>然后执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">idevice_id -l</div></pre></td></tr></table></figure>
<p>以抓取下面的一个 HTTP 请求为例，简单说明一下相关的知识。</p>
<p>GET 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/news/detailV3.html?id=1279391&amp;COMMON_ACCESS_TOKEN=(null)&amp;COMMON_ACCESS_TOKEN_SECRET=(null)&amp;_cT=IOS&amp;_cV=3.1.3&amp;_cA=PM</div></pre></td></tr></table></figure>
<p>看返回结果，选中 Rsponse(200 OK) 右键, Follow/HTTP Stream，如图所示：<br><img src="/upload/images/2018/08/20/5.jpg" alt=""></p>
<p>在弹出的窗口中就可以看到具体的响应内容，以及响应的 json 数据。</p>
<h2 id="过滤器过滤"><a href="#过滤器过滤" class="headerlink" title="过滤器过滤"></a>过滤器过滤</h2><p>在 <code>Wireshark</code> 中显示过滤器会显示很多当前网络的数据包，如果你想看指定规则的数据包怎么办？</p>
<p>别担心，<code>Wireshark</code> 给我们提供了过滤功能，按照一定的过滤规则就可以达到你的目的。</p>
<p><strong>1. 网络协议过滤</strong></p>
<p>比如 TCP，只显示 TCP 协议，HTTP 只显示 HTTP 协议等。在过滤器输入框中直接输入协议名称即可，不区分大小写。</p>
<p><strong>2. IP 地址过滤</strong></p>
<p>如 ip.src == 192.168.1.102 显示源地址为 <code>192.168.1.102</code>，<br>而 ip.dst == 192.168.1.102, 目标地址为 <code>192.168.1.102</code>。</p>
<p><strong>3. 端口过滤</strong></p>
<p>tcp.port == 80, 端口为 80 的</p>
<p>tcp.srcport == 80, 只显示 TCP 协议的原端口为 80 的。</p>
<p><strong>4. Http 模式过滤</strong></p>
<p>http.request.method == “GET”，只显示 HTTP GET 方法的。</p>
<p><strong>5. 结合逻辑运算符 AND/OR 组成复杂的表达式</strong></p>
<blockquote>
<p>AND/OR 也可以写成 <code>&amp;&amp;</code> / <code>||</code></p>
</blockquote>
<p>下面举几个常用的示例，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//源地址或者目标地址是192.168.1.103</div><div class="line">ip.src == 192.168.1.103 or ip.dst == 192.168.1.103</div><div class="line"></div><div class="line">//显示所有目标或源地址是192.168.1.1的数据包</div><div class="line">ip.addr == 192.168.1.1 </div><div class="line"></div><div class="line">//显示目标地址是192.168.1.1的数据包</div><div class="line">ip.dst == 192.168.1.1 </div><div class="line"></div><div class="line">//显示源地址是192.168.1.1的数据包</div><div class="line">ip.src == 192.168.1.1 </div><div class="line"></div><div class="line">//tcp 连接端口为9101的数据包</div><div class="line">tcp.port == 9101</div></pre></td></tr></table></figure>
<p>更多的过滤规则可以去 <a href="https://www.wireshark.org/docs/man-pages/wireshark-filter.html" target="_blank" rel="noopener">官方手册</a> 和 <a href="https://wiki.wireshark.org/CaptureFilters" target="_blank" rel="noopener">CaptureFilters</a> 查阅和学习。</p>
<h2 id="美中不足"><a href="#美中不足" class="headerlink" title="美中不足"></a>美中不足</h2><p><code>Wireshark</code> 只能查看封包，而不能修改封包的内容，或者发送封包。</p>
<p>对于 HTTP、HTTPS 网络封包，<code>Wireshark</code> 都可以捕获， 但不能直接解密 HTTPS，所以想使用 <code>Wireshark</code> 来分析 HTTPS 包中的内容，需要去额外配置，较麻烦，后续研究再分享给大家。</p>
<p>所以建议大家，分析 HTTP/HTTPS 去使用各自平台上面的其他工具， 如 <code>Fiddler</code> 和 <code>Charles</code> 等优秀的抓包工具。</p>
<hr>
<p><strong>扫码关注，你我就各多一个朋友~</strong></p>
<p><img src="/upload/me/qrcode_wx.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Wireshark tcp ip udp http https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置 php7 + Nginx]]></title>
      <url>/2018/08/19/%E9%85%8D%E7%BD%AE-php7-Nginx/</url>
      <content type="html"><![CDATA[<h2 id="配置-php7-Nginx"><a href="#配置-php7-Nginx" class="headerlink" title="配置 php7 + Nginx"></a>配置 php7 + Nginx</h2><p>之前为了配合完成一个项目（PHP 版本为5.6），在本机搭建了 php56 的环境，后面自己系统（macos）升级了，发现系统自带的 PHP 版本已经是 7.1 了，于是就开始使用系统自带的 PHP 版本了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -v</div></pre></td></tr></table></figure>
<p>显示 PHP 版本信息，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PHP 7.1.16 (cli) (built: Apr  1 2018 13:14:42) ( NTS )</div><div class="line">Copyright (c) 1997-2018 The PHP Group</div><div class="line">Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies</div></pre></td></tr></table></figure>
<p>安装 PHP56 可以参考：</p>
<ul>
<li><p><a href="http://www.veryitman.com/2017/02/02/PHP-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/" target="_blank" rel="noopener">PHP开发准备</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2017/02/02/%E5%AE%89%E8%A3%85-PHP-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">安装 PHP 遇到的问题</a></p>
</li>
</ul>
<h2 id="卸载-PHP56"><a href="#卸载-PHP56" class="headerlink" title="卸载 PHP56"></a>卸载 PHP56</h2><p>执行 brew uninstall </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew uninstall php</div></pre></td></tr></table></figure>
<p>即可完成卸载。</p>
<p>如果卸载遇到问题，就打开 <code>/usr/local/Cellar/</code> 目录，删除对应的 PHP 目录即可。</p>
<h2 id="配置-php-fpm"><a href="#配置-php-fpm" class="headerlink" title="配置 php-fpm"></a>配置 php-fpm</h2><p>现在新版本的 PHP 其内核已经集成了 php-fpm，我们不需要另外安装了。</p>
<p>配置 php-fpm 配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf</div></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /private/etc/php-fpm.conf</div></pre></td></tr></table></figure>
<p>找到 error_log 项，添加下面两个配置项，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error_log = /usr/local/var/log/php-fpm.log</div><div class="line">pid = /usr/local/var/run/php-fpm.pid</div></pre></td></tr></table></figure>
<p>如果不配置上面的配置项，启动 php-fpm 会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)</div><div class="line">ERROR: failed to post process the configuration</div><div class="line">ERROR: FPM initialization failed</div></pre></td></tr></table></figure>
<p>接下来, 继续配置，将 <code>www.conf.default</code> 复制一份命名为 <code>www.conf</code> 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /private/etc/php-fpm.d/</div><div class="line"></div><div class="line">sudo cp www.conf.default www.conf</div></pre></td></tr></table></figure>
<p>不配置上面的，会报如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR: No pool defined. at least one pool section must be specified in config file</div><div class="line">ERROR: FPM initialization failed</div></pre></td></tr></table></figure>
<p>至此，可以启动 php-fpm 了，执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php-fpm -D</div></pre></td></tr></table></figure>
<p>不出意外的话，已经成功启动，可以使用下面命令查看端口使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an | grep 9000</div></pre></td></tr></table></figure>
<p>如果你在启动 php-fpm 遇到下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR: unable to bind listening socket for address &apos;127.0.0.1:9000&apos;: Address already in use (48)</div><div class="line">ERROR: FPM initialization failed</div></pre></td></tr></table></figure>
<p>有两种方式解决这个问题</p>
<p><strong>1.</strong>修改 php-fpm 使用的端口号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /private/etc/php-fpm.d/www.conf</div></pre></td></tr></table></figure>
<p>将 <code>listen = 127.0.0.1:9000</code> 改为 <code>listen = 127.0.0.1:9001</code> 即可。</p>
<p><strong>2.</strong>杀掉9000端口占用的进程</p>
<p>关闭所有之前启动的 php-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall php-fpm</div></pre></td></tr></table></figure>
<p>找到占用端口的进程号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an | grep 9000</div></pre></td></tr></table></figure>
<p>然后 <code>kill -9 pid</code>，重新启动 php-fpm 即可。</p>
<h2 id="安装和配置-Nginx"><a href="#安装和配置-Nginx" class="headerlink" title="安装和配置 Nginx"></a>安装和配置 Nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install nginx</div></pre></td></tr></table></figure>
<p>创建文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir -p /usr/local/var/log/nginx</div><div class="line">mkdir -p /usr/local/etc/nginx/sites-available</div><div class="line">mkdir -p /usr/local/etc/nginx/sites-enabled</div><div class="line">mkdir -p /usr/local/etc/nginx/conf.d</div><div class="line">mkdir -p /usr/local/etc/nginx/ssl</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /var/www</div><div class="line">sudo chown :staff /var/www</div><div class="line">sudo chmod 775 /var/www</div><div class="line">vi /var/www/info.php</div><div class="line">vi /var/www/index.html</div><div class="line">vi /var/www/403.html</div><div class="line">vi /var/www/404.html</div></pre></td></tr></table></figure>
<p>改变 nginx.conf 配置文件</p>
<p>该配置文件在 <code>/usr/local/etc/nginx/nginx.conf</code> 下面.</p>
<p>我的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">worker_processes  1;</div><div class="line"> </div><div class="line">error_log  /usr/local/etc/nginx/logs/error.log debug;</div><div class="line">pid        /usr/local/var/run/nginx.pid;</div><div class="line"> </div><div class="line">events &#123;</div><div class="line">    worker_connections  256;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">http &#123;</div><div class="line">    include             mime.types;</div><div class="line">    default_type        application/octet-stream;</div><div class="line"> </div><div class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line"> </div><div class="line">    access_log  /usr/local/etc/nginx/logs/access.log  main;</div><div class="line"> </div><div class="line">    sendfile            on;</div><div class="line"> </div><div class="line">    keepalive_timeout   65;</div><div class="line"> </div><div class="line">    index index.html index.php;</div><div class="line"> </div><div class="line">    include /usr/local/etc/nginx/sites-enabled/*; </div><div class="line">    include /usr/local/etc/nginx/conf.d/*;</div><div class="line">     server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  localhost;</div><div class="line">        #charset koi8-r;</div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line">        location / &#123;</div><div class="line">            root   ~/projs/phpdev/nginx/nginx_sites/; #web的根目录</div><div class="line">            index  index.php index.html index.htm; #加index.php</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	root   ~/projs/phpdev/nginx/nginx_sites/; #web的根目录</div><div class="line">	index  index.php index.html index.htm; #加index.php</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置了我的 web 目录和支持的文件.</p>
<h2 id="运行-PHP"><a href="#运行-PHP" class="headerlink" title="运行 PHP"></a>运行 PHP</h2><ul>
<li><p>创建 index.php</p>
</li>
<li><p>启动 php-fpm</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php-fpm</div></pre></td></tr></table></figure>
<p>或者以守护进程的方式来启动 PHP-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php-fpm -D</div></pre></td></tr></table></figure>
<ul>
<li>启动 Nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nginx</div></pre></td></tr></table></figure>
<ul>
<li>编辑 index.php</li>
</ul>
<p>在 web 目录(我配置的) <code>~/projs/phpdev/nginx/nginx_sites/</code> 新建文件 <code>index.php</code>.</p>
<p>index.php 里面可以编写代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!-- lang: php --&gt;</div><div class="line">&lt;!-- ~/nginx_sites/index.php --&gt;</div><div class="line">&lt;?php</div><div class="line">    echo &quot;Hello PHP&quot;;</div><div class="line">    echo &quot;&lt;/br&gt;&quot;;</div><div class="line">    </div><div class="line">    echo &quot;学习 php&quot;;</div><div class="line">    echo &quot;&lt;/br&gt;&quot;;</div><div class="line">    echo phpinfo();</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>打开浏览器, 输入地址：<a href="http://localhost:8080/index.php" target="_blank" rel="noopener">http://localhost:8080/index.php</a> 你会看到下面的页面:<br><img src="/upload/images/2018/08/19/1.jpg" alt=""></p>
<p>也可以在该目录下创建其他 PHP 文件, 如 <code>m.php</code> 文件.</p>
<p>浏览器中输入 <a href="http://localhost:8080/m.php" target="_blank" rel="noopener">http://localhost:8080/m.php</a> 可以执行相对应的文件.</p>
<p><strong>注意：</strong>这里的 <code>m.php</code> 是新建的 PHP 文件.</p>
<h2 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h2><p><strong>1. nginx log 文件</strong></p>
<p><code>/usr/local/var/log/nginx/access.log</code></p>
<p><code>/usr/local/var/log/nginx/error.log</code></p>
<p><code>/usr/local/etc/nginx/logs/error.log</code></p>
<p><strong>2. nginx 配置文件</strong></p>
<p><code>/usr/local/etc/nginx/nginx.conf</code></p>
<p><strong>3. php-fpm 配置文件</strong></p>
<p><code>/private/etc/php-fpm.d/www.conf</code></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>502 bad gateaway</strong></p>
<p>我是经常看到这个问题，但是每次引起的原因又不太一样，绝大部分是因为 <code>php-fpm</code> 启动不了或者是其端口错误导致的。</p>
<p>这种情况下，建议去看 <code>/usr/local/etc/nginx/logs/error.log</code> 日志文件。</p>
<p>例如下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[error] </div><div class="line">61016#0: *1 kevent() reported that connect() failed (61: Connection refused) while connecting to upstream, </div><div class="line">client: 127.0.0.1, </div><div class="line">server: localhost, </div><div class="line">request: &quot;GET /3.php HTTP/1.1&quot;, </div><div class="line">upstream: &quot;fastcgi://127.0.0.1:9000&quot;, </div><div class="line">host: &quot;localhost:8080&quot;</div></pre></td></tr></table></figure>
<p>最终，我修改了 <code>/private/etc/php-fpm.d/www.conf</code> 中端口为 <code>9000</code>（我之前将该端口修改了其他的），重启 <code>php-fpm</code> 解决问题。 </p>
<hr>
<p><strong>扫码关注，你我就各多一个朋友~</strong></p>
<p><img src="/upload/me/qrcode_wx.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP MySql nginx php-fpm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单配置 Apache]]></title>
      <url>/2018/07/14/%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE-Apache/</url>
      <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>有时候, 我们希望在自己本机(PC)搭建一个 WebServer, 然后自己可以在浏览器或者手机上面可以访问对应的地址直接查看效果, 再或者希望测试下载功能等, 其实 MacOS 自带的有 Apache 服务器.</p>
<p>下面简单分享一下, 在 MacOS 中如何简单的使用 Apache 服务器.</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>常用的命令有开启/重启/停止等.</p>
<p>1.开启: <code>sudo apachectl start</code><br>2.重启: <code>sudo apachectl restart</code><br>3.关闭: <code>sudo apachectl stop</code><br>4.查看版本号: <code>httpd -v</code></p>
<p><strong>1.查看 Apache 版本号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">httpd -v</div></pre></td></tr></table></figure>
<p>或者使用下面的命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apachectl -v</div></pre></td></tr></table></figure>
<p>查看结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Server version: Apache/2.4.28 (Unix)</div><div class="line">Server built:   Oct  9 2017 19:54:20</div></pre></td></tr></table></figure>
<p><strong>2.启动 Apache</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apachectl start</div></pre></td></tr></table></figure>
<p>在浏览器打开: <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></p>
<p>会显示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">It works</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/07/14/1.jpg" alt=""></p>
<p><strong>3.停止 Apache</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apachectl stop</div></pre></td></tr></table></figure>
<p>如果没有开启 Apache 服务, 执行上面命令的话, 会报下面的错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/System/Library/LaunchDaemons/org.apache.httpd.plist: </div><div class="line">Could not find specified service</div></pre></td></tr></table></figure>
<p><strong>4.重新启动 Apache</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apachectl restart</div></pre></td></tr></table></figure>
<p>如果修改了 Apache 的配置文件, 需要重新启动 Apache 服务, 执行上面的命令即可.</p>
<h2 id="配置-Sites"><a href="#配置-Sites" class="headerlink" title="配置 Sites"></a>配置 Sites</h2><p>在自己的用户目录, 新建一个 <code>Sites</code> 目录, 例如我的用户目录是 <code>/Users/mark</code>, 可以在终端分别执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /Users/mark</div><div class="line"></div><div class="line">mkdir Sites</div></pre></td></tr></table></figure>
<p>执行成功后, 可以看到如下图所示的目录:</p>
<p><img src="/upload/images/2018/07/14/2.jpg" alt=""></p>
<p>接下来修改 Apache 中的配置文件, 执行下面命令开始编辑 <code>httpd.conf</code> 文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/apache2/httpd.conf</div></pre></td></tr></table></figure>
<p>打开 httpd.conf 文件，查找 <code>userdir</code> 关键字.</p>
<p>找到如下两行被注释掉的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#Include /private/etc/apache2/extra/httpd-userdir.conf</div><div class="line"></div><div class="line">#LoadModule userdir_module libexec/apache2/mod_userdir.so</div></pre></td></tr></table></figure>
<p>将其前面的 <code>#</code>(注释) 去掉, 紧接着编辑这个文件, 增加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Directory /Users/mark/Sites&gt;</div><div class="line">  Require all granted</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<p>将上面的这些代码放到如下代码下面即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Directory &quot;/Library/WebServer/CGI-Executables&quot;&gt;</div><div class="line">    AllowOverride None</div><div class="line">    Options All</div><div class="line">    Require all granted</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>
<p>保存该文件并退出 vim.</p>
<p>执行下面的命令修改 <code>httpd-userdir.conf</code> 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /private/etc/apache2/extra/httpd-userdir.conf</div></pre></td></tr></table></figure>
<p>增加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UserDir Sites</div><div class="line"></div><div class="line">&lt;IfModule bonjour_module&gt;</div><div class="line">   RegisterUserSite customized-users</div><div class="line">&lt;/IfModule&gt;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong> 如果在 <code>/private/etc/apache2/extra/</code> 目录下没有该文件, 新建一个即可.</p>
<p>保存文件并退出即可.</p>
<p>我们可以将自己需要运行的 html 等文件放到该目录, 如我将 <code>index.html</code> 放到该目录.</p>
<p>重新启动 Apache 服务, 在浏览器中输入 <code>http://localhost/~mark/</code>, 可以看到 <code>index.html</code> 里面的内容.</p>
<h2 id="WebServer-目录"><a href="#WebServer-目录" class="headerlink" title="WebServer 目录"></a>WebServer 目录</h2><p>上面我们提到, 启动 Apache 服务之后, 在浏览器可以看到 <code>It Works</code> 的字样, 那么这个是哪个文件输出的呢?</p>
<p>这个文件是 <code>sudo mvim index.html.en~orig</code>, 在如下目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/WebServer/Documents</div></pre></td></tr></table></figure>
<p>可以使用 vim 编辑该文件, 然后再刷新浏览器就可以看到其变化.</p>
<p>我们也可以把自己的 html 文件放到这里, 如 <code>mark.html</code>, 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">	&lt;h1&gt;Hi, mark, Apache server works!&lt;/h1&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>在浏览器中输入 <code>http://localhost/mark.html</code>, 可以看到对应的输出.</p>
<p>如果嫌配置 <code>Sites</code> 目录麻烦, 可以使用这种方式, 直接拷贝对应的文件或者目录放到 <code>/Library/WebServer/Documents</code> 中, 只不过需要 root 权限罢了.</p>
<hr>
<p><strong>扫码关注，你我就各多一个朋友~</strong></p>
<p><img src="/upload/me/qrcode_wx.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Apache WebServer MacOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RunLoop: 移除常驻线程]]></title>
      <url>/2018/07/01/RunLoop-%E7%A7%BB%E9%99%A4%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>下面两篇文章:</p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/04/21/%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener">常驻线程是一种什么体验</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/05/06/RunLoop-NSTimer-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">NSTimer 实现常驻线程的问题</a></p>
</li>
</ul>
<p>都是在 iOS 平台上如何利用 <code>RunLoop</code> 的特性实现常驻线程.</p>
<p>可能你看到本篇文章的标题 <code>移除常驻线程</code>, 有点不理解甚至觉得作者是不是有点神经病, 都已经需要常驻线程了, 为什么还要去退出呢?</p>
<p>实际应用场景中的确几乎遇不到这种情况, 所以, 本篇只是从技术的角度给大家分享 <code>RunLoop</code> 其他的一些知识点.</p>
<p>且耐住性子往下看…</p>
<p>为了不让大家误解, 统一一下相关的词汇和语境.</p>
<ul>
<li>输入源, 包括 source 和 timer.</li>
<li>退出 RunLoop 指的是在常驻线程的方法中立即返回.</li>
<li>这里的 RunLoop 指的是子线程中的 RunLoop 不是主线程中的.</li>
<li>结合之前介绍常驻线程的文章来看现在的文章, 不然不好理解.</li>
</ul>
<h2 id="运行-RunLoop-的方法"><a href="#运行-RunLoop-的方法" class="headerlink" title="运行 RunLoop 的方法"></a>运行 RunLoop 的方法</h2><p>这里有三种方式开启运行 RunLoop, 分别如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)run;</div><div class="line"></div><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div><div class="line"></div><div class="line">- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure>
<ul>
<li><strong>run 方法</strong></li>
</ul>
<p>看一下 API 文档如何解释 <code>run</code> 方法的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Puts the receiver into a permanent loop, </div><div class="line">during which time it processes data from all attached input sources.</div><div class="line">If no input sources or timers are attached to the run loop, this method exits immediately; </div><div class="line">otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. </div><div class="line">In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</div></pre></td></tr></table></figure>
<p>大致意思讲的是, 在没有任何输入源的情况下, <code>run</code> 方法会立即执行后退出, 不会保持线程的持久性, 换句话说, 在有输入源的情况下, 该方法会进入一个无限循环当中. 本质上, 在 <code>NSDefaultRunLoopMode</code> 模式下, 该方法是反复调用 <code>runMode:beforeDate:</code> 方法的.</p>
<p>在之前文章实现常驻线程的代码中, 我们使用了 <code>run</code> 方法来开启运行 RunLoop.</p>
<p>可以看出, 我们之前实现的常驻线程使用 <code>run</code> 方法是无法退出常驻线程的.</p>
<ul>
<li><strong>runUntilDate:(NSDate *)limitDate 方法</strong></li>
</ul>
<p>该方法 API 释义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Runs the loop until the specified date, </div><div class="line">during which time it processes data from all attached input sources.</div></pre></td></tr></table></figure>
<p>保证有输入源的情况下该方法启动的 RunLoop 可以在指定的日期内一直运行不会返回. 换句话说, 日期只要已到该方法就会立即退出 RunLoop.</p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//等同于 run, 可保证一直运行</div><div class="line">[runLoop runUntilDate:[NSDate distantFuture]];</div><div class="line"></div><div class="line">//立即返回, 退出 RunLoop</div><div class="line">[runLoop runUntilDate:[NSDate date]];</div><div class="line"></div><div class="line">//然后过12秒后返回</div><div class="line">[runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:12.0f]];</div></pre></td></tr></table></figure>
<ul>
<li><strong>runMode:(NSString <em>)mode beforeDate:(NSDate </em>)limitDate 方法</strong></li>
</ul>
<p>该方法有两个参数 <code>mode</code> 和 <code>limitDate</code>, <code>mode</code> 就是 RunLoop 的运行模式, <code>limitDate</code> 就是上面方法一样的释义即在指定的日期内.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runs the loop once, blocking for input in the specified mode until a given date.</div></pre></td></tr></table></figure>
<p>可以这么理解, 该方法开启的 RunLoop 处理完之后会立即返回(once), 如果在指定日期内事件还没处理, 在该日期后会立即返回.<br>换句话说, 如果指定的日期是当前的, 该方法执行后 RunLoop 会立即退出.</p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//立即返回</div><div class="line">[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate date]];</div><div class="line">        </div><div class="line">//有事件到达处理后就返回，如果没有则过12秒返回</div><div class="line">[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:12.0]];</div></pre></td></tr></table></figure>
<p>这三个方法, 总结一下大概如下:</p>
<ul>
<li>这三个方法在没有任何输入源情况下会都立即返回(退出 RunLoop), 不会等待.</li>
<li><code>run</code> 可保证 RunLoop 在有输入源的情况下一直运行.</li>
<li><code>runUntilDate</code> 可以通过设置超时时间来退出 RunLoop. 超时时间一过就会立即退出 RunLoop.</li>
<li>使用 <code>runMode</code> 方式启动的 RunLoop 会在处理完事件后或者超时后, 立即返回. 即可以通过设置超时时间或者使用 <code>CFRunLoopStop</code> 方法来退出 RunLoop.</li>
</ul>
<h2 id="移除常驻线程"><a href="#移除常驻线程" class="headerlink" title="移除常驻线程"></a>移除常驻线程</h2><p>先看一下, 在子线程执行的方法中如何实现的. 示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        _threadRunLoop = runLoop;</div><div class="line">        </div><div class="line">        // 保持常驻线程的方式1: source</div><div class="line">        NSPort *port = [NSMachPort port];</div><div class="line">        _threadPort = port;</div><div class="line">        [runLoop addPort:port forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        // 手动开启 RunLoop</div><div class="line">        // [runLoop run];</div><div class="line">        </div><div class="line">        while (!self.stopLoopRunning &amp;&amp; [runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantPast]]) &#123;</div><div class="line">            </div><div class="line">            // 这里是为了验证常驻线程是否已经退出</div><div class="line">            NSLog(@&quot;--- asyncRun ----&quot;);</div><div class="line">            </div><div class="line">            // 实际业务中, 建议使用空语句实现</div><div class="line">            ; //实现为空语句</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合上面讲解的原理, 这里选择使用 <code>runMode</code> 方法来开启运行 RunLoop. 大家也可以自由发挥使用其他的方法.</p>
<p><strong>注意: <code>stopLoopRunning</code> 是定义的一个属性.</strong></p>
<p>移除的示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    </div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">    </div><div class="line">    // 取消线程</div><div class="line">    // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例</div><div class="line">    BOOL canCancel = YES;</div><div class="line">    if (canCancel) &#123;</div><div class="line">        [[self permanentThread] cancel];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// 停止常驻线程</div><div class="line">    &#123;</div><div class="line">        self.stopLoopRunning = YES;</div><div class="line">        </div><div class="line">        // 移除 port</div><div class="line">        // 如果是用 timer 的方式的常驻线程, 可以 invalid 对应的 timer</div><div class="line">        [self.threadRunLoop removePort:self.threadPort forMode:NSRunLoopCommonModes];</div><div class="line">        </div><div class="line">        // 停止 RunLoop</div><div class="line">        if (nil != self.threadRunLoop) &#123;</div><div class="line">            CFRunLoopStop([self.threadRunLoop getCFRunLoop]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>离开页面后, 可以发现 <code>NSLog(@&quot;--- asyncRun ----&quot;);</code> 停止了打印, 并且当前的 Controller 也 dealloc 了.</p>
<hr>
<p><strong>扫码关注，你我就各多一个朋友~</strong></p>
<p><img src="/upload/me/qrcode_wx.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RunLoop 常驻线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 逆向: dumpdecrypted 砸壳记]]></title>
      <url>/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>今天是一个特别的日子, 高考的第一天, 祝各位莘莘学子金榜题名.</p>
<hr>
<p><a href="http://www.veryitman.com/2018/05/13/iOS-%E9%80%86%E5%90%91-%E7%A0%B8%E5%A3%B3/" target="_blank" rel="noopener">iOS 逆向: 砸壳</a> 介绍了如何使用工具 <code>Clutch</code> 对 iOS 的应用进行砸壳操作, 今天继续给大家分享使用另外一个工具 <code>dumpdecrypted</code> 对 APP 进行砸壳.</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>有些朋友就会问了, 既然 <code>Clutch</code> 已经很牛B了, 为什么还需要 <code>dumpdecrypted</code> 这个工具呢? </p>
<p>刚开始的时候, 我也很排斥使用 <code>dumpdecrypted</code> 这个工具的, 使用起来比较复杂, 并且套路不熟的情况下还很容易出错. </p>
<p>之前说过 <code>Clutch</code> 并不是万能的, 从 App Store 下载的 App(比如 WeChat)有些并不能使用 <code>Clutch</code> 来进行砸壳, 换句话说, 使用 <code>Clutch</code> 工具来进行砸壳会失败, 那么, <code>dumpdecrypted</code> 就登场了.</p>
<p>本次砸壳的系统依然是 <code>iOS10.3.x</code>, 工具使用 <code>dumpdecrypted</code>, 砸壳的对象是 WeChat 这个 App.</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>MacOS PC</li>
<li>越狱手机一台(我用的是iPhone6SPlus 10.3.1)</li>
<li>dumpdecrypted</li>
<li>class-dump</li>
<li>在 Cydia 中安装 cycript, 可以先不用管 cycript 是什么, 下载安装即可.</li>
<li>iFunBox 或者其他助手工具</li>
</ul>
<h2 id="编译-dumpdecrypted"><a href="#编译-dumpdecrypted" class="headerlink" title="编译 dumpdecrypted"></a>编译 dumpdecrypted</h2><p>去 <a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">Github</a> 下载 <code>dumpdecrypted</code> 源码, 源码就一个 C 源文件.</p>
<p>下载 zip 包之后, 解压, 如图:<br><img src="/upload/images/2018/06/07/1.jpg" alt=""></p>
<p>在当前目录, 执行 <code>make</code> 即可完成编译, 如图所示:<br><img src="/upload/images/2018/06/07/2.jpg" alt=""></p>
<p>编译成功后生成 <code>dumpdecrypted.dylib</code> 文件.</p>
<p>这里有个小插曲, 编译 <code>dumpdecrypted</code> 的时候报错了, 错误信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xcrun: error: SDK &quot;iphoneos&quot; cannot be located</div><div class="line">xcrun: error: unable to lookup item &apos;Path&apos; in SDK &apos;iphoneos&apos;</div><div class="line">clang: warning: no such sysroot directory: &apos;-F/System/Library/Frameworks&apos; [-Wmissing-sysroot]</div><div class="line">dumpdecrypted.c:27:10: fatal error: &apos;stdio.h&apos; file not found</div></pre></td></tr></table></figure>
<p>无法找到对应的 <code>SDK</code> 和 <code>stdio.h</code> 文件, 这种问题大多数是 Xcode 路径造成的.</p>
<p>使用下面的命令看一下系统指向的 Xcode 路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcode-select -p</div></pre></td></tr></table></figure>
<p>控制台输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Developer/CommandLineTools</div></pre></td></tr></table></figure>
<p>显然不是 Xcode 的路径, 那只能重新切换一下其路径即指向正确的<code>Xcode</code> 路径即可.</p>
<p>命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo xcode-select --switch /Applications/Xcode.app</div></pre></td></tr></table></figure>
<p>再次编译 <code>dumpdecrypted</code> 即可成功完成.</p>
<h2 id="对-dumpecrypted-dylib-签名"><a href="#对-dumpecrypted-dylib-签名" class="headerlink" title="对 dumpecrypted.dylib 签名"></a>对 dumpecrypted.dylib 签名</h2><blockquote>
<p>如果不对该文件进行签名, 后续砸壳的操作会失败.</p>
</blockquote>
<p>先找到已经在电脑上面安装的苹果开发者证书, 操作如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">## 列出可签名证书, 找到 mac 上面已经安装的证书</div><div class="line">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>
<p>为 dumpecrypted.dylib 签名, 命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codesign --force --verify --verbose --sign &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; dumpdecrypted.dylib</div></pre></td></tr></table></figure>
<p>其中, <code>&quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot;</code> 为你自己本机安装的开发者证书名称.</p>
<h2 id="SSH-连接手机"><a href="#SSH-连接手机" class="headerlink" title="SSH 连接手机"></a>SSH 连接手机</h2><p>使用 OpenSSH 让 Mac 和手机连接起来 这样可以很方便的在 Mac 终端使用 shell 命令来操作手机的目录了.</p>
<p>关于 OpenSSH 的使用请参考我之前的博文 <a href="http://www.veryitman.com/2018/05/12/iOS-%E9%80%86%E5%90%91-%E8%B6%8A%E7%8B%B1%E4%BD%BF%E7%94%A8-SSH/" target="_blank" rel="noopener">iOS 逆向: 越狱使用 SSH</a>.</p>
<h2 id="查找目标-App-所在进程"><a href="#查找目标-App-所在进程" class="headerlink" title="查找目标 App 所在进程"></a>查找目标 App 所在进程</h2><ul>
<li>双击 Home 按键后, 手动杀掉 iPhone 上面所有在后台的 App.</li>
<li>Home 到手机桌面.</li>
<li>打开目标 App 即WeChat, 这里称之为 TargetApp.</li>
<li>Home 到手机桌面.</li>
<li>查看当前运行的所有进程, 命令如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -e</div></pre></td></tr></table></figure>
<p>看到这个货:<br><img src="/upload/images/2018/06/07/3.jpg" alt=""></p>
<p>在如下目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/containers/Bundle/Application/2837EC87-7C28-45C5-9309-24FACD3A97C9/WeChat.app/WeChat</div></pre></td></tr></table></figure>
<p><code>WeChat.app</code> 就是我们要找的 TargetApp.</p>
<p>连接 SSH 成功后, 在 MacOS 终端 <code>ls</code> 一下该目录, 可以发现 <code>WeChat.app</code> 躺在那里.<br><img src="/upload/images/2018/06/07/4.jpg" alt=""></p>
<h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p><strong>1. 查找 Documents 目录</strong></p>
<p><code>WeChat</code> 为当前的进程目标执行文件名称, 从上面的图可以看出, 其对应的进程 id 是 <code>18983</code>.</p>
<p>在命令行中通过 cycript 执行如下操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cycript -p 18983</div></pre></td></tr></table></figure>
<p>再执行 OC 的方法, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</div></pre></td></tr></table></figure>
<p>可以看到对应的输出, 如下图所示, 这就是对应的 Documents 目录.<br><img src="/upload/images/2018/06/07/5.jpg" alt=""></p>
<blockquote>
<p>注意: 执行过程中, 在 iPhone 上面打开运行一下 App, 不然上面的执行一直卡在那里不动.</p>
</blockquote>
<p>找到目录如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/</div></pre></td></tr></table></figure>
<p>同理, 你也可以使用 iFunBox 查看该目录.</p>
<p><strong>2. 拷贝 dumpdecrypted.dylib</strong>.</p>
<p>拷贝 <code>dumpdecrypted.dylib</code> 这个之前编译签名好的文件到iPhone 上面该 APP 的 Documents 目录有两种方法.</p>
<p>第一种方法, 直接在 mac 上面拖拽 <code>dumpdecrypted.dylib</code> 到 iFunBox 显示的这个目录中, 这种方法比较简单且快.</p>
<p>第二种方法, 使用 <code>scp</code> 命令进行操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp ~/dumpdecrypted.dylib root@192.168.99.231:/var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/</div></pre></td></tr></table></figure>
<p><code>192.168.99.231</code> 是 iPhone 设备的 ip 地址.</p>
<p><strong>3. 退出 cycript, 回到命令行模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctrl + d</div></pre></td></tr></table></figure>
<p><strong>4. cd 到 Documents 目录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /var/mobile/Containers/Data/Application/2EFA08B6-DD7B-41A6-92C9-C6115CA6DDA1/Documents/</div></pre></td></tr></table></figure>
<p><strong>5. 砸壳</strong></p>
<p>终端在 Documents 目录下面, 执行下面命令即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/2837EC87-7C28-45C5-9309-24FACD3A97C9/WeChat.app/WeChat</div></pre></td></tr></table></figure>
<p>执行过程显示如下:<br><img src="/upload/images/2018/06/07/6.jpg" alt=""></p>
<p>最后生成了 <code>WeChat.decrypted</code> 文件, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-rw-r--r--  1 root   mobile 74513728 Jun  7 15:20 WeChat.decrypted</div><div class="line">drwxr-xr-x 14 mobile mobile      448 Jun  7 15:20 .</div><div class="line">-rw-r--r--  1 root   mobile   207760 Jun  7 15:15 dumpdecrypted.dylib</div><div class="line">-rw-r--r--  1 mobile mobile        8 Jun  7 13:22 db.globalconfig</div><div class="line">-rw-r--r--  1 mobile mobile       15 Jun  7 11:35 SafeMode.dat</div><div class="line">drwxr-xr-x 26 mobile mobile      832 Jun  7 11:35 MMappedKV</div><div class="line">drwxr-xr-x  3 mobile mobile       96 Jun  7 11:35 CrashReport</div><div class="line">-rw-r--r--  1 mobile mobile     1011 Jun  7 11:35 LocalInfo.lst</div><div class="line">drwxr-xr-x  5 mobile mobile      160 Jun  7 11:35 MemoryStat</div><div class="line">drwxr-xr-x  6 mobile mobile      192 Jun  7 11:35 00000000000000000000000000000000</div><div class="line">drwxr-xr-x 15 mobile mobile      480 Jun  5 13:43 MMResourceMgr</div><div class="line">-rw-r--r--  1 mobile mobile      592 Jun  5 13:43 heavy_user_id_mapping.dat</div><div class="line">drwxr-xr-x  2 mobile mobile       64 Jun  5 10:07 OpenImResource</div></pre></td></tr></table></figure>
<p>使用 <code>iFunBox</code> 或者 <code>scp</code> 命令将 <code>WeChat.decrypted</code> 文件导出到 mac 的任意目录即可.</p>
<p>后续会跟大家分享如何使用砸壳后的文件, 敬请期待.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jailbreak </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 逆向: 砸壳]]></title>
      <url>/2018/05/13/iOS-%E9%80%86%E5%90%91-%E7%A0%B8%E5%A3%B3/</url>
      <content type="html"><![CDATA[<p>所谓的砸壳, 指的是将从 App Store 上面下载的 App 进行破解的过程. 从 App Store 上下载的 ipa 中的二进制文件是经过加密(加壳)的，需要通过破解才能让我们对其 <code>为所欲为</code>, 这里的破解就是通常所说的砸壳.</p>
<p>类似的, Android 应用(apk 文件)也有加壳操作, 如果想破解别人的 apk, 首先要进行砸壳操作.</p>
<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>[1]. Clutch<br>[2]. iFunBox 或者 <code>pp 助手</code><br>[3]. 越狱手机一台(本人iPhone6sPlus iOS10.3.x 系统).<br>[4]. 可以正常使用 SSH 功能.</p>
<p>如果你还没有安装上面提到的除 <code>Clutch</code> 之外的工具, 请先阅读 <a href="http://www.veryitman.com/2018/05/13/iOS-%E9%80%86%E5%90%91-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">iOS 逆向: 查看系统文件目录和结构</a> 这篇文章, 并安装对应的工具.</p>
<h2 id="安装-Clutch"><a href="#安装-Clutch" class="headerlink" title="安装 Clutch"></a>安装 Clutch</h2><p>可以在 Github 获取 <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">Clutch 源码</a>, 然后自己在 MacOS 上面编译得到二进制文件.</p>
<p>也可以去直接下载已经编译好的 <a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="noopener">二进制包</a>, 直接使用, 我是直接下载了已经编译好的二进制包的, 截止到写这篇文章为止, <code>Clutch</code> 版本为 <code>2.0.4</code>.</p>
<p>下载完成后, 我将其放到 <code>~/Downloads</code> 目录下面了.</p>
<p>准备好越狱设备, 保证可以正常连接 wifi, 使用 scp 命令将 <code>Clutch</code> 二进制文件复制到设备的系统目录中, 命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp ~/Downloads/Clutch root@192.168.91.126:/usr/bin</div></pre></td></tr></table></figure>
<p>其中, <code>192.168.91.126</code> 是我设备连接 wifi 后的 IP 地址.</p>
<p>复制成功后, 使用 iFunBox 可以看到 <code>Clutch</code> 静静地躺在那里.</p>
<p><img src="/upload/images/2018/05/13/6.jpg" alt=""></p>
<p>你可以使用 iFunBox 或者 <code>pp 助手</code>, 直接将 <code>~/Downloads/Clutch</code> 拖拽到 <code>/usr/bin</code> 目录.</p>
<h2 id="Clutch-的基本使用"><a href="#Clutch-的基本使用" class="headerlink" title="Clutch 的基本使用"></a>Clutch 的基本使用</h2><p>SSH 连接越狱设备, 开始使用 <code>Clutch</code>. 关于使用 SSH, 可以阅读一下 <a href="http://www.veryitman.com/2018/05/12/iOS-%E9%80%86%E5%90%91-%E8%B6%8A%E7%8B%B1%E4%BD%BF%E7%94%A8-SSH/" target="_blank" rel="noopener">iOS 逆向: 越狱使用 SSH</a> 这篇文章.</p>
<p>如果你发现直接执行 <code>Clutch</code> 说没有权限之类的提示, 可以先将其授予可执行的权限.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x /usr/bin/Clutch</div></pre></td></tr></table></figure>
<p>Clutch 命令选项如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-b --binary-dump     Only dump binary files from specified bundleID</div><div class="line">-d --dump            Dump specified bundleID into .ipa file</div><div class="line">-i --print-installed Print installed application</div><div class="line">--clean              Clean /var/tmp/clutch directory</div><div class="line">--version            Display version and exit</div><div class="line">-? --help            Display this help and exit</div></pre></td></tr></table></figure>
<p><code>-b</code> 选项表示产出一个二进制文件, <code>-d</code> 选项表示产出一个 ipa 文件, <code>-i</code> 表示列出手机上面已经安装的 APP.</p>
<p>我们先看一下手机上已经安装的 App, 命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Clutch -i</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/05/13/7.jpg" alt=""></p>
<p>这些 APP 前面的数字表示指定的 id. <code>-d</code> 和 <code>-b</code> 选项都需要指定这些 id.</p>
<h2 id="砸吧-骚年"><a href="#砸吧-骚年" class="headerlink" title="砸吧, 骚年"></a>砸吧, 骚年</h2><p>我们现在开始使用 <code>Clutch</code> 来对 APP 进行砸壳操作, 这里以已经安装的 App 序号为 8 的为例子.</p>
<p>使用下面的命令开始砸壳:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Clutch -d 8</div></pre></td></tr></table></figure>
<p>效果如下图所示:</p>
<p><img src="/upload/images/2018/05/13/8.jpg" alt=""></p>
<p>砸壳成功后会在 <code>/private/var/mobile/Documents/Dumped</code>  这个目录生成对应的 <code>*.ipa</code> 文件.</p>
<p>砸壳后的 ipa 文件, 可以从 iFunBox 中复制到 MacOS 的目录中, 然后你就可以对该 ipa 进行下一步操作了, 比如获取图片/音频/视频等资源和对应的头文件. 关于这些后续的越狱工作, 我会在下几篇博客中分享给大家.</p>
<p>也许有人会说了, 我自己从 <code>pp 助手</code> 中备份指定的 App 就可以获取资源了, 不需要使用 <code>Clutch</code> 这么麻烦了. 高系统版本, <code>pp 助手</code> 是无法直接获取 ipa 文件的, 况且我们也不仅仅是想获取别人 APP 的资源文件.</p>
<p>当然了, 你可以从越狱 APP 市场直接下载已经被砸壳的 App 进行玩耍, 不需要自己千辛万苦的去砸壳了.</p>
<h2 id="Clutch-并不是万能的"><a href="#Clutch-并不是万能的" class="headerlink" title="Clutch 并不是万能的"></a>Clutch 并不是万能的</h2><p>上面大家可以看出, <code>Clutch</code> 是可以进行砸壳的并且也挺方便, 但 <code>Clutch</code> 并不是万能的, 也就是说, <code>Clutch</code> 不能将任意一个 App Store 下载 APP 进行砸壳.</p>
<p>拿上面序号为4 的微信来说, 执行下面命令报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Clutch -d 4</div></pre></td></tr></table></figure>
<p>砸壳执行过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Writing new checksum</div><div class="line">...</div><div class="line">FAILED: &lt;WeChat bundleID: com.tencent.xin&gt;</div><div class="line">Finished dumping com.tencent.xin in 28.7 seconds</div></pre></td></tr></table></figure>
<p>还有一些 APP, 再被砸壳的时候会报如下的错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">could not obtain mach port either the process is dead</div></pre></td></tr></table></figure>
<p>虽然最新版本(2.0.4)说解决了该问题, 但是实际操作过程中, 还是会出现这个问题, 无法进行砸壳.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jailbreak </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 逆向: 查看系统文件目录和结构]]></title>
      <url>/2018/05/13/iOS-%E9%80%86%E5%90%91-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>在 <a href="http://www.veryitman.com/2018/05/12/iOS-%E9%80%86%E5%90%91-%E8%B6%8A%E7%8B%B1%E4%BD%BF%E7%94%A8-SSH/" target="_blank" rel="noopener">iOS 逆向: 越狱使用 SSH</a> 中给大家分享了如何使用工具对 iOS10.3 的系统进行越狱和配置使用 SSH 的内容, 今天继续探逆向的知识.</p>
<p>手机被越狱之后, 我们首先要搞清楚是否能够正常的访问手机里面的文件和目录结构, 这些文件和目录结构究竟是什么样的, 虽然这些知识很基础, 但是还是很有必要去了解和学习的, 就算是为后期逆向 APP 做点准备吧. </p>
<h2 id="安装-iFunBox"><a href="#安装-iFunBox" class="headerlink" title="安装 iFunBox"></a>安装 iFunBox</h2><p><code>iFunBox</code> 是一个可以浏览 iPhone 文件目录的文件管理工具, 支持 MacOS 和 Windows 两个平台.</p>
<p>点击 <a href="http://www.i-funbox.com/" target="_blank" rel="noopener">下载地址</a> 可以去下载 MacOS 版本的 iFunBox. 关于 <code>iFunBox</code> 的介绍和特性可以去 <a href="http://www.i-funbox.com/en_about.html" target="_blank" rel="noopener">这里</a> 查阅.</p>
<p>最新版本是 <code>1.8</code>, 如图:</p>
<p><img src="/upload/images/2018/05/13/1.jpg" alt=""></p>
<p>手机插上 USB 连接上 Mac 电脑, iFunBox 就可以识别你的手机了, 如图所示:</p>
<p><img src="/upload/images/2018/05/13/2.jpg" alt=""></p>
<p>这个时候, 你点击 <code>Raw File System</code> 其实是看不到 iPhone 的系统目录的, 接下来在 iPhone 中安装另外一个软件就可以了.</p>
<h2 id="安装-Apple-File-Conduit”2”"><a href="#安装-Apple-File-Conduit”2”" class="headerlink" title="安装 Apple File Conduit”2”"></a>安装 Apple File Conduit”2”</h2><p>在 Cydia 中搜索 Apple File Conduit, 如下图所示.</p>
<p><img src="/upload/images/2018/05/13/3.jpg" alt=""></p>
<p>点击更改/安装即可.</p>
<p>如果你没有搜索到, 那么就需要自己添加对应的软件源地址.</p>
<p>点击【软件源】–编辑/添加 –输入源地址 <code>apt.25pp.com</code> – 添加源, 然后再去搜索 <code>Apple File Conduit</code> 安装.</p>
<p>安装好之后, 再用 <code>iFunBox</code>, 就可以正常查看 iPhone 的系统目录了, 如下图所示:</p>
<p><img src="/upload/images/2018/05/13/4.jpg" alt=""></p>
<p>看到这些目录, 是不是跟 linux 或者 MacOS 的目录有很多相似的地方, 哈哈.</p>
<h2 id="安装-pp-助手"><a href="#安装-pp-助手" class="headerlink" title="安装 pp 助手"></a>安装 pp 助手</h2><p>既然已经安装了 <code>iFunBox</code> 工具, 那为什么还需要安装 <code>pp 助手</code> 之类的工具呢? 其实, 这个看个人的需要吧, 在某种程度上, <code>pp 助手</code> 的界面和便捷性要比 <code>iFunBox</code> 好一点.</p>
<p>安装好 <code>pp 助手</code> 后, 点击 Tools/File Manager 显示的目录导航, 如图:</p>
<p><img src="/upload/images/2018/05/13/5.jpg" alt=""></p>
<p>可以看出, 相比 <code>iFunBox</code> 的界面显示, <code>pp 助手</code> 工具显得更加友好一些. </p>
<p>至于使用哪个工具, 要看个人爱好和自己的工作需要, 毕竟工具都是为了提高我们学习和工作效率的, 没有什么绝对的好与坏, 自己觉得合适顺手就好了, 最主要的是能够帮到自己. 我一般是将两者结合使用的, 当然你如果你有更好的工具也可以推荐给我.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jailbreak </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 逆向: 越狱使用 SSH]]></title>
      <url>/2018/05/12/iOS-%E9%80%86%E5%90%91-%E8%B6%8A%E7%8B%B1%E4%BD%BF%E7%94%A8-SSH/</url>
      <content type="html"><![CDATA[<h2 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h2><p>使用苹果设备或者做 iOS 开发的朋友们, 几乎都应该听说过越狱这个词. 那么究竟什么是越狱呢?</p>
<blockquote>
<p>iOS越狱（英语：iOS Jailbreaking）是获取 iOS 设备的 Root 权限的技术手段。iOS 设备的 Root 权限一般是不开放的。由于获得了Root 权限，在越狱之前无法查看的 iOS 的文件系统也可查看.</p>
</blockquote>
<p>上面是维基百科的解释, 具体可以去 <a href="https://zh.wikipedia.org/wiki/%E8%B6%8A%E7%8D%84_(iOS" target="_blank" rel="noopener">iOS 越狱</a>) 了解一下. iOS 的越狱就类似 Android 获取 root 权限一样的道理.</p>
<p>手头上面之前闲置了一台 iPhone4s, 闲来无事就把他越狱了, 后面不知道怎么操作的, 手机变成了白苹果(开机就白屏, 无法进入系统), 最后没办法, 只能升级系统, 这台手机也算是废了. </p>
<p>当时使用的工具是 <a href="http://www.pangu.io/" target="_blank" rel="noopener">盘古越狱</a>, 越狱的 iOS 系统是 7.x. 现在 iOS 已经升级到 11.x 了, 很多 APP 和游戏已经不再支持 iOS8 以下的系统了, 系统的安全性也越来越好了, 越狱破解的难度也随之提高了, 目前市面上能越狱的最高版本应该是 10.3.x 的系统(截止到该篇文章写的时候). </p>
<p>为了能够分析和学习一些优秀 App 的设计, 我索性买了台iPhone6sPlus 拿来越狱, 所以接下来的分享都是基于这台手机的.</p>
<p><strong>越狱工具和设备</strong></p>
<p>[1]. 设备 iPhone6s Plus, 系统 iOS10.3.2<br>[2]. 越狱工具: 爱思助手和 doubleH3lix.ipa</p>
<p>安装并打开 pc 上面的 <code>爱思助手</code> 直接开始越狱, 爱思助手会帮您在设备上安装 <code>doubleH3lix</code>. 运行 <code>doubleH3lix</code> 应用，点击 <code>jailbreak</code> 按钮，等待设备自行重启.</p>
<p>手机重启后, 你会看到 <code>Cydia</code> 静静的呆在那里了, 这种方式的越狱属于非完美越狱, 换句话说就是没有真正的破解 iOS 系统.</p>
<p>如果发现手机断电关机或者重启后 <code>Cydia</code> 一打开就闪退, 就使用 <code>doubleH3lix</code> 重新越狱就可以了, 如果还是不行就需要重新使用 <code>爱思助手</code> 了.</p>
<p>参考越狱教程 <a href="https://weibo.com/ttarticle/p/show?id=2309404217487167220184" target="_blank" rel="noopener">64位设备iOS 10-10.3.3爱思助手一键越狱教程</a>.</p>
<h2 id="安装-iOS-终端"><a href="#安装-iOS-终端" class="headerlink" title="安装 iOS 终端"></a>安装 iOS 终端</h2><p>安装终端, 在 Cydia 中搜索 MTerminal, 安装即可.</p>
<p><img src="/upload/images/2018/05/12/1.jpg" alt=""></p>
<p>安装好终端工具后, 打开终端, 输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su</div></pre></td></tr></table></figure>
<p>紧接着让你输入密码, 默认的 root 用户密码是 <code>alpine</code>. 输入改密码回车即可.</p>
<p>为了安全起见, 修改默认密码 <code>alpine</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd</div></pre></td></tr></table></figure>
<p>连续输入相同的密码即为呢修改后的新密码.</p>
<h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><p>配置和使用 SSH 功能是后续越狱工作的基础, 这样就可以在 MacOS 的终端中访问 iOS 系统了, 各种 shell 命令让你倍感亲切, 所以大家尽量要完成该步骤. 试想一下, 本来手机上面文字输入的体验就不好, 还需要在 iPhone 设备上面的终端中敲着命令…没法忍!</p>
<p>iOS 10 越狱以后自带了 SSH, 所以不需要单独去 Cydia 下载和安装 <code>OpenSSH</code>.</p>
<p>很多人越狱后, 发现也安装了 OpenSSH, 但是一旦连接 iPhone 设备就无法连接甚至报错. 如果你已经安装了 OpenSSH 并且无法使用 SSH 来操作你的 iPhone 设备, 请继续往下看.</p>
<p>[1]. 打开 Cydia, 分别搜索 OpenSSL 和 Openssh, 然后分别卸载 OpenSSL 和 Openssh.</p>
<p>[2]. 打开 Cydia, 添加源：<code>http://cydia.ichitaso.com/test</code></p>
<p><img src="/upload/images/2018/05/12/2.jpg" alt=""></p>
<p>点击左上角的 <code>添加</code>, 在弹框中输入对应的源地址即可.</p>
<p>[3]. 在 Cydia 中搜索 <code>dropbear</code> 并安装.</p>
<p><img src="/upload/images/2018/05/12/3.jpg" alt=""></p>
<p>安装即可.</p>
<p>安装成功后, 一般就可以正常使用 SSH 功能了.</p>
<p>打开 MacOS 终端, 开始使用 SSH 连接你的 iPhone 设备.</p>
<p>[1]. 查看 iPhone 设备的(wifi) IP 地址. 如我的是 <code>192.168.1.105</code>.<br>[2]. 使用 MacOS 终端, 输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@192.168.1.105</div></pre></td></tr></table></figure>
<p>成功的话, 它先会警告你是否继续操作, 输入 <code>yes</code> 即可, 然后又提示你输入 root 密码, 密码就是前面说的修改后的密码. 如果你没有修改密码, 那就是 <code>alpine</code>. 操作流程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;192.168.1.105 (192.168.1.105)&apos; can&apos;t be established.</div><div class="line">ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;192.168.1.105&apos; (ECDSA) to the list of known hosts.</div><div class="line">root@192.168.1.105&apos;s password:</div></pre></td></tr></table></figure>
<p>之前在 iOS 10.2.x 越狱修改对应的配置文件, 就可以使用 SSH 功能了, 但是在 iOS10.3.x 无济于事, 如果你是iOS 10.2.x 的越狱手机, 可以参考本文末附录配置 SSH, 也是我之前实践的结果.</p>
<h2 id="usbmuxd"><a href="#usbmuxd" class="headerlink" title="usbmuxd"></a>usbmuxd</h2><p>上面是通过 wifi 来连接 iPhone 设备的, 其实还有一种方式, 就是借助于 <code>usbmuxd</code> 这个工具通过 USB 连接(手机数据线连接电脑)不需要 wifi, USB连接比 wifi 响应速度快，且无网络环境的限制.</p>
<p>使用 usbmuxd 的前提是你的手机可以正常的使用 SSH 功能, 否则 usbmuxd 也无法救你.</p>
<p>[1].MacOS 安装 <code>usbmuxd</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install usbmuxd</div></pre></td></tr></table></figure>
<p>[2]. 使用 <code>usbmuxd</code> 自带工具 <code>iproxy</code>.</p>
<p><code>iproxy</code> 可以快捷的操作连接 iPhone 等操作.</p>
<p>MacOS 上只支持 4 位的端口号，需要把 iPhone 的默认端口 22 映射到 Mac 上面一个 4 位端口号的端口上面，相当于建立一个 Mac 和 iPhone 之间的通道. <code>iproxy</code> 具体使用, 后面再讲. 大家先安装一下即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iproxy 5678 22</div><div class="line">waiting for connection</div></pre></td></tr></table></figure>
<p>以上命令就是把当前连接设备的 <code>22</code> 端口(SSH端口)映射到电脑的 <code>5678</code> 端口，那么想和设备 <code>22</code> 端口通信，直接和本地的 <code>5678</code> 端口通信就可以了.</p>
<p>终端提示 <code>waiting for connection</code>, 表示这两个端口之间已经可以通信了，保留当前终端窗口(如果关闭就停止端口之间的通信了)，新建另一个终端输入，默认密码 root 密码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p 5678 root@127.0.0.1</div></pre></td></tr></table></figure>
<p>执行过程如下, 类似上面通过 wifi 操作的方式.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;[127.0.0.1]:5678 ([127.0.0.1]:5678)&apos; can&apos;t be established.</div><div class="line">ECDSA key fingerprint is SHA256:ANF7Cvc1yM/ZdaHyz9V1EHjG115cylIcHWyOzCL+kzs.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;[127.0.0.1]:5678&apos; (ECDSA) to the list of known hosts.</div><div class="line">root@127.0.0.1&apos;s password:</div></pre></td></tr></table></figure>
<p>接下来, 你就可以在 MacOS 终端上面操作你的 iPhone 设备了, 尽情的享受 shell 命令吧. 不使用的时候, 输入 <code>exit</code> 即可退出 SSH.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><strong>[1]. iOS 10.2.x 越狱使用 SSH 功能.</strong></p>
<p>首先修改 root 密码.</p>
<p>iOS 10.2 (越狱后)自带 OpenSSH，不需要自己重新安装 OpenSSH, 但是需要修改一个文件才能使用.</p>
<p>在手机上安装 MTERMINAL，运行 su，输入 root 密码，执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux|grep dropbear</div></pre></td></tr></table></figure>
<p>如果你看到的进程没有 dropbear, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/dropbear -F -R -p 22</div></pre></td></tr></table></figure>
<p>然后就可以连接了，重启依然有效.</p>
<p>如果你看到进程是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/dropbear -F -R -p 127.0.0.1:22</div></pre></td></tr></table></figure>
<p>意思是只能数据线重定向连接 SSH，如果你想改成 WIFI 可以访问, 需要修改 <code>/private/var/containers/Bundle/Application/D9185B6D-EA9E-4678-B59C-BF43DEFE67BF/yalu102.app/dropbear.plist</code><br>把里面有个参数 <code>127.0.0.1:22</code> 改成<code>22</code> 保存，重启手机即可.</p>
<p><strong>[2]. 使用 <code>usbmuxd</code> 无法使用 SSH</strong></p>
<p>执行 <code>ssh -p 5678 root@127.0.0.1</code> 后报错, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh_exchange_identification: read: Connection reset by peer</div></pre></td></tr></table></figure>
<p>这种情况一般是没有正确的使用数据线连接 Mac 电脑, 使用数据线正常连接 Mac 电脑即可解决问题.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jailbreak </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RunLoop: NSTimer 实现常驻线程的问题]]></title>
      <url>/2018/05/06/RunLoop-NSTimer-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h2><p>在 <a href="http://www.veryitman.com/2018/04/21/%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener">常驻线程是一种什么体验</a> 这篇文章中给大家分享了如何利用 RunLoop 的特性, 结合 <code>NSMachPort</code> 实现一个 <code>常驻线程</code> 的主题内容.</p>
<p>今天我们探讨一下使用 <code>NSTimer</code> 如何实现 <code>常驻线程</code> 以及注意事项.</p>
<p>从 RunLoop 的特性来看, 只要有 Source 或者 Timer 都会使其能自循环使用, 不会立即终止当前线程的执行, 所以从理论上来看 <code>NSTimer</code> 是可以达到创建 <code>常驻线程</code> 的目的的.</p>
<h2 id="开始实践"><a href="#开始实践" class="headerlink" title="开始实践"></a>开始实践</h2><p>完整的例子代码, 可以从文章的附录获取和查看, 这里只给出核心代码.</p>
<p><strong><em>创建线程</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (NSThread *)permanentThread &#123;</div><div class="line">    </div><div class="line">    static NSThread *thread = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        </div><div class="line">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil];</div><div class="line">        [thread setName:@&quot;veryitman-thread&quot;];</div><div class="line">        </div><div class="line">        // 同一个线程连续多次 start 会导致 crash</div><div class="line">        [thread start];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>线程执行的函数</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        </div><div class="line">        // 保持常驻线程: 使用 NSTimer</div><div class="line">        [self _attachTimerToRunLoop];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        // 手动开启 RunLoop</div><div class="line">        [runLoop run];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>创建定时器</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)_attachTimerToRunLoop &#123;</div><div class="line">    </div><div class="line">    if (nil == self.timer) &#123;</div><div class="line">        </div><div class="line">        // scheduledTimerWithTimeInterval 这种方式</div><div class="line">        // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中</div><div class="line">        _timer = [NSTimer scheduledTimerWithTimeInterval:2</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(runTimer)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:YES];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出, <code>_attachTimerToRunLoop</code> 中是将 timer 加入到当前的 RunLoop 当中了. 这里注意, repeats 值被设置为 <code>YES</code> 了.</p>
<p>跟之前一样, 可以使用点击事件来模拟和验证常驻线程的有效性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    // 模拟在指定线程上面再次执行方法</div><div class="line">    SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;);</div><div class="line">    </div><div class="line">    [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每点击一次屏幕, 都会对应执行 <code>runAnyTime</code> 里面的内容.</p>
<h2 id="对-repeat-的思考"><a href="#对-repeat-的思考" class="headerlink" title="对 repeat 的思考"></a>对 repeat 的思考</h2><p>在上面的示例中, 我将 <code>repeat</code> 参数设置为 <code>YES</code>, 试想一下如果把 <code>repeat</code> 参数设置为 <code>NO</code>, 会不会造成常驻线程失效呢?</p>
<p>动手试试…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)_attachTimerToRunLoop &#123;</div><div class="line">    </div><div class="line">    if (nil == self.timer) &#123;</div><div class="line">        </div><div class="line">        // scheduledTimerWithTimeInterval 这种方式</div><div class="line">        // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中</div><div class="line">        _timer = [NSTimer scheduledTimerWithTimeInterval:2</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(runTimer)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:NO];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次点击屏幕若干次, 同样会执行对应函数里面的内容. 这就说明了即使将 <code>repeat</code> 参数设置为 <code>NO</code>, 也不会影响常驻线程.</p>
<p>那我们再来点具有挑战的活动…</p>
<p>将当前页面加入 <code>UIScrollview</code> 这个视图, 还是保持 <code>repeat</code> 参数设置为 <code>NO</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor lightGrayColor];</div><div class="line">    self.navigationItem.title = @&quot;NSTimer 创建常驻线程&quot;;</div><div class="line">    </div><div class="line">    // 加入滚动视图</div><div class="line">    _scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];</div><div class="line">    [self.view addSubview:self.scrollView];</div><div class="line">    self.scrollView.contentSize = CGSizeMake(1000, 1000);</div><div class="line">    self.scrollView.delegate = self;</div><div class="line">    </div><div class="line">    // 启动线程</div><div class="line">    [self permanentThread];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为加入了滚动视图, 我们换一种方式来模式和验证常驻线程.</p>
<p>在 <code>UIScrollview</code> 代理中来模拟, 示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;</div><div class="line">    </div><div class="line">    // 模拟在指定线程上面再次执行方法</div><div class="line">    SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;);</div><div class="line">    </div><div class="line">    [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后进入该页面, 可以发现常驻线程被终止了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">veryitman--timerRun.</div><div class="line">veryitman--asyncRun. End Run.</div></pre></td></tr></table></figure>
<p>当除我以为更换一下模式即使 将 <code>repeat</code> 参数设置为 <code>NO</code>, 也不会出现常驻线程被终止的问题. 如下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<p>这样更换模式为 <code>NSRunLoopCommonModes</code> 也不行.</p>
<p>在这种情况(有滚动视图的)下, 将 <code>repeat</code> 参数设置为 <code>YES</code> 就不会导致常驻线程被终止了, 无论哪种方式创建的 Timer.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.子线程创建中的 RunLoop 的模式不会与主线程中 RunLoop 的模式冲突, 各自运行在各自的 mode 当中. </p>
<p>2.使用 <code>NSTimer</code> 来创建常驻线程, 在有 <code>UIScrollview</code> 或者其子类的情况下, 需要将 <code>repeats</code> 设置为 <code>YES</code>, 否则不会创建常驻线程. 没有滚动视图的情况下, <code>repeats</code> 设置为 <code>NO</code> 也没有关系.</p>
<p>3.创建 NSTimer</p>
<p>下面两种创建 Timer 的效果是一致的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[NSTimer scheduledTimerWithTimeInterval:2</div><div class="line">                  target:self</div><div class="line">                selector:@selector(runTimer)</div><div class="line">                userInfo:nil</div><div class="line">                 repeats:YES];</div></pre></td></tr></table></figure>
<p><code>scheduledTimerWithTimeInterval</code> 默认会将 Timer 加入到当前的 RunLoop 中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</div></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>完整示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line">#import &quot;MZTimerPermanentThreadController.h&quot;</div><div class="line"></div><div class="line">@interface MZTimerPermanentThreadController () &lt;UIScrollViewDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) UIScrollView *scrollView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation MZTimerPermanentThreadController</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;veryitman---MZTimerPermanentThreadController dealloc.&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor lightGrayColor];</div><div class="line">    self.navigationItem.title = @&quot;NSTimer 创建常驻线程&quot;;</div><div class="line">    </div><div class="line">    // 加入滚动视图</div><div class="line">    _scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];</div><div class="line">    [self.view addSubview:self.scrollView];</div><div class="line">    self.scrollView.contentSize = CGSizeMake(1000, 1000);</div><div class="line">    self.scrollView.delegate = self;</div><div class="line">    </div><div class="line">    // 启动线程</div><div class="line">    [self permanentThread];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    </div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">    </div><div class="line">    // 取消线程</div><div class="line">    // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例</div><div class="line">    BOOL canCancel = YES;</div><div class="line">    if (canCancel) &#123;</div><div class="line">        </div><div class="line">        [self.timer invalidate];</div><div class="line">        _timer = nil;</div><div class="line">        </div><div class="line">        [[self permanentThread] cancel];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;</div><div class="line">    </div><div class="line">    // 模拟在指定线程上面再次执行方法</div><div class="line">    SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;);</div><div class="line">    </div><div class="line">    [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    // 模拟在指定线程上面再次执行方法</div><div class="line">    SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;);</div><div class="line">    </div><div class="line">    [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSThread *)permanentThread &#123;</div><div class="line">    </div><div class="line">    static NSThread *thread = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        </div><div class="line">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil];</div><div class="line">        [thread setName:@&quot;veryitman-thread&quot;];</div><div class="line">        </div><div class="line">        // 同一个线程连续多次 start 会导致 crash</div><div class="line">        [thread start];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return thread;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        </div><div class="line">        // 保持常驻线程: 使用 NSTimer</div><div class="line">        [self _attachTimerToRunLoop];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        // 手动开启 RunLoop</div><div class="line">        [runLoop run];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)runAnyTime &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)_attachTimerToRunLoop &#123;</div><div class="line">    </div><div class="line">    if (nil == self.timer) &#123;</div><div class="line">        </div><div class="line">        // scheduledTimerWithTimeInterval 这种方式</div><div class="line">        // 创建的 Timer 会默认加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中</div><div class="line">        _timer = [NSTimer scheduledTimerWithTimeInterval:2</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(runTimer)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:YES];</div><div class="line">        </div><div class="line">#if 0</div><div class="line">        _timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(runTimer) userInfo:nil repeats:NO];</div><div class="line">        [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)runTimer &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;--veryitman--timerRun.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RunLoop 常驻线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常驻线程是一种什么体验]]></title>
      <url>/2018/04/21/%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h2 id="简说-RunLoop"><a href="#简说-RunLoop" class="headerlink" title="简说 RunLoop"></a>简说 RunLoop</h2><p>关于 iOS RunLoop 网上很多文章都有介绍过, 很多技术面试官也会问关于 RunLoop 的相关知识. 我把自己工作中遇到的问题和总结的经验分享出来(会做成一系列的文章), 也算是对自己的一个总结和沉淀, 欢迎大家交流.</p>
<p>网上的文章基本都是针对于 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">Apple Developer Doc - Run Loops</a> 这篇来展开的, 所以建议大家认真的去通读这篇文章, 并写代码验证, 实践.</p>
<p>可以简单粗暴的这么理解一下 RunLoop, 基于事件驱动的死循环(由内核来调度和管理的), 在需要处理事情的时候就出来干点事, 否则休眠待命.<br>RunLoop 的核心是基于 <code>machport</code> 的，其进入休眠时调用的函数是 mach_msg().</p>
<p>类似下面的代码来说明一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BOOL stopRunning = NO;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">   </div><div class="line">   // 处理 App 中各种操作各种事件</div><div class="line">   // 点击屏幕, 触摸到硬件也会唤醒 RunLoop</div><div class="line">   </div><div class="line">  &#125; while(!stopRunning);</div></pre></td></tr></table></figure>
<p>说到这里, 随便提及一下, 学习过 Android 开发的同事应该和好理解 RunLoop 了,  iOS 的 RunLoop 跟 Android 的 Looper 机制几乎一样, 只是不同的系统之间实现有差异罢了!</p>
<p>有兴趣的朋友可以看一下我之前写的文章 <a href="https://blog.csdn.net/veryitman/article/details/6384641" target="_blank" rel="noopener">Handler: 更新UI的方法</a>.</p>
<hr>
<p>今天跟大家分享如何在 iOS 中结合 RunLoop 和 machport 实现常驻线程, 先跟着实例走, 后续再去总结 RunLoop 的各种细节点.</p>
<h2 id="神奇的-main"><a href="#神奇的-main" class="headerlink" title="神奇的 main"></a>神奇的 main</h2><p>开发过 iOS 应用中的朋友, 对 <code>main.m</code> 再也熟悉不过了, <code>main</code> 函数正是应用的入口函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将 <code>return</code> 代码分开写, 看看有什么蛛丝马迹可寻.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        int ret = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--- UIApplicationMain end.&quot;);</div><div class="line">        </div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论如何你也看不到日志 <code>veryitman--- UIApplicationMain end.</code> 的打印, 这说明 <code>UIApplicationMain</code> 一直在呵护着 APP 的运行, 哈哈.</p>
<p>我们不妨再改一次, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再去运行 APP, 你会发现根本没有让 APP 运行起来, 再次说明没有了 <code>UIApplicationMain</code> 的呵护, APP 无法起死回生.</p>
<p>猜测在 <code>UIApplicationMain</code> 函数中，开启了和主线程相关的 RunLoop，使 <code>UIApplicationMain</code> 不会返回一直在运行中，从而保证了程序的持续运行, 最大的功臣就是  RunLoop.</p>
<h2 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h2><p>一般我们开启的线程在执行完任务后, 就会结束该线程. 除非你写了类似下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while(1) &#123;</div><div class="line">	// 业务处理</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (条件满足) &#123;</div><div class="line">	// 业务处理</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开启一个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (NSThread *)permanentThread &#123;</div><div class="line">    </div><div class="line">    static NSThread *thread = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line"></div><div class="line">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil];</div><div class="line">        [thread setName:@&quot;veryitman-thread&quot;];</div><div class="line">        </div><div class="line">        // 同一个线程连续多次 start 会导致 crash</div><div class="line">        [thread start];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行对应的 <code>asyncRun</code> 函数, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现 <code>asyncRun</code> 很快就可以执行完成 (End Run).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">veryitman--asyncRun. Current Thread: &lt;NSThread: 0x60000066c400&gt;&#123;number = 3, name = veryitman-thread&#125;</div><div class="line">veryitman--asyncRun. End Run.</div></pre></td></tr></table></figure>
<h2 id="子线程开启-RunLoop"><a href="#子线程开启-RunLoop" class="headerlink" title="子线程开启 RunLoop"></a>子线程开启 RunLoop</h2><p>主线程是默认开启 RunLoop 的即 mainRunLoop 是系统默认开启的, 但是子线程中的 RunLoop 需要我们自己手动开启.</p>
<blockquote>
<p>关于为什么子线程中需要手动开启, 后续文章结合源码给大家分析, 这里暂时可以理解为获取 RunLoop 对象是一种懒加载模式. 只不过主线程中, 系统帮我们开启了, 然而子线程中需要我们手动开启而已.</p>
</blockquote>
<p>类似这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        // 手动开启 RunLoop</div><div class="line">        [runLoop run];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在控制台可以看到输出:</p>
<p><img src="/upload/images/2018/04/21/1.jpg" alt="1"></p>
<p>RunLoop 没有任何输入源(input source) 和定时器(timer), 这时即使开启了 RunLoop 也不会让其等待执行, 换句话说会立即结束当前的 RunLoop.</p>
<p>既然这样我们给子线程的 RunLoop 添加源或者定时器即可. 这里以添加 NSPort 为例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        </div><div class="line">        // 添加 source</div><div class="line">        NSPort *port = [NSMachPort port];</div><div class="line">        [runLoop addPort:port forMode:NSRunLoopCommonModes];</div><div class="line">               </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        // 手动开启 RunLoop</div><div class="line">        [runLoop run];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次运行, 你会发现 <code>End Run</code> 这个 Log 是不会打印出来的. 对应当前的 RunLoop 也有了源和定时器, 如图所示:<br><img src="/upload/images/2018/04/21/2.jpg" alt="1"></p>
<p>关于定时器和 RunLoop 的结合, 下篇再分享. </p>
<p>现在有这样一个需求, 需要在指定的线程中执行某项任务, 显然使用上面的方法来满足需求, 下面进入今天的正题.</p>
<h2 id="验证常驻线程"><a href="#验证常驻线程" class="headerlink" title="验证常驻线程"></a>验证常驻线程</h2><p>一定到 <code>常驻</code> 这个词, 就知道是能够让该线程随时待命, 保证其不挂掉.</p>
<p>iOS 中默认就有个主线程即 <code>main 线程</code>, 我们的 UI 线程指的就是主线程, 一般都是在主线程中操作 UI, 从某个角度来说, 主线程就是一个常驻线程.</p>
<p>我们开启其他线程, 目的是为了异步完成一些任务, 这些任务一般都比较耗时, 如果放在主线程当中完成这些任务就会导致主线程的卡顿, 用户体验极其差. </p>
<p>说了这么多, 也许你会问, 为什么要常驻线程呢?</p>
<p>频繁的创建和销毁线程，会造成资源(主要是内存)的浪费, 我们为什么不让频繁使用的子线程常驻在内存中, 想用的时候就用, 不用的时候让他休眠呢?! </p>
<p>上面已经使用 RunLoop 来实现了让线程长时间存活而不被销毁了.</p>
<p>用 <code>touchesBegan</code> 来模拟在指定线程中再次执行任务(runAnyTime)的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    // 模拟在指定线程上面再次执行方法</div><div class="line">    SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;);</div><div class="line">    [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)runAnyTime &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应上面的 <code>asyncRun</code> 实现即可, 你会发现在当前页面每次点击屏幕都会执行 <code>runAnyTime</code>.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>代码的完整实现</p>
<blockquote>
<p>常驻线程, 可以参考具体的注释.</p>
</blockquote>
<p><strong>MZCreatePermanentThreadController.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">@implementation MZCreatePermanentThreadController</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;veryitman---MZCreatePermanentThreadController dealloc.&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor lightGrayColor];</div><div class="line">    self.navigationItem.title = @&quot;创建常驻线程&quot;;</div><div class="line">    </div><div class="line">    // 启动线程</div><div class="line">    [self permanentThread];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    </div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">    </div><div class="line">    // 取消线程</div><div class="line">    // 实际业务场景中自行决定 canCancel 的设置, 这里只是示例</div><div class="line">    BOOL canCancel = YES;</div><div class="line">    if (canCancel) &#123;</div><div class="line">        [[self permanentThread] cancel];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    // 模拟在指定线程上面再次执行方法</div><div class="line">    SEL seltor = NSSelectorFromString(@&quot;runAnyTime&quot;);</div><div class="line">    </div><div class="line">    [self performSelector:seltor onThread:[self permanentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSThread *)permanentThread &#123;</div><div class="line">    </div><div class="line">    static NSThread *thread = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line"></div><div class="line">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(asyncRun) object:nil];</div><div class="line">        [thread setName:@&quot;veryitman-thread&quot;];</div><div class="line">        </div><div class="line">        // 同一个线程连续多次 start 会导致 crash</div><div class="line">        [thread start];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return thread;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)asyncRun &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">        </div><div class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        </div><div class="line">        // 添加 source</div><div class="line">        NSPort *port = [NSMachPort port];</div><div class="line">        [runLoop addPort:port forMode:NSRunLoopCommonModes];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. Current RunLoop: %@&quot;, runLoop);</div><div class="line">        </div><div class="line">        // 执行其他逻辑</div><div class="line">        //...</div><div class="line">        </div><div class="line">        // 手动开启 RunLoop</div><div class="line">        [runLoop run];</div><div class="line">        </div><div class="line">        NSLog(@&quot;veryitman--asyncRun. End Run.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)runAnyTime &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;veryitman--runAnyTime. Current Thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="noopener">Toll-Free Bridging</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">Run Loops</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RunLoop 常驻线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发人员需具备一点产品能力]]></title>
      <url>/2018/04/17/%E5%8F%91%E4%BA%BA%E5%91%98%E9%9C%80%E5%85%B7%E5%A4%87%E4%B8%80%E7%82%B9%E4%BA%A7%E5%93%81%E8%83%BD%E5%8A%9B/</url>
      <content type="html"><![CDATA[<p><img src="/upload/images/2018/04/17/12332.jpg" alt=""></p>
<p>为了开始今天的话题, 我先来借助几个角色, 模拟一下工作中的某些场景.</p>
<h2 id="设立人物"><a href="#设立人物" class="headerlink" title="设立人物"></a>设立人物</h2><p>小 A 是名刚入门的技术人员, 比较听话.<br>小 B 是有工作经验的一名技术人员, 平时喜欢看看产品相关的书籍, 喜欢和产品经理撕逼.<br>小 C 就厉害了, 不仅技术厉害, 也具有产品思维, 除了阅读产品类的书籍, 还写产品体验报告和体验竞品(和当前自己产品相关的产品).<br>小 D 就是一名产品经理, 具有一定的产品能力, 数据分析能力和管理能力.</p>
<p>人物已经设立好了, 现在让他们登场.</p>
<h2 id="情景再现-需求评审"><a href="#情景再现-需求评审" class="headerlink" title="情景再现: 需求评审"></a>情景再现: 需求评审</h2><p>这天风和日丽, 小 D(产品经理) 通知项目组的所有成员, 包括设计/开发/运营/测试等人员按时参加产品需求评审会议.</p>
<p>为了缓解大家的情绪, 小 D 买了很多零食和水果, 也算是犒劳一下大家. 小 D 开始给大家讲需求了, 像往常一样, 拿出精湛的原型, 口沫直飞的向大家展示其绵绵不绝的口才和产品思维. 小 A 一直在点头, 也不知道到底有没有听懂小 D 在说什么, 反正我看到有部分设计人员已经开始打瞌睡了.</p>
<p>突然, 小 C 中断了正在口述的小 D, 小 D 不慌不忙的停止了手中的一切动作, 聚精会神的听小 C 的意见和建议. 小 C 也有条不紊的将刚才的某项需求口述了一遍, 按照小 C 的逻辑, 目前的需求还是存在一些漏洞的, 这个时候, 小 D 开始认真的跟小 C 开始交流, 但是没有马上肯定小 C, 只是说我暂时记下这个点, 回头在思考一番. 产品小 D 稳如老狗, 继续自己的表演.</p>
<p>产品需求基本已经讲完了, 现在是大家提问题和交流的时间, 我看到有些同事揉了揉眼睛, 像是如梦初醒般的看着产品小 D, 不是旁边的同事拉住 Ta, 估计都能冲出会议室. 小 B 也不淡定了, 提出了不少问题, 并从技术的角度说明了实现的难度. 产品经理听的也是一脸懵逼, 心理想: “你实现是否有困难管我鸟事?”.</p>
<p>小 B 在产品小 D 那里并没有得到应有的表扬和鼓励, 反遭到同事小 C 的鄙视, 小 C 说, 你先不要告诉他实现方案, 先讨论这个需求的场景和真伪度. 小 D 默默的对小 C 投过赞赏的目光. 紧接着测试和其他人员提出了几个不痛不痒的问题, 都被老练的小 D 一一破解, 那气势, 啧啧! 势如破竹!</p>
<p>需求评审会议就这样结束了.</p>
<h2 id="情景再现-需求变更"><a href="#情景再现-需求变更" class="headerlink" title="情景再现: 需求变更"></a>情景再现: 需求变更</h2><p>在产品进入开发和设计阶段, 按理说需求变更也算是比较正常的一件事情.</p>
<p>这年头, 唯一不变的就是变化.</p>
<p>小 B 正在聚精会神的写代码, 突然小 D 跟他说, 这个地方的需求需要修改一下, 你看改动有多大?</p>
<p>小 B 鄙视的看着产品经理小 D, 心理在说改动有多大你心里还没有点 B数嘛. 小 B 还是控制了自己的情绪, 接着说道, 你当初应该好好思考的, 你看我都快做完了, 你才告诉我需要改动.</p>
<p>噼里啪啦的说完, 估计小 B 心理也暗爽了不少, 最终还是接受了这次的变动.</p>
<p>小 A 负责的模块, 也被产品经理修改过, Ta 和产品经理小 D 的交流基本是, 哦, 恩, 好, 可以!</p>
<p>当小 C 找到小 D 的时候, 并没有直接告诉小 D 需要改东改西, 而是问问小 D, 你看这样会不会更好一些?</p>
<p>小 C 当然明白小 D 的目的了, 于是拿出自己看过的竞品, 并说出了自己的意见, 愉快的和小 D 交流后, 居然 TMD 的砍了一个需求. 这让旁边的小 A 和小 B 羡慕不已.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的两种情景, 我相信做过开发的同事应该都深有体会, 但是千万不要对号入座, 我只是打个比方.</p>
<p>从上面看出, 小 C 是一个很不错的角色, 无论是思维还是沟通能力都有别与他人, 最重要的是他没有仅仅把自己当做一名开发人员, 而是站在产品的角度去思考问题和解决问题.</p>
<p>需求变更是常态, 作为开发人员, 要最大限度的给产品以支持. 产品经理也是人, 当然有考虑不周的地方, 如果你不能想出更好更完美的解决方案, 请支持他的决定.</p>
<p>多站在别人的角度去思考问题, 换位思考, 才能保证有效的沟通. 作为一名技术人员, 尤其是在互联网行业, 多多少少都应该需要具备一定的产品思维.</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不让 SIGPIPE signal 太嚣张]]></title>
      <url>/2018/04/15/%E4%B8%8D%E8%AE%A9-SIGPIPE-signal-%E5%A4%AA%E5%9A%A3%E5%BC%A0/</url>
      <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于项目迭代比较快, 大家还没有来得及做自我调整和总结, 就需要投入到新版本当中开发新功能了.</p>
<p>在最近的一次版本测试和体验过程中, 很多内测用户反馈进入或者退出 App 的聊天室, 会莫名其妙的崩溃掉(Crash).<br>对于 Crash 的问题, 我们开发同事绝对是零容忍, 于是就开始跟踪问题.</p>
<p>跟踪了很久, 发现这个 Crash 并不是那么的 ‘乖巧’, 很难复现!<br>既然用户已经反馈了并且后台也有 Crash 上报, 这个问题肯定存在, 所以我们不能放弃.</p>
<p>好吧, 继续加班搞…苦逼中…</p>
<p>最终, 我们发现一个规律, 在日志后台, 看到很多类似下面的日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Signal 13 was raised. SIGPIPE (_mh_execute_header + 420728)</div></pre></td></tr></table></figure>
<p>很遗憾的是, 堆栈信息中没有提供给我们更有力的证据, 所以当时定位在 <code>Signal 13</code> 这个点上面.</p>
<p>也算是有了突破…这班没有白加…</p>
<h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>既然所有的罪证都指向了 <code>Signal 13</code>, 我们就需要去跟踪它, 去调查它, 去研究它.</p>
<p>在 <code>signal.h</code> 文件中, 可以发现其定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* write on a pipe with no one to read it */</div><div class="line">#define	SIGPIPE	13</div></pre></td></tr></table></figure>
<p>用通俗的话来讲, 就是管道破裂.</p>
<blockquote>
<p>管道破裂，这个信号通常在进程间通信产生，比如采用 FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到 SIGPIPE 信号.<br>此外用 Socket 通信的两个进程，写进程在写 Socket 的时候，读进程已经终止.<br>另外, 在 send/write 时会引起管道破裂，关闭 Socket, 管道时也会出现管道破裂.<br>使用 Socket 一般都会收到这个 SIGPIPE 信号.</p>
</blockquote>
<p>也就是说, 该信号是跟 Socket 的连接以及数据的读写相关联的.</p>
<p>这样的话，我们就知道为什么进退房间导致 Crash 了，我们的进退房间都和 Socket 有关联，这种 Crash 大都数是在用户网络不好的情况下发生的.</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>类似 <code>signal 13</code> 这种错误是系统发出来的, 和内存使用异常和野指针一样，由于是系统级别崩溃，所以不能通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">@catch(NSException *exception) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>捕获到这类异常.</p>
<p>因此, <code>try catch</code> 是无法解决问题的.</p>
<p>目前有两个方案可用:</p>
<blockquote>
<p>方案1. 忽略这类信号.</p>
<p>方案2. 修改源码, 在 IM 代码里面修改.</p>
</blockquote>
<p>因为, IMSDK 我们是使用第三方的, 所以无法更改其源码, 所以采取了方案1: 忽略这类信号.</p>
<p>忽略的方案很简单, 在你连接或者初始化 IMSDK 之前, 只需要一行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">signal(SIGPIPE, SIG_IGN);</div></pre></td></tr></table></figure>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions </div><div class="line">&#123;</div><div class="line">	// ...</div><div class="line">	</div><div class="line">	signal(SIGPIPE, SIG_IGN);</div><div class="line">	</div><div class="line">	// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 <code>方案2</code>, 我查阅了一下 <code>CocoaAsyncSocket</code> 的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Prevent SIGPIPE signals</div><div class="line">    </div><div class="line">int nosigpipe = 1;</div><div class="line">setsockopt(socketFD, SOL_SOCKET, SO_NOSIGPIPE, &amp;nosigpipe, sizeof(nosigpipe));</div></pre></td></tr></table></figure>
<p>所以对于 <code>方案2</code>, 就是增加上面的代码即可, 即设置 Socket 不发送 SIGPIPE 信号.</p>
<p>对于上面的两种方案, 苹果开发者文档 <a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/CommonPitfalls/CommonPitfalls.html" target="_blank" rel="noopener">Avoiding Common Networking Mistakes</a> 都有提及.</p>
<p><img src="/upload/images/2018/04/15/1.jpg" alt="-w380"></p>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>既然这个问题很难复现, 我们就想办法让他很容易复现.</p>
<p>可以采用手动发送 signal 的方式, 来复现这个问题.</p>
<p>先看一下 <a href="https://linux.die.net/man/3/kill" target="_blank" rel="noopener">kill(3) - Linux man page</a> 函数:</p>
<blockquote>
<p>The kill() function shall send a signal to a process or a group of processes specified by pid. The signal to be sent is specified by sig and is either one from the list given in <signal.h> or 0. If sig is 0 (the null signal), error checking is performed but no signal is actually sent. The null signal can be used to check the validity of pid.</signal.h></p>
</blockquote>
<p>kill 函数是可移植操作系统接口 POSIX(Portable Operating System Interface of UNIX) 定义的, 可以参考 <a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">维基百科</a>.</p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //获取进程 id</div><div class="line">    pid_t cur_pid = getpid();</div><div class="line">    printf(&quot;current process&apos;s id: %i\n&quot;, cur_pid);</div><div class="line">    </div><div class="line">    //延时10s 为了让 Bugtags 有时间上报日志.</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        wpcSendSignal(cur_pid);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">///手动发送信号</div><div class="line">int wpcSendSignal(int pid)</div><div class="line">&#123;</div><div class="line">    int ret = kill(pid, SIGPIPE);</div><div class="line">    </div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将 <code>signal(SIGPIPE, SIG_IGN)</code> 代码先注释.</p>
<p>运行 APP 到手机, 然后退出 Xcode 的连接.</p>
<blockquote>
<p>注意: 这里如果连接 Xcode, 不会直接 Crash, 所以需要断开手机与 Xcode 的连接.</p>
</blockquote>
<p>在后台可以看到类似的 Crash 日志:</p>
<p><img src="/upload/images/2018/04/15/2.jpg" alt="-w500"></p>
<p>除了上面使用 <code>kill</code> 函数外, 我们还可以使用 <code>raise</code> 函数来发送 signal.</p>
<p>关于 raise 函数, 可以查阅 <a href="https://linux.die.net/man/3/raise" target="_blank" rel="noopener">手册</a>.</p>
<p>或者直接问男人(man):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man raise</div></pre></td></tr></table></figure>
<h2 id="问题再次来临-与-Bugtags-的结合"><a href="#问题再次来临-与-Bugtags-的结合" class="headerlink" title="问题再次来临: 与 Bugtags 的结合"></a>问题再次来临: 与 Bugtags 的结合</h2><p>本以为采用上述方案就万事大吉了, 在第二次提测后, 还是有这种 Crash 的问题在后台上报.</p>
<p>排查了很久后才发现，问题的原因是 BugTags 也会控制这个开头，默认是不忽略，这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 是否忽略 PIPE Signal (SIGPIPE) 闪退，默认 NO</div><div class="line"> */</div><div class="line">@property(nonatomic, assign) BOOL ignorePIPESignalCrash;</div></pre></td></tr></table></figure>
<p>这个默认设置为 NO, 即可以上报 PIPE Signal Crash 的问题.</p>
<p>这里也说明一个问题, 即使我们采用 <code>方案1</code> 解决 Crash 的问题了, Bugtags 还是会将这种 Crash 上报到后台.</p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bugtag.option.ignorePIPESignalCrash = YES;</div><div class="line"></div><div class="line">// ...</div><div class="line"></div><div class="line">signal(SIGPIPE, SIG_IGN);</div></pre></td></tr></table></figure>
<p>对比一下测试的两张图, 第一张图到第二张图是增加了两次崩溃次数, 原因是故意设置了 <code>bugtag.option.ignorePIPESignalCrash = NO</code>, 也正好验证了我们的想法.</p>
<p><img src="/upload/images/2018/04/15/3.jpg" alt="-w600"><br><img src="/upload/images/2018/04/15/4.jpg" alt="-w600"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>Xcode 连接真机或者模拟器, 运行出现异常断点, 可能就是隐患点.</p>
</li>
<li><p>学会使用后台日志找到规律, 继而去思考并解决问题.</p>
</li>
<li><p>对 Crash 进行更深入的分析和总结, 不要轻易放弃.</p>
</li>
</ol>
<h2 id="后续研究"><a href="#后续研究" class="headerlink" title="后续研究"></a>后续研究</h2><ol>
<li><p>是否可以忽略其他的 signal, 来避免不必要的 Crash?</p>
</li>
<li><p>自定义一套关于 signal 捕获的跨平台库, 在开发阶段可以直接看到完整的日志.</p>
</li>
</ol>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ol>
<li><p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/CommonPitfalls/CommonPitfalls.html" target="_blank" rel="noopener">Avoiding Common Networking Mistakes</a></p>
</li>
<li><p><a href="https://linux.die.net/" target="_blank" rel="noopener">linux die</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/UsingSocketsandSocketStreams.html#//apple_ref/doc/uid/CH73-SW1" target="_blank" rel="noopener">Using Sockets and Socket Streams</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Crash linux signal SIGPIPE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[这样学习你愿意吗?]]></title>
      <url>/2018/04/07/%E8%BF%99%E6%A0%B7%E5%AD%A6%E4%B9%A0%E4%BD%A0%E6%84%BF%E6%84%8F%E5%90%97/</url>
      <content type="html"><![CDATA[<p><img src="/upload/images/2018/04/07/1.jpg" alt=""></p>
<p>不得不承认, 学习确实是个「苦差事」, 这里说的学习不仅仅指伏案学习, 之乎者也等, 而是一种广泛的学习.</p>
<p>如何学习是始终要去探讨的一个话题, 时代在变, 环境在变, 学习当然也不能一成不变. 坚持学习是一辈子的事, 活到老学到老.</p>
<p>既然学习是一个漫长的马拉松, 那我们只有持之以恒的’跑’下去, 才能保持不掉队. 这样一来, 学习方法和学习技巧就是取胜的关键了.</p>
<p>世上没有绝对的学习妙招和学习宝典, 找到适合自己的就是最好的. 下面我结合自己的一些经历给大家分享在学习的道路上遇到的那些事.</p>
<blockquote>
<p>不管怎样, 学习一定要带着目标, 结合理论再去实践, 事半功倍.</p>
</blockquote>
<hr>
<p>欢迎大家在评论区交流, 不喜勿喷~ </p>
<h2 id="回忆当天事"><a href="#回忆当天事" class="headerlink" title="回忆当天事"></a>回忆当天事</h2><p>每晚躺在床上或者沙发上, 发发呆, 把当天做过的事情, 在脑海中统统的过一遍, 像放电影一样, 能有多详细就多详细, 也就是说尽量的回忆细节.</p>
<p>这种做法看似很简单, 其实很难坚持下去. 特别是中间几天, 很多人都会放弃, 再加上现在手机互联网的 “毒害”, 留给自己去真正学习的时间更少了. 但是只要你咬咬牙坚持一下, 把这个习惯养成, 就会终生受用.</p>
<p>我在初中时期已经养成了这个习惯, 直到大学都没有放弃. 大学里面每次期末考试, 看到很多人忙的不可开交, 我都是不慌不忙的, 悠闲自得, 室友问我怎么做到游刃有余, 我说你白天少睡点觉, 平时注意听讲, 晚上回忆一下就可以了, 从他迷茫的眼神中可以看出, 他当时并不完全相信我说的!</p>
<p>每次回忆结束, 有些东西还是比较模糊甚至一知半解, 没事, 你第二天去翻阅相关知识再去整理和理解一下就好了, 这种自我激励比任何鞭策都有用.</p>
<blockquote>
<p>有些困难只是暂时的, 想办法 ‘挺’ 过去, 你就赢了. 很多时候不是困难吓到了我们, 而是我们放弃了自己.</p>
</blockquote>
<h2 id="多想多问"><a href="#多想多问" class="headerlink" title="多想多问"></a>多想多问</h2><p>和你身边兴趣相投或者比你有能力的人多交流, 交流的过程也是你练习自我表达能力的过程, 把自己的问题能够清楚的描述给别人听, 也是一种能力.</p>
<p>不知道大家有没有这样一种感觉, 在跟别人交流的过程中, 虽然别人没有直接帮你解决问题, 但是你突然有了解决问题的办法. 为什么会这样呢? 很简单, 因为这个问题你之前思考过, 只是在交流的过程中, 你的大脑专注在此, 聚精会神的在想这件事情.</p>
<p>问问题有一套门道. 在请教别人问题之前, 最好自己先尽力想一想, 不要遇到一点问题就去问东问西, 即使别人给你讲了, 你也只是当时明白了, 下次再遇到此类问题, 你依然懵逼. 还有就是会让你形成一种依赖心理, 反正有人能解决, 我问就可以了, 干嘛还有费时费力的去想?! 久而久之, 就破罐子破摔了.</p>
<p>另外一个要说的就是在请教或者交流问题的时候, 要对对方谦虚.</p>
<p>我很感激高中时代, 班主任很信任我, 让我当了三年班长, 那三年让我学到了很多书本之外的东西, 其中沟通和管理让我在今后的工作中受益匪浅. </p>
<h2 id="阅读和写作"><a href="#阅读和写作" class="headerlink" title="阅读和写作"></a>阅读和写作</h2><blockquote>
<p>这里说的写作不是指专业的作家级的写作, 泛指任何文字的记录, 日记也算.</p>
</blockquote>
<p>每天最幸福的时刻就是在 23:00 点之前坐在电脑前, 可以写自己心中要表达的内容, 任思绪飘摇.</p>
<p>只要有闲暇的时间, 我就会整理和总结这段时间发生的事情, 既有工作上的也有生活上的.</p>
<p>小的时候, 家里比较穷, 交学费都是问题, 更别说是买书了. 我记得初中一年级, 我很想要一本英语书籍, 那种渴望至今难忘! 后来, 我每天从自己的生活费里抠出一点钱(生活费本来就少), 就这样积攒了几个星期, 去新华书店买了一本英语书籍. 高中时期, 有同学不要的或者已经不读的书籍, 我都会借过来看, 沉浸在自己的幸福当中.</p>
<p>参加工作之后, 我也有写博客的习惯, 把自己工作中遇到的问题以及解决问题的思路和方式写出来, 分享给其他人, 快乐无比. 特别是收到文章的评论后, 心理美滋滋的. 在互联网的海洋里, 大家素不相识, 通过键盘上敲击的文字互相交流知识和想法, 彼此成长着, 也别具一番乐趣.</p>
<p>阅读和写作可以培养自己的专注力, 这么好的习惯你千万不要拒绝. 写作可以倒逼着你去阅读, 去关心生活里面的点滴, 阅读和生活中的体验又可以激发你写作的欲望, 两者相辅相成.</p>
<p>推荐给大家一本书: <strong>Google 工作整理术</strong></p>
<p><img src="/upload/images/2018/04/07/2.png" alt="-w200"></p>
<blockquote>
<p>谷歌前CIO（首席信息官）分享风靡谷歌的信息整理术，帮助现代人彻底告别无序工作，学会利用数字工具为大脑减压！信息太多、时间太少，整理信息已成为现代人急需掌握的必备技能。谷歌作为引领全球的信息搜索与整合巨头，拥有能够有序整理信息的独特方式，而谷歌首席信息官便是主导这一“信息工厂”的总工程师。如今，曾担任“总工程师”的道格拉斯梅里尔亲自将风靡谷歌的信息整理方式分享给大众读者，帮助现代人克服无序工作的通病。《Google工作整理术》告诉你：不要花太多时间给信息归档，用的时候学会去搜索；在数字信息文档中加上关键词，方便日后检索；从前，知识就是力量,现在，共享知识才是力量；把工作和生活融为一体，而不是力图在二者之间求平衡。这些实用 Tips 都揭示了：信息整理才是高效工作的关键，信息整理已是现代人的工作必备技能！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 感悟 学习 阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC-RunTime: 总结消息转发中用到的知识点]]></title>
      <url>/2018/04/05/OC-RunTime-%E6%80%BB%E7%BB%93%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>推荐博文:</p>
<p><a href="http://www.veryitman.com/2018/03/31/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程</a></p>
<p><a href="http://www.veryitman.com/2018/04/01/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程实例讲解</a></p>
<p><a href="http://www.veryitman.com/2018/04/03/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">OC-RunTime: 消息转发之类方法的转发流程</a></p>
<p>在上面的博文中给大家分享了关于消息转发相关的知识点, 里面有很多细节没有阐述, 如果在之前的文章中加入这些细节点的话, 就拉长了文章的内容, 对于刚接触 RunTime 的朋友来说并不是什么好事, 不如另写一篇来补充一下, 于是就有了这篇文章的诞生.</p>
<h2 id="RunTime-的定义及使用场景"><a href="#RunTime-的定义及使用场景" class="headerlink" title="RunTime 的定义及使用场景"></a>RunTime 的定义及使用场景</h2><p>苹果 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="noopener">开发文档</a> 的这样解释 runtime 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work</div></pre></td></tr></table></figure>
<p>尽量将决定放到运行的时候，而不是在编译和链接过程中.</p>
<p>RunTime 的应用场景:</p>
<blockquote>
<p>1.面向切面编程 AOP.<br>2.方法调配 method swizzling.<br>3.消息转发.<br>4.给分类添加属性(关联对象).<br>5.动态获取 class 和 slector<br>6.KVO/KVC, 修改私有属性的值.</p>
</blockquote>
<p>建议去阅读下面框架的源码:</p>
<blockquote>
<p>Aspects（AOP必备，“取缔” baseVC，无侵入埋点）</p>
<p>MJExtension（JSON 转 model，一行代码实现 NSCoding 协议的自动归档和解档）</p>
<p>JSPatch（动态下发 JS 进行热修复）</p>
<p>NullSafe（防止因发 unrecognised messages 给 NSNull 导致的崩溃）</p>
<p>UITableView-FDTemplateLayoutCell（自动计算并缓存 table view 的 cell 高度）</p>
<p>UINavigationController+FDFullscreenPopGesture（全屏滑动返回）</p>
</blockquote>
<h2 id="提个问题"><a href="#提个问题" class="headerlink" title="提个问题"></a>提个问题</h2><p>在前面的文章中, 很多次看到 IMP, SEL 以及 Method 等关键字, 随着大家后面对 RunTime 的了解会逐渐跟他们越发熟悉.</p>
<p>在看下面内容之前, 先抛出一个问题:</p>
<blockquote>
<p>runtime 如何通过 selector 找到对应的 IMP 地址?</p>
</blockquote>
<p>接下来分别说一下 IMP, SEL 以及 Method.</p>
<h2 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h2><p>大家对 Objective-C 里面的 IMP 并不陌生, IMP 是 Objective-C 方法(method)实现代码块的地址, 本质是一个函数指针, 由编译器生成.</p>
<p>IMP 在 <code>objc.h</code> 中的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// A pointer to the function of a method implementation. </div><div class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</div><div class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </div><div class="line">#else</div><div class="line">typedef id (*IMP)(id, SEL, ...); </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>向对象发送消息之后，是由这个函数指针 IMP 指定的, 即 IMP 函数指针就指向了方法的实现.</p>
<p>IMP 函数指针最少包含 id 和 SEL 类型的两个参数, 后面其他的参数是对应方法需要的参数. 其中 id 代表执行该方法的 target(对象), SEL 就是对应的方法, 通过 id 和 SEL 参数就能确定唯一的方法实现地址.</p>
<p>那么我们如何获取方法的 IMP 呢, 很简单.</p>
<p>在 NSObject 提供了两个方法, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (IMP)methodForSelector:(SEL)aSelector;</div><div class="line">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>对应的实现(源码 NSObject.mm), 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (IMP)instanceMethodForSelector:(SEL)sel &#123;</div><div class="line">    if (!sel) [self doesNotRecognizeSelector:sel];</div><div class="line">    return class_getMethodImplementation(self, sel);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (IMP)methodForSelector:(SEL)sel &#123;</div><div class="line">    if (!sel) [self doesNotRecognizeSelector:sel];</div><div class="line">    return object_getMethodImplementation((id)self, sel);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IMP)methodForSelector:(SEL)sel &#123;</div><div class="line">    if (!sel) [self doesNotRecognizeSelector:sel];</div><div class="line">    return object_getMethodImplementation(self, sel);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里大家可以看到, 对应的 <code>methodForSelector</code> 既有实例方法又有类方法. 而 <code>instanceMethodForSelector</code> 只有类方法.</p>
<p>在使用 <code>methodForSelector</code> 方法时，向类发送消息，则 sel 应该是类方法, 若向实例对象发送消息，则 sel 应该为实例对象方法.</p>
<p>而 <code>instanceMethodForSelector</code> 仅仅允许类发送该消息, 从而获取实例方法的 IMP. 该方法无法获取类方法的 IMP, 如果想获取类方法的 IMP 可以使用 <code>methodForSelector</code> 来获取.<br>函数文档原文解释如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Use this method to ask the class object for the implementation of instance methods only. </div><div class="line">To ask the class for the implementation of a class method, send the methodForSelector: instance method to the class instead.</div></pre></td></tr></table></figure>
<p>举个例子, 或许好理解.</p>
<p>下面两个方法, 一个是类方法(testClassMethod), 另一个是实例方法(testInstanceMethod).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (void)testClassMethod &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testInstanceMethod &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分别使用上面提到的方法来获取 IMP 的几个方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IMP imp = [[self class] instanceMethodForSelector:@selector(testClassMethod)];</div><div class="line">IMP imp2 = [[self class] instanceMethodForSelector:@selector(testInstanceMethod)];</div><div class="line"></div><div class="line">// 也可以改成 NSObject 调用的方式, 结果一样.</div><div class="line">// IMP imp = [NSObject instanceMethodForSelector:@selector(testClassMethod)];</div><div class="line">// IMP imp2 = [NSObject instanceMethodForSelector:@selector(testInstanceMethod)];</div><div class="line">    </div><div class="line">    </div><div class="line">IMP imp3 = [[self class] methodForSelector:@selector(testClassMethod)];</div><div class="line">IMP imp4 = [self methodForSelector:@selector(testInstanceMethod)];</div></pre></td></tr></table></figure>
<p>调试器可以看出, 如下日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Printing description of imp:</div><div class="line">(IMP) imp = 0x000000010d8455c0 (libobjc.A.dylib`_objc_msgForward)</div><div class="line"></div><div class="line">Printing description of imp2:</div><div class="line">(IMP) imp2 = 0x000000010cf19b90 (-[ViewController testInstanceMethod] at ViewController.m:94)</div><div class="line"></div><div class="line">Printing description of imp3:</div><div class="line">(IMP) imp3 = 0x000000010cf19b60 (+[ViewController testClassMethod] at ViewController.m:89)</div><div class="line"></div><div class="line">Printing description of imp4:</div><div class="line">(IMP) imp4 = 0x000000010cf19b90 (-[ViewController testInstanceMethod] at ViewController.m:94)</div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>imp2, imp3, imp4 都是正常的, 唯独 imp 不正常, 也充分说明了 instanceMethodForSelector 无法获取类方法的 IMP.</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>在源码 <code>runtime.h</code> 中, 定义 method, 其本质是一个结构体.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name     OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types  OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp      OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法名 <code>method_name</code> 类型为 SEL.<br><code>method_types</code> 方法类型, 是一个 char 指针，存储着方法的参数类型和返回值类型.<br>方法实现 <code>method_imp</code> 的类型为 IMP.</p>
<p>可以看出, 有 SEL 和 IMP, method_types 是对应的方法返回值和参数类型, 如 <code>v@:</code>, 是一个字符串.</p>
<p><code>runtime.h</code> 中有两个方法, 可以根据 SEL 直接获取实例方法和类方法的 Method, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Method class_getInstanceMethod(Class cls, SEL name);</div><div class="line"></div><div class="line">Method class_getClassMethod(Class cls, SEL name);</div></pre></td></tr></table></figure>
<h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><p>iOS 开发中, 经常看到和使用 <code>selector</code>, 称之为方法选择器. SEL 是 <code>selector</code> 在 Objective-C 中的表示类型. <code>selector</code> 可以理解为是区别各个方法的 ID.</p>
<p>SEL 定义在源码 <code>objc.h</code> 中, 是一个结构体指针, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/// An opaque type that represents a method selector.</div><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>但是源码中查不到 <code>objc_selector</code> 具体的定义和实现.</p>
<p>获取 SEL 有三个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SEL sel = @selector(play:);</div><div class="line">SEL sel = sel_registerName(&quot;play:&quot;); </div><div class="line">SEL sel = NSSelectorFromString(@&quot;play&quot;);</div></pre></td></tr></table></figure>
<p>从上面可以看出 IMP/Method/Selector 三者之间是密切关联的, SEL 就是其中的桥梁.</p>
<p>总之, 在类的方法(实例和类方法)调度表(dispatch table, 也可以说是分发表)中的每一个实体代表一个方法 Method, 其名字叫做选择器 SEL，并对应着一种方法实现称之为 IMP.</p>
<h2 id="class-addMethod"><a href="#class-addMethod" class="headerlink" title="class_addMethod"></a>class_addMethod</h2><p>查看源码 <code>objc-runtime-new.mm</code> 中该函数实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</div><div class="line">&#123;</div><div class="line">    if (!cls) return NO;</div><div class="line"></div><div class="line">    rwlock_writer_t lock(runtimeLock);</div><div class="line">    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开发文档中这样描述该函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Adds a new method to a class with a given name and implementation.</div><div class="line">class_addMethod will add an override of a superclass&apos;s implementation, </div><div class="line">but will not replace an existing implementation in this class. </div><div class="line">To change an existing implementation, use method_setImplementation.</div></pre></td></tr></table></figure>
<p>解释一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以为类根据 SEL 和 IMP 动态添加一个新方法.</div><div class="line">class_addMethod 仅可以动态添加方法, 不会替换.</div><div class="line">如果想达到方法替换的效果可使用 method_setImplementation 函数.</div></pre></td></tr></table></figure>
<p>关于 <code>method_setImplementation</code> 和 <code>method_exchangeImplementations</code> 后面文章再做分析.</p>
<p>其实, <code>method_exchangeImplementations</code> 的内部实现相当于调用了 2 次 <code>method_setImplementation</code> 方法.</p>
<p><code>class_addMethod</code> 不仅可以动态添加类方法, 也可以添加实例方法.</p>
<p>参数及返回值解释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">返回值: 返回 YES 表示方法添加成功, 否则添加失败.</div><div class="line"></div><div class="line">参数 Class cls: 将要给添加方法的类, 即［类名 class］</div><div class="line"></div><div class="line">参数 SEL name: 将要添加的方法 SEL, 即 @selector(方法名)</div><div class="line"></div><div class="line">参数 IMP imp：实现这个方法的函数. 有两种写法即 C 和 OC 的写法. 一个 IMP 最少包括两个参数, 上面已经说过.</div><div class="line"></div><div class="line">参数 const char *types: 实现方法的函数的返回和参数编码类型. 如, &quot;v@:&quot; 表示返回值为 void, 没有参数的一个函数, 其中 @和:分别代表 IMP 的默认两个参数即 id 和 sel.</div></pre></td></tr></table></figure>
<p>关于 types, 可以使用 <code>method_getTypeEncoding</code> 来获取.<br>更多关于 types 的内容可以参考开发者文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>.</p>
<h2 id="解答问题"><a href="#解答问题" class="headerlink" title="解答问题"></a>解答问题</h2><p>读到这里, 大家对 IMP, SEL 以及 Method 应该有了初步的了解了<br>, 那么来解答一下刚才提出的问题.</p>
<blockquote>
<p>runtime 如何通过 selector 找到对应的 IMP 地址<br>?</p>
</blockquote>
<p>回答这个问题的关键是要知道消息调度表(也叫分度表).<br>正是因为有了这个表, runtime 才能游刃有余. 另外一个要回答的要点是 IMP 的实现和获取以及和 Method 之间的关系.</p>
<p>下面大概说说.</p>
<p>类对象中有类方法和实例方法的列表(即分度表)，表中记录着方法的名字、参数和实现，selector 本质就是方法名称，runtime 通过这个方法名称就可以在列表中找到该方法对应的实现.</p>
<p>系统为我们提供了获取 IMP 指针的函数, 无论是类方法还是实例方法我们都可以获取对应的 IMP.</p>
<p>而 Method 将 Selector 和 IMP 联系起来, 可从源码中看出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name     OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types  OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp      OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IMP 是一个函数的指针, 它是由编译器编译生成的.<br>当发一个消息时，它会找到那段代码执行, IMP 指向了这个方法的具体的实现. 得到这个函数的指针可以直接执行, 从上面的讲解实例中也可以看出来.</p>
<p>IMP 指向的方法与 <code>objc_msgSend</code> 函数类型相同，参数都包含 id 和 SEL 类型. 每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址, 反之亦然. 当发送消息给一个对象时， runTime 会在对象的类对象方法列表里查找.<br>当我们发送一个消息给一个类时，这条消息会在类的 <code>Meta Class</code> 对象的方法列表里查找.</p>
<p>关于分度表和消息相关的知识可以参考开发文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" target="_blank" rel="noopener">Messaging</a>, 讲得很清楚.</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>上面说了很多理论知识, 下面举个例子, 更好的理解一下上面的内容.</p>
<h3 id="动态添加实例方法"><a href="#动态添加实例方法" class="headerlink" title="动态添加实例方法"></a>动态添加实例方法</h3><p><strong>Student.m</strong></p>
<p>除 <code>init</code> 外, Student 只有一个实例方法 <code>studentWalkImp</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@implementation Student</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        SEL proxySelector = NSSelectorFromString(@&quot;studentWalkImp&quot;);</div><div class="line">        IMP impletor = class_getMethodImplementation([self class], proxySelector);</div><div class="line">        </div><div class="line">        // 获取实例方法</div><div class="line">        Method method = class_getInstanceMethod([self class], proxySelector);</div><div class="line">        const char *types = method_getTypeEncoding(method);</div><div class="line">        </div><div class="line">        SEL origSel = NSSelectorFromString(@&quot;walk&quot;);</div><div class="line">        class_addMethod([self class], origSel, impletor, types);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)studentWalkImp</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- Student studentWalkImp&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>调用测试一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    Student *stud = [[Student alloc] init];</div><div class="line">    [stud performSelector:NSSelectorFromString(@&quot;walk&quot;) withObject:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 Student 并没有 <code>walk</code> 方法, 故意为之, 运行后控制台会打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">---veryitman--- Student studentWalkImp</div></pre></td></tr></table></figure>
<p>成功的为 Student 添加了一个实例方法 <code>walk</code> 的实现 <code>studentWalkImp</code>.</p>
<p>上面的例子是使用 OC 的 IMP 方式来实现的, 可以改为 C 实现版本的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation Student</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">		SEL origSel = NSSelectorFromString(@&quot;walk&quot;);</div><div class="line">        class_addMethod([self class], origSel, (IMP)studentWalkImp, &quot;v:@&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void studentWalkImp()</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- Student studentWalkImp&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="动态添加类方法"><a href="#动态添加类方法" class="headerlink" title="动态添加类方法"></a>动态添加类方法</h3><p>动态添加类方法, 和动态添加实例方法稍微有点不同. 下面是改造后的 <code>Student.m</code>.</p>
<p><strong>Student.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@implementation Student</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        // 获取 MetaClass, 类方法不可以使用 [self class]</div><div class="line">        Class metaCls = objc_getMetaClass([NSStringFromClass([self class]) UTF8String]);</div><div class="line">        </div><div class="line">        SEL proxySelector = NSSelectorFromString(@&quot;clsImp&quot;);</div><div class="line">        IMP impletor = class_getMethodImplementation(metaCls, proxySelector);</div><div class="line">        </div><div class="line">        // 获取类方法</div><div class="line">        Method method = class_getClassMethod([self class], proxySelector);</div><div class="line">        </div><div class="line">        const char *types = method_getTypeEncoding(method);</div><div class="line">        SEL origSel = NSSelectorFromString(@&quot;walk&quot;);</div><div class="line">        </div><div class="line">        class_addMethod(metaCls, origSel, impletor, types);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)clsImp</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- Student clsImp&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意: 这里获取 Class 稍微不同的是使用了 <code>objc_getMetaClass</code>, 这里关系到 Objective-C 中的类, Class, 根类和元类的区别, 后续博文再做分享.</p>
<p>调用测试一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    Student *stud = [[Student alloc] init];</div><div class="line">    </div><div class="line">    [[stud class] performSelector:NSSelectorFromString(@&quot;walk&quot;) withObject:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制台打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">---veryitman--- Student clsImp</div></pre></td></tr></table></figure>
<p>成功的动态添加了一个类方法.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="noopener">Objective-C对象模型及应用</a></p>
<p>2.Apple RunTime 源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723.tar.gz</a></p>
<p>3.<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" target="_blank" rel="noopener">Messaging</a></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>点击下载文中完整的 <a href="https://github.com/veryitman/iOSDemo/tree/master/MZRuntimeMsgForward" target="_blank" rel="noopener">Demo</a>.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS RunTime MessageForward </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC-RunTime: 消息转发之类方法的转发流程]]></title>
      <url>/2018/04/03/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>本篇是「消息转发」系列的第三篇, 在 <a href="http://www.veryitman.com/2018/03/31/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程</a> 和 <a href="http://www.veryitman.com/2018/04/01/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]</a> 中分享了实例方法的转发流程.</p>
<p>今天分享如何对类方法进行消息的转发.</p>
<h2 id="resolveClassMethod"><a href="#resolveClassMethod" class="headerlink" title="resolveClassMethod"></a>resolveClassMethod</h2><p>NSObject 提供了 <code>resolveClassMethod</code> 来让开发者在里面动态添加一个类方法.</p>
<p>类方法的转发流程和实例方法转发的流程大致一样, 唯独不同的是需要重写的方法(NSObject中)的不一样.</p>
<p>当时我在写 Demo, 以为只需要将 <code>resolveInstanceMethod</code> 改为 <code>resolveClassMethod</code> 就万事大吉了即重写下面几个方法就可以解决问题, 事实证明这样是不行的.</p>
<blockquote>
<ol>
<li>+resolveClassMethod</li>
<li>-forwardingTargetForSelector</li>
<li>-methodSignatureForSelector</li>
<li>-forwardInvocation</li>
<li>-doesNotRecognizeSelector:</li>
</ol>
</blockquote>
<p>网上很多博文并没有深入的探讨关于类方法转发的流程, 只是在介绍实例方法转发的流程的同时, 一笔带过类方法转发机制和流程.</p>
<p>通过对 <code>NSObject.mm</code> 源码的查看, 可以看到对应上面的几个方法都有类方法. 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. +resolveClassMethod</div><div class="line">2. +forwardingTargetForSelector</div><div class="line">3. +methodSignatureForSelector</div><div class="line">4. +forwardInvocation</div><div class="line">5. +doesNotRecognizeSelector:</div></pre></td></tr></table></figure>
<p>重新这几个方法才是解决问题的关键.</p>
<p>现在我们重写 <code>resolveClassMethod</code>, 如下.</p>
<hr>
<p><strong>ViewController.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">static NSString * const sPerformClassMethodName = @&quot;veryClassMethod&quot;;</div><div class="line"></div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 1--- +resolveClassMethod&quot;);</div><div class="line">    </div><div class="line">    NSString *methodName = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    if ([sPerformClassMethodName isEqualToString:methodName]) &#123;</div><div class="line">        </div><div class="line">        // 获取 MetaClass</div><div class="line">        Class predicateMetaClass = objc_getMetaClass([NSStringFromClass(self) UTF8String]);</div><div class="line">        // 根据 metaClass 获取方法的实现</div><div class="line">        IMP impletor = class_getMethodImplementation(predicateMetaClass, @selector(proxyMethod));</div><div class="line">        // 获取类方法</div><div class="line">        Method predicateMethod = class_getClassMethod(predicateMetaClass, @selector(proxyMethod));</div><div class="line">        const char *encoding = method_getTypeEncoding(predicateMethod);</div><div class="line">        </div><div class="line">        // 动态添加类方法</div><div class="line">        class_addMethod(predicateMetaClass, sel, impletor, encoding);</div><div class="line">        </div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)proxyMethod</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- +proxyMethod of class&apos;s method for OC.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模拟调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // 运行类方法</div><div class="line">    SEL selector = NSSelectorFromString(sPerformClassMethodName);</div><div class="line">    SuppressPerformSelectorLeakWarning(</div><div class="line">        [[self class] performSelector:selector withObject:nil];</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 <code>SuppressPerformSelectorLeakWarning</code> 可以参考 <a href="http://www.veryitman.com/2018/04/01/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]</a>.</p>
<p>将动态添加的方法让 <code>proxyMethod</code> 来执行, 显示结果达到预期.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveClassMethod</div><div class="line">---veryitman--- +proxyMethod of class&apos;s method for OC.</div></pre></td></tr></table></figure>
<h2 id="创建被转发者"><a href="#创建被转发者" class="headerlink" title="创建被转发者"></a>创建被转发者</h2><p><strong>MZTempObj.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@implementation MZTempObj</div><div class="line"></div><div class="line">/// 类方法</div><div class="line">+ (void)veryClassMethod</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- veryClassMethod&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里有类方法的一个实现 <code>veryClassMethod</code>.</p>
<h2 id="重写转发消息的函数"><a href="#重写转发消息的函数" class="headerlink" title="重写转发消息的函数"></a>重写转发消息的函数</h2><p>同理将 <code>resolveClassMethod</code> 修改一下, 为了保证流程继续.</p>
<p>示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 1--- +resolveClassMethod. selector: %@&quot;, NSStringFromSelector(sel));</div><div class="line">    </div><div class="line">    NSString *methodName = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    // 这里故意将 sPerformClassMethodName 改为 @&quot;&quot;, 为了流程往下走</div><div class="line">    if ([@&quot;&quot; isEqualToString:methodName]) &#123;</div><div class="line">        </div><div class="line">        // 获取 MetaClass</div><div class="line">        Class predicateMetaClass = objc_getMetaClass([NSStringFromClass(self) UTF8String]);</div><div class="line">        // 根据 metaClass 获取方法的实现</div><div class="line">        IMP impletor = class_getMethodImplementation(predicateMetaClass, @selector(proxyMethod));</div><div class="line">        // 获取类方法</div><div class="line">        Method predicateMethod = class_getClassMethod(predicateMetaClass, @selector(proxyMethod));</div><div class="line">        const char *encoding = method_getTypeEncoding(predicateMethod);</div><div class="line">        </div><div class="line">        // 动态添加类方法</div><div class="line">        class_addMethod(predicateMetaClass, sel, impletor, encoding);</div><div class="line">        </div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 2--- +forwardingTargetForSelector&quot;);</div><div class="line">    </div><div class="line">    NSString *selectorName = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    if ([sPerformClassMethodName isEqualToString:selectorName]) &#123;</div><div class="line">        </div><div class="line">        // 注意1: 也可在此转发实例方法</div><div class="line">#if 0</div><div class="line">        // 让 MZTempObj 去执行 aSelector, 实现消息的转发</div><div class="line">        MZTempObj *myobject = [[MZTempObj alloc] init];</div><div class="line">        </div><div class="line">        return myobject;</div><div class="line">#endif</div><div class="line">        </div><div class="line">        // 转发类方法对应返回类对象</div><div class="line">        return [MZTempObj class];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id obj = [super forwardingTargetForSelector:aSelector];</div><div class="line">    </div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 3--- +methodSignatureForSelector&quot;);</div><div class="line">    </div><div class="line">    // 找出对应的 aSelector 签名</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    </div><div class="line">    // 注意2: 也可以在此获取实例方法的签名</div><div class="line">#if 0</div><div class="line">    if (nil == signature) &#123;</div><div class="line">        </div><div class="line">        // 是否有 aSelector</div><div class="line">        if ([MZTempObj instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [MZTempObj instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return signature;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    if (nil == signature) &#123;</div><div class="line">        </div><div class="line">        // 是否有 aSelector</div><div class="line">        if ([MZTempObj respondsToSelector:aSelector]) &#123;</div><div class="line">            </div><div class="line">            //methodSignatureForSelector 可以获取类方法和实例方法的签名</div><div class="line">            //instanceMethodSignatureForSelector只能获取实例方法的签名</div><div class="line">            signature = [MZTempObj methodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 4--- +forwardInvocation&quot;);</div><div class="line">    </div><div class="line">    // 注意3: 也可以调用实例方法</div><div class="line">#if 0</div><div class="line">    if ([MZTempObj instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:[[MZTempObj alloc] init]];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    if ([MZTempObj respondsToSelector:anInvocation.selector]) &#123;</div><div class="line">        </div><div class="line">        // 这里转发的是 MZTempObj Class, 不是对象</div><div class="line">        [anInvocation invokeWithTarget:[MZTempObj class]];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)doesNotRecognizeSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 5--- +doesNotRecognizeSelector: %@&quot;, NSStringFromSelector(aSelector));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行后, 控制台输出日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveClassMethod. selector: veryClassMethod</div><div class="line">---veryitman--- 2--- +forwardingTargetForSelector</div><div class="line">---veryitman--- veryClassMethod</div></pre></td></tr></table></figure>
<p><strong>这里注意一下</strong></p>
<blockquote>
<p>将代码中 <code>注意1</code> <code>注意2</code> 等部分可以自行打开测试一下, 然后将 <code>MZTempObj.m</code> 中的类方法(+veryClassMethod)改为实例方法(-veryClassMethod), 也是可以的, 这样就达到了将类方法转发给实例方法的效果.</p>
</blockquote>
<p>修改一下 <code>forwardingTargetForSelector</code> 中的实现, 可以看到 4, 5也会执行.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 2--- +forwardingTargetForSelector&quot;);</div><div class="line">    </div><div class="line">    NSString *selectorName = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    if ([@&quot;&quot; isEqualToString:selectorName]) &#123;</div><div class="line">        </div><div class="line">        // 注意1: 也可在此转发实例方法</div><div class="line">#if 0</div><div class="line">        // 让 MZTempObj 去执行 aSelector, 实现消息的转发</div><div class="line">        MZTempObj *myobject = [[MZTempObj alloc] init];</div><div class="line">        </div><div class="line">        return myobject;</div><div class="line">#endif</div><div class="line">        </div><div class="line">        // 转发类方法对应返回类对象</div><div class="line">        return [MZTempObj class];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id obj = [super forwardingTargetForSelector:aSelector];</div><div class="line">    </div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveClassMethod. selector: veryClassMethod</div><div class="line">---veryitman--- 2--- +forwardingTargetForSelector</div><div class="line">---veryitman--- 3--- +methodSignatureForSelector</div><div class="line">---veryitman--- 1--- +resolveClassMethod. selector: _forwardStackInvocation:</div><div class="line">---veryitman--- 4--- +forwardInvocation</div><div class="line">---veryitman--- veryClassMethod</div></pre></td></tr></table></figure>
<p>同理我们可以得到类方法的消息转发流程图, 如下图所示:</p>
<p><img src="/upload/images/2018/04/03/1.jpg" alt="1"></p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="http://www.veryitman.com/2018/03/31/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程</a></p>
<p><a href="http://www.veryitman.com/2018/04/01/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程实例讲解</a></p>
<p><a href="http://www.veryitman.com/2018/04/05/OC-RunTime-%E6%80%BB%E7%BB%93%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">OC-RunTime: 总结消息转发中用到的知识点</a></p>
<p>点击下载文中完整的 <a href="https://github.com/veryitman/iOSDemo/tree/master/MZRuntimeMsgForward" target="_blank" rel="noopener">Demo</a>.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS RunTime MessageForward </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程[实例讲解]]]></title>
      <url>/2018/04/01/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><a href="http://www.veryitman.com/2018/03/31/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程</a> 分享了消息转发的流程, 本次结合实际例子继续分析一下消息转发流程.</p>
<h2 id="发送不存在的消息"><a href="#发送不存在的消息" class="headerlink" title="发送不存在的消息"></a>发送不存在的消息</h2><p>在 ViewController 的 viewDidLoad 中运行 <code>veryTestMethod</code> 方法.</p>
<p><strong>ViewController.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static NSString * const sPerformInstanceMethodName = @&quot;veryTestMethod&quot;;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // 运行实例方法</div><div class="line">    SEL selector = NSSelectorFromString(sPerformInstanceMethodName);</div><div class="line">    </div><div class="line">    SuppressPerformSelectorLeakWarning(</div><div class="line">        [self performSelector:selector withObject:nil];</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中, <code>SuppressPerformSelectorLeakWarning</code> 是定义的一个宏.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define SuppressPerformSelectorLeakWarning(Stuff) \</div><div class="line">do &#123; \</div><div class="line">    _Pragma(&quot;clang diagnostic push&quot;) \</div><div class="line">    _Pragma(&quot;clang diagnostic ignored \&quot;-Warc-performSelector-leaks\&quot;&quot;) \</div><div class="line">    Stuff; \</div><div class="line">    _Pragma(&quot;clang diagnostic pop&quot;) \</div><div class="line">&#125; while (0)</div></pre></td></tr></table></figure>
<p>在 ViewController 中我并没有写 <code>veryTestMethod</code> 这个函数, 只是借助 <code>performSelector</code> 动态执行, 如果编译运行直接会 crash.</p>
<p>可以查看 <code>NSObject.mm</code> 源码, 里面关于消息转发的几个重要函数都写着 <code>_objc_fatal</code>, 可谓是招招毙命.</p>
<p>紧接着, 我们可以借助 <code>resolveInstanceMethod</code> 来完成消息转发给 ViewController.</p>
<h2 id="resolveInstanceMethod-转发"><a href="#resolveInstanceMethod-转发" class="headerlink" title="resolveInstanceMethod 转发"></a>resolveInstanceMethod 转发</h2><p>重写 NSObject 中的 <code>resolveInstanceMethod</code> 函数.</p>
<blockquote>
<p>+resolveInstanceMethod</p>
</blockquote>
<p><strong>ViewController.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 记得导入 RunTime 头文件</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 1--- +resolveInstanceMethod&quot;);</div><div class="line">    </div><div class="line">    NSString *methodName = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    if ([sPerformInstanceMethodName isEqualToString:methodName]) &#123;</div><div class="line">        </div><div class="line">        SEL proxySelector = NSSelectorFromString(@&quot;proxyMethod&quot;);</div><div class="line">        IMP impletor = class_getMethodImplementation(self, proxySelector);</div><div class="line">        </div><div class="line">        // 获取实例方法</div><div class="line">        Method method = class_getInstanceMethod(self, proxySelector);</div><div class="line">        const char *types = method_getTypeEncoding(method);</div><div class="line">        </div><div class="line">        // 添加 OC 的函数</div><div class="line">        class_addMethod([self class], sel, impletor, types);</div><div class="line">        </div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewController 中实现的 <code>proxyMethod</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// OC 实现</div><div class="line">- (void)proxyMethod</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- -proxyMethod of instance&apos;s method for OC.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>resolveInstanceMethod</code> 中动态添加了 <code>veryTestMethod</code> 方法, 并让 <code>proxyMethod</code> 函数来实现(IMP).</p>
<p>运行可以看到, 程序并没有 crash, 成功的执行了 <code>proxyMethod</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveInstanceMethod</div><div class="line">---veryitman--- -proxyMethod of instance&apos;s method for OC.</div></pre></td></tr></table></figure>
<p>到此为止, 我们已经看到动态添加一个方法的实现并成功运行的完整例子.</p>
<p>接下来, 我们将转发给其他对象 <code>MZTempObj</code> 来执行.</p>
<h2 id="自定义被转发的对象"><a href="#自定义被转发的对象" class="headerlink" title="自定义被转发的对象"></a>自定义被转发的对象</h2><p><strong>MZTempObj.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@implementation MZTempObj</div><div class="line"></div><div class="line">- (void)veryTestMethod</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- veryTestMethod&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>veryTestMethod</code> 就是我们要转发对应的消息.</p>
<h2 id="消息转发实践"><a href="#消息转发实践" class="headerlink" title="消息转发实践"></a>消息转发实践</h2><p>接下来我们把向 ViewController 发送 <code>veryTestMethod</code> 的消息转发给 <code>MZTempObj</code> 的  <code>veryTestMethod</code> 方法.</p>
<p>继续重写下面函数, 不过 <code>resolveInstanceMethod</code> 要稍微改造一下, 才能达到我们实践的目的.</p>
<blockquote>
<ol>
<li>+resolveInstanceMethod</li>
<li>-forwardingTargetForSelector</li>
<li>-methodSignatureForSelector</li>
<li>-forwardInvocation</li>
<li>-doesNotRecognizeSelector:</li>
</ol>
</blockquote>
<p><strong>ViewController.m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">// 记得导入 RunTime 头文件</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 1--- +resolveInstanceMethod: %@&quot;, NSStringFromSelector(sel));</div><div class="line">    </div><div class="line">    NSString *methodName = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    // 这里故意为之, 让流程往下走</div><div class="line">    if ([@&quot;&quot; isEqualToString:methodName]) &#123;</div><div class="line">        </div><div class="line">        SEL proxySelector = NSSelectorFromString(@&quot;proxyMethod&quot;);</div><div class="line">        IMP impletor = class_getMethodImplementation(self, proxySelector);</div><div class="line">        </div><div class="line">        // 获取实例方法</div><div class="line">        Method method = class_getInstanceMethod(self, proxySelector);</div><div class="line">        const char *types = method_getTypeEncoding(method);</div><div class="line">        </div><div class="line">        // 添加 OC 的函数</div><div class="line">        class_addMethod([self class], sel, impletor, types);</div><div class="line">        </div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 转发给对应的某个对象来执行 aSelector</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 2--- -forwardingTargetForSelector&quot;);</div><div class="line">    </div><div class="line">    NSString *selectorName = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    if ([sPerformInstanceMethodName isEqualToString:selectorName]) &#123;</div><div class="line">        </div><div class="line">        // 让 MZTempObj 去执行 aSelector, 实现消息的转发</div><div class="line">        MZTempObj *myobject = [[MZTempObj alloc] init];</div><div class="line">        </div><div class="line">        return myobject;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id obj = [super forwardingTargetForSelector:aSelector];</div><div class="line">    </div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 3--- -methodSignatureForSelector&quot;);</div><div class="line">    </div><div class="line">    // 找出对应的 aSelector 签名</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    </div><div class="line">    if (nil == signature) &#123;</div><div class="line">        </div><div class="line">        // 是否有 aSelector</div><div class="line">        if ([MZTempObj instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [MZTempObj instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    return signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 4--- -forwardInvocation&quot;);</div><div class="line">    </div><div class="line">    if ([MZTempObj instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:[[MZTempObj alloc] init]];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 5--- -doesNotRecognizeSelector: %@&quot;, NSStringFromSelector(aSelector));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序, 控制台打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveInstanceMethod</div><div class="line">---veryitman--- 2--- -forwardingTargetForSelector</div><div class="line">---veryitman--- veryTestMethod</div></pre></td></tr></table></figure>
<p>这里对照之前的流程图是完全符合的, 那么怎么让其执行 3 和 4 呢? 很简单, 修改一下 <code>forwardingTargetForSelector</code> 里面的实现即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;---veryitman--- 2--- -forwardingTargetForSelector&quot;);</div><div class="line">    </div><div class="line">    NSString *selectorName = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    // 故意为之</div><div class="line">    if ([@&quot;&quot; isEqualToString:selectorName]) &#123;</div><div class="line">        </div><div class="line">        // 让 MZTempObj 去执行 aSelector, 实现消息的转发</div><div class="line">        MZTempObj *myobject = [[MZTempObj alloc] init];</div><div class="line">        </div><div class="line">        return myobject;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id obj = [super forwardingTargetForSelector:aSelector];</div><div class="line">    </div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次执行看结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveInstanceMethod veryTestMethod</div><div class="line">---veryitman--- 2--- -forwardingTargetForSelector</div><div class="line">---veryitman--- 3--- -methodSignatureForSelector</div><div class="line">---veryitman--- 1--- +resolveInstanceMethod: _forwardStackInvocation:</div><div class="line">---veryitman--- 4--- -forwardInvocation</div><div class="line">---veryitman--- veryTestMethod</div></pre></td></tr></table></figure>
<p><strong>注意:</strong> 这里在 3后面会多了一个 <code>1--- resolveInstanceMethod</code> 的打印, 是系统调用的, 此时对应的 sel 是 <code>_forwardStackInvocation</code>.</p>
<p>如果不去重写 <code>methodSignatureForSelector</code> 打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---veryitman--- 1--- +resolveInstanceMethod</div><div class="line">---veryitman--- 2--- -forwardingTargetForSelector</div><div class="line">---veryitman--- 5--- -doesNotRecognizeSelector: veryTestMethod</div></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>1.Apple RunTime 源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723.tar.gz</a></p>
<p>2.<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="noopener">Message Forwarding</a></p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="http://www.veryitman.com/2018/03/31/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程</a></p>
<p><a href="http://www.veryitman.com/2018/04/03/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">OC-RunTime: 消息转发之类方法的转发流程</a></p>
<p><a href="http://www.veryitman.com/2018/04/05/OC-RunTime-%E6%80%BB%E7%BB%93%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">OC-RunTime: 总结消息转发中用到的知识点</a></p>
<p>点击下载文中完整的 <a href="https://github.com/veryitman/iOSDemo/tree/master/MZRuntimeMsgForward" target="_blank" rel="noopener">Demo</a>.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS RunTime MessageForward </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC-RunTime: 消息转发之实例方法的转发流程]]></title>
      <url>/2018/03/31/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>本篇只是从系统函数的实现上, 来分析消息转发的流程. </p>
<p>下一篇结合本篇的理论和实际的例子来分析一下消息转发.</p>
<h2 id="需要明确的几个问题"><a href="#需要明确的几个问题" class="headerlink" title="需要明确的几个问题"></a>需要明确的几个问题</h2><p>在往下看这篇博文之前, 有几个问题需要大家达成共识.</p>
<p><strong>1.Objective-C 的特点</strong><br>按照是否需要编译的原理来说, 编程语言一般可以分为静态编译类型和动态解释类型.</p>
<p>如 Java/C/C++ 是属于编译类型的语言, Php/Python/Ruby 属于解释类型的语言.</p>
<p>Objective-C 是基于 C 并具有自身特点的编译型语言, 再加上其 RunTime 机制, Objective-C 既是编译型又是动态的一门编程语言. 所谓的动态指的是在程序编译后运行中可以改变其结构.</p>
<p><strong>2.函数调用</strong><br>在 Objective-C 中调用函数, 被解释为向一个对象发送消息, 该对象可以是类对象也可以是实例对象.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person play];</div></pre></td></tr></table></figure>
<p>意思是向实例对象 person 发送一个 play 的消息. </p>
<p>还有一个比较有意思的是, 向一个空对象(nil) 发送消息不会 crash, 如果在 Java 中这个是不行的.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person = nil;</div><div class="line">[person play];</div></pre></td></tr></table></figure>
<p>这个不会导致程序崩溃, 只是调用 <code>play</code> 函数没有任何反应罢了!</p>
<p><strong>3.self</strong><br>在 C++/Java 语言中, 有 this 指针的概念, 在 Objective-C 中, 也有类似的 this 指针即 self. self 既可以是实例对象也可以是类对象.</p>
<p>这里举个例子, 下面两个同名函数, 一个是类方法(+)一个是实例方法(-).<br>跟 Java 中的类似, 实例方法可以直接使用类方法, 但是类方法不可以直接使用实例方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+ (void)testClassMethod</div><div class="line">&#123;</div><div class="line">    [self sendMsg];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testInstanceMethod</div><div class="line">&#123;</div><div class="line">    [self sendMsg];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类方法</div><div class="line">+ (void)sendMsg</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;+ sendMsg. self: %@&quot;, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实例方法</div><div class="line">- (void)sendMsg</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;- sendMsg. self: %@&quot;, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ViewController 中分别调用两个 test 方法, 输出内容, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ sendMsg. self: ViewController</div><div class="line"></div><div class="line">- sendMsg. self: &lt;ViewController: 0x7fc64740a5e0&gt;</div></pre></td></tr></table></figure>
<p>从结果可以看出类方法中的 self 代表的是该类, 实例方法中的 self 指的是类的一个实例即对象.</p>
<h2 id="关于-Message-Forwarding"><a href="#关于-Message-Forwarding" class="headerlink" title="关于 Message Forwarding"></a>关于 Message Forwarding</h2><p>Message Forwarding 即消息转发. </p>
<p>关于消息转发, 官方文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="noopener">Message Forwarding</a> 是这么解释的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Sending a message to an object that does not handle that message is an error. However, </div><div class="line">before announcing the error, </div><div class="line">the runtime system gives the receiving object a second chance to handle the message.</div></pre></td></tr></table></figure>
<p>大概意思是这样的:</p>
<blockquote>
<p>向一个对象发送消息, 该对象如果无法处理该消息, 系统就会报错, 但是在报错之前, 利用 Objective-C 提供的运行时机制可以防止报错的发生. 在 iOS 中类似这样的报错会导致程序直接 crash.<br>这里的对象, 可以是实例对象又可以是类对象.</p>
</blockquote>
<p>在开发过程中, 大家一般都会遇到类似的 crash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> *** Terminating app due to uncaught exception  </div><div class="line">&apos;NSInvalidArgumentException&apos;, </div><div class="line">reason: &apos;-[Controller play]: unrecognized selector sent to instance 0x7ff779f322a0&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">CoreFoundation  0x000000010d89712b __exceptionPreprocess + 171</div><div class="line">libobjc.A.dylib 0x000000010cf2bf41 objc_exception_throw + 48</div><div class="line">CoreFoundation  0x000000010d918024 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132</div><div class="line">UIKit 			0x000000010df48f51 -[UIResponder doesNotRecognizeSelector:] + 295</div><div class="line">CoreFoundation  0x000000010d819f78 ___forwarding___ + 1432</div><div class="line">CoreFoundation  0x000000010d819958 _CF_forwarding_prep_0 + 120</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这个 crash 很明显, <code>Controller</code> 中调用了一个不存在的函数 <code>play</code>.</p>
<p>这里可以看到一个被调用的系统函数 <code>doesNotRecognizeSelector</code>, 今天我们剖析一下消息转发的流程.</p>
<h2 id="实例方法-消息-转发的流程"><a href="#实例方法-消息-转发的流程" class="headerlink" title="实例方法(消息)转发的流程"></a>实例方法(消息)转发的流程</h2><p>在上面已经说过, OC 可以通过运行时来避免因为找不到方法而导致错误.</p>
<p>其实, 含义就是 OC 给了我们第二次机会来避免类似的错误.</p>
<p>我们重写 NSObject 中的 5 个方法, 分别是:</p>
<blockquote>
<ol>
<li>+resolveInstanceMethod</li>
<li>-forwardingTargetForSelector</li>
<li>-methodSignatureForSelector</li>
<li>-forwardInvocation</li>
<li>-doesNotRecognizeSelector:</li>
</ol>
</blockquote>
<p>当无法找到对应的方法时, 调用的方法和顺序大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+resolveInstanceMethod</div><div class="line">-forwardingTargetForSelector</div><div class="line">-methodSignatureForSelector</div><div class="line">-doesNotRecognizeSelector:</div></pre></td></tr></table></figure>
<p>当找到对应的方法时, 调用方法和顺序大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+resolveInstanceMethod</div><div class="line">-forwardingTargetForSelector</div><div class="line">-methodSignatureForSelector</div><div class="line">-forwardInvocation</div></pre></td></tr></table></figure>
<p>根据实践结果, 画流程图如下:<br><img src="/upload/images/2018/03/31/1.jpg" alt="1"></p>
<p>下面分别解释一下这几个方法的作用和意义.</p>
<p><strong>+ (BOOL)resolveInstanceMethod:(SEL)sel</strong></p>
<p>解析对应的实例方法. 在该方法中允许增加一个方法的实现, 从而实现动态添加方法.</p>
<p>默认返回 NO.</p>
<p>在 <code>NSObject.mm</code> 中可以看到方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>- (id)forwardingTargetForSelector:(SEL)aSelector</strong></p>
<p>将对应的 selector 转发给指定的对象. 换句话说就是将之前没有实现的 selector 转交给另外一个可能实现了该 selector 的对象去处理.</p>
<p>默认返回 nil.</p>
<p><strong>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</strong></p>
<p>该方法返回对 selector 实现的方法签名.</p>
<p>默认实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</div><div class="line">    _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot;</div><div class="line">                &quot;not available without CoreFoundation&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>- (void)forwardInvocation:(NSInvocation *)anInvocation</strong></p>
<p>该方法是依赖第3个方法的, 如果第三个方法找到了对应的方法签名, 该方法就可以实现转向调用了.</p>
<p><strong>- (void)doesNotRecognizeSelector:(SEL)sel</strong></p>
<p>如果前面几个方法都没有处理好, 系统会调用该方法, 直接导致程序 crash, 也称之为终极死亡方法.</p>
<p>源码实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)doesNotRecognizeSelector:(SEL)sel &#123;</div><div class="line">    _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结, Objective-C 中给一个对象发送消息会经过如下几个步骤：</p>
<p><strong>步骤1.</strong> 在类的调度表(dispatch table) 中找要执行的函数(消息), 如果找到了，到相应的函数 IMP 去执行.</p>
<blockquote>
<p>每个类的结构体包含着两个必备的元素:<br>[1]. 指向父类的指针<br>[2]. class dispatch table(调度表). 调度表中包含了 method selectors 和特定 class 相应方法实现的地址.</p>
</blockquote>
<p><strong>步骤2.</strong> 如果没找到，运行时会调用 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试解析这个消息. 在该方法中, 允许动态添加一个方法的实现.</p>
<blockquote>
<p>关于 <code>resolveClassMethod</code> 这个放在另一篇博客中讲解.</p>
</blockquote>
<p><strong>步骤3.</strong> 如果 resolveXX 返回 YES, 直接结束后面的流程, 执行解析得到的方法. 如果 resolveXX 返回 NO，运行时就发送 forwardingTargetForSelector 消息, 允许这个消息转发给另一个可能实现了对应 selector 的对象.</p>
<p><strong>步骤4.</strong> 如果没有新的目标对象返回, 运行时就会发送methodSignatureForSelector 消息, 找到对应的方法签名.<br>如果找到了, 会接着调用 forwardInvocation, 如果没有找到即返回 nil, 那么直接调用 doesNotRecognizeSelector.</p>
<p>下一篇结合实际例子分析一下整个实例方法的转发流程.</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>1.Apple 开发者文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="noopener">Message Forwarding</a></p>
<p>2.Apple RunTime 源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723.tar.gz</a></p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="http://www.veryitman.com/2018/04/01/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B-%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/" target="_blank" rel="noopener">OC-RunTime: 消息转发之实例方法的转发流程实例讲解</a></p>
<p><a href="http://www.veryitman.com/2018/04/03/OC-RunTime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B9%8B%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">OC-RunTime: 消息转发之类方法的转发流程</a></p>
<p><a href="http://www.veryitman.com/2018/04/05/OC-RunTime-%E6%80%BB%E7%BB%93%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">OC-RunTime: 总结消息转发中用到的知识点</a></p>
<p>点击下载文中完整的 <a href="https://github.com/veryitman/iOSDemo/tree/master/MZRuntimeMsgForward" target="_blank" rel="noopener">Demo</a>.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS RunTime MessageForward </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MacOS 文件大小的单位]]></title>
      <url>/2018/03/24/MacOS-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8D%95%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>我一直以为文件大小都是按照 <code>1024</code> 为单位来计算的, 但是在 MacOS 上面是按照 <code>1000</code> 为单位计算的, windows 上面是按照 <code>1024</code> 为单位来计算的.</p>
<h2 id="偶然的发现"><a href="#偶然的发现" class="headerlink" title="偶然的发现"></a>偶然的发现</h2><p>之前写代码, 需要用到获取文件大小的功能, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 读取文件大小</div><div class="line">long getFileSize(char *filename) &#123;</div><div class="line">    </div><div class="line">    FILE *fp = fopen(filename, &quot;r&quot;);</div><div class="line">    if (!fp) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fseek(fp, 0, SEEK_END);</div><div class="line">    </div><div class="line">    long size = ftell(fp);</div><div class="line">    fclose(fp);</div><div class="line">    </div><div class="line">    return size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件名是 <code>mm.aac</code>, 一个音频文件, 获取到的文件大小是 <code>76395</code> 字节.</p>
<p>我无聊至极, 使用 <code>du</code> 命令来获取该文件的大小:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -sh mm.aac</div></pre></td></tr></table></figure>
<p>显示文件大小是 <code>76KB</code>.</p>
<p>MacOS 上面查看文件属性, 获取到的大小也是 <code>76KB</code></p>
<p><img src="/upload/images/2018/03/24/1.jpg" alt="1"></p>
<p>二者获取的文件大小一致, 可以看出文件的大小是正确的.</p>
<p>于是我查了一下在 windows 上面的该文件的大小, 如下截图:</p>
<p><img src="/upload/images/2018/03/24/2.png" alt="1"></p>
<p>可以看出, MacOS 上面文件大小是按照 1000 单位来计算的, 而 windows 上面是按照 1024 单位来计算的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">76395 / 1000 = 76.395</div><div class="line">76395 / 1024 = 74.604</div></pre></td></tr></table></figure>
<blockquote>
<p>按照 GNU 的习惯，单纯的 <code>K</code> <code>M</code> <code>G</code> <code>T</code> 分别指代 <code>KiB</code> <code>MiB</code> <code>GiB</code> <code>TiB</code> 以 1024 进制数据量单位，用 <code>KB</code> <code>MB</code> <code>GB</code> <code>TB</code> 以 1000 进制数据量单位. </p>
</blockquote>
<p>所以, 在 windows 上面准确表示 <code>76395bytes</code> 应该是 <code>74.6KiB</code>.</p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>在线计算 <a href="http://www.justintools.com/unit-conversion/data-storage.php?" target="_blank" rel="noopener">单位换算</a>.</p>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MacOS C 文件大小单位 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GO: 写第一个 GOLang 程序]]></title>
      <url>/2018/03/11/GO-%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA-GOLang-%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>本文分享在 MacOS 上面通过 pkg 的方式安装 GO 编程环境, 以及编译运行第一个使用 GOLang 编写的程序.</p>
<p>其他关于 GO 的安装方式, 如使用 Homebrew 安装或者使用源码安装的方式, 请自行尝试.</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>在 <a href="https://golang.org/doc/install" target="_blank" rel="noopener">这里</a> 下载 GO 的 pkg 安装包.</p>
<p>但是你需要科(fan)学(qiang)才能下载.</p>
<p><img src="/upload/images/2018/03/11/1.jpg" alt="1"></p>
<p>你也可以下载 Stable versions.</p>
<p>下载完成后, 直接双击安装即可.</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>安装完成后, GO 安装目录在 <code>/usr/local</code> 下面.</p>
<p>安装目录如下图所示:</p>
<p><img src="/upload/images/2018/03/11/2.jpg" alt="1"></p>
<p>需要将其设置到环境变量中, 才能在终端使用其相关的命令.</p>
<p>编辑 <code>~/.bash_profile</code>, 增加下面几行即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Golang</div><div class="line"></div><div class="line">export GOROOT=/usr/local/go</div><div class="line">export GOPATH=~/gowork</div><div class="line">export PATH=$GOROOT/bin:$GOPATH:$PATH</div></pre></td></tr></table></figure>
<blockquote>
<p>记住, GOROOT 和 GOPATH 必须设置.<br><code>gowork</code> 是我自己新建的目录. GOPATH 可以理解为工作目录.</p>
</blockquote>
<p>关于 GOPATH 可以参考这个文档 <a href="https://github.com/golang/go/wiki/SettingGOPATH" target="_blank" rel="noopener">SettingGOPATH</a>.</p>
<p>我刚开始没有配置 GOROOT 变量, 执行 go 命令会提示警告, 警告内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">warning: GOPATH set to GOROOT (/usr/local/go) has no effect</div></pre></td></tr></table></figure>
<p>编辑保存, 然后使其立即生效.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>检查环境变量是否生效.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go version</div></pre></td></tr></table></figure>
<p>对应输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go version go1.9.4 darwin/amd64</div></pre></td></tr></table></figure>
<p>也可以使用 <code>go env</code> 来查看更加详细的内容.</p>
<h2 id="编译运行-GOLang-程序"><a href="#编译运行-GOLang-程序" class="headerlink" title="编译运行 GOLang 程序"></a>编译运行 GOLang 程序</h2><p><strong>1.编写代码</strong></p>
<p>编辑一个 <code>Hello GOLang</code> 的程序.</p>
<p>在任意一个文件夹位置, 新建一个 <code>go_hello.go</code> 的文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch go_hello.go</div></pre></td></tr></table></figure>
<p>写入如下程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">   fmt.Println(&quot;Hello, GOLang!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.编译运行</strong></p>
<p>使用 <code>go build</code> 命令编译.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build go_hello.go</div></pre></td></tr></table></figure>
<p>编译成功后, 生成可执行文件 <code>go_hello</code>. 执行即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./go_hello</div></pre></td></tr></table></figure>
<p>或者直接运行, 执行下面的命令.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go run go_hello.go</div></pre></td></tr></table></figure>
<p>这个不会生成可执行文件.</p>
<p>至此, GO 的编程环境已经搭建完成, 比较简单.</p>
<h2 id="卸载-GO"><a href="#卸载-GO" class="headerlink" title="卸载 GO"></a>卸载 GO</h2><p>如果你想卸载 GO 环境, 只需要三个步骤.</p>
<p><strong>1.删除安装目录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo rm -fr /usr/local/go</div></pre></td></tr></table></figure>
<p><strong>2.删除 go 文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo rm -f /etc/paths.d/go</div></pre></td></tr></table></figure>
<p><strong>3.删除环境变量</strong></p>
<p>编辑 etc, 删除对应添加的 go 环境变量即可.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://golang.org/doc/install" target="_blank" rel="noopener">GO: Getting Started</a></p>
<p><a href="https://golang.org/doc/" target="_blank" rel="noopener">GO: DOC</a></p>
<p><a href="https://github.com/golang/go/wiki/SettingGOPATH" target="_blank" rel="noopener">SettingGOPATH</a></p>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GOLanguage Google </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C 指针与 OC 对象之间的转换]]></title>
      <url>/2018/03/07/C-%E6%8C%87%E9%92%88%E4%B8%8E-OC-%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h2 id="Core-Foundation-框架"><a href="#Core-Foundation-框架" class="headerlink" title="Core Foundation 框架"></a>Core Foundation 框架</h2><p>Core Foundation 框架 (CoreFoundation.framework) 是一组 C 语言接口， 简称 CF. </p>
<p>它们为 iOS 应用程序提供基本数据管理和服务功能.</p>
<p>如 Core Graphics、Core Text，并且我们可能需要将 CF 对象和OC 对象进行相互转化，ARC 下，编译器不会自动管理 CF 对象的内存，我们需要手动管理. </p>
<p>创建一个 CF 对象使用后, 需要使用 CFRelease 将其手动释放, 换句话说, Core Foundation 对象类型不在 ARC 管理范畴内.</p>
<p>如何将 CF 和 OC 对象有效的结合起来, 在 ARC 环境下, 提供了 <code>桥接</code> 的技术, 即 ARC 下 OC 对象和 Core Foundation 对象之间的桥梁.</p>
<h2 id="ARC-桥接"><a href="#ARC-桥接" class="headerlink" title="ARC 桥接"></a>ARC 桥接</h2><p>ARC 下 C 指针与 OC 指针(对象)之间转换, 一般会用到下面的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;</div><div class="line"></div><div class="line">__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;</div><div class="line"></div><div class="line">__bridge &lt;#type#&gt;)&lt;#expression#&gt;</div></pre></td></tr></table></figure>
<p>也就是所谓的 <code>桥接</code>, 它是 Object-C 在 ARC 环境下开发出来的一种用作转换 C 指针跟 OC (类)指针的一种转换技术, 所以是 ARC 下的称谓, 在 MRC 下没有 <code>桥接</code>.</p>
<p>针对内存管理问题，ARC 可以管理 Objective-C 对象, 但不支持 Core Foundation 对象的管理，所以转换后要注意一个问题：谁来释放使用后的对象.</p>
<p>结合 ARC 和 内存管理, 下面分别介绍一下.</p>
<p>Core Foundation 对象必须使用 CFRetain 和 CFRelease 来进行内存管理.<br>当使用 Objective-C 和 Core Foundation 对象相互转换的时候，必须让编译器知道，到底由谁来负责释放对象，是否交给 ARC 处理, 只有正确的处理，才能避免内存泄漏和 double free 导致程序崩溃.</p>
<h2 id="bridge-retained-lt-CF-type-gt-lt-expression-gt"><a href="#bridge-retained-lt-CF-type-gt-lt-expression-gt" class="headerlink" title="__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;"></a>__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;</h2><p><code>__bridge_retained</code> 等同于 <code>CFBridgingRetain()</code>.</p>
<p>将 Objective-C 对象转换为 Core Foundation 对象，把对象所有权桥接给 Core Foundation 对象，同时剥夺 ARC 的管理权，后续需要开发者使用 CFRelease 或者相关方法手动来释放 CF 对象.</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void *cPointer;</div><div class="line">NSObject *objc = [[NSObject alloc] init];</div><div class="line"></div><div class="line">//将 OC 对象转换为 C 指针</div><div class="line">cPointer = (__bridge_retained void*)objc;</div><div class="line"></div><div class="line">//use cPointer ...</div><div class="line"></div><div class="line">//需要释放资源</div><div class="line">CFRelease(cPointer);</div></pre></td></tr></table></figure>
<p>在 ARC 下, CFBridgingRetain 实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NS_INLINE CF_RETURNS_RETAINED CFTypeRef _Nullable CFBridgingRetain(id _Nullable X) &#123;</div><div class="line">    return (__bridge_retained CFTypeRef)X;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 CFTypeRef, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef const CF_BRIDGED_TYPE(id) void * CFTypeRef;</div></pre></td></tr></table></figure>
<p>所以 CFBridgingRetain 返回值是 <code>const void *</code> 类型的.</p>
<p>上面的示例可以改写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const void *cPointer;</div><div class="line">const NSObject *objc = [[NSObject alloc] init];</div><div class="line">cPointer = CFBridgingRetain(objc);</div><div class="line">    </div><div class="line">//use cPointer ...</div><div class="line">    </div><div class="line">CFRelease(cPointer);</div></pre></td></tr></table></figure>
<h2 id="bridge-transfer-lt-Objective-C-type-gt-lt-expression-gt"><a href="#bridge-transfer-lt-Objective-C-type-gt-lt-expression-gt" class="headerlink" title="__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;"></a>__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;</h2><p><code>__bridge_transfer</code> 等同于 <code>CFBridgingRelease()</code>.</p>
<p>将非 OC 对象转换为 OC 对象，同时将对象的管理权交给 ARC，开发者无需手动管理内存.</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);</div><div class="line">CFStringRef strUUID = CFUUIDCreateString(kCFAllocatorDefault, uuid);</div><div class="line">NSString *str = (__bridge_transfer NSString *)strUUID;</div><div class="line"></div><div class="line">//无需释放 strUUID</div><div class="line">//CFRelease(strUUID);</div><div class="line"></div><div class="line">CFRelease(uuid);</div></pre></td></tr></table></figure>
<p>CFBridgingRelease 实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NS_INLINE id _Nullable CFBridgingRelease(CFTypeRef CF_CONSUMED _Nullable X) &#123;</div><div class="line">    return (__bridge_transfer id)X;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的示例可以改写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);</div><div class="line">CFStringRef strUUID = CFUUIDCreateString(kCFAllocatorDefault, uuid);</div><div class="line">NSString *str = CFBridgingRelease(strUUID);</div><div class="line">    </div><div class="line">//无需释放 strUUID</div><div class="line">//CFRelease(strUUID);</div><div class="line">    </div><div class="line">CFRelease(uuid);</div></pre></td></tr></table></figure>
<h2 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h2><p><code>__bridge</code> 不改变对象所有权, 需要我们自己来管理内存, 它也是我们经常使用的方法, 从某种程度上来说, 它是上面两个方法的简化版本.</p>
<p><code>__bridge</code> 可以将 OC 对象 与 C 指针相互转换, 示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//CFString -&gt; OC 对象</div><div class="line">CFStringRef cfString = CFStringCreateWithCString(kCFAllocatorDefault, &quot;very&quot;, kCFStringEncodingUTF8);</div><div class="line">NSString *nsString = (__bridge NSString *)cfString;</div><div class="line">NSLog(@&quot;CFString -&gt; NSString: %@&quot;, nsString);</div><div class="line">CFRelease(cfString);</div></pre></td></tr></table></figure>
<p>如果将 <code>CFRelease(cfString)</code> 注释掉, Xcode 的静态检测器会告诉你有内存泄露的情况, 如图:</p>
<p><img src="/upload/images/2018/03/07/2.png" alt="1"></p>
<p>再来另外一个例子, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//OC 对象 -&gt; CFString</div><div class="line">NSString *nstr = @&quot;itman&quot;;</div><div class="line">CFStringRef cfStringRef = (__bridge CFStringRef)nstr;</div><div class="line">NSLog(@&quot;NSString -&gt; CFString: %@&quot;, cfStringRef);</div><div class="line">CFRelease(cfStringRef);</div></pre></td></tr></table></figure>
<p>无论是使用 <code>CFRelease(cfStringRef)</code>, 还是注释掉 <code>CFRelease(cfStringRef)</code>, 静态检测器都不会报错. 说明这种情况下, 当前的内存管理已经被 OC 对象管理.</p>
<h2 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h2><h3 id="NSString-与-CFString-转换"><a href="#NSString-与-CFString-转换" class="headerlink" title="NSString 与 CFString 转换"></a>NSString 与 CFString 转换</h3><p>NSString → CFString</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    NSString *string = @&quot;veryitman.com&quot;;</div><div class="line">    // 方法1: 不需要释放</div><div class="line">    CFStringRef cfStr = (__bridge CFStringRef)string;</div><div class="line">    </div><div class="line">    // 方法2: 需要释放, 这里 retain 了</div><div class="line">    CFStringRef cfStr2 = (__bridge_retained CFStringRef)string;</div><div class="line">    CFRelease(cfStr2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CFString → NSString</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CFStringRef cfStr = CFStringCreateWithCString(kCFAllocatorDefault, &quot;veryitman&quot;, kCFStringEncodingUnicode);</div><div class="line">    </div><div class="line">// 方法1: 需要释放</div><div class="line">NSString *string = (__bridge NSString *)cfStr;</div><div class="line">NSLog(@&quot;OC string: %@&quot;, string);</div><div class="line">CFRelease(cfStr);</div><div class="line">    </div><div class="line">// 方法2: 不需要释放, __bridge_transfer 自带 release</div><div class="line">string = (__bridge_transfer NSString *)cfStr;</div></pre></td></tr></table></figure>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>运行下面的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void *p;</div><div class="line">&#123;</div><div class="line">    NSObject *objc = [[NSObject alloc] init];</div><div class="line">    p = (__bridge void*)objc;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">NSLog(@&quot;mark: %@&quot;, (__bridge NSObject*)p);</div></pre></td></tr></table></figure>
<p>会直接 crash, 如图:</p>
<p><img src="/upload/images/2018/03/07/1.jpg" alt="1"></p>
<p>当 <code>objc</code> 这个对象超出作用域范围，其内存就会被回收，接着在作用域范围外用 <code>void *p</code> 去访问 <code>objc</code> 的内存，就造成了野指针.</p>
<p>结合上面所说的, 我们可以让指针 p 对 objc 进行引用即 retain 操作, 修改如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void *p;</div><div class="line">&#123;</div><div class="line">    NSObject *objc = [[NSObject alloc] init];</div><div class="line">    //p = (__bridge void*)objc;</div><div class="line">    p = (__bridge_retained void*)objc;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">NSLog(@&quot;mark: %@&quot;, (__bridge NSObject*)p);</div><div class="line">    </div><div class="line">// 一定要释放</div><div class="line">CFRelease(p);</div></pre></td></tr></table></figure>
<p>可以正常的运行. 还可以修改为另一种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void *p;</div><div class="line">&#123;</div><div class="line">    NSObject *objc = [[NSObject alloc] init];</div><div class="line">    //p = (__bridge void*)objc;</div><div class="line">    //p = (__bridge_retained void*)objc;</div><div class="line">    p = (void *)CFBridgingRetain(objc);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">NSLog(@&quot;mark: %@&quot;, (__bridge NSObject*)p);</div><div class="line">    </div><div class="line">// 一定要释放</div><div class="line">CFRelease(p);</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[音视频编程: iOS 推流]]></title>
      <url>/2018/02/26/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E6%8E%A8%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>本篇分享是基于 <a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a> 这篇文章的, 之前是使用 ffmpeg 命令进行推流并且都是在 macos 上面进行的操作.</p>
<p>现在在 iOS 平台上使用 <a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit</a> 进行推流, 然后使用 VLC 播放器播放流视频.</p>
<p><strong>该系列博文:</strong></p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/" target="_blank" rel="noopener">音视频编程: 编译 faac/faad2</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">音视频编程: iOS 使用 faac 编码</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> </p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/26/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E6%8E%A8%E6%B5%81/" target="_blank" rel="noopener">音视频编程: iOS 推流</a> (本篇)</p>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一般直播过程包括对音视频的采集、处理、编码、封包、推流、传输、转码、分发、解码、播放等. </p>
<p><strong>推流</strong>, 指使用推流工具把直播内容传输到服务器的过程. 本篇分享使用 LFLiveKit 工具将 iPhone 摄像头和麦克风采集的数据推流到本地流服务器.</p>
<p><strong>拉流</strong>, 指对服务器直播的内容，用指定地址进行拉取(播放)的过程, 本篇分享使用 VLC 充当拉流的角色.</p>
<h2 id="集成-LFLiveKit"><a href="#集成-LFLiveKit" class="headerlink" title="集成 LFLiveKit"></a>集成 LFLiveKit</h2><p>LFLiveKit 是一个开源的推流 SDK, 支持 H264 and AAC 的硬编码, 支持美颜(集成了 GPUImage).</p>
<p>使用 LFLiveKit 比较简单, 按照其 demo 集成即可.</p>
<p><strong>1.工程配置info.plist</strong></p>
<p>需要访问相机和麦克风权限.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Privacy - Camera Usage Description</div><div class="line"></div><div class="line">Privacy - Microphone Usage Description</div></pre></td></tr></table></figure>
<p><strong>2.请求相机和麦克风权限.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">- (void)requestAccessForVideo &#123;</div><div class="line">    </div><div class="line">    __weak typeof(self) _self = self;</div><div class="line">    AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];</div><div class="line">    </div><div class="line">    switch (status) &#123;</div><div class="line">            </div><div class="line">        case AVAuthorizationStatusNotDetermined: &#123;</div><div class="line">            </div><div class="line">            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123;</div><div class="line">                </div><div class="line">                if (granted) &#123;</div><div class="line">                    </div><div class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                        [_self.session setRunning:YES];</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        case AVAuthorizationStatusAuthorized: &#123;</div><div class="line">            </div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [_self.session setRunning:YES];</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        case AVAuthorizationStatusDenied:</div><div class="line">        case AVAuthorizationStatusRestricted:</div><div class="line">            // 用户明确地拒绝授权，或者相机设备无法访问</div><div class="line">            break;</div><div class="line">            </div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)requestAccessForAudio &#123;</div><div class="line">    </div><div class="line">    AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];</div><div class="line">    </div><div class="line">    switch (status) &#123;</div><div class="line">            </div><div class="line">        case AVAuthorizationStatusNotDetermined: &#123;</div><div class="line">            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeAudio completionHandler:^(BOOL granted) &#123;</div><div class="line">            &#125;];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        case AVAuthorizationStatusAuthorized: &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        case AVAuthorizationStatusDenied:</div><div class="line">        case AVAuthorizationStatusRestricted:</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>务必要调用 LFLiveSession 的 <code>setRunning</code> 方法.</p>
<p>完整的工程代码, 后续我会放到 Github 上面. 方便有需要的下载.</p>
<h2 id="推流播放"><a href="#推流播放" class="headerlink" title="推流播放"></a>推流播放</h2><p>上面的基本配置完成后, 可以开始推流了.</p>
<p><strong>1.启动 nginx</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nginx</div></pre></td></tr></table></figure>
<p><strong>2.启动推流</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)startLive &#123;</div><div class="line">    </div><div class="line">    LFLiveStreamInfo *streamInfo = [LFLiveStreamInfo new];</div><div class="line">    streamInfo.url = sRTMPUrl;</div><div class="line">    [self.session startLive:streamInfo];</div><div class="line">    self.session.beautyFace = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <code>sRTMPUrl</code> 是一个常量定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static NSString * const sRTMPUrl = @&quot;rtmp://192.168.1.102:1935/rtmplive/channel&quot;;</div></pre></td></tr></table></figure>
<p><code>192.168.1.102</code> 是我的本机(mac) ip 地址.</p>
<p>如果一切正常的话, 你在手机上面可以看到自己的预览画面.</p>
<p><strong>3.VLC 播放</strong></p>
<p>使用 VLC 播放 rtmp 的流, 打开 VLC 播放器, 选择 File/Open Network, 输入 <code>rtmp://192.168.1.102:1935/rtmplive/channel</code> 这个地址即可实时播放了.</p>
<p>这里注意一定要使用本机的 ip 地址, 不要使用 <code>localhost:1935</code> 类似的地址, 否则无法播放和推流.</p>
<p>后续分享如何在 iOS 上面使用播放器来播放直播流.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频 rtmp nginx 推流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[音视频编程: 构建 nginx 推流服务器]]></title>
      <url>/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇分享的主要内容</p>
</blockquote>
<p>如何在 macos 中构建本地的推流服务器(nginx + rtmp-nginx-module), 并使用 ffmpeg 命令进行视频推流, 然后使用 VLC 播放器播放视频.</p>
<p><strong>该系列博文:</strong></p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/" target="_blank" rel="noopener">音视频编程: 编译 faac/faad2</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">音视频编程: iOS 使用 faac 编码</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> </p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a> (本篇)</p>
</li>
</ul>
<h2 id="安装-rtmp-nginx-module"><a href="#安装-rtmp-nginx-module" class="headerlink" title="安装 rtmp-nginx-module"></a>安装 rtmp-nginx-module</h2><p>之前在测试 php 程序的时候, 我已经安装过 nginx, 但是发现这样在配置 rtmp-nginx-module 的时候, 无法成功.</p>
<p>配置文件修改完成之后, nginx 总是无法识别 <code>rtmp</code>, 报错如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[emerg] 30766#0: unknown directive &quot;rtmp&quot; in /usr/local/etc/nginx/nginx.conf:40</div></pre></td></tr></table></figure>
<p>现在需要卸载原来已经安装的 nginx, 命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew uninstall nginx</div></pre></td></tr></table></figure>
<p>再次安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install nginx-full --with-rtmp-module</div></pre></td></tr></table></figure>
<p>耐心等待一会 ~~</p>
<p>nginx 的版本(nginx -v):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx/1.12.2</div></pre></td></tr></table></figure>
<p>rtmp-nginx-module 版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.1.7.11-dev_2</div></pre></td></tr></table></figure>
<h2 id="配置-rtmp"><a href="#配置-rtmp" class="headerlink" title="配置 rtmp"></a>配置 rtmp</h2><p>编辑 nginx 的配置文件, 文件位置位于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/etc/nginx/nginx.conf</div></pre></td></tr></table></figure>
<p>在 <code>http {}</code> 后面写入如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">rtmp &#123;</div><div class="line">   server &#123;</div><div class="line">        #rtmp协议的默认端口号是 1935</div><div class="line">        listen 1935;</div><div class="line">        #直播流配置, 访问 path 是 rtmplive</div><div class="line">        application rtmplive &#123;</div><div class="line">              #开启实时</div><div class="line">              live on;</div><div class="line">              #设置 rtmp 引擎的最大连接数. 默认为off</div><div class="line">              max_connections 1024;</div><div class="line">              #不记录数据</div><div class="line">             record off;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意: <code>rtmplive</code> 是固定的.</p>
<p>具体的 nginx 配置详见后面的附录内容.</p>
<h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><p><strong>1.安装 ffmpeg 即可. </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ffmpeg</div></pre></td></tr></table></figure>
<p>这个过程有点久, 如果你没有梯子基本安装不了 [大哭]~</p>
<p><strong>2.安装 VLC</strong></p>
<p>直接去官网下载 dmg 包, 安装即可.</p>
<p>打开 VLC 然后选择从 File/Open Network 打开文件, 如下图所示:</p>
<p><img src="/upload/images/2018/02/25/1.jpg" alt="1"></p>
<p>在弹出的框中, 写入推流地址 <code>rtmp://localhost:1935/rtmplive/channel</code>, 如图所示:</p>
<p><img src="/upload/images/2018/02/25/2.jpg" alt="1"></p>
<p>直接点击 Open.</p>
<blockquote>
<p>注意: 如果 localhost 无法播放, 请更换为你的本机 ip, 如我的本机 ip 是 <code>192.168.1.122</code>, 对应的播放地址为 <code>rtmp://192.168.1.122:1935/rtmplive/channel</code>.<br>如果还是无法成功, 请关闭 macos 的防火墙.</p>
</blockquote>
<p><strong>3.启动 nginx</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nginx</div></pre></td></tr></table></figure>
<p>可以在浏览器访问如下地址, 看看 nginx 是否启动成功.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8080/index.html</div></pre></td></tr></table></figure>
<p><strong>4.ffmpeg 推流</strong></p>
<p>推流的命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ffmpeg -re -i ~/Desktop/launcher.mp4 -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmplive/channel</div></pre></td></tr></table></figure>
<p>其中 <code>launcher.mp4</code> 是我自己从网络上面下载的一个视频文件, 时长大约是 5 分钟.</p>
<p>在 VLC 中, 就可以看到推流播放的视频了. [开心]~~</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">worker_processes  1;</div><div class="line"> </div><div class="line">error_log  /usr/local/etc/nginx/logs/error.log debug;</div><div class="line"></div><div class="line">pid        /usr/local/var/run/nginx.pid;</div><div class="line"> </div><div class="line">events &#123;</div><div class="line">    worker_connections  256;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">http &#123;</div><div class="line">    include             mime.types;</div><div class="line">    default_type        application/octet-stream;</div><div class="line"> </div><div class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line"> </div><div class="line">    access_log  /usr/local/etc/nginx/logs/access.log  main;</div><div class="line"> </div><div class="line">    sendfile            on;</div><div class="line"> </div><div class="line">    keepalive_timeout   65;</div><div class="line"> </div><div class="line">    index index.html index.php;</div><div class="line"> </div><div class="line">    include /usr/local/etc/nginx/sites-enabled/*; </div><div class="line">    include /usr/local/etc/nginx/conf.d/*;</div><div class="line"></div><div class="line">     server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            root   /Users/me/workspace/projs/phpwork/; #web的根目录</div><div class="line">            index  index.php index.html index.htm; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">rtmp &#123;</div><div class="line">   server &#123;</div><div class="line">        #rtmp协议的默认端口号是1935</div><div class="line">        listen 1935;</div><div class="line">        #直播流配置,访问路径是rtmplive</div><div class="line">        application rtmplive &#123;</div><div class="line">              #开启实时</div><div class="line">              live on;</div><div class="line">              #为rtmp引擎设置最大连接数.默认为off</div><div class="line">              max_connections 1024;</div><div class="line">              #不记录数据</div><div class="line">             record off;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="视频文件"><a href="#视频文件" class="headerlink" title="视频文件"></a>视频文件</h2><p>使用下载的 mp4 文件, 有些无法播放, 暂时估计应该是码率的问题, 大家在测试过程中, 发现视频无法播放, 最后试试其他视频文件.</p>
<p>另外, 视频文件不要太小, 尽量能让其播放时长在 3-5 分钟.</p>
<h2 id="brew-install-uninstall-报错"><a href="#brew-install-uninstall-报错" class="headerlink" title="brew install/uninstall 报错"></a>brew install/uninstall 报错</h2><p>报错信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Error: undefined method `patch&apos; for #&lt;Resource:0x000001040877a8&gt;</div><div class="line">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/gcc@4.9.rb:55:in `block in &lt;class:GccAT49&gt;&apos;</div><div class="line">/usr/local/Homebrew/Library/Homebrew/resource.rb:49:in `instance_eval&apos;</div><div class="line">/usr/local/Homebrew/Library/Homebrew/resource.rb:49:in `initialize&apos;</div><div class="line">/usr/local/Homebrew/Library/Homebrew/software_spec.rb:111:in `new&apos;</div><div class="line">/usr/local/Homebrew/Library/Homebrew/software_spec.rb:111:in `resource&apos;</div></pre></td></tr></table></figure>
<p>最终的解决方案是重新安装 Homebrew, 命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<h2 id="检查本机的-ip"><a href="#检查本机的-ip" class="headerlink" title="检查本机的 ip"></a>检查本机的 ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频 rtmp nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSLog 格式化输出 NSInteger/NSUInteger]]></title>
      <url>/2018/02/22/NSLog-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-NSInteger-NSUInteger/</url>
      <content type="html"><![CDATA[<p>在 Xcode 中 使用 NSLog 打印 NSInteger/NSUInteger 数据, 经常会遇到类似的警告. </p>
<p>如下图所示:<br><img src="/upload/images/2018/02/22/1.jpg" alt="1"></p>
<p>但是在 iphone 4s(32位)机器上就没有任何警告, 只是在64位的机型上面有这样的警告.</p>
<p>在 <code>NSObjCRuntime.h</code> 里面定义 <code>NSInteger</code> 和 <code>NSUInteger</code> 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</div><div class="line">typedef long NSInteger;</div><div class="line">typedef unsigned long NSUInteger;</div><div class="line">#else</div><div class="line">typedef int NSInteger;</div><div class="line">typedef unsigned int NSUInteger;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>也就是说 64 位下是 long 类型，32 位下是 int 类型.</p>
<p>所以, 上面的代码在 32 位机型上面不会有警告.</p>
<p>按照 Xcode 的提示, Fix it: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUInteger iun = 3;</div><div class="line">NSLog(@&quot;iun: %lu&quot;, (unsigned long)iun);</div><div class="line">    </div><div class="line">NSInteger nsi = 6;</div><div class="line">NSLog(@&quot;nsi: %ld&quot;, (long)nsi);</div></pre></td></tr></table></figure>
<p>这样无论在 32 位还是在 64 位机型上面, 都没有警告了.</p>
<h2 id="Twitter-帖子"><a href="#Twitter-帖子" class="headerlink" title="Twitter 帖子"></a>Twitter 帖子</h2><p>在 <a href="https://twitter.com/gparker/status/377910611453046784" target="_blank" rel="noopener">twitter 有个帖子</a> 说了另一种解决办法, 原文如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%zd, %tu, %tx (signed, unsigned, hex) currently format NSInteger and NSUInteger with no warnings.</div></pre></td></tr></table></figure>
<blockquote>
<p>意思是使用 zd 可以格式化有符号的如 NSInteger, 使用 tu 格式化无符号的如 NSUInteger. 而 tx 可以用来格式化输出 16 进制数据.</p>
</blockquote>
<p>按照这个说法, 修改如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUInteger iun = 3;</div><div class="line">NSLog(@&quot;iun: %zd&quot;, iun);</div><div class="line">    </div><div class="line">NSInteger nsi = 6;</div><div class="line">NSLog(@&quot;nsi: %td&quot;, nsi);</div></pre></td></tr></table></figure>
<p>或者这样修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUInteger iun = 3;</div><div class="line">NSLog(@&quot;iun: %tu&quot;, iun);</div><div class="line">    </div><div class="line">NSInteger nsi = 6;</div><div class="line">NSLog(@&quot;nsi: %td&quot;, nsi);</div></pre></td></tr></table></figure>
<p>确实没有了警告的问题.</p>
<p>我在实践过程中发现一个问题: 使用 <code>zu</code> 来格式化输出 NSUInteger, 在 32 位机器上面, 仍旧会报警告.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSUInteger iun = 3;</div><div class="line">NSLog(@&quot;iun: %zu&quot;, iun);</div></pre></td></tr></table></figure>
<p>这就让我开始怀疑 z 和 t 的可靠性了.</p>
<p>下面接着了解一下它们.</p>
<h2 id="关于-z-t"><a href="#关于-z-t" class="headerlink" title="关于 z t"></a>关于 z t</h2><p>关于 <code>z</code> <code>t</code> 的说明可以参考 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html" target="_blank" rel="noopener">String Format Specifiers</a></p>
<p><img src="/upload/images/2018/02/22/2.jpg" alt="1"></p>
<p>可以说明:</p>
<blockquote>
<p>格式化 z 可以用来代表 size_t.<br>格式化 t 可以用来代表 ptrdiff_t.</p>
</blockquote>
<p>ptrdiff_t 是C/C++标准库中定义的一个与机器相关的数据类型.<br>ptrdiff_t 类型变量通常用来保存两个指针减法操作的结果, 其定义在 C99 标准中.</p>
<p><strong>size_t 类型用于指明数组长度, 它必须是一个正数, 而 ptrdiff_t 类型则应保证足以存放同一数组中两个指针之间的差距, 它有可能是负数.</strong></p>
<p>即: size_t 是 unsigned 类型, 而 ptrdiff_t 则是 signed 整型.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printf(&quot;size_t bytes = %d\n&quot; ,sizeof(size_t));</div><div class="line">printf(&quot;ptrdiff_t bytes = %d\n&quot; ,sizeof(ptrdiff_t));</div></pre></td></tr></table></figure>
<p>在 32 位机型中输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">size_t bytes = 4</div><div class="line">ptrdiff_t bytes = 4</div></pre></td></tr></table></figure>
<p>在 64 位机型中输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">size_t bytes = 8</div><div class="line">ptrdiff_t bytes = 8</div></pre></td></tr></table></figure>
<p>这说明, sizet_t 和 ptrdiff_t 是和机器类型相关的跨平台的.</p>
<p>系统定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef __SIZE_TYPE__ size_t;</div><div class="line">typedef __PTRDIFF_TYPE__ ptrdiff_t;</div></pre></td></tr></table></figure>
<p>32 位机型定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define __SIZE_TYPE__ long unsigned int</div><div class="line">#define __PTRDIFF_TYPE__ int</div></pre></td></tr></table></figure>
<p>64 位机型定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define __SIZE_TYPE__ long unsigned int</div><div class="line">#define __PTRDIFF_TYPE__ long int</div></pre></td></tr></table></figure>
<h2 id="终极解决方案"><a href="#终极解决方案" class="headerlink" title="终极解决方案"></a>终极解决方案</h2><p>既然在 Xcode 里面提示 Fix it 可以使用, 那么为了提高代码的健壮性和可维护性, 可以定义宏定义来解决.</p>
<p>宏定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#if __LP64__</div><div class="line">#define MZNSI @&quot;ld&quot;</div><div class="line">#define MZNSU @&quot;lu&quot;</div><div class="line">#else</div><div class="line">#define MZNSI @&quot;d&quot;</div><div class="line">#define MZNSU @&quot;u&quot;</div><div class="line">#endif //__LP64__</div></pre></td></tr></table></figure>
<p>使用方法, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSInteger nsi = 6;</div><div class="line">NSUInteger iun = 3;</div><div class="line">NSLog(@&quot;NSInteger nsi = %&quot;MZNSI, nsi);</div><div class="line">NSLog(@&quot;NSUInteger iun = %&quot;MZNSU, iun);</div></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>给出常用的格式化打印输出字符串中的格式符, 如下所示:</p>
<p>1）%c：对应参数是一个 <code>int</code> 类型，但实际运行时会将该 <code>int</code>类型对象转换为 <code>unsigned char</code> 类型.</p>
<p>2）%d 或者 %i：对应参数是一个 <code>int</code> 类型. 只不过, %d 一般用于十进制, %i 可以对应各种进制的数据.</p>
<blockquote>
<p>二者在打印输出上面没有什么太大的差别. 但是在接收输入(scanf)上, %d 用于十进制, %i 对应各种进制的数据. 可以参考 <a href="https://www.geeksforgeeks.org/difference-d-format-specifier-c-language/" target="_blank" rel="noopener">Difference between %d and %i format specifier in C language</a> 这篇文章.</p>
</blockquote>
<p>3）%f：对应参数是一个 <code>double</code> 类型.</p>
<p>4）%ld：对应参数是一个 <code>long int</code> 类型.</p>
<p>5）%s：对应参数是一个 <code>const char*</code> 类型，表示输出一个字符串.</p>
<p>6）%u：对应参数是一个 <code>unsigned int</code> 类型.</p>
<p>7）%zu：对应参数是一个 <code>size_t</code> 类型.</p>
<p>8）%td：对应参数是一个 <code>ptrdiff_t</code> 类型.</p>
<p>9）%x（或 %X）：对应参数是一个 <code>int</code> 类型，不过会以十六进制形式输出，其中大于 9 的数字根据字母 <code>x</code> 大小写进行转换，如果是 <code>%x</code>，则大于 9 的数用 <code>a～f</code> 表示；如果是 <code>%X</code>，则用 <code>A～F</code> 表示.</p>
<p>10）%%：输出一个 % 符号.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NSLog printf scanf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[音视频编程: iOS 使用 faad2]]></title>
      <url>/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/</url>
      <content type="html"><![CDATA[<p>本次分享使用 faad2 解码 AAC 音频文件, 将 AAC 文件转换为 WAV 文件并使用 AVAudioPlayer 进行播放.</p>
<p>在博文 <a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a> 给大家简单的分析了一下 WAV 的数据头协议, 其实也是为了这篇博文来服务的, 所以阅读本文之前, 建议先看上文.</p>
<p><strong>该系列博文:</strong></p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/" target="_blank" rel="noopener">音视频编程: 编译 faac/faad2</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">音视频编程: iOS 使用 faac 编码</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> (本篇)</p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a></p>
</li>
</ul>
<h2 id="例子简介"><a href="#例子简介" class="headerlink" title="例子简介"></a>例子简介</h2><p>本文以一个实际的例子, 使用 faad2的各个函数来解码 AAC 数据.</p>
<p>主要有以下几个步骤:</p>
<ul>
<li>获取输入文件</li>
<li>获取 faad 解码器句柄</li>
<li>初始化 faad 解码器</li>
<li>根据文件解析文件帧, 并写入输出文件中</li>
<li>写入文件头将其封装为 WAV 格式的音频文件</li>
<li>关闭 faad 解码器句柄</li>
</ul>
<h2 id="工程实战"><a href="#工程实战" class="headerlink" title="工程实战"></a>工程实战</h2><h3 id="引入-faad2"><a href="#引入-faad2" class="headerlink" title="引入 faad2"></a>引入 faad2</h3><p>将编译好的 faad2 导入工程即可.</p>
<p><img src="/upload/images/2018/02/20/11.jpg" alt="1"><br>其中关键的 API 在 neaacdec.h 中有描述.</p>
<p>工程效果图:<br><img src="/upload/images/2018/02/20/22.jpg" alt="1"></p>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>在 <a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a> 中已经定义了 WAV 的数据头.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct MZWavAudioFileHeader</div><div class="line">&#123;</div><div class="line">    char       riff[4];       // 字符串 &quot;RIFF&quot;</div><div class="line">    uint32_t   totalLength; // 文件总大小, 包括PCM 数据大小和该文件头大小</div><div class="line">    char       wave[4];     // 字符串 &quot;WAVE&quot;</div><div class="line">    char       fmt[4];      // 字符串 &quot;fmt &quot;</div><div class="line">    uint32_t   format;      // WAV 头大小, 固定为值 16</div><div class="line">    uint16_t   pcm;         // PCM 编码方式, 固定值为 1</div><div class="line">    uint16_t   channels;    // 声道数量, 为 2</div><div class="line">    uint32_t   frequency;   // 采样频率</div><div class="line">    uint32_t   bytes_per_second; // 每秒字节数(码率), 其值=采样率x通道数x位深度/8</div><div class="line">    uint16_t   bytes_by_capture; // 采样块大小</div><div class="line">    uint16_t   bits_per_sample; // 采样点大小, 这里是 16 位</div><div class="line">    char       data[4];         // 字符串 &quot;data&quot;</div><div class="line">    uint32_t   bytes_in_pcmdata;  // pcm 数据长度</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在实现写入数据头的方法 <code>mz_write_wav_header</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 写入 wav 头数据.</div><div class="line"> *</div><div class="line"> *  @param file  wav 文件指针.</div><div class="line"> *  @param total_samples_per_channel 每个声道的采样数.</div><div class="line"> *  @param samplerate 采样率.</div><div class="line"> *  @param channels 声道数.</div><div class="line"> */</div><div class="line">void mz_write_wav_header(FILE *file, int total_samples_per_channel, int samplerate, int channels) &#123;</div><div class="line">    </div><div class="line">    if (NULL == file) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (total_samples_per_channel &lt;= 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    printf(&quot;FAAD. total_samples_per_channel: %i, samplerate: %i, channels: %i\n&quot;,</div><div class="line">           total_samples_per_channel, samplerate, channels);</div><div class="line">    </div><div class="line">    struct MZWavAudioFileHeader wavHeader;</div><div class="line">    </div><div class="line">    // 写入 RIFF</div><div class="line">    strcpy(wavHeader.riff, &quot;RIFF&quot;);</div><div class="line">    </div><div class="line">    wavHeader.bits_per_sample = 16;</div><div class="line">    </div><div class="line">    wavHeader.totalLength = (total_samples_per_channel * channels * wavHeader.bits_per_sample/8) + sizeof(wavHeader) - 8;</div><div class="line">    </div><div class="line">    // 写入 WAVE 和 fmt</div><div class="line">    strcpy(wavHeader.wave, &quot;WAVE&quot;);</div><div class="line">    strcpy(wavHeader.fmt, &quot;fmt &quot;);</div><div class="line">    </div><div class="line">    wavHeader.format = 16;</div><div class="line">    wavHeader.pcm = 1;</div><div class="line">    wavHeader.channels = channels;</div><div class="line">    wavHeader.frequency = samplerate;</div><div class="line">    </div><div class="line">    // 每秒的字节数(码率)=采样率x通道数x位深度/8</div><div class="line">    wavHeader.bytes_per_second = wavHeader.channels * wavHeader.frequency * wavHeader.bits_per_sample/8;</div><div class="line">    </div><div class="line">    wavHeader.bytes_by_capture = wavHeader.channels*wavHeader.bits_per_sample/8;</div><div class="line">    </div><div class="line">    wavHeader.bytes_in_pcmdata = total_samples_per_channel * wavHeader.channels * wavHeader.bits_per_sample/8;</div><div class="line">    </div><div class="line">    // 写入 data</div><div class="line">    strcpy(wavHeader.data, &quot;data&quot;);</div><div class="line">    </div><div class="line">    fwrite(&amp;wavHeader, 1, sizeof(wavHeader), file);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解码主要用到了 FAAD2 中的 <code>NeAACDecDecode</code> 函数. 函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void* NEAACDECAPI NeAACDecDecode(NeAACDecHandle hDecoder,</div><div class="line">                                 NeAACDecFrameInfo *hInfo,</div><div class="line">                                 unsigned char *buffer,</div><div class="line">                                 unsigned long buffer_size);</div></pre></td></tr></table></figure>
<p>对应帧定义的结构体: <code>NeAACDecFrameInfo</code>, 定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">typedef struct NeAACDecFrameInfo</div><div class="line">&#123;</div><div class="line">    unsigned long bytesconsumed;</div><div class="line">    unsigned long samples;</div><div class="line">    unsigned char channels;</div><div class="line">    unsigned char error;</div><div class="line">    unsigned long samplerate;</div><div class="line"></div><div class="line">    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */</div><div class="line">    unsigned char sbr;</div><div class="line"></div><div class="line">    /* MPEG-4 ObjectType */</div><div class="line">    unsigned char object_type;</div><div class="line"></div><div class="line">    /* AAC header type; MP4 will be signalled as RAW also */</div><div class="line">    unsigned char header_type;</div><div class="line"></div><div class="line">    /* multichannel configuration */</div><div class="line">    unsigned char num_front_channels;</div><div class="line">    unsigned char num_side_channels;</div><div class="line">    unsigned char num_back_channels;</div><div class="line">    unsigned char num_lfe_channels;</div><div class="line">    unsigned char channel_position[64];</div><div class="line"></div><div class="line">    /* PS: 0: off, 1: on */</div><div class="line">    unsigned char ps;</div><div class="line">&#125; NeAACDecFrameInfo;</div></pre></td></tr></table></figure>
<p>具体的解码实现, 我放到了 Github 上面了, 大家可以去 <a href="https://github.com/veryitman/faacfaad2" target="_blank" rel="noopener">这里</a> 查看.</p>
<h2 id="麻烦"><a href="#麻烦" class="headerlink" title="麻烦"></a>麻烦</h2><blockquote>
<p>解码 aac, 解决采样频率和通道数不对的问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//防止采样频率加倍</div><div class="line">NeAACDecConfigurationPtr conf = NeAACDecGetCurrentConfiguration(decoder);</div><div class="line">conf-&gt;dontUpSampleImplicitSBR = 1;</div><div class="line">NeAACDecSetConfiguration(decoder, conf);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//从双声道的数据中提取单通道  </div><div class="line">for(i=0,j=0; i&lt;4096 &amp;&amp; j&lt;2048; i+=4, j+=2) &#123;</div><div class="line"></div><div class="line">	frame_mono[j]=pcm_data[i];</div><div class="line">	frame_mono[j+1]=pcm_data[i+1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体可以查阅 FAAD2 的源码. 感谢 <a href="http://blog.csdn.net/machh/article/details/47153111" target="_blank" rel="noopener">使用FAAD库解码AAC实例及 及 faad解码后的通道数不正确的问题</a> 提供.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频 wav pcm faad2 aac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[音视频编程: 简单分析 WAV 文件]]></title>
      <url>/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>这篇分享是下篇 <a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> 的预备知识, 如果要解码 WAV 文件, 首先需要了解一下 WAV 音频文件的格式.</p>
<p>今天说的是 <code>线性 PCM</code> 对应的 WAV 格式的数据.</p>
<blockquote>
<p>PCM 的种类</p>
</blockquote>
<ul>
<li>线性化 PCM</li>
<li>A律量化的 PCM</li>
<li>U律量化的 PCM</li>
<li>AD PCM</li>
<li>GSM</li>
</ul>
<p><strong>该系列博文:</strong></p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/" target="_blank" rel="noopener">音视频编程: 编译 faac/faad2</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">音视频编程: iOS 使用 faac 编码</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a>(本篇)</p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> </p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a></p>
</li>
</ul>
<h2 id="WAV-简介"><a href="#WAV-简介" class="headerlink" title="WAV 简介"></a>WAV 简介</h2><p>WAV 只是该音频文件的后缀名, 其完整名称缩写是 WAVE.</p>
<p>WAVE(Waveform Audio File Format), 采用RIFF（Resource Interchange File Format）文件格式结构.</p>
<p>WAV 格式的音频文件通常用来保存 PCM 格式的原始音频数据，通常被称之为无损音频. </p>
<p>WAV 音频文件, 粗略来说是 WAV 数据头 + PCM 数据组成的. 裸数据 PCM 外面包了一层文件头，WAV 实质为一个 <a href="http://www.cnblogs.com/wangguchangqing/p/5957531.html" target="_blank" rel="noopener">RIFF 文件</a>.</p>
<h2 id="WAV-数据头"><a href="#WAV-数据头" class="headerlink" title="WAV 数据头"></a>WAV 数据头</h2><p>关于 WAV 音频文件的数据头定义如下图所示:</p>
<p><img src="/upload/images/2018/02/20/1.jpg" alt="1"></p>
<p>最前面的4个字节用来标示是 RIFF 字符串.</p>
<p>可以看出, 一般的 WAV 文件的数据头为 44 个字节, 其后面跟的是 PCM 数据.</p>
<h2 id="分析-WAV-数据头"><a href="#分析-WAV-数据头" class="headerlink" title="分析 WAV 数据头"></a>分析 WAV 数据头</h2><p>使用 hexdump 来看一下 WAV 文件的数据头.</p>
<p>在当前路径下, 有个 wav 格式的音频文件 <code>m.wav</code>, 使用 hexdump 分析一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexdump -n 44 m.wav</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/02/20/2.jpg" alt="2"></p>
<p>其中, <code>-n 44</code> 表示查看前 44 个字节.</p>
<p>按字节分组的图, 如下所示:<br><img src="/upload/images/2018/02/20/3.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">52 49 46 46</div></pre></td></tr></table></figure>
<p>分别是 RIFF 的 ASCII 码.</p>
<p>跟在 RIFF 后面的四个字节是文件的大小信息, 我们先使用 <code>ls</code> 命令看一下该文件的大小.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al</div></pre></td></tr></table></figure>
<p>输出文件大小为(字节数): 1080808</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">staff  1080808 Jan 25 15:44 m.wav</div></pre></td></tr></table></figure>
<p>RIFF 后面的四个字节分别是: e0 7d 10 00, 由于该存储使用了小端序(Little-Endian 存储，也就是说对其中的数据，低位字节在前，高位字节在后), 所以16进制表示为: 0x00107de0, 对应的字节大小是 <code>1080808</code>.</p>
<p>上面说到, 线性 PCM, 其实在该文件头中, 第17到第第22个字节(上图红色的5和6组合)标示了 PCM 的类型, 即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 00 00 00 01 00</div></pre></td></tr></table></figure>
<p>其他类型的 PCM 类型定义为:</p>
<blockquote>
<p>A律量化的PCM: 12 00 00 0006 00<br>U律量化的PCM: 12 00 00 00 07 00<br>AD PCM: 32 00 00 00 02 00<br>GSM: 14 00 00 00 31 00</p>
</blockquote>
<p>最后4个字节表示真正 PCM 数据的文件大小, 即: 0x00107dbc, 其10进制大小为: 1080764, 用总文件大小减去 1080764, 就是文件头的大小, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1080808 - 1080764 = 44</div></pre></td></tr></table></figure>
<p>其他对应的数据, 大家可以对照表自行分析.</p>
<h2 id="定义数据头"><a href="#定义数据头" class="headerlink" title="定义数据头"></a>定义数据头</h2><blockquote>
<p>数据类型</p>
</blockquote>
<ul>
<li>char 占用 1 个字节</li>
<li>uint32_t 占用 4 个字节</li>
<li>uint16_t 占用 2 个字节</li>
</ul>
<p>这里使用结构体定义 WAV 文件头, 其定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct MZWavAudioFileHeader</div><div class="line">&#123;</div><div class="line">    char       riff[4];       // 字符串 &quot;RIFF&quot;</div><div class="line">    uint32_t   totalLength; // 文件总大小, 包括PCM 数据大小和该文件头大小</div><div class="line">    char       wave[4];     // 字符串 &quot;WAVE&quot;</div><div class="line">    char       fmt[4];      // 字符串 &quot;fmt &quot;</div><div class="line">    uint32_t   format;      // WAV 头大小, 固定为值 16</div><div class="line">    uint16_t   pcm;         // PCM 编码方式, 固定值为 1</div><div class="line">    uint16_t   channels;    // 声道数量, 为 2</div><div class="line">    uint32_t   frequency;   // 采样频率</div><div class="line">    uint32_t   bytes_per_second; // 每秒字节数(码率), 其值=采样率x通道数x位深度/8</div><div class="line">    uint16_t   bytes_by_capture; // 采样块大小</div><div class="line">    uint16_t   bits_per_sample; // 采样点大小, 这里是 16 位</div><div class="line">    char       data[4];         // 字符串 &quot;data&quot;</div><div class="line">    uint32_t   bytes_in_pcmdata;  // pcm 数据长度</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以使用下面代码来计算该结构体所占的字节数(结果是44):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int wav_header_size = sizeof(struct MZWavAudioFileHeader);</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频 wav pcm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[音视频编程: iOS 使用 faac 编码]]></title>
      <url>/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文分享如何将 WAV 格式的音频文件转换(编码)为 AAC 格式的音频文件并使用 AVAudioPlayer 播放编码后的文件. </p>
<p>这里的编码功能使用 faac 这个库来实现.</p>
<p><strong>该系列博文:</strong></p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/" target="_blank" rel="noopener">音视频编程: 编译 faac/faad2</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">音视频编程: iOS 使用 faac 编码</a>(本篇)</p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> </p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a></p>
</li>
</ul>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><blockquote>
<p>获取 faac 的版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int FAACAPI faacEncGetVersion(char **faac_id_string, char **faac_copyright_string);</div></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">char *version;</div><div class="line">char *copyright;</div><div class="line">faacEncGetVersion(&amp;version, &amp;copyright);</div><div class="line">printf(&quot;FAAC version: %s, copyright: %s&quot;, version, copyright);</div></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FAAC version: 1.28, copyright: FAAC - Freeware Advanced Audio Coder (http://www.audiocoding.com/)</div><div class="line">Copyright (C) 1999,2000,2001  Menno Bakker</div><div class="line">Copyright (C) 2002,2003  Krzysztof Nikiel</div><div class="line">This software is based on the ISO MPEG-4 reference source code.</div></pre></td></tr></table></figure>
<blockquote>
<p>打开并初始化 faac 编码器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// sampleRate: 采样率</div><div class="line">// numChannels: 通道数量，1-单声道 2-立体声</div><div class="line">// inputSamples: 编码后的数据长度</div><div class="line">// maxOutputBytes: 编码后的信息最大长度</div><div class="line">faacEncHandle FAACAPI faacEncOpen(unsigned long sampleRate,</div><div class="line">				  unsigned int numChannels,</div><div class="line">				  unsigned long *inputSamples,</div><div class="line">				  unsigned long *maxOutputBytes);</div></pre></td></tr></table></figure>
<p>该函数返回一个 faac 编码器句柄. 其很多函数都需要这个句柄.</p>
<blockquote>
<p>关闭 faac 编码器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int FAACAPI faacEncClose(faacEncHandle hEncoder);</div></pre></td></tr></table></figure>
<p>将开启 faac 编码器返回的句柄传入即可.</p>
<blockquote>
<p>获取配置和设置配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">faacEncConfigurationPtr FAACAPI</div><div class="line">  faacEncGetCurrentConfiguration(faacEncHandle hEncoder);</div><div class="line"></div><div class="line"></div><div class="line">int FAACAPI faacEncSetConfiguration(faacEncHandle hEncoder,</div><div class="line">				    faacEncConfigurationPtr config);</div></pre></td></tr></table></figure>
<p>faac 的配置被定义为了一个结构体 faacEncConfiguration, 大家可以看源码.</p>
<blockquote>
<p>编码(编码一帧音频数据)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//	hEncoder: faacEncOpen 返回的编码器句柄</div><div class="line">//	inputBuffer: 输入信息缓冲区</div><div class="line">//	samplesInput: faacEncOpen编码后的数据长度，即缓冲区长度</div><div class="line">//	outputBuffer: 编码后输出信息缓冲区</div><div class="line">//	bufferSize: 输出信息长度</div><div class="line">int FAACAPI faacEncEncode(faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput,</div><div class="line">			 unsigned char *outputBuffer,</div><div class="line">			 unsigned int bufferSize);</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以自己新建一个 iOS 工程.</p>
<p>准备好一个 <code>wav</code> 格式的音频文件.</p>
<p>效果如下图所示:<br><img src="/upload/images/2018/02/16/1.jpg" alt="1"></p>
<p>新建一个 C++ 文件, MZCodec.</p>
<blockquote>
<p>MZCodec.hpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#ifndef MZCodec_hpp</div><div class="line">#define MZCodec_hpp</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int codeWAV(const char *srcFilePath,  const char *destPath);</div><div class="line"></div><div class="line">#endif /* MZCodec_hpp */</div></pre></td></tr></table></figure>
<blockquote>
<p>MZCodec.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">#include &quot;MZCodec.hpp&quot;</div><div class="line"></div><div class="line">#include &quot;faac.h&quot;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int codeWAV(const char *srcFilePath,  const char *destPath) &#123;</div><div class="line">    </div><div class="line">    unsigned long nSampleRate   = 44100;//采样率</div><div class="line">    unsigned int nChannels      = 2;//声道数</div><div class="line">    unsigned int nPCMBitSize    = 16;//单样本位数</div><div class="line">    </div><div class="line">    unsigned long nInputSamples   = 0;</div><div class="line">    unsigned long nMaxOutputBytes = 0;</div><div class="line">    </div><div class="line">    int nRet;</div><div class="line">    faacEncHandle hEncoder;</div><div class="line">    faacEncConfigurationPtr pConfiguration;</div><div class="line">    </div><div class="line">    size_t nBytesRead;</div><div class="line">    unsigned long nPCMBufferSize;</div><div class="line">    unsigned char *pbPCMBuffer;</div><div class="line">    unsigned char *pbAACBuffer;</div><div class="line">    </div><div class="line">    FILE *fpIn; // WAV file for input</div><div class="line">    FILE *fpOut; // AAC file for output</div><div class="line">    </div><div class="line">    /// 获取 faac 版本信息</div><div class="line">    &#123;</div><div class="line">        char *version;</div><div class="line">        char *copyright;</div><div class="line">        faacEncGetVersion(&amp;version, &amp;copyright);</div><div class="line">        printf(&quot;FAAC version: %s, copyright: %s&quot;, version, copyright);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fpIn = fopen(srcFilePath, &quot;rb&quot;);</div><div class="line">    </div><div class="line">    if (NULL == fpIn) &#123;</div><div class="line">        return -2;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fpOut = fopen(destPath, &quot;wb&quot;);</div><div class="line">    </div><div class="line">    /// 1. 打开 FAAC</div><div class="line">    hEncoder = faacEncOpen(nSampleRate, nChannels, &amp;nInputSamples, &amp;nMaxOutputBytes);</div><div class="line">    </div><div class="line">    if (NULL == hEncoder) &#123;</div><div class="line">        </div><div class="line">        printf(&quot;[ERROR] Failed to call faacEncOpen()\n&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    nPCMBufferSize = nInputSamples * nPCMBitSize / 8;</div><div class="line">    pbPCMBuffer = new unsigned char[nPCMBufferSize];</div><div class="line">    pbAACBuffer = new unsigned char[nMaxOutputBytes];</div><div class="line">    </div><div class="line">    /// 2.1. 获取当前的编码器配置</div><div class="line">    pConfiguration = faacEncGetCurrentConfiguration(hEncoder);</div><div class="line">    </div><div class="line">    pConfiguration-&gt;inputFormat = FAAC_INPUT_16BIT;</div><div class="line">    // 对象类型只有为 LOW, iOS 的 AVAudioPlayer 才能播放</div><div class="line">    pConfiguration-&gt;aacObjectType = LOW;</div><div class="line">    // 0 = Raw; 1 = ADTS</div><div class="line">    pConfiguration-&gt;outputFormat = 1;</div><div class="line">    pConfiguration-&gt;mpegVersion = MPEG4;</div><div class="line">    pConfiguration-&gt;useTns = 1;</div><div class="line">    pConfiguration-&gt;bitRate = 30;</div><div class="line">    </div><div class="line">    /// 2.2. 配置编码器</div><div class="line">    nRet = faacEncSetConfiguration(hEncoder, pConfiguration);</div><div class="line">    </div><div class="line">    //是wav格式, 先读取前面的</div><div class="line">    fseek(fpIn, 58, SEEK_SET);</div><div class="line">    </div><div class="line">    do &#123;</div><div class="line">        </div><div class="line">        //读入的实际字节数，最大不会超过 nPCMBufferSize</div><div class="line">        nBytesRead = fread(pbPCMBuffer, 1, nPCMBufferSize, fpIn);</div><div class="line">        </div><div class="line">        //输入样本数，用实际读入字节数计算</div><div class="line">        //一般只有读到文件尾时才不是 nPCMBufferSize/(nPCMBitSize/8)</div><div class="line">        nInputSamples = nBytesRead / (nPCMBitSize / 8);</div><div class="line">        </div><div class="line">        /// 3. 编码</div><div class="line">        nRet = faacEncEncode(hEncoder,</div><div class="line">                             (int *)pbPCMBuffer,</div><div class="line">                             (unsigned int)nInputSamples,</div><div class="line">                             pbAACBuffer,</div><div class="line">                             (unsigned int)nMaxOutputBytes);</div><div class="line">        </div><div class="line">        fwrite(pbAACBuffer, 1, nRet, fpOut);</div><div class="line">        </div><div class="line">        printf(&quot;FaacEncEncode returns %d\n&quot;, nRet);</div><div class="line">    &#125; while (nBytesRead &gt; 0);</div><div class="line">    </div><div class="line">    /// 4. 关闭 FAAC</div><div class="line">    nRet = faacEncClose(hEncoder);</div><div class="line">    </div><div class="line">    delete[] pbPCMBuffer;</div><div class="line">    delete[] pbAACBuffer;</div><div class="line">    </div><div class="line">    fclose(fpIn);</div><div class="line">    fclose(fpOut);</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 MZCodec 的 Controller 需要命名为 <code>.mm</code> 文件.</p>
<blockquote>
<p>ViewController.mm</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSBundle *bundle = [NSBundle mainBundle];</div><div class="line">NSString *resPath = [bundle pathForResource:@&quot;m&quot; ofType:@&quot;wav&quot;];</div><div class="line">NSLog(@&quot;The path of wav file: %@&quot;, resPath);</div><div class="line">    </div><div class="line">NSArray&lt;NSString *&gt; *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</div><div class="line">NSString *destPath = [[docPath lastObject] stringByAppendingString:@&quot;/out.aac&quot;];</div><div class="line">NSLog(@&quot;The path of aac file: %@&quot;, destPath);</div><div class="line">    </div><div class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    </div><div class="line">    codeWAV([resPath UTF8String], [destPath UTF8String]);</div><div class="line">    </div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">		//转换完成.</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>编码过程需要点时间, 如果文件很大, 时间越久. 所以, 新开线程来进行编码.</p>
<p>编码完成后, 可在对应的沙盒目录找到 <code>out.aac</code> 文件.</p>
<p>具体代码在 <a href="https://github.com/veryitman/faacfaad2/tree/master/MZAudioCodec" target="_blank" rel="noopener">Github</a> 上面, 感兴趣的可以点击 <a href="https://github.com/veryitman/faacfaad2/tree/master/MZAudioCodec" target="_blank" rel="noopener">前往</a>.</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>这个 <code>aacObjectType</code> 需要注意, 之前我在这里折腾了很久.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pConfiguration-&gt;aacObjectType = LOW;</div></pre></td></tr></table></figure>
<p>如果设置为其他三种, 编码后的 aac 文件, AVAudioPlayer 播放不了, 初始化 AVAudioPlayer 就会报错, 报错信息如下:</p>
<p><img src="/upload/images/2018/02/16/2.jpg" alt="1"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频 faac faad2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[音视频编程: 编译 faac/faad2]]></title>
      <url>/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/</url>
      <content type="html"><![CDATA[<p>本文分享如何在 MacOS 上面编译 faac 和 faad2, 编译后的库文件可以直接在 iOS 上面使用.</p>
<p>后续会分享如何编译给 Android 使用的库文件的方法以及实战.</p>
<p><strong>该系列博文:</strong></p>
<ul>
<li><p><a href="http://www.veryitman.com/2018/02/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-faac-faad2/" target="_blank" rel="noopener">音视频编程: 编译 faac/faad2</a>(本篇)</p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/16/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faac-%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">音视频编程: iOS 使用 faac 编码</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">音视频编程: 简单分析 WAV 文件</a></p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-iOS-%E4%BD%BF%E7%94%A8-faad2/" target="_blank" rel="noopener">音视频编程: iOS 使用 faad2</a> </p>
</li>
<li><p><a href="http://www.veryitman.com/2018/02/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E6%9E%84%E5%BB%BA-nginx-%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">音视频编程: 构建 nginx 推流服务器</a></p>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>faad</code> 是 AAC 格式文件的音频解码库. 相对于 FFmpeg 来说比较轻量和简单. 编译出来全平台静态库文件较小, API 也比较简单, 缺点是功能单一, 只能处理 AAC 格式的音频文件.</p>
<p><code>faac</code> 是与之对应的 AAC 音频编码库. 支持 MPEG-4 和 MPEG-2 的AAC 编码，其特性包括：可移植性好，快速，支持LC/Main/LTP，通过 Dream 支持 DRM.</p>
<p>这两个库虽然很久没有更新了, 但是其功能已经满足很多业务场景了, 并且很好用.</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>点击 <a href="http://www.audiocoding.com/downloads.html" target="_blank" rel="noopener">源码链接</a> 即可下载源码.</p>
<p><img src="/upload/images/2018/02/14/1.jpg" alt="1"></p>
<h2 id="编译-faac"><a href="#编译-faac" class="headerlink" title="编译 faac"></a>编译 faac</h2><p>下载完成后, 解压, 将 <code>faac-1.28</code> 放到新建目录  <code>src</code> 下面即可, 目录结构如下:<br><img src="/upload/images/2018/02/14/2.jpg" alt="1"></p>
<p>修改 <code>build_faac.sh</code> 权限:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x build_faac.sh</div></pre></td></tr></table></figure>
<p>编辑 <code>build_faac.sh</code> 内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh  </div><div class="line">  </div><div class="line"># http://www.linuxfromscratch.org/blfs/view/svn/multimedia/faac.html  </div><div class="line"># ftp://mirror.ovh.net/gentoo-distfiles/distfiles/  </div><div class="line">  </div><div class="line">major=1  </div><div class="line">minor=28  </div><div class="line">micro=  </div><div class="line"></div><div class="line">XCD_ROOT=&quot;/Applications/Xcode.app/Contents/Developer&quot;  </div><div class="line">TOL_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain&quot;  </div><div class="line">#修改为最新的 sdk 版本</div><div class="line">SDK_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.2.sdk&quot;  </div><div class="line">SDK_SML_ROOT=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk&quot;  </div><div class="line"></div><div class="line">export PATH=$TOL_ROOT/usr/bin:$PATH  </div><div class="line">  </div><div class="line">work=`pwd`  </div><div class="line">srcs=$work/src  </div><div class="line">buid=$work/build  </div><div class="line">insl=$buid/install  </div><div class="line">name=faac-$&#123;major&#125;.$&#123;minor&#125;  </div><div class="line">pakt=$&#123;name&#125;.tar.gz  </div><div class="line">dest=$work/faac-iOS-$&#123;major&#125;.$&#123;minor&#125;.$&#123;micro&#125;.tgz  </div><div class="line">  </div><div class="line">rm -rf $srcs $buid $dest &amp;&amp; mkdir -p $srcs $buid  </div><div class="line"></div><div class="line"> </div><div class="line">archs=&quot;i386 x86_64 armv7 armv7s arm64&quot;  </div><div class="line">  </div><div class="line">for a in $archs; do  </div><div class="line">  case $a in  </div><div class="line">    arm*)  </div><div class="line">      sys_root=$&#123;SDK_ROOT&#125;  </div><div class="line">      host=arm-apple-darwin</div><div class="line">      ;;  </div><div class="line">    i386|x86_64)  </div><div class="line">      sys_root=$&#123;SDK_SML_ROOT&#125;  </div><div class="line">      host=$a-apple-darwin</div><div class="line">      ;;  </div><div class="line">  esac  </div><div class="line">  prefix=$insl/$a &amp;&amp; rm -rf $prefix &amp;&amp; mkdir -p $prefix  </div><div class="line">  rm -rf $srcs &amp;&amp; mkdir -p $srcs &amp;&amp; cd $work &amp;&amp; tar xvzf $pakt -C $srcs &amp;&amp; cd $srcs/$name  </div><div class="line"></div><div class="line">  </div><div class="line">  export CC=&quot;$TOL_ROOT/usr/bin/clang -arch $a -isysroot $sys_root&quot;</div><div class="line">  export CXX=&quot;$TOL_ROOT/usr/bin/clang++ -arch $a -isysroot $sys_root&quot;</div><div class="line">  export CXXFLAGS=&quot;-arch $a -isysroot $sys_root&quot;</div><div class="line">  export CFLAGS=&quot;-arch $a -isysroot $sys_root&quot;</div><div class="line">  export LDFLAGS=&quot;-isysroot $sys_root&quot;</div><div class="line">  export LIBS=&quot;-L$&#123;sys_root&#125;/usr/lib&quot;</div><div class="line"></div><div class="line">  chmod +x bootstrap  </div><div class="line">  ./bootstrap \</div><div class="line">    &amp;&amp;./configure \</div><div class="line">    --host=$host \</div><div class="line">    --with-sysroot=$sys_root \</div><div class="line">    --prefix=$prefix \</div><div class="line">    --disable-shared \</div><div class="line">    --enable-static \</div><div class="line">    --disable-faac \</div><div class="line">    --with-mp4v2 \</div><div class="line">    &amp;&amp;make &amp;&amp; make install</div><div class="line">  lipo_archs=&quot;$lipo_archs $prefix/lib/libfaac.a&quot;</div><div class="line"></div><div class="line">  echo &apos;continue any key pressed..&apos;</div><div class="line">  read -n 1</div><div class="line">done</div><div class="line">  </div><div class="line">univ=$insl/universal &amp;&amp; mkdir -p $univ/lib  </div><div class="line">cp -r $prefix/include $univ/  </div><div class="line">lipo $lipo_archs -create -output $univ/lib/libfaac.a  </div><div class="line">ranlib $univ/lib/libfaac.a  </div><div class="line">strip -S $univ/lib/libfaac.a  </div><div class="line">  </div><div class="line">cd $univ &amp;&amp; tar cvzf $dest *</div></pre></td></tr></table></figure>
<p>执行 <code>./build_faac.sh</code>, 开始编译.</p>
<p>编译成功后, 生成 build 目录.<br><img src="/upload/images/2018/02/14/3.jpg" alt="1"></p>
<p>其中, universal 生成的库是通用库.</p>
<h2 id="编译-faad2"><a href="#编译-faad2" class="headerlink" title="编译 faad2"></a>编译 faad2</h2><p>解压后, 将 <code>faad2-2.7</code> 改名为 <code>faad</code>.</p>
<p>编写编译的脚本文件, 这里取名为 <code>build_fadd2.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch build_fadd2.sh</div></pre></td></tr></table></figure>
<p>编辑 <code>build_fadd2.sh</code> 文件.</p>
<p>写入如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">CONFIGURE_FLAGS=&quot;--enable-static --with-pic&quot;</div><div class="line"></div><div class="line">ARCHS=&quot;arm64 armv7s armv7 x86_64 i386&quot;</div><div class="line"></div><div class="line"># directories</div><div class="line">SOURCE=&quot;faad&quot;</div><div class="line">FAT=&quot;fat-faad&quot;</div><div class="line"></div><div class="line">SCRATCH=&quot;scratch-faad&quot;</div><div class="line"># must be an absolute path</div><div class="line">THIN=`pwd`/&quot;thin-faad&quot;</div><div class="line"></div><div class="line">COMPILE=&quot;y&quot;</div><div class="line">LIPO=&quot;y&quot;</div><div class="line"></div><div class="line">if [ &quot;$*&quot; ]</div><div class="line">then</div><div class="line">if [ &quot;$*&quot; = &quot;lipo&quot; ]</div><div class="line">then</div><div class="line"># skip compile</div><div class="line">COMPILE=</div><div class="line">else</div><div class="line">ARCHS=&quot;$*&quot;</div><div class="line">if [ $# -eq 1 ]</div><div class="line">then</div><div class="line"># skip lipo</div><div class="line">LIPO=</div><div class="line">fi</div><div class="line">fi</div><div class="line">fi</div><div class="line"></div><div class="line">if [ &quot;$COMPILE&quot; ]</div><div class="line">then</div><div class="line">CWD=`pwd`</div><div class="line">for ARCH in $ARCHS</div><div class="line">do</div><div class="line">echo &quot;building $ARCH...&quot;</div><div class="line">mkdir -p &quot;$SCRATCH/$ARCH&quot;</div><div class="line">cd &quot;$SCRATCH/$ARCH&quot;</div><div class="line"></div><div class="line">if [ &quot;$ARCH&quot; = &quot;i386&quot; -o &quot;$ARCH&quot; = &quot;x86_64&quot; ]</div><div class="line">then</div><div class="line">PLATFORM=&quot;iPhoneSimulator&quot;</div><div class="line">CPU=</div><div class="line">if [ &quot;$ARCH&quot; = &quot;x86_64&quot; ]</div><div class="line">then</div><div class="line">SIMULATOR=&quot;-mios-simulator-version-min=7.0&quot;</div><div class="line">HOST=&quot;--host=x86_64-apple-darwin&quot;</div><div class="line">else</div><div class="line">SIMULATOR=&quot;-mios-simulator-version-min=5.0&quot;</div><div class="line">HOST=&quot;--host=i386-apple-darwin&quot;</div><div class="line">fi</div><div class="line">else</div><div class="line">PLATFORM=&quot;iPhoneOS&quot;</div><div class="line">if [ $ARCH = &quot;armv7s&quot; ]</div><div class="line">then</div><div class="line">CPU=&quot;--cpu=swift&quot;</div><div class="line">else</div><div class="line">CPU=</div><div class="line">fi</div><div class="line">SIMULATOR=</div><div class="line">HOST=&quot;--host=arm-apple-darwin&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">XCRUN_SDK=`echo $PLATFORM | tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;`</div><div class="line">CC=&quot;xcrun -sdk $XCRUN_SDK clang -Wno-error=unused-command-line-argument-hard-error-in-future&quot;</div><div class="line">AS=&quot;$CWD/$SOURCE/extras/gas-preprocessor.pl $CC&quot;</div><div class="line">CFLAGS=&quot;-arch $ARCH $SIMULATOR&quot;</div><div class="line">CXXFLAGS=&quot;$CFLAGS&quot;</div><div class="line">LDFLAGS=&quot;$CFLAGS&quot;</div><div class="line"></div><div class="line">CC=$CC CFLAGS=$CXXFLAGS LDFLAGS=$LDFLAGS CPPFLAGS=$CXXFLAGS CXX=$CC CXXFLAGS=$CXXFLAGS  $CWD/$SOURCE/configure \</div><div class="line">$CONFIGURE_FLAGS \</div><div class="line">$HOST \</div><div class="line">--prefix=&quot;$THIN/$ARCH&quot; \</div><div class="line">--disable-shared \</div><div class="line">--without-mp4v2</div><div class="line"></div><div class="line">make clean &amp;&amp; make &amp;&amp; make install-strip</div><div class="line">cd $CWD</div><div class="line">done</div><div class="line">fi</div><div class="line"></div><div class="line">if [ &quot;$LIPO&quot; ]</div><div class="line">then</div><div class="line">echo &quot;building fat binaries...&quot;</div><div class="line">mkdir -p $FAT/lib</div><div class="line">set - $ARCHS</div><div class="line">CWD=`pwd`</div><div class="line">cd $THIN/$1/lib</div><div class="line">for LIB in *.a</div><div class="line">do</div><div class="line">cd $CWD</div><div class="line">lipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIB</div><div class="line">done</div><div class="line"></div><div class="line">cd $CWD</div><div class="line">cp -rf $THIN/$1/include $FAT</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>给予执行权限:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x build_fadd2.sh</div></pre></td></tr></table></figure>
<p>此时目录结构如下:<br><img src="/upload/images/2018/02/14/4.jpg" alt="1"></p>
<p>执行编译脚本, 在当前目录生成 <code>scratch-faad</code> 和 <code>fat-faad</code> 以及 <code>thin-faad</code> 目录, 如下:<br><img src="/upload/images/2018/02/14/5.jpg" alt="1"></p>
<p>使用 <code>fat-faad</code> 里面的库和文件即可.</p>
<p>可以使用下面的命令查看对应的 <code>.a</code> 文件所支持的架构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo -info libfaad.a</div></pre></td></tr></table></figure>
<p>会得到对应的输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Architectures in the fat file: libfaad.a are: i386 armv7 armv7s arm64</div></pre></td></tr></table></figure>
<p>同样可以查看 <code>libfaac.a</code>.</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>编译好的文件, 已经放到 github 上面了, 有需要的可以下载使用, 点击 <a href="https://github.com/veryitman/faacfaad2" target="_blank" rel="noopener">下载链接</a> 进入.</p>
<p>感谢 <a href="https://github.com/fflydev/faac-ios-build" target="_blank" rel="noopener">fflydev/faac-ios-build</a> 提供编译 <code>faac</code> 的 shell, 只需要将里面对应的 SDK 改为本机最新的 SDK 即可.</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="http://www.voidcn.com/article/p-ftajkybd-p.html" target="_blank" rel="noopener">faac 1.28的交叉编译与问题解决</a></p>
</li>
<li><p><a href="http://blog.csdn.net/coloriy/article/details/52053144" target="_blank" rel="noopener">使用FAAD库解码AAC实例</a></p>
</li>
<li><p><a href="https://magiclen.org/linux-fdk-aac-2/" target="_blank" rel="noopener">在Linux上使用FDK AAC將音樂轉成M4A(AAC、HE-AAC、HE-AACv2)格式</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/45928cdafde0" target="_blank" rel="noopener">aac文件转码为wav文件</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 音视频 faac faad2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 多线程: 初步认识]]></title>
      <url>/2018/02/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>几乎每个编程语言或者平台都会遇到多线程的问题, 说明多线程是一个非常重要且开发者必须了解和掌握的.</p>
<p>多线程也是面试官比较喜欢问的问题, 例如:</p>
<ul>
<li>进程和线程的区别, Android 是否支持多进程?</li>
<li>线程池如何实现的?</li>
<li>锁机制?</li>
<li>多线程之间如何通信?</li>
</ul>
<p>谈及 iOS 中的多线程，一般说的是 pthread，NSthread，GCD，NSOperation 这四种, 用的最多也最方便的就是 GCD 了. 关于这四者, 后续会为大家一一分享.</p>
<p>phtread 是跨平台的, C/C++ 中都有它的声影, GCD 和 NSOperation 都是常用的，NSOperation 是基于 GCD 的. GCD 的核心概念是将一个任务添加到队列，指定任务执行的方法，然后执行, NSOperation 则是直接将一个操作添加到队列中.</p>
<p>该系列文章来跟大家分享关于 iOS 中的多线程.</p>
<ul>
<li>iOS 多线程: 初步认识(本篇)</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程和线程的定义, 大家可以自行到维基百科上面去查.</p>
<p>这里只说二者的区别.</p>
<ul>
<li><p>一个程序至少有一个进程, 一个进程至少有一个线程如主线程.</p>
</li>
<li><p>多线程程序的并发性高.</p>
</li>
<li><p>进程在执行过程中拥有独立的内存单元，而多线程是共享内存的，从而极大地提高了程序的运行效率.</p>
</li>
<li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口. 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制.</p>
</li>
<li><p>操作系统并没有将多个线程看做多个独立的应用, 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行, 从而实现了进程的调度和管理以及资源分配.</p>
</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>iOS 中, 队列主要分为:</p>
<ul>
<li>全局队列</li>
<li>主队列.</li>
<li>串行队列.</li>
<li>并发队列.</li>
</ul>
<blockquote>
<ul>
<li><p>Concurrent:<br>tasks are dequeued in FIFO order, but run concurrently and can finish in any order.</p>
</li>
<li><p>Serial: .<br>tasks execute one at a time in FIFO order</p>
</li>
</ul>
</blockquote>
<p>并发: 任务以 FIFO 从序列中移除，然后并发运行，可以按照任何顺序完成.</p>
<p>串行: 任务以FIFO从序列中一个一个执行. 一次只调度一个任务.</p>
<p>在 iOS 中, 并发不一定会开启多个线程, 串行也不一定只开启一个线程. 因为这里会牵扯到是异步还是同步执行.</p>
<p>主队列, 即 mainQueue.</p>
<blockquote>
<p>Returns the default queue that is bound to the main thread.</p>
</blockquote>
<p>会关联主线程.</p>
<p>全局队列, 即 globalQueue.</p>
<blockquote>
<p>The well-known global concurrent queues may not be modified.</p>
</blockquote>
<p>全局队列中执行不一定会开启新线程.</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>在 iOS 的 GCD 中, 还有同步和异步执行的区别.</p>
<blockquote>
<p>同步</p>
</blockquote>
<p>同步执行代码块, 诸如 dispatch_async 中执行的.</p>
<blockquote>
<p>异步</p>
</blockquote>
<p>异步执行代码块, 诸如 dispatch_sync 中执行的.</p>
<h2 id="创建队列的方法"><a href="#创建队列的方法" class="headerlink" title="创建队列的方法"></a>创建队列的方法</h2><p><strong>创建主队列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dispatch_get_main_queue(void);</div></pre></td></tr></table></figure>
<p><strong>创建全局队列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);</div></pre></td></tr></table></figure>
<p>参数 identifier 用来表示优先级. 对应的优先级为:</p>
<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIG</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
</ul>
<p>如果传入 0 标示 DISPATCH_QUEUE_PRIORITY_DEFAULT.</p>
<p>参数 flags 是一个保留参数, API 文档要求传入 0, 非0值可能会导致返回结果为 NULL.</p>
<p><strong>自定义队列</strong></p>
<p>dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);</p>
<p>参数 label 是一个字符串.</p>
<p>参数 attr 用来标示是串行还是并行队列. 可以从 DISPATCH_QUEUE_SERIAL, DISPATCH_QUEUE_CONCURRENT 二者中取值.</p>
<p>如果该参数传入 NULL, 默认是 DISPATCH_QUEUE_SERIAL 串行队列.</p>
<h2 id="串行队列中的线程"><a href="#串行队列中的线程" class="headerlink" title="串行队列中的线程"></a>串行队列中的线程</h2><p>串行队列到底是开了一个线程, 还是开了多个线程, 我们一探究竟.</p>
<p>先看例子1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">for (int i=0; i&lt;10; i++) &#123;</div><div class="line">    </div><div class="line">    dispatch_async(serialQueue, ^&#123;</div><div class="line">        NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/02/12/1.jpg" alt="1"></p>
<p>可以看出, 只开启一个新线程.</p>
<p>再看例子2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);</div><div class="line">    sleep(2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/02/12/2.jpg" alt="1"></p>
<p>可以看出, 也只开启一个新线程.</p>
<p>改造一下例子2, 将其中的一个异步改为同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.veryitman&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);</div><div class="line">    sleep(2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL CurrentThread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/02/12/3.jpg" alt="1"></p>
<p>可以看出, 同步的执行在主线程, 二者并不是在一个线程中执行.</p>
<p>所以, 串行队列中执行的代码, 不一定都在子线程中, 如果是异步都是同一个线程中执行.如果是同步的话, 会在主线程中执行.</p>
<p><strong>同理, 并行队列中的异步执行会开启多个线程来执行.</strong></p>
<h2 id="执行方式和队列"><a href="#执行方式和队列" class="headerlink" title="执行方式和队列"></a>执行方式和队列</h2><p>这里的执行方式指的是同步或者异步执行.</p>
<p>先看异步执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/// 异步全局队列和主队列</div><div class="line">    &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            // 1</div><div class="line">            NSLog(@&quot;dispatch_async. mainQueue. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">            // 0</div><div class="line">            NSLog(@&quot;dispatch_async. globalQueue. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// 异步串行和并行队列</div><div class="line">    &#123;</div><div class="line">        dispatch_async(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</div><div class="line">            // 0</div><div class="line">            NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_SERIAL. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        dispatch_async(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123;</div><div class="line">            // 0</div><div class="line">            NSLog(@&quot;dispatch_async. DISPATCH_QUEUE_CONCURRENT. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/02/12/4.jpg" alt="1"></p>
<p>再看同步执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/// 同步全局队列和主队列</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    #if 0</div><div class="line">        // 会死锁</div><div class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">            NSLog(@&quot;dispatch_sync. mainQueue. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line">    #endif</div><div class="line"></div><div class="line">        dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">            // 1</div><div class="line">            NSLog(@&quot;dispatch_sync. globalQueue. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// 同步串行和并行队列</div><div class="line">    &#123;</div><div class="line">        dispatch_sync(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</div><div class="line">            // 1</div><div class="line">            NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_SERIAL. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        dispatch_sync(dispatch_queue_create(&quot;&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123;</div><div class="line">            // 1</div><div class="line">            NSLog(@&quot;dispatch_sync. DISPATCH_QUEUE_CONCURRENT. isMainThread: %i&quot;, [NSThread isMainThread]);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2018/02/12/5.jpg" alt="1"></p>
<blockquote>
<p>得出结论</p>
</blockquote>
<ul>
<li>任何队列的同步执行, 都没有开启新线程, 在主线程中执行.</li>
<li>主队列的同步执行会造成死锁.</li>
<li>主队列的异步执行, 没有开启新线程. 在主线程中执行.</li>
<li>串行和并行以及全局队列的异步执行, 都会开启新线程.</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://blog.csdn.net/robbyo/article/details/8549904" target="_blank" rel="noopener">进程和线程的区别</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS 多线程 进程 GCD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C/C++: 如何相互调用]]></title>
      <url>/2018/02/12/C-C-%E5%A6%82%E4%BD%95%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>C++ 中调用 C 比较简单. 但是 C 调用 C++ 稍微复杂一些.</p>
<p>C 调用 C++ 分为可以调用 C++ 类中的函数和普通 cpp 中的函数. 无论是哪种函数, 我们都可以使用封装了 C++ 的文件作为适配供给 C 来使用.</p>
<p>下面看具体的例子.</p>
<h2 id="C-调用-C"><a href="#C-调用-C" class="headerlink" title="C++ 调用 C"></a>C++ 调用 C</h2><p>首先创建 CFile.h 和 CFile.c 文件.</p>
<blockquote>
<p>CFile.h</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#ifndef CFile_h</div><div class="line">#define CFile_h</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">extern void start_c(int cmd);</div><div class="line"></div><div class="line">#endif /* CFile_h */</div></pre></td></tr></table></figure>
<blockquote>
<p>CFile.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &quot;CFile.h&quot;</div><div class="line"></div><div class="line">void start_c(int cmd) &#123;</div><div class="line">    </div><div class="line">    printf(&quot;start_c by cmd: %i\n&quot;, cmd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 C++ 文件中调用 C 代码, 示例如下:</p>
<blockquote>
<p>main.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#include &quot;CFile.h&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    </div><div class="line">    start_c(1);</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看到导入 C 文件的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#include &quot;CFile.h&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果直接导入, 如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &quot;CFile.h&quot;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    </div><div class="line">    start_c(1);</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Undefined symbols for architecture x86_64:</div><div class="line">  &quot;start_c(int)&quot;, referenced from:</div><div class="line">      _main in main.o</div><div class="line">ld: symbol(s) not found for architecture x86_64</div></pre></td></tr></table></figure>
<p>这里的 <code>extern &quot;C&quot;</code> 告诉编译器, 要按照 C 的链接约定，而不是 C++ 的链接约定.</p>
<p>C 编译器不支持 <code>extern &quot;C&quot;</code>.</p>
<h2 id="C-调用普通-C-的函数"><a href="#C-调用普通-C-的函数" class="headerlink" title="C 调用普通 C++ 的函数"></a>C 调用普通 C++ 的函数</h2><p>C 调用 C++ 有点曲折.</p>
<blockquote>
<p>CPPFile.hpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#ifndef CPPFile_hpp</div><div class="line">#define CPPFile_hpp</div><div class="line"></div><div class="line">void start_cpp(int cmd);</div><div class="line"></div><div class="line">#endif /* CPPFile_hpp */</div></pre></td></tr></table></figure>
<blockquote>
<p>CPPFile.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &quot;CPPFile.hpp&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void start_cpp(int cmd) &#123;</div><div class="line">    </div><div class="line">    cout &lt;&lt; &quot;start_cpp by cmd: &quot; &lt;&lt; cmd &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要写一个中间的 cpp(CPPAdapter.cpp)文件, 提供方法给 C 来使用.</p>
<p>注意: 这里没有 <code>CPPAdapter.hpp</code> 头文件.</p>
<blockquote>
<p>CPPAdapter.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &quot;CPPFile.hpp&quot;</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    void adapter_start_cpp(int cmd) &#123;</div><div class="line">        </div><div class="line">        //调用 CPPFile 中的方法</div><div class="line">        start_cpp(cmd);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>然后在 C 中调用 C++ 的代码:</p>
<blockquote>
<p>CFile.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &quot;CFile.h&quot;</div><div class="line"></div><div class="line">//声明函数</div><div class="line">extern void adapter_start_cpp(int cmd);</div><div class="line"></div><div class="line">void start_c(int cmd) &#123;</div><div class="line">        </div><div class="line">    //调用 c++ 代码</div><div class="line">    adapter_start_cpp(5);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-调用-C-类中的方法"><a href="#C-调用-C-类中的方法" class="headerlink" title="C 调用 C++ 类中的方法"></a>C 调用 C++ 类中的方法</h2><p>和上面例子的原理一样的.</p>
<blockquote>
<p>CPPClassFile.hpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#ifndef CPPClassFile_hpp</div><div class="line">#define CPPClassFile_hpp</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Person &#123;</div><div class="line">private:</div><div class="line">    string name;</div><div class="line">    </div><div class="line">public:</div><div class="line">    Person();</div><div class="line">    ~Person();</div><div class="line">    </div><div class="line">    int setName(string name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif /* CPPClassFile_hpp */</div></pre></td></tr></table></figure>
<blockquote>
<p>CPPClassFile.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &quot;CPPClassFile.hpp&quot;</div><div class="line"></div><div class="line">Person::Person() &#123;</div><div class="line">    </div><div class="line">    cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person::~Person() &#123;</div><div class="line">    </div><div class="line">    cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int Person::setName(string name) &#123;</div><div class="line">    </div><div class="line">    this-&gt;name = name;</div><div class="line">    </div><div class="line">    cout &lt;&lt; &quot;Set name: &quot; &lt;&lt; name &lt;&lt; endl;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>CPPAdapter.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &quot;CPPFile.hpp&quot;</div><div class="line">#include &quot;CPPClassFile.hpp&quot;</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot; &#123;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    void adapter_start_cpp(int cmd) &#123;</div><div class="line">        </div><div class="line">        //调用 CPPFile 中的方法</div><div class="line">        start_cpp(cmd);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int adapter_set_name(const char *cName) &#123;</div><div class="line">        </div><div class="line">        Person *person = new Person();</div><div class="line">        int ret = person-&gt;setName(cName);</div><div class="line">        delete person;</div><div class="line">        </div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>在 C 中可以调用了, 如下代码:</p>
<blockquote>
<p>CFile.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &quot;CFile.h&quot;</div><div class="line"></div><div class="line">///声明 CPPFile 中的方法</div><div class="line">extern void adapter_start_cpp(int cmd);</div><div class="line"></div><div class="line">///声明 CPPClassFile 中的方法</div><div class="line">extern int adapter_set_name(const char *cName);</div><div class="line"></div><div class="line">void start_c(int cmd) &#123;</div><div class="line">    </div><div class="line">    printf(&quot;start_c by cmd: %i\n&quot;, cmd);</div><div class="line">    </div><div class="line">    //调用 CPPFile 中的方法</div><div class="line">    adapter_start_cpp(5);</div><div class="line">    </div><div class="line">    //调用 CPPClassFile 中的方法</div><div class="line">    adapter_set_name(&quot;www.veryitman.com&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p><code>extern &quot;C&quot;</code> 中的 “C” 并不表示 C 语言，”C” 表示的是一种链接约定.</p>
<p><code>extern &quot;C&quot;</code> 指令描述的是一种链接约定，它并不影响调用函数的定义，即使做了该声明，对函数类型的检查和参数转换仍要遵循 C++ 的标准，而不是 C 的标准.</p>
<p>不同的编程语言(编译型)链接特性是不同的，这也决定了它们编译后的链接符号的不同.</p>
<p>如函数 <code>void function(int d)</code>，C 语言会把它编译成类似 <code>_function</code> 这样的符号，C 链接器只要找到该函数符号就可以链接成功.</p>
<p>C++ 会把这个函数编译成类似 <code>_function_int</code> 或 <code>_xxx_functionIntxxx</code> 这样的符号，即在符号上增加了类型信息，这也解释了为什么 C++ 可以实现函数重载了.</p>
<p>那么，对于用 C 编译器编译成的库，用 C++ 直接链接势必会出现不能识别符号的问题，用 <code>extern &quot;C&quot;</code> 就可以解决, 正如上面的例子.</p>
<p>简单来说, <code>extern &quot;C&quot;</code> 的作用就是让编译器知道要以 C 语言的方式编译和链接函数.</p>
<h2 id="cplusplus-宏"><a href="#cplusplus-宏" class="headerlink" title="__cplusplus 宏"></a>__cplusplus 宏</h2><p><code>__cplusplus</code> 宏是 C++ 编译器默认定义的.</p>
<p>类似如下的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">#endif</div><div class="line"></div><div class="line">void fun(int, size_t);</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>在 C++ 中, 编译器将 fun 按照 C 的链接约定来编译, 而如果是 C 编译器, 直接按照 C 的链接约定来编译即可.</p>
<p><code>__cplusplus</code> 是在 C++ 编译器中默认定义的,Ｃ语言不支持 <code>extern &quot;Ｃ&quot;</code>.</p>
<p>上面的代码很实用, 也是一种编程技巧.</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C C++ 编程语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS APNs: Background Fetch]]></title>
      <url>/2018/02/08/iOS-APNs-Background-Fetch/</url>
      <content type="html"><![CDATA[<p>在前面的几篇文章中, 给大家介绍了跟推送相关的内容.</p>
<p>今天跟大家聊一聊 iOS7 新加入的 <code>Background Fetch</code> 功能.</p>
<p>该系列博客:</p>
<blockquote>
<p><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 远程推送</a><br><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 本地推送</a><br><a href="http://www.veryitman.com/2017/08/07/iOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">iOS APNs: 处理数据</a><br><a href="http://www.veryitman.com/2018/02/06/iOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 静默推送</a><br>iOS APNs: Background Fetch(本篇)</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从 <code>Background Fetch</code> 字面上来看, 大致意思是可在后台获取数据.</p>
<p>在 iOS7 中，Apple 为开发者提供了可以在后台更新应用程序界面和内容的 API, 即 <code>Background Fetch</code>.</p>
<p>该特性允许开发者在一个周期间隔后进行特定的动作，如获取网络内容, 更新 UI 操作等.</p>
<p>同时在 iOS7 中, 也加入了另一个特性, 就是博文 <a href="http://www.veryitman.com/2018/02/06/iOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 静默推送</a> 里面说的静默推送.</p>
<p>这些都是对 iOS 后台多任务的补充和完善, Apple 一直在优化系统从而增强用户体验.</p>
<h2 id="开启-Background-Fetch"><a href="#开启-Background-Fetch" class="headerlink" title="开启 Background Fetch"></a>开启 Background Fetch</h2><p><strong>1.需要 APP 支持</strong></p>
<p>如下图所示, 勾选即可.</p>
<p><img src="/upload/images/2018/02/08/1.png" alt="1"></p>
<p><strong>2.设置 fetch 时间间隔</strong></p>
<p>在 AppDelegate 中设置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; </div><div class="line"></div><div class="line">	// 设置 fetch 时间间隔</div><div class="line">    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UIApplicationBackgroundFetchIntervalMinimum</code> 是系统自定义的时间. 如果不设置, 默认是 <code>UIApplicationBackgroundFetchIntervalNever</code>, 这样就不会让 <code>Background Fetch</code> 生效了.</p>
<p>可以查看对 UIApplicationBackgroundFetchIntervalNever 的官方解释.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIApplicationBackgroundFetchIntervalNever</div><div class="line"></div><div class="line">A fetch interval large enough to prevent fetch operations from occurring.</div></pre></td></tr></table></figure>
<p>当然, 你也可以设置自己定义的时间的间隔, 但是基本没有什么作用, 因为这个时间间隔完全由系统来决定, 系统会根据你的电量以及使用频率来决定.</p>
<p>所以, 可以理解为 <code>setMinimumBackgroundFetchInterval</code> 方法只是开启了 <code>Background Fetch</code> 功能.</p>
<p><strong>3.开启了系统后台更新功能</strong></p>
<p>在 iOS 系统中, 设置/通用/后台应用刷新中一定要开启对应 APP 的功能.</p>
<p>判断是否已经开启该功能的示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ([[UIApplication sharedApplication] backgroundRefreshStatus] != UIBackgroundRefreshStatusAvailable) &#123;</div><div class="line"></div><div class="line">	//不可用提示用户</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="处理回调"><a href="#处理回调" class="headerlink" title="处理回调"></a>处理回调</h2><p>在实际的应用环中，<code>Background Fetch</code> 事件是由系统管理的，我们开发者是无法预先知道 Fetch 事件达到的时机的. </p>
<p>网上很多说可以使用 Xcode 模拟这个事件, 估计也是之前的系统和 Xcode 版本, 现在的 Xcode9 貌似不行了.</p>
<p>但是, 你的手机在后台等几分钟, 有时候会被系统触发该事件, 触发后, 对应的系统回调(在 AppDelegate 中)会被调用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Background fetch 回调</div><div class="line">- (void)application:(UIApplication *)application</div><div class="line">performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;AppDelegate. Background fetch.&quot;);</div><div class="line">    </div><div class="line">    //可进行对应的耗时操作, 如下载等.</div><div class="line">    </div><div class="line">    completionHandler(UIBackgroundFetchResultNoData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Background Fetch</code> 会为我们的 App 争取更多的后台时间, 但是一般是几十秒左右, 不会太多. 所以, 不要在回调中做太多耗时的操作.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APNs 远程推送 BackgroundFetch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS APNs: 静默推送]]></title>
      <url>/2018/02/06/iOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81/</url>
      <content type="html"><![CDATA[<p>今天跟大家介绍一下 ios 的静默推送功能.</p>
<p>静默推送, 简单来说就是通过推送实现用户无感知的消息通知.</p>
<p>该系列博文:</p>
<blockquote>
<p><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 远程推送</a><br><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 本地推送</a><br><a href="http://www.veryitman.com/2017/08/07/iOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">iOS APNs: 处理数据</a><br>iOS APNs: 静默推送(本篇)</p>
</blockquote>
<h2 id="普通推送"><a href="#普通推送" class="headerlink" title="普通推送"></a>普通推送</h2><p>例如微信, 好友给你发送了一条消息, 你的微信APP 在后台, 此时会收到带声音的一个消息提示.</p>
<p>这条推送机油有文字又有声音, 点开这个推送可以直接打开 APP.</p>
<p>从程序的角度来讲, 进入 App 后会调用下面的方法:</p>
<p>iOS10.0.x 和其之前的系统调用下面的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</div></pre></td></tr></table></figure>
<p>iOS10.0.x 之后的系统, 会调用如下的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application</div><div class="line">                    didReceiveRemoteNotification:(NSDictionary *)userInfo</div><div class="line">                    fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler</div></pre></td></tr></table></figure>
<h2 id="静默推送的异同"><a href="#静默推送的异同" class="headerlink" title="静默推送的异同"></a>静默推送的异同</h2><p><strong>1.没有弹出框</strong></p>
<p>没有推送的弹框出现, 用户毫无感知的接收到了这个推送消息. 有 <code>润物细无声</code> 的感觉.</p>
<p>该推送既没有文字又没有声音.</p>
<p><strong>2.需要用户授权允许推送</strong></p>
<p>这个跟普通推送一样, 都需要用户授权才可以推送.</p>
<p><strong>3.会执行代理方法</strong></p>
<p>静默推送来的时候, 也能执行上面的回调方法. 执行上面方法的场景如下::</p>
<blockquote>
<p>1.App 在前台.<br>2.App 在后台, 但是没有被 kill 掉.</p>
</blockquote>
<p><strong>4.iOS7 以后才有的</strong></p>
<p>对于 iOS 之前是没有静默推送的.</p>
<p><strong>5.可以延长后台时间</strong></p>
<p>收到静默推送后, 在应用程序挂起之前有 30 秒左右可以执行相关的操作.</p>
<p>6.推送频率的控制</p>
<p>静默的推送是苹果推送服务器控制推送频率的.</p>
<p>苹果推送服务根据后台推送任务的能耗(用电量,接收情况)来控制后台推送的推送频率和延迟时间.</p>
<hr>
<p><strong>总之</strong>, 静默推送是普通推送的一种变种而已. </p>
<p>无论是静默推送还是普通推送, 开发者证书里面必须开通 push 相关的功能, 并且也需要用户开启允许推送的授权.</p>
<p>这个在 <a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 远程推送</a> 里面已经介绍过, 不在这里赘述.</p>
<h2 id="推送的格式"><a href="#推送的格式" class="headerlink" title="推送的格式"></a>推送的格式</h2><p>普通推送的格式, 大致是这个样子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;aps&quot;:</div><div class="line">		&#123;</div><div class="line">			&quot;alert&quot;:&quot;Testing.. (15),</div><div class="line">			&quot;badge&quot;:1,</div><div class="line">			&quot;sound&quot;:&quot;default&quot;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静默推送是不允许带 <code>alert</code> <code>badge</code>  <code>sound</code> 等字段的. 但是必须包含 <code>&quot;content-available&quot;:1</code>.</p>
<p>例如下面的形式都可以:</p>
<blockquote>
<p>形式1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;aps&quot;:</div><div class="line">		&#123;</div><div class="line">			&quot;content-available&quot;:1</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>形式2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;aps&quot;:</div><div class="line">		&#123;</div><div class="line">			&quot;custom&quot;:&quot;open_profile_page&quot;</div><div class="line">			&quot;content-available&quot;:1</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中, custom 是自己定义的, 大家根据需求自行扩展即可.</p>
<blockquote>
<p>形式3</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot; : &#123;</div><div class="line">        &quot;content-available&quot; : 1</div><div class="line">    &#125;,</div><div class="line">    &quot;acme1&quot; : &quot;bar&quot;,</div><div class="line">    &quot;acme2&quot; : 42</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个来自苹果开发者 <a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank" rel="noopener">文档</a>.</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>具体的使用场景, 需要结合本身的业务和功能特点来说.</p>
<p>静默推送的前提是 APP 没有被杀死, 可以通过回调函数来执行相关的代码.</p>
<p>另外, 静默推送不会打扰用户, 比如用户正在游戏中战斗, 你频繁的使用普通推送给他, 估计他都要疯了. </p>
<p>我个人使用静默推送的场景大致是这样的, APP 将要挂起的时候, 请求服务器去发一条静默推送, 然后使用本地通知的方式唤起用户来打开 APP, 从而保证 APP 处于保活的状态, 至少静默推送可以增加后台挂起的时间.</p>
<p>关于本地通知的内容, 可以参考之前的文章 <a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 本地推送</a>.</p>
<p>更多的使用场景等大家在业务中去挖掘.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APNs 推送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hi 2018, 我又来了]]></title>
      <url>/2018/02/02/Hi-2018-%E6%88%91%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>好久没有更新自己的博客了, 以前坚持一周至少两三篇博文的我, 从 2017 年 10 月份到现在居然停止了. </p>
<p>其实, 这是有原因的…</p>
<h2 id="数据丢了"><a href="#数据丢了" class="headerlink" title="数据丢了"></a>数据丢了</h2><p>2017 年 10 月 15 日晚, 我亲手把自己的之前写的文章(原数据)给弄丢了. 我自己搭建的博客系统是使用 GitHub + Hexo 部署和发布的.</p>
<p>事情大致经过是这样的…</p>
<p>Mac 操作系统提示, 有更新的系统可以使用了, 问是否立即安装, 在公司的时候, 我心想, 更新后, 自己安装的一些库, 估计也要重新安装, 嫌麻烦就直接跳过了.</p>
<p>过了几天, 我晚上下班回家, 系统又提示我更新. 当时, 我就没有忍住, 直接更新了, 毕竟早晚都要更新的, 再说了 MacOS 还是比较让人放心的.</p>
<p>趁电脑更新系统的时候, 我就去洗了澡, 回来发现系统更新已经完成了. </p>
<p>心中想正好可以把之前没有完成的博客去完善一下, 谁知道…天不遂我愿呀! 再去使用 Hexo 的时候, 提示我失败, 居然无法使用了. 这可把我急的够呛, 一气之下(脑子估计当时进水了), 直接删了 Hexo 目录, 是那种程序员式的毫不留情的删除.</p>
<pre><code>rm -fr ./hexo
</code></pre><p>潇洒的操作后, 重新安装 Hexo, 又折腾了两个晚上, 最终也是安装好了, 可以写东东了.</p>
<p>但是发现从 Github 上面 clone 后的文件, 无法还原成自己当初的 MarkDown 文件了.</p>
<p>雪花那个飘啊飘, 北风那个萧呀萧…</p>
<p>一切都晚了! ^^</p>
<p>唯一值得庆幸的是, 原来自己的网站博文还在那里.</p>
<h2 id="还原数据"><a href="#还原数据" class="headerlink" title="还原数据"></a>还原数据</h2><p>从哪里跌倒, 就从哪里爬起来, 我决定把之前的数据使用 <code>人工智能</code> 的方式还原回来.</p>
<p>😆我就是那个 <code>人工</code>, 手动的将 HTML 转换为 MarkDown 文档, 压根没有什么 <code>智能</code>.</p>
<p>好歹那也是自己熬过多少个日夜的成果呀, 没有功劳也有苦劳, 我不忍心就这样让它丢掉, 含着泪也要把它们给找回来!</p>
<p>自己下半年也比较忙, 周末都在加班, 只能每天晚上回家抽些时间还原一点, 有时候太困, 就推迟到下个晚上. 大概用了 3 个月左右的时间, 基本还原回来了. </p>
<p>每篇文章基本都有配图, 都有跳转链接, 恢复起来, 还是需要一点时间和毅力的, 中途我也放弃过, 但是想想它们就要这样的被我抹杀了, 实在太可怜了, 就坚持下来了.</p>
<h2 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h2><p>还原之前的数据, 比写新文章还累, 主要是心累.</p>
<p>刚开始的时候, 我每篇都想一步到位的还原, 发现坚持几个晚上, 效率很低, 很容易放弃.</p>
<p>最后, 我调节了一下心态, 分 <code>迭代</code> 去做.</p>
<p><strong>第一个阶段</strong>, 把 HTML 文章拷贝到 MarkDown 工具中, 不做任何的修饰和修改.</p>
<p><strong>第二个阶段</strong>, 梳理 MarkDown 文档, 把缺失的图片补上去.</p>
<p><strong>第三个阶段</strong>, 把文章中的链接尽量补全.</p>
<p>经过这三个阶段后, 文章基本已经复原了, 只是格式上看起来有点糟糕. </p>
<p><strong>第四个阶段</strong>, 整理文章的排版, 对比已经发布的文章, 查漏补缺.</p>
<p>第四个阶段结束后, 文章基本都复活了, 接下来就是部署和发布了.</p>
<p><strong>第五个阶段</strong>, 整理 Hexo, 配置相关的主题.</p>
<p><strong>第六个阶段</strong>, 本地预览和再次校验文章, 统一发布.</p>
<p>每个阶段, 我都给自己一个小目标, 不断的去完善, 最后将各个阶段的成果串联起来, 就完成了. 当自己遇到困难的时候, 不妨分解一下任务, 不断的去完成每个小任务, 每个完成的小任务都是对自己最大的奖励.</p>
<p>整个还原的过程, 又让我重新梳理了一下之前的文章, 包括目录规划和文章中的措辞, 也对图片进行了压缩和处理. 收获颇多.</p>
<p>如果当初自己不那么冲动, 如果当初自己备份了文件, 应该就不会有这么一个艰辛的历程了.</p>
<blockquote>
<p>数据备份很重要, 冲动是要付出代价的.</p>
</blockquote>
<p>现在我把原数据保存在云盘中, 本地也保留一份, 定期更新到云盘中. 这样就可以防止数据丢失了.</p>
<p>祝大家在 2018 发发发, 身体健康, 幸福安康!</p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐给 Mac 用户一个图片压缩工具 <a href="https://imageoptim.com/mac" target="_blank" rel="noopener">imageoptim</a>.</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 生活 反思 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCC: 静态库]]></title>
      <url>/2017/10/08/GCC-%E9%9D%99%E6%80%81%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>如果你对 GCC 的编译 C语言的流程不清楚, 建议在阅读本文之前先去看一下 <a href="http://www.veryitman.com/2017/10/03/GCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">GCC: 编译C语言的流程</a> 这篇文章, 篇幅短小精悍, 阅读后, 至少可以扫扫盲😜.</p>
<p>本篇博文用到的一些基础知识点:</p>
<p><strong>1.GCC</strong></p>
<p>gcc -c 选项含义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Only run preprocess, compile, and assemble steps</div></pre></td></tr></table></figure>
<p>是 <code>-c</code> 选项只是进行了预处理, 编译, 汇编的阶段, 不会进行链接的操作.</p>
<p><strong>2.静态库</strong></p>
<p>Linux 上的静态库，本质是一些目标文件的归档文件.</p>
<p><strong>3.静态库和共享库区别</strong></p>
<p>[1].使用共享库可以节省内存.</p>
<blockquote>
<p>比如 libc，系统中几乎所有的进程都映射 libc 到自己的进程地址空间，而 libc 的只读部分在物理内存中只需要存在一份，就可以被所有进程共享，这就是“共享库”这个名称的由来了.</p>
</blockquote>
<p>[2].使用共享库可以很方便地升级库文件而不需要重新编译应用程序.</p>
<p>[3].共享库占用更少的体积.</p>
<blockquote>
<p>在运行时做动态链接.而在链接静态库时, 链接器会把静态库中的目标文件取出来和可执行文件真正链接在一起.</p>
</blockquote>
<h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><p>创建静态库的步骤如下:</p>
<p>[1]. 写源文件.<br>[2]. 通过 gcc -c x.c 生成目标文件.<br>[2]. 归档. 用 ar 归档目标文件，生成静态库.<br>[3]. 写头文件, 便于使用者知道怎么使用该静态库.</p>
<p>使用静态库时，在源码中包含对应的头文件，链接时记得链接自己的库.</p>
<p>下面结合具体例子, 展开讲.</p>
<h2 id="写源文件"><a href="#写源文件" class="headerlink" title="写源文件"></a>写源文件</h2><p>目录结构<br><img src="/upload/images/2017/10/08/1.jpg" alt="1"></p>
<p>示例文件都是很简单的代码, 附录可以查看完整示例.</p>
<h2 id="生成目标文件"><a href="#生成目标文件" class="headerlink" title="生成目标文件"></a>生成目标文件</h2><p>将 libs 目录下面的(c)源文件进行预处理, 编译和汇编.<br>注意这里没有进行链接.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c libs/person.c libs/eat.c libs/play.c libs/sleep.c</div></pre></td></tr></table></figure>
<p>执行城后, 会生成对应的 .o 文件.</p>
<h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><p><code>libperson.a</code> 是要生成的库文件.</p>
<p>库文件都以 lib 开头, 静态库以. a 为后缀. 所以一般是 lib+ 名字.a</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ar rs libperson.a person.o sleep.o play.o eat.o</div></pre></td></tr></table></figure>
<p>ar: 类似于 tar, 用来对文件进行库打包.</p>
<p>r 选项: 将其后面的文件列表添加到文件包(libperson.a)中, 如果 libperson.a 不存在就创建它, 如果 libperson.a 已经存在且里面有同名的目标文件就进行替换操作.</p>
<p>s 选项: 为静态库创建索引.这个索引会被链接器使用.</p>
<blockquote>
<p>ranlib 命令也可以为静态库创建索引. 所以上面的命令可以等效为下面的两个命令.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ar r libperson.a person.o sleep.o play.o eat.o</div><div class="line">ranlib libperson.a</div></pre></td></tr></table></figure>
<h2 id="写头文件"><a href="#写头文件" class="headerlink" title="写头文件"></a>写头文件</h2><p>写一个 person.h 文件, 便于调用者查看库如何使用.</p>
<p>person.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#ifndef _PERSON_H</div><div class="line">#define _PERSON_H</div><div class="line">extern void init(int pUid);</div><div class="line">extern void eat();</div><div class="line">extern void play();</div><div class="line">extern void sleep();</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>使用静态库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -L. -lperson -Ilibs -o main</div></pre></td></tr></table></figure>
<p>-L 选项: 告诉编译器去哪里找库文件, 这里的 _L. 表示在当前目录.<br>如果不用 -L 选项, 即使库文件在当前目录, 编译器也不会去找, 所以该选项不能少.</p>
<p>报错信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ld: library not found for -lperson</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure>
<p>-lperson: 告诉编译器要链接 libperson.a 库.</p>
<p>-I: 告诉编译器到哪里找头文件.<br>如果不指定头文件的查找目录, 也会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">main.c:2:10: fatal error: &apos;person.h&apos; file not found</div><div class="line">#include &quot;person.h&quot;</div><div class="line">         ^~~~~~~~~~</div><div class="line">1 error generated.</div></pre></td></tr></table></figure>
<p>此时的目录结构:<br><img src="/upload/images/2017/10/08/2.jpg" alt="1"></p>
<p>链接成功后, 可以执行生成的 main (可执行)文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./main</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uid: 101 eating</div><div class="line">uid: 101 playing</div><div class="line">uid: 101 has sleep</div></pre></td></tr></table></figure>
<h2 id="有趣的实验"><a href="#有趣的实验" class="headerlink" title="有趣的实验"></a>有趣的实验</h2><p>猜想一下如果有两个库一个是共享库, 一个是静态库, 而且二者除了后缀不一样, 名字都一样如 libperson.a 和 libperson.so, 那么调用方如何来选择对应的库文件呢?</p>
<p>我们把 GCC: 共享库 里面生成的共享库 libperson.so 放到当前的目录, 重新编译链接 main.c 文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -L. -lperson -Ilibs -o main</div></pre></td></tr></table></figure>
<p>再次执行 ./main, 得到结果是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">From sharedlib.uid: 101 eating</div><div class="line">From sharedlib.uid: 101 playing</div><div class="line">From sharedlib.uid: 101 has sleep</div></pre></td></tr></table></figure>
<p>以上的结果, 说明链接器会优先选择共享库其次才是静态库.</p>
<blockquote>
<p>Linux(MacOS 也一样) 的 GCC 默认链接动态库，只有当动态库不存在时，才去链接静态库.<br>若是需要强制指定静态库需要指定选项 -static.但是在 MacOS 上面不支持该选项.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -static main.c -L. -lperson -Ilibs -o main</div></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例完整代码</p>
<blockquote>
<p>main.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;person.h&quot;</div><div class="line">int main() &#123;</div><div class="line">    init(101);</div><div class="line">    eat();</div><div class="line">    play();</div><div class="line">    sleep();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>person.h</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#ifndef _PERSON_H</div><div class="line">#define _PERSON_H</div><div class="line">extern void init(int pUid);</div><div class="line">extern void eat();</div><div class="line">extern void play();</div><div class="line">extern void sleep();</div><div class="line">#endif</div></pre></td></tr></table></figure>
<blockquote>
<p>person.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int uid;</div><div class="line">void init(int pUid) &#123;</div><div class="line">    uid = pUid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>eat.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">extern int uid;</div><div class="line">void eat() &#123;</div><div class="line">    printf(&quot;uid: %i eating\n&quot;, uid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>play.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">extern int uid;</div><div class="line">void play() &#123;</div><div class="line">    printf(&quot;uid: %i playing\n&quot;, uid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>sleep.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">extern int uid;</div><div class="line">void sleep() &#123;</div><div class="line">    printf(&quot;uid: %i has sleep\n&quot;, uid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="GCC-系列博文"><a href="#GCC-系列博文" class="headerlink" title="GCC 系列博文"></a>GCC 系列博文</h2><p><a href="http://www.veryitman.com/2017/10/03/GCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">GCC: 编译 C 语言的流程</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils/" target="_blank" rel="noopener">GCC: Homebrew 安装 GCC 和 Binutils</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-%E5%85%B1%E4%BA%AB%E5%BA%93/" target="_blank" rel="noopener">GCC: 共享库</a></p>
<p><a href="http://www.veryitman.com/2017/10/08/GCC-%E9%9D%99%E6%80%81%E5%BA%93/" target="_blank" rel="noopener">GCC: 静态库</a></p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCC 编译器 静态库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCC: 共享库]]></title>
      <url>/2017/10/07/GCC-%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>共享库: 在程序执行期间需要调用到共享库的时候才加载到内存里面，可以被多个程序共享使用.</p>
<p>在 MacOS 上面创建和使用共享库要比在 Linux 上面简单.<br>在 Linux 上面还会牵扯到共享库路径问题, 在 Mac 上面就没有这样的问题.</p>
<p>在 MacOS 上面使用的 GCC 其本质是 LLVM. 你可以在命令行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -v</div></pre></td></tr></table></figure>
<p>可以看到对应的输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1</div><div class="line">Apple LLVM version 9.0.0 (clang-900.0.37)</div><div class="line">Target: x86_64-apple-darwin16.7.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</div></pre></td></tr></table></figure>
<h2 id="创建共享库步骤"><a href="#创建共享库步骤" class="headerlink" title="创建共享库步骤"></a>创建共享库步骤</h2><p>[1].写源文件.这里以 C文件为基础.<br>[2].将源文件生成目标文件.<br>[3].创建共享库.<br>[4].写头文件, 供调用方使用.</p>
<p>下面结合实例来分享一下如何在 Mac 上面创建共享库.</p>
<h2 id="写源文件"><a href="#写源文件" class="headerlink" title="写源文件"></a>写源文件</h2><p>目录结构:<br><img src="/upload/images/2017/10/07/1.jpg" alt="1"></p>
<p>对应的完整代码可以看文末的附录.</p>
<h2 id="生成目标文件"><a href="#生成目标文件" class="headerlink" title="生成目标文件"></a>生成目标文件</h2><p>执行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Wall -c -fPIC libs/eat.c libs/play.c libs/sleep.c libs/person.c</div></pre></td></tr></table></figure>
<p>注意: <code>-fPIC</code> 选项一定要加.</p>
<blockquote>
<p>PIC(position independent code), 产生位置无关码</p>
</blockquote>
<h2 id="生成共享库"><a href="#生成共享库" class="headerlink" title="生成共享库"></a>生成共享库</h2><p>这里把共享库暂且称之为 <code>libperson.so</code>.</p>
<p>执行下面命令创建:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -shared -fPIC eat.o play.o sleep.o person.o -o libperson.so</div></pre></td></tr></table></figure>
<h2 id="写头文件"><a href="#写头文件" class="headerlink" title="写头文件"></a>写头文件</h2><p>这里头文件主要是 <code>person.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#ifndef _PERSON_H</div><div class="line">#define _PERSON_H</div><div class="line">extern void init(int pUid);</div><div class="line">extern void eat();</div><div class="line">extern void play();</div><div class="line">extern void sleep();</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h2 id="使用共享库"><a href="#使用共享库" class="headerlink" title="使用共享库"></a>使用共享库</h2><p>main.c 是使用方, 编译链接即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -L. -lperson -Ilibs -o main</div></pre></td></tr></table></figure>
<p>生成可执行文件 main, 执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">From sharedlib.uid: 101 eating</div><div class="line">From sharedlib.uid: 101 playing</div><div class="line">From sharedlib.uid: 101 has sleep</div></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>-L 选项, 告诉编译器去哪里找库文件, 这里的 _L. 表示在当前目录.</p>
<p>-lperson, 表示 libperson.so 库.</p>
<p>-Ilibs 告诉编译器头文件所在的目录.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例完整代码</p>
<blockquote>
<p>main.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;person.h&quot;</div><div class="line">int main() &#123;</div><div class="line">    init(101);</div><div class="line">    eat();</div><div class="line">    play();</div><div class="line">    sleep();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>person.h</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#ifndef _PERSON_H</div><div class="line">#define _PERSON_H</div><div class="line">extern void init(int pUid);</div><div class="line">extern void eat();</div><div class="line">extern void play();</div><div class="line">extern void sleep();</div><div class="line">#endif</div></pre></td></tr></table></figure>
<blockquote>
<p>person.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int uid;</div><div class="line">void init(int pUid) &#123;</div><div class="line">    uid = pUid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>eat.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">extern int uid;</div><div class="line">void eat() &#123;</div><div class="line">    printf(&quot;From sharedlib.uid: %i eating\n&quot;, uid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>play.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">extern int uid;</div><div class="line">void play() &#123;</div><div class="line">    printf(&quot;From sharedlib.uid: %i playing\n&quot;, uid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>sleep.c</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">extern int uid;</div><div class="line">void sleep() &#123;</div><div class="line">    printf(&quot;From sharedlib.uid: %i has sleep\n&quot;, uid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="GCC-系列博文"><a href="#GCC-系列博文" class="headerlink" title="GCC 系列博文"></a>GCC 系列博文</h2><p><a href="http://www.veryitman.com/2017/10/03/GCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">GCC: 编译 C 语言的流程</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils/" target="_blank" rel="noopener">GCC: Homebrew 安装 GCC 和 Binutils</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-%E5%85%B1%E4%BA%AB%E5%BA%93/" target="_blank" rel="noopener">GCC: 共享库</a></p>
<p><a href="http://www.veryitman.com/2017/10/08/GCC-%E9%9D%99%E6%80%81%E5%BA%93/" target="_blank" rel="noopener">GCC: 静态库</a></p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCC 编译器 共享库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCC: Homebrew 安装 GCC 和 Binutils]]></title>
      <url>/2017/10/07/GCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils/</url>
      <content type="html"><![CDATA[<h2 id="文章背景"><a href="#文章背景" class="headerlink" title="文章背景"></a>文章背景</h2><p>前段时间, 有个博客上面的小伙伴给我发来邮件, 问我关于 GCC 相关的知识, 对于 GCC 我也只是凭着之前的了解, 回复他了.</p>
<p>这位小伙伴还在读大学, 自学能力比较强, 自己出了完成课时之外, 还会在网上找资料自学.</p>
<p>我记得自己在大学的时候, 对 GCC 一窍不通, 只知道 Turbo-C 和那些被强制记住的关键字, 哈哈!</p>
<p>最后告诉他, 我会坚持把自己以前学习过相关 GCC 的知识, 以博客的形式输出.</p>
<p>于是, 就有了 <code>GCC: 系列</code> 的文章. 希望能够帮到大家.</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>这篇博客主要分享 MacOS 下安装 GCC 和 Binutils 工具.</p>
<p>MacOS 下输入 <code>gcc -v</code>, 其实是链接指向了 LLVM 编译器, 不是 GNU 的 GCC.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1</div><div class="line">Apple LLVM version 9.0.0 (clang-900.0.37)</div><div class="line">Target: x86_64-apple-darwin16.7.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</div></pre></td></tr></table></figure>
<h2 id="安装-GCC"><a href="#安装-GCC" class="headerlink" title="安装 GCC"></a>安装 GCC</h2><p>关于 GCC, 可以参考 <a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">维基百科</a>.</p>
<p>执行下面命令, 即可开始安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">brew tap homebrew/versions</div><div class="line">brew install gcc49</div><div class="line">brew 会自动为你安装相关依赖, 比如</div><div class="line">gmp4, mpfr2, libmpc08, isl011, cloog018</div></pre></td></tr></table></figure>
<p>这里安装需要等待一段时间…</p>
<p>看到下面的内容, 表示安装完毕.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pouring gcc49-4.9.2_1.yosemite.bottle.1.tar.gz</div><div class="line">/usr/local/Cellar/gcc49/4.9.2_1: 1138 files, 164M</div></pre></td></tr></table></figure>
<p>安装成功后, 安装目录在:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/Cellar/gcc49/4.9.2_1</div></pre></td></tr></table></figure>
<p>你在终端直接输入 gcc -v, 其实还是 LLVM, 那么如何使用我们 刚安装的 gcc?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/gcc49/4.9.2_1/bin</div><div class="line">ls -l</div></pre></td></tr></table></figure>
<p>可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">c++-4.9</div><div class="line">cpp-4.9</div><div class="line">g++-4.9</div><div class="line">gcc-4.9</div><div class="line">gcc-ar-4.9</div><div class="line">gcc-nm-4.9</div><div class="line">gcc-ranlib-4.9</div><div class="line">gcov-4.9</div><div class="line">x86_64-apple-darwin14.3.0-c++-4.9</div><div class="line">x86_64-apple-darwin14.3.0-g++-4.9</div><div class="line">x86_64-apple-darwin14.3.0-gcc-4.9</div><div class="line">x86_64-apple-darwin14.3.0-gcc-4.9.2</div><div class="line">x86_64-apple-darwin14.3.0-gcc-ar-4.9</div><div class="line">x86_64-apple-darwin14.3.0-gcc-nm-4.9</div><div class="line">x86_64-apple-darwin14.3.0-gcc-ranlib-4.9</div></pre></td></tr></table></figure>
<p>Ok, 你应该明白了, 在命令行输入 <code>gcc-4.9 -v</code> 就可以使用我们刚安装的 GCC 了. 包括 g++ 工具.</p>
<p>以后使用 GNU 的 GCC 输入 <code>gcc-4.9</code> 就好了.</p>
<h2 id="安装-Binutils"><a href="#安装-Binutils" class="headerlink" title="安装 Binutils"></a>安装 Binutils</h2><p>关于 Binutils 可以参考 <a href="https://zh.wikipedia.org/zh-cn/GNU_Binutils" target="_blank" rel="noopener">维基百科</a>.</p>
<p>执行下面命令, 直接安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install binutils</div></pre></td></tr></table></figure>
<p>同理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/Cellar/binutils/2.25/bin</div></pre></td></tr></table></figure>
<p>可以看到你需要的工具:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">gaddr2line</div><div class="line">gar</div><div class="line">gc++filt</div><div class="line">gcoffdump</div><div class="line">gdlltool</div><div class="line">gdllwrap</div><div class="line">gelfedit</div><div class="line">gnlmconv</div><div class="line">gnm</div><div class="line">gobjcopy</div><div class="line">gobjdump</div><div class="line">granlib</div><div class="line">greadelf</div><div class="line">gsize</div><div class="line">gsrconv</div><div class="line">gstrings</div><div class="line">gstrip</div><div class="line">gsysdump</div><div class="line">gwindmc</div><div class="line">gwindres</div></pre></td></tr></table></figure>
<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>在 MacOS 上面, 即使安装了 GNU 的 GCC, 也没有在 Linux 上面用的那么爽, 很多 GCC 的命令选项在 MacOS 上面无法使用.</p>
<p>所以, 在 MacOS 上面编译一些 C文件, 有时候需要走一些弯路, 但是不得不承认 LLVM 是比较优秀的编译器.</p>
<h2 id="GCC-系列博文"><a href="#GCC-系列博文" class="headerlink" title="GCC 系列博文"></a>GCC 系列博文</h2><p><a href="http://www.veryitman.com/2017/10/03/GCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">GCC: 编译 C 语言的流程</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils/" target="_blank" rel="noopener">GCC: Homebrew 安装 GCC 和 Binutils</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-%E5%85%B1%E4%BA%AB%E5%BA%93/" target="_blank" rel="noopener">GCC: 共享库</a></p>
<p><a href="http://www.veryitman.com/2017/10/08/GCC-%E9%9D%99%E6%80%81%E5%BA%93/" target="_blank" rel="noopener">GCC: 静态库</a></p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCC C 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCC: 编译C语言的流程]]></title>
      <url>/2017/10/03/GCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>再看下文之前，先普及一下 Linux 和 gcc 的历史，下面的这段内容来自于网络。</p>
<blockquote>
<p>早在 20 世纪 70 年代，UNIX 系统是开源而且免费的。但是在 1979 年时，AT&amp;T 公司宣布了对 UNIX 系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。</p>
<p>于是在 1984 年，Richard Stallman 面对于如此封闭的软件创作环境，发起了 GNU 源代码开放计划并制定了著名的 GPL 许可协议。</p>
<p>1987 年时，GNU 计划获得了一项重大突破—gcc编译器发布，这使得程序员可以基于该编译器编写出属于自己的开源软件。</p>
<p>随之，在 1991 年10 月，芬兰赫尔辛基大学的在校生 Linus Torvalds 编写了一款名为 Linux 的操作系统。该系统因其较高的代码质量且基于 GNU GPL 许可协议的开放源代码特性，迅速得到了 GNU 计划和一大批黑客程序员的支持。</p>
<p>随后 Linux 系统便进入了如火如荼的发展阶段。</p>
<p>1994 年 1 月，Bob Young 在 Linux 系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了 Linux 系统的普及。</p>
<p>1998 年以后，随着 GNU 源代码开放计划和 Linux 系统的继续火热，以 IBM 和 Intel 为首的多家 IT 企业巨头开始大力推动开放源代码软件的发展。</p>
<p>到了 2017 年年底，Linux 内核已经发展到了 4.13 版本，并且 Linux 系统版本也有数百个之多，但它们依然都使用 Linus Torvalds 开发、维护的Linux 系统内核。RedHat 公司也成为了开源行业及 Linux 系统的带头公司。</p>
</blockquote>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>这篇博文 <a href="http://blog.csdn.net/veryitman/article/details/7340668" target="_blank" rel="noopener">makefile: gcc 工作流程</a> 早期被我放在 CSDN 上面过.时隔多年, 仍不能忘怀, 现乔迁至此.</p>
<p>本文比较简单, 比较适合初学者.<br>我只是试图以实例的方式给大家讲解一下 GCC 编译链接 C语言程序的流程, 并没有高深的知识.</p>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>C 语言经过预处理、编译、连接最后生成可执行文件.</p>
<p>在 Linux 的 GCC 下面，看看其工作流程. 流程图如下：</p>
<p><img src="/upload/images/2017/10/03/1.jpg" alt="1"></p>
<p>预处理，将包含的 <em>.h 文件或者一些预处理语句（如 #define）处理一下，然后将 </em>.c 文件生成 *.i 的中间文件.</p>
<blockquote>
<p>注意了 GCC 不会自动生成这样一个文件，如果需要，自己加 -E 参数即可.</p>
</blockquote>
<p>编译、汇编阶段生成 *.o 目标文件，最后经过链接生成可执行文件.</p>
<blockquote>
<p>注意：可执行文件不一定是 exe 文件.</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面以一个实例 hello.c，说明这个过程.</p>
<p><img src="/upload/images/2017/10/03/2.jpg" alt="1"></p>
<p>源文件很简单，这里只是为了说明问题.</p>
<p>在命令行，执行下面命令完成预处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc  -E  hello.c  -o  hello.i</div></pre></td></tr></table></figure>
<p>执行之后，你可以打开 hello.i 文件，可以看到很多 extern 以及将 MAX 解释为 20：<br><img src="/upload/images/2017/10/03/3.jpg" alt="1"></p>
<p>在命令行，执行下面命令, 完成编译阶段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc  -S  hello.i  -o hello.s</div></pre></td></tr></table></figure>
<p>这时可以生成 *.s 文件，其实就是一些汇编语句，如下所示：<br><img src="/upload/images/2017/10/03/4.jpg" alt="1"></p>
<p>那麽，我们就可以进入汇编阶段了，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc  -c  hello.s  -o hello.o</div></pre></td></tr></table></figure>
<p>打开这个 hello.o 文件，都是一些机器码.</p>
<p>最后一个连接生成可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc hello.o -o hello</div></pre></td></tr></table></figure>
<p>在当前目录就可以生成 hello 这个可执行文件.</p>
<p>执行 ./hello，就会输出：<br><img src="/upload/images/2017/10/03/5.jpg" alt="1"></p>
<p>到此，GCC 编译连接生成可执行文件完毕！</p>
<p>当前目录下面的文件：<br><img src="/upload/images/2017/10/03/6.jpg" alt="1"></p>
<p>以上的步骤，其实一句命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc  hello.c  -o  hello</div></pre></td></tr></table></figure>
<p>此时目录内容如下：<br><img src="/upload/images/2017/10/03/7.jpg" alt="1"></p>
<p>自己动手感受一下，你会收获更多！</p>
<h2 id="GCC-系列博文"><a href="#GCC-系列博文" class="headerlink" title="GCC 系列博文"></a>GCC 系列博文</h2><p><a href="http://www.veryitman.com/2017/10/03/GCC-%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">GCC: 编译 C 语言的流程</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-Homebrew-%E5%AE%89%E8%A3%85-GCC-%E5%92%8C-Binutils/" target="_blank" rel="noopener">GCC: Homebrew 安装 GCC 和 Binutils</a></p>
<p><a href="http://www.veryitman.com/2017/10/07/GCC-%E5%85%B1%E4%BA%AB%E5%BA%93/" target="_blank" rel="noopener">GCC: 共享库</a></p>
<p><a href="http://www.veryitman.com/2017/10/08/GCC-%E9%9D%99%E6%80%81%E5%BA%93/" target="_blank" rel="noopener">GCC: 静态库</a></p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCC C 编译器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS APNs: 处理数据]]></title>
      <url>/2017/08/07/iOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>博文: <a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS 细说推送: 远程推送</a> 和 <a href="http://www.veryitman.com/2017/08/07/iOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">iOS 细说推送: 本地推送</a><br>分别介绍了 iOS 的两种典型推送, iOS 还有很多类型的推送, 如静默推送, VOIP 推送(iOS8)等, 后面会慢慢介绍给大家.</p>
<p>今天跟大家聊聊关于如何处理推送的数据(payload).</p>
<p>该系列博客:</p>
<blockquote>
<p><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 远程推送</a><br><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 本地推送</a><br>iOS APNs: 处理数据(本篇)<br><a href="http://www.veryitman.com/2018/02/06/iOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 静默推送</a><br><a href="http://www.veryitman.com/2018/02/08/iOS-APNs-Background-Fetch/" target="_blank" rel="noopener">iOS APNs: Background Fetch</a></p>
</blockquote>
<h2 id="推送的代理回调时机"><a href="#推送的代理回调时机" class="headerlink" title="推送的代理回调时机"></a>推送的代理回调时机</h2><p>还记得 AppDelegate 里面关于推送的几个代理方法吧.<br>~ 估计你也忘记了, 没关系, 我们再一起整理一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;markApp push. RemotePush userInfo: %@&quot;, userInfo);</div><div class="line">    </div><div class="line">    // 可以根据推送内容决定下一步的行为</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法在接收到 RemotePush 的时候, 调用时机:</p>
<p>1.APP 在前台运行的, RemotePush 被推送过来了.<br>2.APP 在后台运行, 无论是否被挂起只要没有被杀死, 点击推送内容.</p>
<p>以上两种情况均可以进入 didReceiveRemoteNotification 方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App push. LocalPush notification: %@&quot;, notification);</div><div class="line">    </div><div class="line">    // 可以根据推送内容决定下一步的行为</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法接收到 LocalPush 的时候, 调用时机:</p>
<p>1.APP 在前台运行的, LocalPush 被推送过来了.<br>2.APP 在后台运行, 无论是否被挂起只要没有被杀死, 点击推送内容.</p>
<p>以上两种情况均可以进入 didReceiveLocalNotification 方法.</p>
<p>这两个回调方法, 分别接收 RemotePush 和 LocalPush 的推送消息.</p>
<p>有些人会问了, 假如这个时候我的应用在后台, 被系统杀死了或者被用户双击 Home 键杀死了, 此时远程推送过来了, 或者状态栏里面有本地推送的消息, 我点击推送消息, 这两个方法会被调用吗?</p>
<p>类似这种效果, 上面是 RemotePush, 下面是 LocalPush.</p>
<p><img src="/upload/images/2017/08/07/1.jpg" alt="1"></p>
<p>我肯定的告诉大家, 应用被杀死的情况下, 点击推送内容, didReceiveRemoteNotification 和 didReceiveLocalNotification 都不会被调用.</p>
<p>这个时候, AppDelegate 中的另一个方法上场了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application </div><div class="line">	didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div></pre></td></tr></table></figure>
<p>看一下 didFinishLaunchingWithOptions 的具体实现, 示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    </div><div class="line">    /// 将应用图标的 badge 清零</div><div class="line">    &#123;</div><div class="line">        [[UIApplication sharedApplication] setApplicationIconBadgeNumber:1];</div><div class="line">        [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];</div><div class="line">        [[UIApplication sharedApplication] cancelAllLocalNotifications];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (nil != launchOptions) &#123;</div><div class="line">        /// 处理 LocalPush</div><div class="line">        &#123;</div><div class="line">            // 这里可以得到 UILocalNotification 对象</div><div class="line">            id localPushNotify = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey];</div><div class="line">            </div><div class="line">            MZLOG(@&quot;AppDelegate localPush: %@&quot;, localPushNotify);</div><div class="line">            </div><div class="line">            if (nil != localPushNotify) &#123;</div><div class="line">                if ([localPushNotify isKindOfClass:[UILocalNotification class]]) &#123;</div><div class="line">                    // 获取 userinfo 数据</div><div class="line">                    NSDictionary *userInfo = [(UILocalNotification *)localPushNotify userInfo];</div><div class="line">                    MZLOG(@&quot;AppDelegate localPush of UILocalNotification: %@&quot;, userInfo);</div><div class="line">                    </div><div class="line">                    // 根据 userInfo 的内容处理如页面跳转等</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /// 处理 RemotePush</div><div class="line">        &#123;</div><div class="line">            NSDictionary *remotePushNotify = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];</div><div class="line">            MZLOG(@&quot;AppDelegate remotePush: %@&quot;, remotePushNotify);</div><div class="line">            </div><div class="line">            if (nil != remotePushNotify) &#123;</div><div class="line">                NSDictionary *remoteAps = [remotePushNotify objectForKey:@&quot;aps&quot;];</div><div class="line">                MZLOG(@&quot;AppDelegate remotePush. The aps&apos; info, alert: %@, badge: %@, sound: %@&quot;,</div><div class="line">                      [remoteAps objectForKey:@&quot;alert&quot;],</div><div class="line">                      [remoteAps objectForKey:@&quot;badge&quot;], [remoteAps objectForKey:@&quot;sound&quot;]);</div><div class="line">				// 根据推送的内容处理如页面跳转等</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;AppDelegate. launchOptions: %@&quot;, launchOptions);</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的打印输出内容, 如下</p>
<p>本地推送的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> AppDelegate localPush of UILocalNotification: &#123;</div><div class="line">    &quot;user_info_key&quot; = &quot;user_info_value_json_str&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>远程推送的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aps = &#123;</div><div class="line">			alert = &quot;Testing.. (2)&quot;;</div><div class="line">			badge = 1;</div><div class="line">			sound = default;</div><div class="line">      &#125;;</div><div class="line">            </div><div class="line">The aps&apos; info, alert: Testing.. (19), badge: 1, sound: default</div></pre></td></tr></table></figure>
<h2 id="自定义推送内容"><a href="#自定义推送内容" class="headerlink" title="自定义推送内容"></a>自定义推送内容</h2><blockquote>
<p>对于推送的数据格式, 是苹果规定的格式, 我们可以在其基础上添加我们需要的数据.</p>
</blockquote>
<p>在介绍下面内容之前, 先了解一下什么是 payload.</p>
<blockquote>
<p>payload 是推送通知的一部分，每一条推送通知都包含一个 Payload.<br>它包含了系统提醒用户通知到达的方式，还可以添加自定义的数据, 即通知主要传递的数据为 payload.</p>
<p>Payload 本身为 JSON 格式的字符串，它内部必须要包含一个键为 aps 的字典.也就是说 payload 是整个字符串.</p>
</blockquote>
<p>关于 payload 的限制</p>
<p>在早期的推送中, payload 不能超过 256bytes, 中间还经历过推送的 payload 最大为 2KB.<br>现在苹果支持最大为5KB(VOIP 推送), 官方文档有说, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For regular remote notifications, the maximum size is 4KB (4096 bytes)</div><div class="line">For Voice over Internet Protocol (VoIP) notifications, the maximum size is 5KB (5120 bytes)</div><div class="line">NOTE</div><div class="line">If you are using the legacy APNs binary interface to send notifications instead of an HTTP/2 request, the maximum payload size is 2KB (2048 bytes)</div></pre></td></tr></table></figure>
<p>上面是 <a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html#//apple_ref/doc/uid/TP40008194-CH10-SW1" target="_blank" rel="noopener">官方文档</a> 的原文, 大概意思是:</p>
<blockquote>
<p>现在 APNs 支持 payload 为 4KB, 如果是 VoIP 推送的话, 支持 5KB. 但是, 如果你使用传统的 APNs 而不是使用 HTTP/2 的话, 最大支持 2KB. 也就是说, 推送的 payload 大小和 iOS 系统无关, 而是和协议有关.</p>
</blockquote>
<p>可以使用下面代码, 查看 payload 长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">payload.getBytes().length</div></pre></td></tr></table></figure>
<p>我们正常的推送内容是这样的, 正常格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;aps&quot;:&#123;&quot;alert&quot;:&quot;Testing.. (21)&quot;,&quot;badge&quot;:1,&quot;sound&quot;:&quot;default&quot;&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果想对推送内容做自定义, 可以自己添加额外的数据, 如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;aps&quot;:&#123;&quot;alert&quot;:&quot;Testing.. (21)&quot;,&quot;badge&quot;:1,&quot;sound&quot;:&quot;default&quot;&#125;, &quot;ext&quot;:&#123;&quot;key&quot;:&quot;value&quot;&#125;&#125;</div></pre></td></tr></table></figure>
<p>其中, ext 就是额外添加的数据模型.</p>
<p>在 APP 收到这样的数据模型时, 可以对应不同的行为.</p>
<p>大家可以根据自己的业务需求, 自行定义数据格式.</p>
<p>自定义的数据格式, 注意内容的长度, 在不同的 iOS 系统上面, 对于推送的内容是有长度限制的.</p>
<h2 id="再唠叨几句"><a href="#再唠叨几句" class="headerlink" title="再唠叨几句"></a>再唠叨几句</h2><p>关于 iOS7 以后添加的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application </div><div class="line">	didReceiveRemoteNotification:(NSDictionary *)userInfo </div><div class="line">	fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</div></pre></td></tr></table></figure>
<p>这个方法也是在 AppDelegate 中实现的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application </div><div class="line">	didReceiveRemoteNotification:(NSDictionary *)userInfo</div></pre></td></tr></table></figure>
<p>这个方法在 iOS3 就已经有了, 可谓是历史悠久.我姑且称之为该方法为 FatherMethod, 上面那个新加入的称之为 SonMethod.</p>
<p><strong>注意事项:</strong></p>
<p>[1]. 实现了 FatherMethod, 即使你实现了 SonMethod, SonMethod 也不会被调用.<br>[2]. SonMethod 比 FatherMethod 多了一个参数 completionHandler, 这个在后面会说到.主要用于 Background Mode 中的 Background Fetch.<br>[3]. 推送被调用的时机, 除了 FatherMethod 的时机外, 还多了一种时机, 就是在 APP 被杀死后, 点击推送内容打开 APP, 此时 APP 再次回到前台的时候, 该方法也会被调用(didFinishLaunchingWithOptions也会调用), 所以在处理远程推送内容的时候, 要注意这一点.</p>
<p>针对注意事项[3], 目前我能给出的有两种解决方案:</p>
<p>第一, 判断是否是第一次启动 APP, 如果是第一次启动 APP, 统一在didFinishLaunchingWithOptions 中处理, 不在 SonMethod 中处理.</p>
<p>第二, 远程推送统一在 SonMethod 中处理, didFinishLaunchingWithOptions 中只处理在 APP 被杀死的情况下, 用户点击推送本地的内容.</p>
<p>我个人采用的是第二中方案.</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>在推送工具 NWPusher 和 Xcode 的 Window/Devices/Console 帮助下, 才得以完善博文.</p>
<p>NWPusher 用来发送推送内容.</p>
<p>Window/Devices/Console 用于查看输出日志.</p>
<h2 id="必看文档"><a href="#必看文档" class="headerlink" title="必看文档"></a>必看文档</h2><p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html#//apple_ref/doc/uid/TP40008194-CH10-SW1" target="_blank" rel="noopener">Creating the Remote Notification Payload</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html#//apple_ref/doc/uid/TP40008194-CH17-SW1" target="_blank" rel="noopener">Payload Key Reference</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APNs 推送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS APNs: 本地推送]]></title>
      <url>/2017/08/06/iOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/</url>
      <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p><code>iOS APNs: 远程推送</code> 说过远程推送(RemotePush).</p>
<p>今天说说本地推送, 本地推送也就是平时所说的 LocalPush.</p>
<p>该系列博客:</p>
<blockquote>
<ul>
<li><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 远程推送</a></li>
<li>iOS APNs: 本地推送(本篇)</li>
<li><a href="http://www.veryitman.com/2017/08/07/iOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">iOS APNs: 处理数据</a></li>
<li><a href="http://www.veryitman.com/2018/02/06/iOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 静默推送</a></li>
<li><a href="http://www.veryitman.com/2018/02/08/iOS-APNs-Background-Fetch/" target="_blank" rel="noopener">iOS APNs: Background Fetch</a></li>
</ul>
</blockquote>
<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>在具体实现之前, 先说一下业务场景.</p>
<p>假如你的 APP 具有 IM(即时通讯) 功能, 这个时候, 你可以根据连接来判断用户是否在线, 如果不在线, 可以使用远程推送将推送内容告知用户.如果在线, 可以通过 IM 把内容告诉 APP, APP 收到这个消息后, 可以使用本地推送告知给用户.</p>
<p>据说 APNs 每天要处理的推送在亿级别, 所以如果可以使用 LocalPush 完成的业务, 我建议大家还是不要使用远程推送, 况且苹果并不一定保证远程推送一定成功, 如果网络或者 APNs 压力大, 推送也会延时.</p>
<p>给苹果减少点压力吧, 哈哈!</p>
<p>再说一个业务场景, 你的 APP 在后台运行时间快到要被系统挂起的时候了, 你可以发送一个 LocalPush 来提示用户或者刺激用户, 再次将 APP 拉回前台运行. 这样可以保证 APP 可以正常运行了.</p>
<p>上面说的第二个业务场景, 是今天例子的基础, 你也可以根据自己的实际业务场景来使用 LocalPush 功能.</p>
<h2 id="LocalPush-简介"><a href="#LocalPush-简介" class="headerlink" title="LocalPush 简介"></a>LocalPush 简介</h2><p>LocalPush 允许 APP 向用户发送通知, 对于用户来说, 就跟远程推送是一样的, 基本没有感知, 开发者也不希望用户有感知.</p>
<p>推送效果图:</p>
<p><img src="/upload/images/2017/08/06/1.png" alt="1"></p>
<blockquote>
<p>注意: 如果你的 APP 在前台, 发送 LocalPush 是不会要上述效果的.<br>如果在前台, 可以使用自定义的弹框来提示用户.</p>
</blockquote>
<p>LocalPush 同样需要用户授权推送的权限, 否则也无法发送成功.这个跟远程推送是一样的.</p>
<p>另外, LocalPush 需要 APP 在后台没有被挂起的情况下, 才能发送, 否则无法启用.</p>
<p>发送 LocalPush 的一个好处是不需要用户连接网络, 这个是区别于远程推送的, 因为远程推送必须要求用户连接网络的.很多单机游戏或者弱联网的游戏, 发送的推送都是 LocalPush, 而非远程推送.</p>
<p>在阅读下面内容之前, 建议大家先看看 iOS 后台模式 这篇文章.本篇也是基于这个为基础的.</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个示例, 实现的场景如下:</p>
<p>用户打开 APP, 授权了推送的权限, 用户试玩一会之后, 将 APP 退到了后台, APP 监听退到后台之后, 延时一定时间发送 LocalPush 给用户.</p>
<p>AppDelegate.m 中使用后台模式</p>
<p>关于 MZBackgroundTask 的实现, 附录给出.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class="line">    </div><div class="line">    [[MZBackgroundTask sharedTask] startTask];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>ViewController.m</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                             selector:@selector(onDidEnterBackground:)</div><div class="line">                                                 name:UIApplicationDidEnterBackgroundNotification</div><div class="line">                                               object:nil];</div><div class="line">&#125;</div><div class="line">- (void)onDidEnterBackground:(NSNotification *)notification &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;);</div><div class="line">    </div><div class="line">    // 等待 6s 后, 这个时间可以根据具体情况去修改, 这里只是模拟</div><div class="line">    int delta = 6;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;);</div><div class="line">        </div><div class="line">        if (UIApplicationStateBackground == [UIApplication sharedApplication].applicationState) &#123;</div><div class="line">            UILocalNotification *notification = [UILocalNotification new];</div><div class="line">            notification.alertBody = @&quot;走, 去high吧!&quot;;</div><div class="line">            notification.soundName = UILocalNotificationDefaultSoundName;</div><div class="line">            // 应用图标上面显示的数字</div><div class="line">            notification.applicationIconBadgeNumber = notification.applicationIconBadgeNumber + 1;</div><div class="line">            // 可以自定义数据</div><div class="line">            notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;;</div><div class="line">            </div><div class="line">            [[UIApplication sharedApplication] scheduleLocalNotification:notification];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">        	// 显示自定义弹框等</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 APP 点击 Home 键退到后台, 6s 后可以看到推送的效果.</p>
<p>点击推送的提示框, 再次打开了 APP, 会执行 AppDelegate 中的方法, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App push. notification: %@&quot;, notification);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印出来的 notification, 如下图所示:</p>
<p><img src="/upload/images/2017/08/06/2.jpg" alt="1"></p>
<p>其中, user_info 是我们自定义的数据部分.</p>
<p>附录</p>
<blockquote>
<p>MZBackgroundTask 实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">#import &quot;MZBackgroundTask.h&quot;</div><div class="line"></div><div class="line">@implementation MZBackgroundTask</div><div class="line"></div><div class="line">+ (instancetype)sharedTask &#123;</div><div class="line">    </div><div class="line">    static MZBackgroundTask *_task;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _task = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return _task;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)startTask &#123;</div><div class="line">    </div><div class="line">    if (![self _checkSupportBackgroundTask]) &#123;</div><div class="line">        MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIApplication *application = [UIApplication sharedApplication];</div><div class="line">    </div><div class="line">    __block UIBackgroundTaskIdentifier taskId;</div><div class="line">    </div><div class="line">    /// 申请后台执行</div><div class="line">    /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟</div><div class="line">    &#123;</div><div class="line">        taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123;</div><div class="line">            </div><div class="line">            MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining);</div><div class="line">            </div><div class="line">            [application endBackgroundTask:taskId];</div><div class="line">            </div><div class="line">            taskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (UIBackgroundTaskInvalid == taskId) &#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;);</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// 可以监控后台任务剩余的时间, 针对业务可以去处理</div><div class="line">    &#123;</div><div class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">            </div><div class="line">            while (true) &#123;</div><div class="line">                // 剩余可以后台执行的时间</div><div class="line">                NSTimeInterval remainedTime = application.backgroundTimeRemaining;</div><div class="line">                MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime);</div><div class="line">                </div><div class="line">                if (remainedTime &lt; 2) &#123;</div><div class="line">                    // 可以告诉其他业务, 后台任务即将结束了</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                // 睡眠(延时)1s</div><div class="line">                [NSThread sleepForTimeInterval:1.f];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            /// 这里可以做一些清除工作</div><div class="line">            &#123;</div><div class="line">                // clean up</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            [application endBackgroundTask:taskId];</div><div class="line">            </div><div class="line">            taskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private.</div><div class="line"></div><div class="line">/**</div><div class="line"> *  当前设备是否支持后台任务.</div><div class="line"> *</div><div class="line"> *  @return YES, 支持后台任务. 否则, 不支持后台任务.</div><div class="line"> */</div><div class="line">- (BOOL)_checkSupportBackgroundTask &#123;</div><div class="line">    </div><div class="line">    SEL sel = @selector(isMultitaskingSupported);</div><div class="line">    BOOL supportBTask = [[UIDevice currentDevice] respondsToSelector:sel];</div><div class="line">    </div><div class="line">    return supportBTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APNs 远程推送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS APNs: 远程推送]]></title>
      <url>/2017/08/06/iOS-APNs-%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本篇博文, 你首先需要知道的内容:</p>
<blockquote>
<p>1.了解过 Push.<br>2.阅读过 [iOS 后台模式] 这篇文章.<br>3.申请过苹果证书或者知道如何申请和制作证书.<br>4.iOS 开发基本知识.</p>
</blockquote>
<p>你在这篇博文将会学到:</p>
<blockquote>
<p>1.Push 的发展历程.<br>2.开源推送工具 NWPusher 的使用.<br>3.Push 的基本原理.</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APNs, 苹果推送通知服务. 全称是: Apple Push Notification Service.</p>
<p>推送指的是由 APNs 服务器、ProviderService、iOS 系统、App 构成的通讯系统，也是移动互联网与传统的 Web 最明显不同的.</p>
<p>官方有比较详细的文档介绍, 可以戳这里 <a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1" target="_blank" rel="noopener">官方文档</a> 查看.</p>
<p>苹果的文档写的确实好, 但是作为程序员, 最重要的还是要结合理论去实践.</p>
<p>本篇结合自己的实践和对推送的理解, 跟大家分享一下推送相关的知识.</p>
<h2 id="Push-发展历程"><a href="#Push-发展历程" class="headerlink" title="Push 发展历程"></a>Push 发展历程</h2><p>iOS 历经很多版本, 一直在优化或者说是进化推送相关的内容, 无论是从实用性和技术上来看, 推送是至关重要的.</p>
<p>看一下 push 发展历程</p>
<ul>
<li><p>iOS 3 - 引入推送通知 UIApplication 的 registerForRemoteNotificationTypes 与 UIApplicationDelegate 的 application(:didRegisterForRemoteNotificationsWithDeviceToken:)，application(:didReceiveRemoteNotification:)</p>
</li>
<li><p>iOS 4 - 引入本地通知 scheduleLocalNotification，presentLocalNotificationNow:， application(_:didReceive:)</p>
</li>
<li><p>iOS 5 - 加入通知中心页面</p>
</li>
<li><p>iOS 6 - 通知中心页面与 iCloud 同步</p>
</li>
<li><p>iOS 7 - 后台静默推送 application(_:didReceiveRemoteNotification:fetchCompletionHandle:)</p>
</li>
<li><p>iOS 8 - 重新设计 notification 权限请求，Actionable 通知 registerUserNotificationSettings(:)，UIUserNotificationAction 与 UIUserNotificationCategory，application(:handleActionWithIdentifier:forRemoteNotification:completionHandler:) 等</p>
</li>
<li><p>iOS 9 - Text Input action，基于 HTTP/2 的推送请求 UIUserNotificationActionBehavior，全新的 Provider API 等</p>
</li>
<li><p>iOS 10- 支持Images, GIFs, Audio and Video类型, 并且有 Notification Service Extension 与 Notification Content Extension，可以实现推送数据在展示前进行下载更新、定制通知 UI, 并且统一了通知类型，具有时间间隔通知、地理位置通知和日历通知.</p>
</li>
</ul>
<p>该系列博客共分为几个部分:</p>
<ul>
<li>iOS APNs: 远程推送(本篇)</li>
<li><a href="http://www.veryitman.com/2017/08/06/iOS-APNs-%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 本地推送</a></li>
<li><a href="http://www.veryitman.com/2017/08/07/iOS-APNs-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">iOS APNs: 处理数据</a></li>
<li><a href="http://www.veryitman.com/2018/02/06/iOS-APNs-%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81/" target="_blank" rel="noopener">iOS APNs: 静默推送</a></li>
<li><a href="http://www.veryitman.com/2018/02/08/iOS-APNs-Background-Fetch/" target="_blank" rel="noopener">iOS APNs: Background Fetch</a></li>
</ul>
<p>如果需要完整源码的, 可以通过邮件联系我(veritman@126.com), 后续完成后会上传到 github.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先看官方的流程图, 如下所示:</p>
<p><img src="/upload/images/2017/08/05/1.jpg" alt="1"></p>
<p>该流程图, 主要说明的是自己 业务服务器(Provider) 推送消息到用户(Client APP) 的流程.</p>
<p>注意: 这里说的以及本文后面说的 业务服务器, 统一指的是可以向 APNs 发送推送消息的服务器.</p>
<p>下面这张图是比较完整的一张流程图, 自己画的, 凑合看吧!</p>
<p><img src="/upload/images/2017/08/05/2.jpg" alt="1"></p>
<p>大概流程, 我详细说一下.</p>
<p>1.iOS 设备启动后连接网络, 会与苹果服务器建立一个安全的长连接.<br>这个是系统维护的, 这也是推送的关键.<br>2.用户打开 app, 授权了推送通知的权限.<br>3.授权成功后, APNs 会将 deviceToken 返回给 iOS 终端.<br>4.终端将该 deviceToken 返回给指定的 APP.<br>5.APP 拿到 deviceToken 上传给我们自己的业务服务器.<br>6.业务服务器向 APNs 发送推送请求, 带上 deviceToken.<br>7.APNs 推送内容到指定的 iOS 终端.<br>8.iOS 终端将内容推送给用户.</p>
<p>关于 deviceToken 后面会讲.</p>
<h2 id="关于-deviceToken"><a href="#关于-deviceToken" class="headerlink" title="关于 deviceToken"></a>关于 deviceToken</h2><p>这里简单介绍一下 deviceToken.</p>
<blockquote>
<p>deviceToken 是 NSData 类型的数据, 是苹果服务器根据 设备,证书等信息和一定算法生成的.<br>需要将这个 deviceToken 传送给我们的服务器端, 这样一个用户对象就绑定了一个 deviceToken.<br>当需要给用户推送消息, 通过自己的业务服务器, 找用户对应的 deviceToken 和要发送的推送内容, 发送到苹果的 APNs, 然后 APNs 将消息推送到该 deviceToken 对应的手机上.</p>
</blockquote>
<p>关于 deviceToken 是否可变的问题</p>
<p>网上有些人说, deviceToken 是可变的, 有些人说, deviceToken 是不可变的, 我也不知道他们到底有没有实践过, 今天我要告诉大家的是, deviceToken 是可变的.</p>
<p>如卸载重装 app, deviceToken 会变. 我的设备 iphone6, iOS10.3.</p>
<p>下面是我实验的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">第一次安装运行得到的 deviceToken</div><div class="line"></div><div class="line">&lt;4e0f2928 5be0700c=&quot;&quot; 296bf7f1=&quot;&quot; 3b0837e4=&quot;&quot; bc9da6d1=&quot;&quot; 9fdb672e=&quot;&quot; f87446be=&quot;&quot; 1c098431=&quot;&quot;&gt;</div><div class="line">卸载后, 第一次安装运行得到的 deviceToken</div></pre></td></tr></table></figure>
<p>这说明, deviceToken 是可变的.</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>上面基本都是一些理论知识, 下面结合代码, 具体实现.</p>
<h3 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h3><p>在写代码之前, 需要配置一下工程.关于如何创建带有 push 功能的苹果证书的操作, 大家自行去网上学习, 这里不赘述.</p>
<p>不过这里要提醒一点, 创建的证书一定要和自己项目的 appid 保持一致, 否则无法推送.</p>
<p>这个 Demo 工程的名字是 MZPush.</p>
<p>安装好证书, 打开工程, 并能让工程识别到.</p>
<p>切换到 Target, 点击 Capabilities 选项.</p>
<p>步骤1: 配置 Push, 打开开关即可.</p>
<p><img src="/upload/images/2017/08/05/3.jpg" alt="1"></p>
<p>配置后台模式, 打开开关, 选中Remote notifications.</p>
<p><img src="/upload/images/2017/08/05/4.jpg" alt="1"></p>
<p>不过这一步, 不是必须的, 如果你不配置, 工程会有警告.我建议是选上, 在后面的博文中, 再仔细说说这个东西的好处.</p>
<p>警告信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You&apos;ve implemented -[&lt;UIApplicationDelegate&gt; application:didReceiveRemoteNotification:fetchCompletionHandler:], </div><div class="line">but you still need to add &quot;remote-notification&quot; to the list of your supported UIBackgroundModes in your Info.plist.</div></pre></td></tr></table></figure>
<p>步骤2: 配置完这一步后,在 Info.plist 中可以看到多了一项内容:</p>
<p><img src="/upload/images/2017/08/05/5.jpg" alt="1"></p>
<p>步骤3: 配置工程最小兼容版本</p>
<p><img src="/upload/images/2017/08/05/6.jpg" alt="1"></p>
<p>因为我要兼容 iOS7, 所以在 Xcode8 中, 自己手动改为了 7.0.</p>
<p>步骤4: 关闭 Bitcode(可选操作)</p>
<p><img src="/upload/images/2017/08/05/7.jpg" alt="1"></p>
<p>步骤5: 配置支持 HTTP(可选操作)</p>
<p>在 Info.plist 中, 添加如下:</p>
<p><img src="/upload/images/2017/08/05/8.jpg" alt="1"></p>
<h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p>询问用户授权的实现</p>
<p>该实现兼容了 iOS7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (void)applyPushPermission &#123;</div><div class="line">    </div><div class="line">    UIApplication *application = [UIApplication sharedApplication];</div><div class="line">    </div><div class="line">    if (MZSysVersion &lt;= 7.0) &#123;</div><div class="line">        UIRemoteNotificationType nType = UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound;</div><div class="line">        [application registerForRemoteNotificationTypes:nType];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        UIUserNotificationType nType =  UIUserNotificationTypeBadge|UIUserNotificationTypeSound|UIUserNotificationTypeAlert;</div><div class="line">        UIUserNotificationSettings *nSettings = [UIUserNotificationSettings settingsForTypes:nType categories:nil];</div><div class="line">        [application registerUserNotificationSettings:nSettings];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于用户授权, 分几种情况来看待.</p>
<p>情景一. 用户不允许 APP 推送, 即不授权.</p>
<p>Appdelegate 代理调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App push. notificationSettings: %@&quot;, notificationSettings);</div><div class="line">    </div><div class="line">    [application registerForRemoteNotifications];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error</div></pre></td></tr></table></figure>
<p>error 信息大概如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error Domain=NSCocoaErrorDomain Code=3000 &quot;未找到应用程序的“aps-environment”的授权字符串&quot;</div><div class="line">UserInfo=&#123;NSLocalizedDescription=未找到应用程序的“aps-environment”的授权字符串&#125;</div></pre></td></tr></table></figure>
<p>情景二. 用户允许授权了, 又分为两种情况</p>
<p>1.使用具有 push 功能的证书</p>
<p>一定要有带有 push 功能的证书.</p>
<p>代理调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App push. notificationSettings: %@&quot;, notificationSettings);</div><div class="line">    </div><div class="line">    [application registerForRemoteNotifications];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法大概在上面回调 1s 后才会调用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App push. deviceToken: %@&quot;, deviceToken);</div><div class="line">    </div><div class="line">    // 格式化该数据</div><div class="line">    NSString *deviceTokenStr = [NSString stringWithFormat:@&quot;%@&quot;, deviceToken];</div><div class="line">    deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;];</div><div class="line">    deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;];</div><div class="line">    deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</div><div class="line">    MZLOG(@&quot;App push. deviceToken string: %@&quot;, deviceTokenStr);</div><div class="line">    </div><div class="line">    // 可以上传该 token 到自己的业务服务器</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 didRegisterForRemoteNotificationsWithDeviceToken 方法中可以得到 deviceToken 信息:</p>
<p><img src="/upload/images/2017/08/05/9.jpg" alt="1"></p>
<p>注意: 代码中将 NSData 的 deviceToken 转换为了 NSString 类型的数据类型.</p>
<p>2.使用一般的证书, 没有 push 功能的证书</p>
<p>这种情况和 <code>情景一</code> 一样.</p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>万事俱备, 只欠东风了.</p>
<p>今天没有准备搭建一个自己的业务服务器去推送, 可以使用推送工具来替代.</p>
<p>安装 <a href="https://github.com/noodlewerk/NWPusher" target="_blank" rel="noopener">NWPusher</a> 这个工具, 可以进行推送测试.</p>
<p>安装成功后, 打开这个 Mac APP, 填写相关信息.</p>
<p>点击 push 即可推送.</p>
<p><img src="/upload/images/2017/08/05/10.jpg" alt="1"></p>
<p>在 Appdelegate 中的代理回调中, 可以打印推送内容.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App push. userInfo: %@&quot;, userInfo);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>推送的内容, 如下图所示.</p>
<p><img src="/upload/images/2017/08/05/11.jpg" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    aps =     &#123;</div><div class="line">        alert = &quot;Testing.. (6)&quot;;</div><div class="line">        badge = 1;</div><div class="line">        sound = default;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>1.<a href="https://onevcat.com/2016/08/notification/" target="_blank" rel="noopener">活久见的重构 - iOS 10 UserNotifications 框架解析
</a></p>
<p>2.<a href="http://www.jianshu.com/p/ace1b422bad4" target="_blank" rel="noopener">国内 90%以上的 iOS 开发者，对 APNs 的认识都是错的
</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 推送 APNs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 后台模式]]></title>
      <url>/2017/07/30/iOS-%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="应用状态"><a href="#应用状态" class="headerlink" title="应用状态"></a>应用状态</h2><p>来自苹果开发者文档 The App Life Cycle 的图.</p>
<p><img src="/upload/images/2017/07/30/Background1.jpg" alt="1"></p>
<p>下面这张图说明了应用程序的状态, 如下所示:</p>
<p><img src="/upload/images/2017/07/30/Background2.jpg" alt="1"></p>
<p>具体的说一下这5中状态:</p>
<p>1.Not running</p>
<blockquote>
<p>未运行, 程序没启动或者被系统被用户杀死</p>
</blockquote>
<p>2.Inactive</p>
<blockquote>
<p>未激活, 程序在前台运行，不过没有接收到事件.<br>在没有事件处理情况下程序通常停留在这个状态.</p>
</blockquote>
<p>3.Active</p>
<blockquote>
<p>激活, 程序在前台运行而且接收到了事件.<br>这也是前台的一个正常的模式</p>
</blockquote>
<p>4.Backgroud</p>
<blockquote>
<p>后台, 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会.<br>时间到之后会进入挂起状态(Suspended). 有的程序经过特殊的请求后可以长期处于 Backgroud 状态.</p>
</blockquote>
<p>5.Suspended</p>
<blockquote>
<p>挂起, 程序在后台不能执行代码.<br>系统会自动把程序变成这个状态而且不会发出通知.<br>当挂起时, 程序还是停留在内存中的, 当系统内存低时, 系统就把挂起的程序清除掉, 为前台程序提供更多的内存.</p>
</blockquote>
<p>关于 Backgroud 状态, 是我们今天要说的重点部分.</p>
<h2 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h2><p>iOS 的多任务是在 iOS4 的时候被引入的，在此之前 iOS 的 APP 都是按下 Home 键就被干掉了.<br>iOS4 虽然引入了后台和多任务，但是实际上是伪多任务，一般的 APP 后台并不能执行自己的代码，只有少数几类服务在通过注册后可以真正在后台运行，并且在提交到 AppStore 的时候也会被严格审核是否有越权行为，这种限制主要是出于对于设备的续航和安全两方面进行的考虑.之后经过iOS5 和 iOS6 的逐渐发展，后台能运行的服务的种类虽然出现了增加，但是 iOS 后台的本质并没有变化.<br>在iOS7之前，系统所接受的应用多任务可以大致分为几种：</p>
<ul>
<li>后台完成某些花费时间的特定任务.</li>
<li>后台播放音乐等.</li>
<li>位置服务.</li>
<li>IP电话(VOIP).</li>
<li>Newsstand.</li>
</ul>
<p>iOS7 后台任务申请的最长时间 10分钟.<br>iOS8+ 后台任务申请最长时间 3分钟.</p>
<h2 id="示例-APP-退到后台会被挂起"><a href="#示例-APP-退到后台会被挂起" class="headerlink" title="示例: APP 退到后台会被挂起"></a>示例: APP 退到后台会被挂起</h2><p>今天跟大家分享的是一般应用如何在后台延长生命周期的知识, 关于其他特殊的 App 如上面提到的5中情况, 不是今天讨论的重点.</p>
<p>我们先看一个例子, 例子很简单.</p>
<blockquote>
<p>这里要说明一下概念, 直接锁屏和点击 Home 键, 都会导致应用处于后台模式, 这里为了说明问题, 统一点<br>击 Home 作为代名词.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];    </div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                             selector:@selector(onDidEnterBackground:)</div><div class="line">                                                 name:UIApplicationDidEnterBackgroundNotification</div><div class="line">                                               object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)onDidEnterBackground:(NSNotification *)notification &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;);</div><div class="line">    </div><div class="line">    int delta = 1;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;);</div><div class="line">        </div><div class="line">        UILocalNotification *notification = [UILocalNotification new];</div><div class="line">        notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3];</div><div class="line">        notification.alertBody = @&quot;走, 去high吧!&quot;;</div><div class="line">        notification.soundName = UILocalNotificationDefaultSoundName;</div><div class="line">        // 可以自定义数据</div><div class="line">        notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;;</div><div class="line">        </div><div class="line">        [[UIApplication sharedApplication] scheduleLocalNotification:notification];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UIApplicationDidEnterBackgroundNotification</code> 可以监听到用户将 APP 退到后台.</p>
<p>当 APP 退到后台, 会调用 onDidEnterBackground 这个方法.</p>
<p>在 onDidEnterBackground 这个方法中, 我故意延时执行代码, 这里使用的是 dispatch_after.</p>
<p>编译运行这个工程, 运行成功后, 可以点击 Home 键将应用退到后台.</p>
<p>可以在 Xcode 的控制台看到 App Background. Enter onDidEnterBackground. 的打印信息, 但是迟迟不见 dispatch_after 里面的代码执行.</p>
<p>这里说明, APP 退到后台后被系统挂起了.</p>
<p>另外一个例子就是使用 NSTimer, 在 APP 退到后台后, 也会被终止.</p>
<p>完整例子, 一会在文章后台附录给出.</p>
<h2 id="通过后台模式延长-APP-运行"><a href="#通过后台模式延长-APP-运行" class="headerlink" title="通过后台模式延长 APP 运行"></a>通过后台模式延长 APP 运行</h2><p>上面的例子充分说明了, 在我们没有做任何处理的情况下, iOS 系统在 APP 退到后台的情况下, 会被系统挂起, 从而终止 APP 的代码行为.</p>
<p>下面通过实例, 来开启后台任务, 让 APP 尽可能的延长声明周期.</p>
<p>在工程的基础上, 新建一个文件 <code>MZBackgroundTask</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface MZBackgroundTask : NSObject</div><div class="line">+ (instancetype)sharedTask;</div><div class="line">- (void)startTask;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>具体实现, 只给出关键代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">- (void)startTask &#123;</div><div class="line">    </div><div class="line">    if (![self _checkSupportBackgroundTask]) &#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIApplication *application = [UIApplication sharedApplication];</div><div class="line">    </div><div class="line">    __block UIBackgroundTaskIdentifier taskId;</div><div class="line">    </div><div class="line">    /// 申请后台执行</div><div class="line">    /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟</div><div class="line">    &#123;</div><div class="line">        taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123;</div><div class="line">            </div><div class="line">            MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining);</div><div class="line">            </div><div class="line">            [application endBackgroundTask:taskId];</div><div class="line">            </div><div class="line">            taskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (UIBackgroundTaskInvalid == taskId) &#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;);</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// 可以监控后台任务剩余的时间, 针对业务可以去处理</div><div class="line">    &#123;</div><div class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">            </div><div class="line">            __block NSTimeInterval remainedTime;</div><div class="line">            </div><div class="line">            while (true) &#123;</div><div class="line">                </div><div class="line">                // 剩余可以后台执行的时间</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    </div><div class="line">                    // application.backgroundTimeRemaining 必须在主线程获取</div><div class="line">                    remainedTime = application.backgroundTimeRemaining;</div><div class="line">                    </div><div class="line">                    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                       </div><div class="line">                        MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime);</div><div class="line">                        </div><div class="line">                        if (remainedTime &lt; 10) &#123;</div><div class="line">                            </div><div class="line">                            // 可以告诉其他业务, 后台申请的时间即将结束了</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        if (remainedTime &lt; 2) &#123;</div><div class="line">                            </div><div class="line">                            /// 这里可以做一些清除工作</div><div class="line">                            &#123;</div><div class="line">                                // clean up</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            [application endBackgroundTask:taskId];</div><div class="line">                            </div><div class="line">                            taskId = UIBackgroundTaskInvalid;</div><div class="line">                            </div><div class="line">                            return;</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        // 睡眠(延时)1s</div><div class="line">                        [NSThread sleepForTimeInterval:1.f];</div><div class="line">                    &#125;);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>startTask 开启后台任务.</p>
<p>在 AppDelegate 中, 调用这个方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class="line">    </div><div class="line">    [[MZBackgroundTask sharedTask] startTask];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次运行工程, 可以根据日志看出, 之前的 dispatch_after 和 timer 可以运行了, 并且可以运行3分钟(180s).</p>
<p>根据 backgroundTimeRemaining 这个属性, 可以看出具体的后台可执行的剩余时间.</p>
<p><img src="/upload/images/2017/07/30/Background3.jpg" alt="1"></p>
<p>注意: 我测试的时候使用的是 iOS10 设备.</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>除了苹果规定的几种类型(如定位, 录音, VOIP 等)的应用外, 其他 APP 想申请更多的后台驻留时间, 就需要一些 <code>旁门左道</code> 的方法了.</p>
<p>苹果对后台操作做了这么多限制, 也是从用户的角度出发, 如安全, 省电, 省流量等.</p>
<p>比如, 在后台播放没有声音的音乐.</p>
<p>再比如, 申请定位服务的权限, 这样也可以保持 APP 在后台不被挂起.<br>但是, 依照苹果一贯的审核做法来看，如果声明了需要某项后台权限，你却没有相关实现的话，会直接被拒掉的.</p>
<p>这些是技术上的实现, 我没有推荐大家这么干, 现在苹果审核比以前还要严格, 大家还是悠着点干吧.如果你的 APP 不需要上架到 AppStore 的话, 就尽情的放纵吧…</p>
<h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p>1.<a href="http://www.jianshu.com/p/50ff7a3a0fcd" target="_blank" rel="noopener">iOS实现无限后台background的方法</a></p>
<p>2.<a href="https://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="noopener">WWDC 2013 Session笔记 - iOS7中的多任务</a></p>
<p>iOS 在后台的时候如果不使用后台模式, socket 也会被系统关闭连接, 比如我们使用的 IM 功能.<br>使用后台模式后, 向系统申请的时间(3分钟内), socket 还是没有被关闭的, 除非断网或者被路由器给断开了, 在申请的这段时间内, socekt 还是可以使用的, 如果想持续的保持 socket 连接, 就需要去了解一下 VOIP Socket 相关的知识了, 实践过后, 分享给大家.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>下面是具体的实现代码.</p>
<blockquote>
<p>ViewController.m</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                             selector:@selector(onDidEnterBackground:)</div><div class="line">                                                 name:UIApplicationDidEnterBackgroundNotification</div><div class="line">                                               object:nil];</div><div class="line">    </div><div class="line">    // 每隔一秒执行一次</div><div class="line">    _timer = [NSTimer scheduledTimerWithTimeInterval:1</div><div class="line">                                              target:self</div><div class="line">                                            selector:@selector(onTimerDidRun:)</div><div class="line">                                            userInfo:nil repeats:YES];</div><div class="line">    </div><div class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Callback.</div><div class="line"></div><div class="line">- (void)onTimerDidRun:(id)sender &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App Background. Timer Running.&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)onDidEnterBackground:(NSNotification *)notification &#123;</div><div class="line">    </div><div class="line">    MZLOG(@&quot;App Background. Enter onDidEnterBackground.&quot;);</div><div class="line">    </div><div class="line">    int delta = 1;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delta * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;App Background. Enter onDidEnterBackground diapatch.&quot;);</div><div class="line">        </div><div class="line">        UILocalNotification *notification = [UILocalNotification new];</div><div class="line">        notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:3];</div><div class="line">        notification.alertBody = @&quot;走, 去high吧!&quot;;</div><div class="line">        notification.soundName = UILocalNotificationDefaultSoundName;</div><div class="line">        // 可以自定义数据</div><div class="line">        notification.userInfo = @&#123;@&quot;user_info_key&quot;: @&quot;user_info_value_json_str&quot;&#125;;</div><div class="line">        </div><div class="line">        [[UIApplication sharedApplication] scheduleLocalNotification:notification];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - SetupViews.</div><div class="line"></div><div class="line">- (void)_setupViews &#123;</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor purpleColor];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>MZBackgroundTask.m</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">#import &quot;MZBackgroundTask.h&quot;</div><div class="line"></div><div class="line">@implementation MZBackgroundTask</div><div class="line"></div><div class="line">+ (instancetype)sharedTask &#123;</div><div class="line">    </div><div class="line">    static MZBackgroundTask *_task;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _task = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return _task;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)startTask &#123;</div><div class="line">    </div><div class="line">    if (![self _checkSupportBackgroundTask]) &#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;BackgroundTask. Current device don&apos;t support backgroundTask.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIApplication *application = [UIApplication sharedApplication];</div><div class="line">    </div><div class="line">    __block UIBackgroundTaskIdentifier taskId;</div><div class="line">    </div><div class="line">    /// 申请后台执行</div><div class="line">    /// 注意: 在iOS7和该版本前，后台可以用下面的的方式在后台存活5-10分钟，在iOS8及后，最多存活3分钟</div><div class="line">    &#123;</div><div class="line">        taskId = [application beginBackgroundTaskWithName:NSStringFromClass([self class]) expirationHandler:^&#123;</div><div class="line">            </div><div class="line">            MZLOG(@&quot;BackgroundTask. BackgroundTask is Over. The remained time: %f&quot;, application.backgroundTimeRemaining);</div><div class="line">            </div><div class="line">            [application endBackgroundTask:taskId];</div><div class="line">            </div><div class="line">            taskId = UIBackgroundTaskInvalid;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (UIBackgroundTaskInvalid == taskId) &#123;</div><div class="line">        </div><div class="line">        MZLOG(@&quot;BackgroundTask. Apply backgroundTask failed.&quot;);</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// 可以监控后台任务剩余的时间, 针对业务可以去处理</div><div class="line">    &#123;</div><div class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">            </div><div class="line">            __block NSTimeInterval remainedTime;</div><div class="line">            </div><div class="line">            while (true) &#123;</div><div class="line">                </div><div class="line">                // 剩余可以后台执行的时间</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    </div><div class="line">                    // application.backgroundTimeRemaining 必须在主线程获取</div><div class="line">                    remainedTime = application.backgroundTimeRemaining;</div><div class="line">                    </div><div class="line">                    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                       </div><div class="line">                        MZLOG(@&quot;BackgroundTask. The remained time: %f&quot;, remainedTime);</div><div class="line">                        </div><div class="line">                        if (remainedTime &lt; 10) &#123;</div><div class="line">                            </div><div class="line">                            // 可以告诉其他业务, 后台申请的时间即将结束了</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        if (remainedTime &lt; 2) &#123;</div><div class="line">                            </div><div class="line">                            /// 这里可以做一些清除工作</div><div class="line">                            &#123;</div><div class="line">                                // clean up</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            [application endBackgroundTask:taskId];</div><div class="line">                            </div><div class="line">                            taskId = UIBackgroundTaskInvalid;</div><div class="line">                            </div><div class="line">                            return;</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        // 睡眠(延时)1s</div><div class="line">                        [NSThread sleepForTimeInterval:1.f];</div><div class="line">                    &#125;);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private.</div><div class="line"></div><div class="line">/**</div><div class="line"> *  当前设备是否支持后台任务.</div><div class="line"> *</div><div class="line"> *  @return YES, 支持后台任务. 否则, 不支持后台任务.</div><div class="line"> */</div><div class="line">- (BOOL)_checkSupportBackgroundTask &#123;</div><div class="line">    </div><div class="line">    SEL sel = @selector(isMultitaskingSupported);</div><div class="line">    BOOL supportBTask = [[UIDevice currentDevice] respondsToSelector:sel];</div><div class="line">    </div><div class="line">    return supportBTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后台模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Charles]]></title>
      <url>/2017/07/23/%E4%BD%BF%E7%94%A8-Charles/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Charles 是 Mac 上面比较好用的抓包工具.</p>
<p>在使用微信登录 SDK 的时候, 我想看看微信请求的内容, 以及其授权过程, 发现只要连接 Charles, 跳转到微信之后无法打开微信的授权登录页面, 提示网络不可用.</p>
<p>经过研究, 是需要使用 Charles 配置 HTTPS, 配置完成后, 就可以随心所欲了.</p>
<p>所以, 今天跟大家分享一下 Charles 使用的两个点:</p>
<ul>
<li>Charles 的 HTTPS 配置.</li>
<li>使用 Charles 模拟(慢)网络.</li>
</ul>
<h2 id="工具和系统"><a href="#工具和系统" class="headerlink" title="工具和系统"></a>工具和系统</h2><ul>
<li>iPhone: iOS 10.3.</li>
<li>Mac OS: 10.12.5.</li>
<li>Charles: 4.0.2.</li>
</ul>
<h2 id="抓取-HTTPS-请求"><a href="#抓取-HTTPS-请求" class="headerlink" title="抓取 HTTPS 请求"></a>抓取 HTTPS 请求</h2><p><strong>1.Mac 安装证书</strong></p>
<blockquote>
<p>打开 Charles, 在 Help 选项中选择 SSL Proxying, 如下图所示:</p>
</blockquote>
<p><img src="/upload/images/2017/07/23/1.jpg" alt="1"></p>
<p><strong>2.Mac 信任证书</strong></p>
<blockquote>
<p>打开 Keychain Access (钥匙串), 找到刚才安装的证书, 信任证书, 如图:</p>
</blockquote>
<p><img src="/upload/images/2017/07/23/2.jpg" alt="1"></p>
<p><strong>3.给 iPhone 安装证书</strong></p>
<blockquote>
<p>打开 Charles, 在 Help 选项中选择 SSL Proxying, 操作如图:</p>
</blockquote>
<p><img src="/upload/images/2017/07/23/3.jpg" alt="1"></p>
<p>在弹出的对话框中, 可以看到 <code>chls.pro/ssl</code></p>
<p><img src="/upload/images/2017/07/23/4.jpg" alt="1"></p>
<p>手机设置代理, 连接 Charles</p>
<blockquote>
<p>一定要记住: 手机一定要设置代理, 否则安装证书会失败.</p>
</blockquote>
<p>打开手机的 Safari 浏览器, 输入 <code>chls.pro/ssl</code> 这个地址.</p>
<p><img src="/upload/images/2017/07/23/5.jpg" alt="1"></p>
<p>设置信任证书, 如下图:</p>
<p><img src="/upload/images/2017/07/23/6.jpg" alt="1"></p>
<p><img src="/upload/images/2017/07/23/7.jpg" alt="1"></p>
<h2 id="模拟任意网络"><a href="#模拟任意网络" class="headerlink" title="模拟任意网络"></a>模拟任意网络</h2><p>Charles 给我们提供了可以模拟任何网速的网络环境的条件.</p>
<p><img src="/upload/images/2017/07/23/8.jpg" alt="1"></p>
<p>打开 Throttle Settings, 然后 Enable Throttling</p>
<p><img src="/upload/images/2017/07/23/9.jpg" alt="1"></p>
<p>可以看到很多类型的网络供你选择.</p>
<p>Add Preset 可以自己自定义一个网络环境.</p>
<p>这个功能非常实用, 可以让我们模拟慢网络环境, 更好地调试自己的程序.</p>
<h2 id="遇到麻烦"><a href="#遇到麻烦" class="headerlink" title="遇到麻烦"></a>遇到麻烦</h2><p>1.抓取 HTTPS 的请求出现错误</p>
<p>错误日志如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SSLHandshake: Received fatal alert: unknown_ca</div><div class="line">Charles Proxy will even offer a helpful suggestion:</div><div class="line">You may need to configure your browser or application to trust the Charles Root Certificate. See SSL Proxying in the Help menu.</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2017/07/23/10.jpg" alt="1"></p>
<p>这种错误一般是出现在 iOS10 上面.</p>
<p>请在关于本机里面再设置一次 证书信任设置, 即可.</p>
<p><img src="/upload/images/2017/07/23/11.jpg" alt="1"></p>
<p>2.系统升级后, 设置的 HTTPS 抓包失效</p>
<p>按照上述方法, 重新设置一次即可.</p>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Charles MacOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocos2d-js: 在 iOS 上运行]]></title>
      <url>/2017/07/23/Cocos2d-js-%E5%9C%A8-iOS-%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>在我的博文 <a href="http://www.veryitman.com/2017/05/14/2017-05-14-Cocos2d-js-%E9%A6%96%E6%AC%A1%E5%9C%A8-Mac-%E4%B8%8A%E9%9D%A2%E8%BF%90%E8%A1%8C/" target="_blank" rel="noopener">Cocos2d-js: 首次在 Mac 上面运行</a> 这篇文章中, 介绍了 Cocos2d 相关的知识, 并且使用Cocos2dx 创建了一个 JS 的简单游戏项目.</p>
<p>今天跟大家分享一下, 如何在 ios 设备上面运行一个 JS 游戏项目.</p>
<p>该游戏项目(贪吃蛇)来自网络资源, 只供演示使用, 不提供任何关于游戏的资源.</p>
<h2 id="当初的想当然"><a href="#当初的想当然" class="headerlink" title="当初的想当然"></a>当初的想当然</h2><p>在 Mac 上面 so easy 的编译并运行了 JS 游戏, 我想在 iOS 设备上应该也很简单的就可以运行起来, 但是我发现我简单不加思考的想法, 是行不通的.</p>
<p>博文 <a href="http://www.veryitman.com/2017/05/14/2017-05-14-Cocos2d-js-%E9%A6%96%E6%AC%A1%E5%9C%A8-Mac-%E4%B8%8A%E9%9D%A2%E8%BF%90%E8%A1%8C/" target="_blank" rel="noopener">Cocos2d-js: 首次在 Mac 上面运行</a> 在 FireFox 浏览器上面可以直接运行 <code>index.html</code>, 但是在 Chrome 浏览器上面就没那么顺利.</p>
<p>想到这里, 我就受到了启发, 莫非 iOS 设备上面需要自己搭建一套 Web Server?</p>
<h2 id="搭建-Web-Server"><a href="#搭建-Web-Server" class="headerlink" title="搭建 Web Server"></a>搭建 Web Server</h2><p>既然想到了这一步, 接下来就是找方案实施了.</p>
<p><a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="noopener">CocoaHTTPServer</a> 这个可以满足我的需求, 于是, 我就直接拿来使用了.</p>
<p>项目中, 我使用了 Cocoapods 来管理第三方库.在 podfile 中直接添加下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;CocoaHTTPServer&apos;, &apos;~&gt; 2.3&apos;</div></pre></td></tr></table></figure>
<p>然后 pod install 即可.</p>
<p>1.在 ViewController 中导入头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;HTTPServer.h&gt;</div><div class="line">ViewController 声明部分</div><div class="line"></div><div class="line">@interface ViewController () &lt;WKNavigationDelegate&gt;</div><div class="line">@property (nonatomic, strong) WKWebView *webView;</div><div class="line">@property (nonatomic, strong) HTTPServer *localHttpServer;</div><div class="line">@property (nonatomic, strong) WKWebViewConfiguration *wbConfig;</div><div class="line">//用于调试的 UILabel</div><div class="line">@property (nonatomic, strong) IBOutlet UILabel *loadingLb;</div><div class="line">@property (nonatomic, assign) BOOL startServerSuccess;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>2.配置 Web Server</p>
<p>核心实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> - (void)_configLocalHttpServer</div><div class="line">&#123;</div><div class="line">    NSString *webPath = [[NSBundle mainBundle] pathForResource:@&quot;crazySnake&quot; ofType:nil];</div><div class="line">    _localHttpServer = [[HTTPServer alloc] init];</div><div class="line">    [_localHttpServer setType:@&quot;_http.tcp&quot;];</div><div class="line">    </div><div class="line">    NSFileManager *fileManager = [[NSFileManager alloc] init];</div><div class="line">    NSLog(@&quot;%@&quot;, webPath);</div><div class="line">    </div><div class="line">    if (![fileManager fileExistsAtPath:webPath]) &#123;</div><div class="line">        NSLog(@&quot;File path error!&quot;);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        NSString *webLocalPath = webPath;</div><div class="line">        [_localHttpServer setDocumentRoot:webLocalPath];</div><div class="line">        NSLog(@&quot;webLocalPath:%@&quot;, webLocalPath);</div><div class="line">        [self _startWebServer];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)_startWebServer</div><div class="line">&#123;</div><div class="line">    self.loadingLb.hidden = NO;</div><div class="line">    </div><div class="line">    NSError *error;</div><div class="line">    if ([_localHttpServer start:&amp;error]) &#123;</div><div class="line">        NSLog(@&quot;Started HTTP Server on port %hu&quot;, [_localHttpServer listeningPort]);</div><div class="line">        self.port = [NSString stringWithFormat:@&quot;%d&quot;, [_localHttpServer listeningPort]];</div><div class="line">        </div><div class="line">        self.loadingLb.text = @&quot;Start Server Successfully.&quot;;</div><div class="line">        </div><div class="line">        _startServerSuccess = YES;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        NSLog(@&quot;Error starting HTTP Server: %@&quot;, error);</div><div class="line">        </div><div class="line">        self.loadingLb.text = @&quot;Start Server failed.&quot;;</div><div class="line">        </div><div class="line">        _startServerSuccess = NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_configLocalHttpServer</code> 是配置 HTTPServer 的方法, <code>_startWebServer</code> 是开启 Web Server 的方法.</p>
<p>这样调用 <code>_configLocalHttpServer</code> 就可以开启在设备上面开启一个 Web Server 了.</p>
<h2 id="Xcode-导入-JS-游戏项目"><a href="#Xcode-导入-JS-游戏项目" class="headerlink" title="Xcode 导入 JS 游戏项目"></a>Xcode 导入 JS 游戏项目</h2><p>首先看一下我的工程和资源目录结构, 如图:</p>
<p><img src="/upload/images/2017/07/23/2_1.jpg" alt="1"></p>
<p>仔细看一下, <code>crazySnake</code> 这个文件夹是蓝色的, 不是黄色的.</p>
<p>这里特别注意, 导入这个 crazySnake 文件夹的时候, Options 一定要选择 <code>Create folder reference</code>.</p>
<p>为什么要这么做?</p>
<p>细心的朋友可以发现, 使用 <code>Create folder reference</code>导入的文件夹, 在项目打包生成的 archive 的文件中(自己可以解压看)是可以看到 crazySnake 这个文件夹的, 如果不是这种方式, 而是使用 Create groups 方式(在 Xcode 中显示黄色), 在 archive 中是看不到 crazySnake 这个文件夹的, 而是将里面的文件打散放在 archive 的根目录下面了.</p>
<blockquote>
<p>总之, 一句话, <code>Create folder reference</code> 方式导入的文件夹在打包后还是原来的文件夹, 不会将文件夹里面的文件打散.</p>
</blockquote>
<p>试想一下, 如果多加入几个这样的目录, 都打散在根目录下面, 我们就不好管理这个文件夹里面的文件了.</p>
<h2 id="配置-WKWebView"><a href="#配置-WKWebView" class="headerlink" title="配置 WKWebView"></a>配置 WKWebView</h2><blockquote>
<p>这里我使用了 WKWebView 而不是 UIWebView 作为加载 HTML 的容器.<br>当然, 你也可以使用 UIWebView.</p>
</blockquote>
<p>主要的核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.navigationController.navigationBarHidden = YES;</div><div class="line">    </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        self.loadingLb.text = @&quot;Config server...&quot;;</div><div class="line">        [self _configLocalHttpServer];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    /// 增加的调式方法: 可以重新启动 web server.</div><div class="line">    &#123;</div><div class="line">        SEL sel = @selector(_configLocalHttpServer);</div><div class="line">        UITapGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] initWithTarget:self</div><div class="line">                                                                                  action:sel];</div><div class="line">        [self.loadingLb addGestureRecognizer:gesture];</div><div class="line">        self.loadingLb.userInteractionEnabled = YES;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    </div><div class="line">    // 配置 WKWebView</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        _wbConfig = [[WKWebViewConfiguration alloc] init];</div><div class="line">        self.wbConfig.userContentController = [[WKUserContentController alloc] init];</div><div class="line">        </div><div class="line">        _webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:self.wbConfig];</div><div class="line">        </div><div class="line">        _webView.frame = self.view.bounds;</div><div class="line">        _webView.scrollView.showsHorizontalScrollIndicator = NO;</div><div class="line">        _webView.scrollView.showsVerticalScrollIndicator   = NO;</div><div class="line">        </div><div class="line">        [self.view addSubview:self.webView];</div><div class="line">        self.webView.frame = self.view.bounds;</div><div class="line">        self.webView.navigationDelegate = self;</div><div class="line">        </div><div class="line">        if (self.startServerSuccess) &#123;</div><div class="line">            self.loadingLb.hidden = YES;</div><div class="line">            </div><div class="line">            NSString *gameUrl = [[NSBundle mainBundle] pathForResource:@&quot;index&quot;</div><div class="line">                                                                ofType:@&quot;html&quot;</div><div class="line">                                                           inDirectory:@&quot;crazySnake&quot;];</div><div class="line">            NSURL *url = [NSURL fileURLWithPath:gameUrl];</div><div class="line">            </div><div class="line">            url = [NSURL URLWithString:[NSString stringWithFormat:@&quot;http://127.0.0.1:%@/index.html&quot;, self.port]];</div><div class="line">            [self.webView loadRequest:[NSURLRequest requestWithURL:url]];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单, 就是使用 WKWebView 加载一个 HTML 文件并启动 Web Server.</p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>接下来, 就是见证奇迹的时刻了…</p>
<p>上面配置了 Web Server 和 加载 html 的 WKWebView, 现在可以直接运行项目看效果了.</p>
<p>无论你是在模拟器还是在真机上面都可以运行这个 JS 游戏项目了.</p>
<p><img src="/upload/images/2017/07/23/2_2.jpg" alt="1"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面的例子本人亲自实践过的, 给大家提供了一个实现思路, 算是抛砖引玉.</p>
<p>如果想做好这个模式, 还需要很多工作要做, 这里列出来给大家分享一下.</p>
<blockquote>
<p>1.游戏资源包管理和下载.<br>2.游戏中需要和 Native 的交互逻辑.<br>3.数据加密.<br>4.移动端游戏本身的加载优化.</p>
</blockquote>
<p>如果你有更好的方案和想法, 我很乐意邮件 (veryitman@126.com) 与你沟通, 非常感谢!</p>
<p>代码示例我放在了 GitHub, 点击 <a href="https://github.com/veryitman/MZMWPlay" target="_blank" rel="noopener">MZMWPlay</a> 前往下载体验.</p>
]]></content>
      
        <categories>
            
            <category> Game </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cocos Cocos2d-js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android: Chrome 调试 WEB 页面]]></title>
      <url>/2017/06/01/Android-Chrome-%E8%B0%83%E8%AF%95-WEB-%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Mac OS 上面通过 Safari 调试 iOS 设备或者模拟器的 WEB 页面, 比较方便.</p>
<p>关于具体如何使用 Safari 来调试 iOS 设备, 可以参考 [Safari 的开发者模式] 这篇文章.</p>
<p>自从踏上开发的道路, 电脑上就安装了 Chrome 浏览器, 并且一直保持着更新, Chrome 以其简单设计和高效的用法吸引了大批开发者.</p>
<p>使用 Chrome 调试 Android 设备的 WEB 页面, 易如反掌.</p>
<h2 id="Chrome-调试条件"><a href="#Chrome-调试条件" class="headerlink" title="Chrome 调试条件"></a>Chrome 调试条件</h2><p>使用这项技能的条件如下:</p>
<blockquote>
<p>1.Android 设备系统最低为4.4, 也就是 android-19</p>
<p>2.Chrome 最好使用最新版本的, 以前的版本不支持, 最低兼容版本目前尚不清楚.</p>
<p>3.配置 Android WebView, 使其支持 Debug 和使能 JavaScript 功能.</p>
<p>4.设备和 PC 通过 USB 连接正常, 且支持 USB 调试的.</p>
</blockquote>
<p>我目前使用的设备和 Chrome 版本信息如下:</p>
<blockquote>
<p>Android 设备: 5.1.1版本<br>Chrome: Version 58.0.3029.110 (64-bit)</p>
</blockquote>
<p>我们在地址栏中输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chrome://inspect</div></pre></td></tr></table></figure>
<p>就可以打开设备列表界面.<br><img src="/upload/images/2017/06/01/14962450324558.jpg" alt="1"></p>
<p>可以看到我的 Android 设备已经显示出来了.</p>
<p>下面举个例子说明该调试工具的使用.</p>
<h2 id="简单的-Android-工程示例"><a href="#简单的-Android-工程示例" class="headerlink" title="简单的 Android 工程示例"></a>简单的 Android 工程示例</h2><p>该工程只有一个 Activity, 使用 WebView 加载本地 HTML 文件.</p>
<h4 id="1-创建-assets-目录"><a href="#1-创建-assets-目录" class="headerlink" title="1. 创建 assets 目录"></a>1. 创建 assets 目录</h4><p>工程切换到 Project Files 视图<br><img src="/upload/images/2017/06/01/14962453176556.jpg" alt="1"></p>
<p>这样就可以在 src/main 目录下新建了 assets 文件夹了.</p>
<h4 id="2-创建-HTML-文件"><a href="#2-创建-HTML-文件" class="headerlink" title="2. 创建 HTML 文件"></a>2. 创建 HTML 文件</h4><blockquote>
<p>该 HTML 文件, 命名为 local.html, 放在 assets 目录下面.</p>
</blockquote>
<p>local.html 源文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;</div><div class="line">&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p&gt;A function is triggered when the button is clicked.&lt;/p&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    function myFunction() &#123;</div><div class="line">        console.log(&apos;js console.&apos;);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h4 id="3-在-Activity-中配置-WebView"><a href="#3-在-Activity-中配置-WebView" class="headerlink" title="3.在 Activity 中配置 WebView."></a>3.在 Activity 中配置 WebView.</h4><p>Activity.java 源文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class MZWebPage extends AppCompatActivity &#123;</div><div class="line">    private WebView webView;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_mzweb_page);</div><div class="line">        webView = (WebView) this.findViewById(R.id.ui_web_view);</div><div class="line">        // 设置 WebView 的 Debug 为可用状态</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            WebView.setWebContentsDebuggingEnabled(true);</div><div class="line">        &#125;</div><div class="line">        WebSettings settings = webView.getSettings();</div><div class="line">        </div><div class="line">        // 设置 JavaScript 可以使用, 否则在 HTML 中无法调用 JavaScript 代码</div><div class="line">        settings.setJavaScriptEnabled(true);</div><div class="line">        // 本地文件</div><div class="line">        String url = &quot;file:///android_asset/local.html&quot;;</div><div class="line">        webView.loadUrl(url);</div><div class="line">        webView.setWebViewClient(new WebViewClient() &#123;</div><div class="line">            @Override</div><div class="line">            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</div><div class="line">                return super.shouldOverrideUrlLoading(view, request);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        // 设置渲染视图</div><div class="line">        webView.setWebChromeClient(new WebChromeClient());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的 xml 布局文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    tools:context=&quot;demo.droidsdk.near.idreamsky.com.nearsdk.MZWebPage&quot;&gt;</div><div class="line">    &lt;WebView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:id=&quot;@+id/ui_web_view&quot;&gt;</div><div class="line">    &lt;/WebView&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<h4 id="4-运行程序"><a href="#4-运行程序" class="headerlink" title="4. 运行程序"></a>4. 运行程序</h4><p>在 Chrome 中输入 chrome://inspect 打开, 可以看到正在运行的 local.html.<br><img src="/upload/images/2017/06/01/14962458882973.jpg" alt="1"></p>
<p>点击 <code>inspect</code>, 进入调试界面.</p>
<p>在调试界面, 点击页面的 Click me, 按钮, 对应的会有 log 输出.<br><img src="/upload/images/2017/06/01/14962459967493.jpg" alt="1"></p>
<h4 id="5-调试出错的-HTML"><a href="#5-调试出错的-HTML" class="headerlink" title="5.调试出错的 HTML"></a>5.调试出错的 HTML</h4><p>修改一下 local.html 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;</div><div class="line">&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;p&gt;A function is triggered when the button is clicked.&lt;/p&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    function myFunction() &#123;</div><div class="line">        console.log(&apos;js console.&apos; + var_error);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>这里可以看出 <code>var_error</code> 是一个不存在的变量.</p>
<p>重新运行, 点击 Click me, 可以看到右侧的 error:<br><img src="/upload/images/2017/06/01/14962461463698.jpg" alt="1"></p>
<p>关于 Chrome 开发者工具的更多使用, 可以参考官方文档 <a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn" target="_blank" rel="noopener">Chrome 开发者工具</a>.</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Chrome Web Debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[保持你的好习惯]]></title>
      <url>/2017/05/29/%E4%BF%9D%E6%8C%81%E4%BD%A0%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF/</url>
      <content type="html"><![CDATA[<p><img src="/upload/images/2017/05/29/1.jpeg" alt="1"></p>
<p>明天就是传统的端午节了, 提前祝大家端午安康!</p>
<p>今天老婆让我帮忙把粽叶子洗洗, 说要包粽子, 我听话地把刚买来的粽叶子洗了个干净, 那都是带有绿色的叶子, 生机勃勃, 让我从指尖中感到无比的温馨和无尽的希望.</p>
<p>小的时候, 我很享受妈妈为我们包粽子的过程, 说实话, 我不是很喜欢吃粽子, 但是特别喜欢粽子锅里面的煮鸡蛋, 特别美味.</p>
<p>老家的粽子没有什么特色, 就是简简单单的糯米被包在叶子中, 然后放在锅里慢慢的煮, 熟了之后, 蘸点白糖就可以吃了.</p>
<p>到了南方之后, 我才发现世界上原来有各种各样的粽子, 红枣的, 绿豆的, 猪肉馅的, 鸡肉馅的…等等!</p>
<p>这些都是偶发的回忆, 和今天的推文没有关系, 不信, 你接着往下看.</p>
<h2 id="养成阅读的习惯"><a href="#养成阅读的习惯" class="headerlink" title="养成阅读的习惯"></a>养成阅读的习惯</h2><p>我不是一个聪明的孩子, 直到小学三年级, 我才真正的开始明白学习到底是怎么一回事, 用老家人的话说算是开窍了.</p>
<p>后来我很顺利的上了初中, 家里的大部分收入要靠庄家, 一年四季能够风调雨顺的话, 也能过个不错的年, 至少能把学费给交上.</p>
<p>初中二年级的时候, 我辍学了, 也许是命运的安排吧, 当时自己也没有多想, 毅然决定下学去寻找另一种人生.</p>
<p>于是, 我选择了理发这个行业. 和师傅在风风雨雨中度过了一年多的时间, 在当时的农村, 不上学有门手艺也算是对自己和父母有个交代.</p>
<p>我的内心仍然渴望去上学, 虽然不知道为什么要去上学也不知道上学后能干什么, 但是心里面总是觉得自己不能放弃学业.在理发的一年多时间里, 我没有放弃过学习.<br>冥冥之中自有安排, 妈妈有次问我: “还想去上学不?”, 我想都没想就情不自禁的点头了, 妈妈又说:”我就知道你没有放弃, 去继续上学吧, 不要留下遗憾!”.当时的我甭提有多高兴了.</p>
<p>再次回到校园的我比以前更加努力和拼命了, 更加懂得如何珍惜这来之不易的学习机会了.</p>
<p>直到大学毕业, 参加工作以及有了孩子后, 我也能保持自我学习和自我激励的状态, 保持好的阅读习惯, 让我受益终身.</p>
<p>有次孩子早晨起床忙完后, 就开始坐在那里看书, 有好几次晚上, 我也发现他洗完澡后, 坐在那里看书, 或者是做手工, 或是画画.</p>
<p>我感到很好奇, 决定找个机会问问他.</p>
<p>有一个周末的上午, 早餐过后, 我就把他拉到身边, 和他一起看儿童读物, 问他:”宝贝, 你为什么喜欢看书呢?”, 他说:”爸爸, 是你影响了我, 你喜欢看书, 我也喜欢看书.”, 看着他一副天真的样子, 我真的不敢相信几岁的孩子能说出这样的话, 但我内心感到无比的欣慰.原来好的习惯会传染给自己身边的人, 并且能让你感到自豪.</p>
<h2 id="坚持写博客"><a href="#坚持写博客" class="headerlink" title="坚持写博客"></a>坚持写博客</h2><p>写博客或者是生活日记, 确实很”浪费”时间, 甚至会占用你任何休息的时间, 写博客偶尔也会让你抓耳挠腮, 感叹:”书到用时方恨少”!</p>
<p>所以, 读, 写不能分家, 更应该是将二者紧密的联合在一起.<br>多阅读多写, 才会让你更加的通透, 当然了, 我只是喜欢写, 写的质量也很一般, 只是为了满足内心的那一点点对知识的渴望.</p>
<p>写的多了, 你就更加愿意去思考了, 思考多了, 很多事情你就看开了, 对你的生活和工作都有好处.</p>
<p>从09年到现在我一直坚持写博客, 刚开始也是无从下笔, 不知道自己到底该写一写什么东西, 写了之后, 是不是别人看了会嘲笑我, 诸如此类的担心太多太多, 后来我也想明白了, 你写的再好也有人比你写得好, 也会有人说你写的不好.那我何必去计较这么些个事儿了, 只管动手写吧!</p>
<p>然后, 就在博客网站上面耕耘, 技术的, 吐槽的, 生活的我都喜欢写, 不管你喜不喜欢看, 它都在那里, 哈哈!</p>
<p>我把博客当做自己的朋友, 心情好亦或是不好的时候, 我都会向他倾诉, 希望自己写下的东西或多或少能帮助一些人, 这也许是我坚持写博客的最大动力了.</p>
<p>如果你也喜欢写博客或者是准备写博客, 就开始动手写吧, 不要再犹豫了.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个世界上, 没多少人喜欢听别人啰嗦, 即使听了你的啰嗦, 也不一定会付出实践, 即使你是长者或者是智者, 况且我只是一介平民.</p>
<p>但是我还是要啰嗦一句:”保持持续学习的习惯, 会消耗你的勤奋, 但会让你受益终生”, 信不信由你!</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 思考 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Safari 的开发者模式]]></title>
      <url>/2017/05/15/Safari-%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="设置-Safari"><a href="#设置-Safari" class="headerlink" title="设置 Safari"></a>设置 Safari</h2><p>1.打开 Safari 的 Preference<br><img src="/upload/images/2017/05/15/14948249631231.jpg" alt="1"></p>
<p>2.切换到 Advanced 选项<br><img src="/upload/images/2017/05/15/14948250437147.jpg" alt="1"></p>
<p>将 <code>Show Develop menu in menu bar</code> 选中.</p>
<p>可以看到 Safari 多了 Develop 选项<br><img src="/upload/images/2017/05/15/14948254198174.jpg" alt="1"></p>
<h2 id="设置设备或者模拟器"><a href="#设置设备或者模拟器" class="headerlink" title="设置设备或者模拟器"></a>设置设备或者模拟器</h2><h3 id="在-iphone或者模拟器-中设置-Safari"><a href="#在-iphone或者模拟器-中设置-Safari" class="headerlink" title="在 iphone或者模拟器 中设置 Safari"></a>在 iphone或者模拟器 中设置 Safari</h3><h4 id="打开-Safari-的高级选项"><a href="#打开-Safari-的高级选项" class="headerlink" title="打开 Safari 的高级选项"></a>打开 Safari 的高级选项</h4><p><img src="/upload/images/2017/05/15/14948252328005.jpg" alt="1"></p>
<h4 id="打开-Web-检查器"><a href="#打开-Web-检查器" class="headerlink" title="打开 Web 检查器"></a>打开 Web 检查器</h4><p><img src="/upload/images/2017/05/15/14948252717169.jpg" alt="1"></p>
<p>上面设置完毕后, 运行你的程序, 在 Safari 的 Develop 中可以看到对应设备, 从而可以调试 HTML 页面了.<br><img src="/upload/images/2017/05/15/14948259031169.jpg" alt="1"></p>
<p>在调试窗口中，可以看到当前正在加载网页的各种信息，如源码、请求头、图片、加载的资源与脚本、控制台输出等.</p>
<p>也可以直接修改网页的 CSS 样式和布局等进行修改，而不用重新运行 App.<br><img src="/upload/images/2017/05/15/14948635711574.jpg" alt="1"></p>
<p>使用 Safari 的开发者模式, 可以帮助我们调试前端页面, 解决一些问题, 比较方便.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS Safari </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS: 自定义 UIWebView 和 WKWebView 的 UserAgent]]></title>
      <url>/2017/05/14/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89-UIWebView-%E5%92%8C-WKWebView-%E7%9A%84-UserAgent/</url>
      <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>在 iOS8, 苹果推出了 WKWebView, 目的很明显: 取代 UIWebView.</p>
<p>随着时间的推移, 越来越多的应用开始最低版本支持为 iOS8, 大家也纷纷的开始使用 WKWebView 组件.</p>
<p>在 iOS10.x 版本上, UIWebView 的表现不尽如人意, 在我们的后台日志和用户反馈, 存在很多莫名其妙的 crash 以及卡顿现象, 内存飙升等问题. 针对不同的 JS 游戏引擎, UIWebView 表现也不够好, 所以是时候使用 WKWebView 了.</p>
<p>但是话又说回来, 如果你最低版本支持 iOS8, 也不能完全放弃 UIWebView, WKWebView 有一部分 API 只有 iOS9+ 才有, 如果你的应用在 iOS8 运行而使用 iOS9 的 API, 肯定会 crash.</p>
<p>例如:</p>
<blockquote>
<p>1.清除缓存.<br>2.设置 user-agent.</p>
</blockquote>
<p>今天要说的是关于设置自定义 UIWebView 和 WKWebView 的 UserAgent 问题.</p>
<h2 id="WKWebView-UserAgent"><a href="#WKWebView-UserAgent" class="headerlink" title="WKWebView UserAgent"></a>WKWebView UserAgent</h2><h4 id="默认的-UserAgent"><a href="#默认的-UserAgent" class="headerlink" title="默认的 UserAgent"></a>默认的 UserAgent</h4><p>使用下面的代码, 可以输出 WKWebView 的默认 UserAgent.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidload </div><div class="line">&#123;</div><div class="line">	[self.wkWebView evaluateJavaScript:@&quot;navigator.appName&quot; completionHandler:^(id __nullable appName, NSError * __nullable error) &#123;</div><div class="line">        NSLog(@&quot;navigator.appName: %@&quot;, appName);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [self.wkWebView evaluateJavaScript:@&quot;navigator.userAgent&quot; completionHandler:^(id __nullable userAgent, NSError * __nullable error) &#123;</div><div class="line">    	NSLog(@&quot;navigator.userAgent: %@&quot;, userAgent);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>navigator.appName 无论在 iOS8, iOS9 还是 iOS10, 输出结果都是一致的.</p>
<p>navigator.userAgent 在不同的 iOS 系统上面输出结果略有不同.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// iOS 8.3</div><div class="line">// Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12F70</div><div class="line">// iOS 9.0</div><div class="line">// Mozilla/5.0 (iPhone; CPU iPhone OS 9_0 like Mac OS X) AppleWebKit/601.1.32 (KHTML, like Gecko) Mobile/13A4254v</div><div class="line">// iOS 10.x</div><div class="line">//Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E269</div></pre></td></tr></table></figure>
<h4 id="自定义-UserAgent"><a href="#自定义-UserAgent" class="headerlink" title="自定义 UserAgent"></a>自定义 UserAgent</h4><p>修改默认的 UserAgent, 需要使用下面的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.wkWebView.customUserAgent = @&quot;CustomUserAgent&quot;</div></pre></td></tr></table></figure>
<p>这样, 就改变了其默认的 UserAgent 值了.</p>
<p>特别需要注意: customUserAgent 是 iOS9 之后才有的字段.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*! @abstract The custom user agent string or nil if no custom user agent string has been set.</div><div class="line">*/</div><div class="line">@property (nullable, nonatomic, copy) NSString *customUserAgent API_AVAILABLE(macosx(10.11), ios(9.0));</div></pre></td></tr></table></figure>
<p>所以在 iOS8.x, 如果你想改变 UserAgent, 还是要使用 UIWebView.</p>
<h2 id="HTML-使用-UserAgent"><a href="#HTML-使用-UserAgent" class="headerlink" title="HTML 使用 UserAgent"></a>HTML 使用 UserAgent</h2><p>HTML 中可以根据自定义的 UserAgent, 做出不同的行为, 如自定的 UserAgent 可以包括应用的版本号, HTML 可以根据不同的版本来做版本区分等逻辑.</p>
<p>在 HTML 中, 可以使用 JS 来获取 UserAgent 的值.</p>
<p>Demo.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;utf-8&quot; /&gt;</div><div class="line">        &lt;title&gt;user-agent&lt;/title&gt;</div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            function getUserAgent() &#123;</div><div class="line">                var ug = navigator.userAgent;</div><div class="line">                document.getElementById(&quot;mySpan&quot;).innerHTML = ug;</div><div class="line">            &#125;</div><div class="line">        &lt;/script&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;h1&gt;显示 user-agent&lt;/h1&gt;</div><div class="line">        &lt;p&gt;&lt;span style=&quot;font-size:30px&quot; id=&quot;mySpan&quot;&gt;..&lt;/span&gt;&lt;/p&gt;</div><div class="line">        &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;点击显示 user-agent&quot; onclick=&quot;getUserAgent()&quot;  class=&quot;button&quot;/&gt;&lt;/p&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    </div><div class="line">    &lt;style&gt;</div><div class="line">        .button &#123;</div><div class="line">            background-color: #4C0950;</div><div class="line">            border: none;</div><div class="line">            color: white;</div><div class="line">            padding: 15px 32px;</div><div class="line">            text-align: center;</div><div class="line">            text-decoration: none;</div><div class="line">            display: inline-block;</div><div class="line">            font-size: 40px;</div><div class="line">            margin: 20px 200px 100px 300px;</div><div class="line">            cursor: pointer;</div><div class="line">            border-radius: 15;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>使用 WKWebView 加载该 Demo.html 文件, 效果图如下:<br><img src="/upload/images/2017/05/14/webView.jpg" alt="1"></p>
<h2 id="UIWebView-UserAgent"><a href="#UIWebView-UserAgent" class="headerlink" title="UIWebView UserAgent"></a>UIWebView UserAgent</h2><h4 id="默认的-UserAgent-1"><a href="#默认的-UserAgent-1" class="headerlink" title="默认的 UserAgent"></a>默认的 UserAgent</h4><p>使用下面的代码, 可以输出 UIWebView 的默认 UserAgent.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *appName = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.appName&quot;];</div><div class="line">NSLog(@&quot;navigator.appName: %@&quot;, appName);</div><div class="line">    </div><div class="line">NSString *userAgent = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];</div><div class="line">NSLog(@&quot;navigator.userAgent %@&quot;, userAgent);</div></pre></td></tr></table></figure>
<p>打印输出结果和 WKWebView 的结果一致.</p>
<h4 id="设置自定的-UserAgent"><a href="#设置自定的-UserAgent" class="headerlink" title="设置自定的 UserAgent"></a>设置自定的 UserAgent</h4><p>设置一个 key 为 @”UserAgent” 的本地存储即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:@&#123;@&quot;UserAgent&quot;:@&quot;CustomUserAgent-UIWebView&quot;&#125;];</div><div class="line">    </div><div class="line">NSString *appName = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.appName&quot;];</div><div class="line">NSLog(@&quot;navigator.appName: %@&quot;, appName);</div><div class="line">    </div><div class="line">NSString *userAgent = [self.webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];</div><div class="line">NSLog(@&quot;navigator.userAgent %@&quot;, userAgent);</div></pre></td></tr></table></figure>
<p>这样就改变了 UIWebView 的默认 UserAgent 了.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>应用最低版本支持 iOS7/8 的开发者们, 可以考虑 UIWebView 和 WKWebView 并存的开发模式. iOS9及以上的开发者你们, 可以完全放弃 UIWebView, 大胆的拥抱 WKWebView 了.</p>
<p>移植 UIWebView 到 WKWebView 的成本不算大.<br>如果你现在有时间, 可以开始着手做这些事了.前端和客户端需要考虑之前交互那部分的逻辑, 即 JS 调用 Native 或者 Native 调用 JS 的需要做些调整, 因为 WKWebView 的调用方式和 UIWebView 不一样了, 前端页面要考虑版本兼容性.</p>
<p>新的 WKWebView 虽然存在一些坑, 但是使用它亦是大势所趋, 正所谓 存在即合理, 你没有理由拒绝它.</p>
<p>后续, 我会写一写在 WKWebView 上面遇到的一些问题, 分享给大家.</p>
<p>之前我也写过一篇文章, 是关于 UIWebView 缓存的, 不妨, 你也瞅瞅 [iOS: 聊聊 UIWebView 缓存].</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UIWebView WKWebView UserAgent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocos2d-js: 首次在 Mac 上面运行]]></title>
      <url>/2017/05/14/Cocos2d-js-%E9%A6%96%E6%AC%A1%E5%9C%A8-Mac-%E4%B8%8A%E9%9D%A2%E8%BF%90%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h2 id="Cocos2d-js-介绍"><a href="#Cocos2d-js-介绍" class="headerlink" title="Cocos2d-js 介绍"></a>Cocos2d-js 介绍</h2><p>如果你是刚接触 Cocos2d-js 开发的人, 一定会被 Cocos2d-js 和 Cocos2d-HTML5 以及 Cocos2d-x 搞得晕头转向.</p>
<p>下面简单介绍一下 Cocos2d-js 的前世今生.</p>
<p>目前 Cocos2d-x 支持使用 C++、Lua、Javascript 语言来进行开发，且内置 JavaScript 引擎，通过 C++ 解析 Javascript 去执行.</p>
<p>Cocos2d-HTML5 是使用 JavaScript 进行开发，最终运行在浏览器里的.</p>
<p>v3.0 后，Cocos2d-HTML5 和 Cocos2d-x JSBinding 被合到了一起，称作 Cocos2d-JS.</p>
<p>与 Cocos2d-HTML5 不同的是，Cocos2d-js 开发的程序不仅能运行在浏览器里，还能编译运行在 Mac OSX, Windows, iOS, Android 平台上.</p>
<p>从 Cocos2d-x v3.7 版本之后, js 版本被合并到 Cocos2d-x 中了.</p>
<p>具体可以看 <a href="https://github.com/cocos2d/cocos2d-x/blob/cocos2d-x-3.7/docs/RELEASE_NOTES.md" target="_blank" rel="noopener">Release Note</a> 这个说明.</p>
<p>这个版本的发布日期是在2015年7月21.</p>
<p>原来的 Cocos2d-js 版本在 [GitHub] 上面已经停止更新了.</p>
<p>说明如下:</p>
<blockquote>
<p>2/27/2016 - This repository is no longer active.<br>Cocos2d-JS was merged with Cocos2d-x starting at version 3.7.</p>
</blockquote>
<p>可以看出, Cocos2d-js 原来独立的项目被合并到了 Cocos2d-x 中了.</p>
<p>现在使用 Cocos2d-x 不仅可以创建 cpp 项目和 lua 项目, 也可以创建 js 项目了.</p>
<p>官方有说明的:</p>
<blockquote>
<p>Cocos2d-JS is Cocos2d-x engine’s JavaScript version that includes Cocos2d-html5 and Cocos2d-x JavaScript Bindings.</p>
</blockquote>
<p>至于什么是 Cocos2d-x JavaScript Bindings, 大家自行 google, 这里不赘述.</p>
<p>关系图大概如下:<br><img src="/upload/images/2017/05/14/3.png" alt="1"></p>
<p>Cocos2d-x 框架图<br><img src="/upload/images/2017/05/14/4.jpg" alt="1"></p>
<h2 id="搭建-Cocos2d-js-开发环境"><a href="#搭建-Cocos2d-js-开发环境" class="headerlink" title="搭建 Cocos2d-js 开发环境"></a>搭建 Cocos2d-js 开发环境</h2><h4 id="1-下载-Cocos2d-x"><a href="#1-下载-Cocos2d-x" class="headerlink" title="1.下载 Cocos2d-x"></a>1.下载 Cocos2d-x</h4><p>可以在官网下载最新的 Release 包, 点击 下载地址, 我下载的最新包是 cocos2d-x-3.15.</p>
<p>下载解压即可, 这里我把 cocos2d-x-3.15 修改为 cocos2d-x.</p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>在 cocos2d-x 目录, 执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py</div></pre></td></tr></table></figure>
<p>执行完毕后, 可以看到 ‘~/.bash_profile` 的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Add environment variable COCOS_CONSOLE_ROOT for cocos2d-x</div><div class="line">export COCOS_CONSOLE_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/tools/cocos2d-console/bin</div><div class="line">export PATH=$COCOS_CONSOLE_ROOT:$PATH</div><div class="line"># Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-x</div><div class="line">export COCOS_TEMPLATES_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/templates</div><div class="line">export PATH=$COCOS_TEMPLATES_ROOT:$PATH</div></pre></td></tr></table></figure>
<p>这里, 没有看到我的 <code>ANT_ROOT</code> 路径, 其实该脚本智能的找到 <code>/usr/local/Cellar/ant/1.9.7/bin</code>, 但是我不想使用这个 ant, 想使用自己下载的 ant, 修改该文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Add environment variable COCOS_CONSOLE_ROOT for cocos2d-x</div><div class="line">export COCOS_CONSOLE_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/tools/cocos2d-console/bin</div><div class="line">export PATH=$COCOS_CONSOLE_ROOT:$PATH</div><div class="line"># Add environment variable ANT_ROOT for cocos2d-x</div><div class="line">export ANT_ROOT=/Users/mark/developer/apache/apache-ant-1.10.1/bin</div><div class="line">export PATH=$ANT_ROOT:$PATH</div><div class="line"># Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-x</div><div class="line">export COCOS_TEMPLATES_ROOT=/Users/mark/workspace/mzProjs/c2dx/cocos2d-x/templates</div><div class="line">export PATH=$COCOS_TEMPLATES_ROOT:$PATH</div></pre></td></tr></table></figure>
<p>最后执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>使环境变量立即生效.</p>
<h4 id="创建-js-工程"><a href="#创建-js-工程" class="headerlink" title="创建 js 工程"></a>创建 js 工程</h4><p>cd 到任意目录, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cocos new HelloJs -l js -d .</div></pre></td></tr></table></figure>
<blockquote>
<p>new HelloJs 表示工程名字为 HelloJs<br>-l js 表示创建 js 工程.<br>-d . 表示在当前路径创建该工程</p>
</blockquote>
<p>可以看到下面创建工程的过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Copy template into /Users/mark/workspace/mzProjs/c2dx/works/HelloJs</div><div class="line">Copying directory from cocos root directory...</div><div class="line">Copying files from template directory...</div><div class="line">Copying Cocos2d-x files...</div><div class="line">Rename project name from &apos;HelloJavascript&apos; to &apos;HelloJs&apos;</div><div class="line">Replace the project name from &apos;HelloJavascript&apos; to &apos;HelloJs&apos;</div><div class="line">Replace the project package name from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;</div><div class="line">Replace the Mac bundle id from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;</div><div class="line">Replace the iOS bundle id from &apos;org.cocos2dx.hellojavascript&apos; to &apos;org.cocos2dx.HelloJs&apos;</div></pre></td></tr></table></figure>
<p>工程目录:<br><img src="/upload/images/2017/05/14/1.jpg" alt="1"></p>
<h4 id="工程发布"><a href="#工程发布" class="headerlink" title="工程发布"></a>工程发布</h4><p>将上面的工程编译发布.</p>
<p>编译发布:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cocos compile -p web -m release</div></pre></td></tr></table></figure>
<blockquote>
<p>-p web 表示编译 web 平台.<br>-m release 表示编译为 release 模式.</p>
</blockquote>
<p>编译输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Building mode: release</div><div class="line">running: &apos;/Users/mark/developer/apache/apache-ant-1.10.1/bin/ant -f /Users/mark/workspace/mzProjs/c2dx/works/HelloJs/publish/html5/build.xml&apos;</div><div class="line">Buildfile: /Users/mark/workspace/mzProjs/c2dx/works/HelloJs/publish/html5/build.xml</div><div class="line">compile:</div><div class="line">   [jscomp] Compiling 156 file(s) with 42 extern(s)</div><div class="line">   [jscomp] 0 error(s), 0 warning(s)</div><div class="line">BUILD SUCCESSFUL</div><div class="line">Total time: 8 seconds</div></pre></td></tr></table></figure>
<p>如果你在这一步编译报错, 或者执行不下去, 一般都是没有在环境变量中配置好 ant.</p>
<p>编程成功后, 会多出 publish 目录:<br><img src="/upload/images/2017/05/14/2.jpg" alt="1"></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>执行 cocos run 命令来在系统默认的浏览器上面运行.</p>
<p>cd 到工程目录, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cocos run -p web -s . --port 9009</div></pre></td></tr></table></figure>
<p>这样会帮我们在本地启动一个 webServer 来运行示例, 直接打开了默认使用的浏览器.</p>
<blockquote>
<p>-s: 表示当前需要执行的源码路径<br>–port: 指定端口, 如果不指定端口, 默认在 8000 端口执行.</p>
</blockquote>
<p>更多 cocos run 命令可以, 使用下面的命令来查看帮助:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cocos run --help</div></pre></td></tr></table></figure>
<h2 id="本地运行-index-html-的问题"><a href="#本地运行-index-html-的问题" class="headerlink" title="本地运行 index.html 的问题"></a>本地运行 index.html 的问题</h2><p>你可以用火狐浏览器(FireFox)打开本地工程目录中的 index.html, 即可看到运行效果了.<br>FireFox 应该是在本地启动了一个 WebServer 来运行.</p>
<p>在 chrome 中直接运行 index.html, 无法看到最终效果, 一直卡在 loading 界面.</p>
<p>打开 inspect, 可以看到报错信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load file:/xx/publish/html5/project.json.</div><div class="line">Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</div></pre></td></tr></table></figure>
<p>网上有人讨论过过问题, 说是 chrome 跨域不支持 file 协议，那么即使你允许 chrome 跨域支持, 直接运行本地的 index.html 还是报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">game.min.js:54 Uncaught TypeError: Cannot read property &apos;modules&apos; of null</div></pre></td></tr></table></figure>
<p>在 MacOS 上面允许 chrome 跨域访问文件的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open /Applications/Google\ Chrome.app --args --allow-file-access-from-files</div></pre></td></tr></table></figure>
<p>可以看出, 在这方面, FireFox 做的比 chrome 好.</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><blockquote>
<p>更新时间 2017-10-15</p>
</blockquote>
<p>在微信公众号上面看到 <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODAxNTM2NA==&amp;mid=2659646056&amp;idx=1&amp;sn=239871c3775ae12af5edf9ac2381b0b2" target="_blank" rel="noopener">一招教你辨别 Cocos、Cocos2d、Cocos2d-x</a> 这篇文章, 大家可以看看, 对 cocos 会有更加深入的了解.</p>
]]></content>
      
        <categories>
            
            <category> Game </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cocos cocos2d-js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小小篮球队]]></title>
      <url>/2017/04/29/%E5%B0%8F%E5%B0%8F%E7%AF%AE%E7%90%83%E9%98%9F/</url>
      <content type="html"><![CDATA[<p><img src="/upload/images/2017/04/29/hua.jpeg" alt="1"></p>
<p>篮球, 我最喜欢的一项体育运动, 大学的业余时间基本都”泡”在球场, 压根不知道什么是累.</p>
<p>毕业后的第一份工作, 做的比较开心, 大家年龄相仿, 兴趣相投.</p>
<p>小小的团队, 没有任何纷争, 大家互相学习, 氛围及其融洽.</p>
<p>每个周五我们几个人都会提前下班去打一场篮球, 完事后, 一起喝点小酒, 那日子甭提有多他NND的惬意.</p>
<p>公司解散后, 大家各奔东西, 事过境迁, 各有各的工作和生活, 聚在一起的日子也是少之又少, 以前的日子只能怀念了.</p>
<p>人总需要一些非工作之外的兴趣, 整天围绕着工作, 早晚都会疯掉.</p>
<p>有些人喜欢泡泡图书馆, 有些人喜欢打打游戏, 有些人喜欢跑跑步, 有些人喜欢唱唱歌…</p>
<p>不管怎么样, 你需要某种爱好, 来润色一下你的生活, 我选择了篮球运动.</p>
<p>下面, 来说说篮球队中典型的几种人, 大家结合自己的工作和生活, 思考一下吧~</p>
<h2 id="单打独斗"><a href="#单打独斗" class="headerlink" title="单打独斗"></a>单打独斗</h2><p>篮球运动是一项集体运动, 需要每个人发挥自己应有的水平, 才能发挥团队的力量.</p>
<p>有些人喜欢单打独斗, 完全不考虑团队中其他成员的感受, 只要球到了他手中, 其他人只能看他的表演, 任凭你喊破嗓子, 他也不会理你.</p>
<p>这种人, 其实是有一定能力的人, 不然也不会也不可能这么做, 只是他们觉得凭一己之力就可以让大家高正无忧了, 自己没有思考过这样做是不是最合适的.</p>
<p>久而久之, 大家看着他的”表演”, 再也不想发挥了, 单打独斗的人慢慢的也累了, 最后大家都身心疲惫, 球队被对方轻而易举地打败.</p>
<h2 id="“指挥官”"><a href="#“指挥官”" class="headerlink" title="“指挥官”"></a>“指挥官”</h2><p>球队中有一种人, 自己不努力, 总是喜欢颐指气使, 经常听到他们说这样的话:</p>
<blockquote>
<p>你快点跑呀, 积极点…<br>死死地防着他, 不要让他进攻, 快…<br>你传球给我呀, 让你别着急, 好了吧, 输了吧…<br>输了, 都怪你…</p>
</blockquote>
<p>听到这些话, 再好脾气的人估计都难以接受, 脾气不好的直接开始打他了吧!</p>
<p>这种人最不受待见, 也最遭人唾骂, 这种人在实际工作中, 可能是你的领导.</p>
<h2 id="偷懒的"><a href="#偷懒的" class="headerlink" title="偷懒的"></a>偷懒的</h2><p>篮球运动的确很消耗体力, 如果在万箭齐发的时刻, 有人故意掉链子, 那将是功亏一篑.</p>
<p>大家在打球的时候, 都在为”荣誉”而战, 但是偏偏有人会使点小心眼, 能少跑一步就少跑一步, 能放对方走就放对方走, 绝对不伤害对方一毛一线. 明明可以稍微努力一下, 就可以拿到篮板, 偏偏让对方比自己还矮小的轻而易举的拿走了篮板.</p>
<p>要知道比自己矮小的那个人, 只是努力的跳了一下.</p>
<p>球场上虽然不是让你拼个你死我活, 不要求你全力以赴, 但是尽力而为总是要有的, 这是一种态度.</p>
<p>在实际工作中, 这种”队友”比比皆是, 但是不一定遭人恨, 有些还是很招人喜欢的, 毕竟他们没有抢你的功劳, 处处让着你, 没有他们的这些所谓的付出, 哪能衬托出你的光芒.</p>
<h2 id="鼓励你的"><a href="#鼓励你的" class="headerlink" title="鼓励你的"></a>鼓励你的</h2><p>上面说的都是一些”负能量”, 大家一笑而过吧.下面说点正能量的.</p>
<p>在球队中, 还有一种这样的人, 他会察言观色, 觉得你累了, 就告诉大家: “我们应该节奏慢一点, 缓冲一下.”,</p>
<p>当你手感不好的时候, 他会告诉你, 没事, 多来几次就好了, 不要有压力.</p>
<p>当你防守遇到困难时, 他会默默的给你补防, 给你接力, 最大程度的给你信心.</p>
<p>当大家士气不高的时候, 他会站出来投几个漂亮的球, 抑或给对方一个完美的盖帽, 并且鼓励大家不要放弃, 给大家信心, 做大家坚固的后盾.</p>
<p>这种人除了自己有一定的能力外, 还能顾全大局, 并且可以帮助队友, 帮助团队渡过难关, 确实难得.</p>
<h2 id="渴望进步的"><a href="#渴望进步的" class="headerlink" title="渴望进步的"></a>渴望进步的</h2><p>球队中, 存在一些新人, 或者是渴望自己能投出漂亮弧线球的人, 他们比不上那些资历老且经验丰富的前辈, 但是他们内心有一份信念: “我要变强!”.</p>
<p>这种人, 跟你讨论球技, 虚心向你学习一切可以提高球技的方法, 即使在观众席上, 他们也能聚精会神的观看, 自己领悟其中的奥妙. 只要你约他出来打球, 他都在第一时间出现在球场, 因为他不想放弃学习的机会.</p>
<p>久而久之, 这些人会变得越来越厉害, 通过不断的学习和摸索, 有了一套自己的打法, 步伐稳健, 再也不是那种接球不稳, 传球频频失误的”毛头小子”了.</p>
<p>这种人, 值得我们去挖掘和鼓励, 如果你正好是那个资历老且经验丰富的前辈, 就传授”真经”给他们吧.<br>对于你来说, 有人愿意跟你学习, 跟你分享, 也是美事一桩.</p>
<p>何乐而不为呢?</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不管你遇到什么样的队友, 如果你愿意, 请胸怀宇宙(当然不是 孙连城 那种啊).</p>
<p>万事万物皆有联系, 愿你能偶尔放下手中的工作, 去选择和爱上另一种乐趣.</p>
<p>五一放假了, 祝大家节日快乐!</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 思考 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS: 应用内打开 AppStore]]></title>
      <url>/2017/04/15/iOS-%E5%BA%94%E7%94%A8%E5%86%85%E6%89%93%E5%BC%80-AppStore/</url>
      <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>我们的 App 需要在 AppStore 上面打开某个 App 或者游戏, 目的最常见的有:</p>
<blockquote>
<p>1.评分评论.<br>2.推荐下载(App 或者游戏).</p>
</blockquote>
<p>很多开发者知道打开 AppStore 只需要一句代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itunes app url&quot;]];</div></pre></td></tr></table></figure>
<p>这样就很简单的打开 AppStore 了, 但是产品经理问了, 能在我们应用内打开 AppStore 吗?</p>
<p>你当时懵逼了吗?</p>
<p>不要懵逼, 以后只要遇到类似这种问题, 你就问产品经理哪个 APP 这样做了?<br>然后, 他就给你看别人家的效果, 你就理直气壮地说: “别人可以做到的, 我们也可以做到!”.</p>
<p>应用内打开 AppStore 也很简单.<br>在 iOS6之后, 苹果已经给我们提供了 <a href="https://developer.apple.com/reference/storekit/skstoreproductviewcontroller#//apple_ref/doc/c_ref/SKStoreProductViewController" target="_blank" rel="noopener">SKStoreProductViewController</a>, 大家看一下文档, 你就笑了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SKStoreProductViewController</div><div class="line">/* View controller to display iTunes Store product information */</div></pre></td></tr></table></figure>
<h2 id="应用内打开-AppStore"><a href="#应用内打开-AppStore" class="headerlink" title="应用内打开 AppStore"></a>应用内打开 AppStore</h2><p>这里我以在应用内打开 <code>微信</code> 为例子.</p>
<p>效果图如下:<br><img src="/upload/images/2017/04/15/eff_appstore_1.png" alt="1"></p>
<p>从效果图可以看出, 用户在自己的应用内打开 AppStore 后, 不仅可以下载或者打开微信, 还可以直接评论评分, 简直爽(也难怪产品经理这么干).</p>
<p>那我们说一下如何实现上面的效果.</p>
<p>实现方案和步骤</p>
<p>1.包含头文件 <code>#import &lt;StoreKit/StoreKit.h&gt;</code></p>
<p>2.实现 <code>SKStoreProductViewControllerDelegate</code></p>
<p>具体代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (void)openAppFromAppStore:(NSString *)appid</div><div class="line">&#123;</div><div class="line">	if (nil == appid || appid.length &lt;= 0) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 加个 loading</div><div class="line">	</div><div class="line">	SKStoreProductViewController *store = [[SKStoreProductViewController alloc] init];</div><div class="line">	    </div><div class="line">	    store.delegate = self;</div><div class="line">	    </div><div class="line">	    NSDictionary&lt;NSString *, id&gt; *parameters = @&#123;SKStoreProductParameterITunesItemIdentifier: appid&#125;;</div><div class="line">	</div><div class="line">	    [store loadProductWithParameters:parameters completionBlock:^(BOOL result, NSError *error) &#123;</div><div class="line">	    </div><div class="line">	        // 结束 loading</div><div class="line">	        </div><div class="line">	        if (error) &#123;</div><div class="line">	            </div><div class="line">	            NSLog(@&quot;error %@ with userInfo %@&quot;, error, [error userInfo]);</div><div class="line">	            </div><div class="line">	            // 提示用户发生了错误</div><div class="line">	            </div><div class="line">	            // 或者通过 URL 打开 AppStore App.</div><div class="line">	            </div><div class="line">	            // NSString *url = @&quot;https://itunes.apple.com/in/app/wechat/id414478124?mt=8&quot;;</div><div class="line">	            </div><div class="line">	            //[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];</div><div class="line">	        &#125;</div><div class="line">	        else &#123;</div><div class="line">	            </div><div class="line">	            [self presentViewController:store animated:YES completion:^&#123;</div><div class="line">	            &#125;];</div><div class="line">	        &#125;</div><div class="line">	    &#125;];</div><div class="line">&#125;</div><div class="line">/// 用户点击取消会执行该方法</div><div class="line">- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController</div><div class="line">&#123;</div><div class="line">    [viewController dismissViewControllerAnimated:YES completion:^&#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用(@”414478124” 是 微信 的)方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self openAppFromAppStore:@&quot;414478124&quot;];</div></pre></td></tr></table></figure>
<h2 id="修改-AppStore-的导航栏"><a href="#修改-AppStore-的导航栏" class="headerlink" title="修改 AppStore 的导航栏"></a>修改 AppStore 的导航栏</h2><p>产品经理说, 既然你已经实现了上面的功能, 看看能不能把 AppStore 的导航栏改一个牛逼的颜色, 就像上面的大红色.</p>
<p>~</p>
<p>可以, 干!</p>
<p>直接上代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)openAppFromAppStore:(NSString *)appid</div><div class="line">&#123;</div><div class="line">	if (nil == appid || appid.length &lt;= 0) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 加个 loading</div><div class="line">	</div><div class="line">	// 导航栏上面的文字和图片颜色变了</div><div class="line">	[[UINavigationBar appearance] setTintColor:[UIColor greenColor]];</div><div class="line">    </div><div class="line">    // 导航栏的大红色出来了</div><div class="line">    [[UINavigationBar appearance] setBarTintColor:[UIColor redColor]];</div><div class="line">    </div><div class="line">    [UINavigationBar appearanceWhenContainedIn:[SKStoreProductViewController class], nil];</div><div class="line">	</div><div class="line">	SKStoreProductViewController *store = [[SKStoreProductViewController alloc] init];</div><div class="line">	    </div><div class="line">	    store.delegate = self;</div><div class="line">	    </div><div class="line">	    NSDictionary&lt;NSString *, id&gt; *parameters = @&#123;SKStoreProductParameterITunesItemIdentifier: appid&#125;;</div><div class="line">	</div><div class="line">	    [store loadProductWithParameters:parameters completionBlock:^(BOOL result, NSError *error) &#123;</div><div class="line">	        </div><div class="line">	        // 结束 loading</div><div class="line">	        </div><div class="line">	        if (error) &#123;</div><div class="line">	            </div><div class="line">	            NSLog(@&quot;error %@ with userInfo %@&quot;, error, [error userInfo]);</div><div class="line">	            </div><div class="line">	            // 提示用户发生了错误</div><div class="line">	            </div><div class="line">	            // 或者通过 URL 打开 AppStore App.</div><div class="line">	        &#125;</div><div class="line">	        else &#123;</div><div class="line">	            </div><div class="line">	            [self presentViewController:store animated:YES completion:^&#123;</div><div class="line">	            &#125;];</div><div class="line">	        &#125;</div><div class="line">	    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.打开 <code>SKStoreProductViewController</code> 目前只能使用 <code>present</code> 方式, 不可以使用 <code>push</code> 的方式.</p>
<p>否则会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Terminating app due to uncaught exception &apos;SKUnsupportedPresentationException&apos;,</div><div class="line">//reason: &apos;SKStoreProductViewController must be used in a modal view controller&apos;</div></pre></td></tr></table></figure>
<p>2.加入 loading</p>
<p>在应用内打开 AppStore, 为了不让用户傻等(网络不好的时候, 打开很慢), 可以加入 loading, 缓解一下用户急躁的心情.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AppStore iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[找合伙人, 不易]]></title>
      <url>/2017/03/26/%E6%89%BE%E5%90%88%E4%BC%99%E4%BA%BA-%E4%B8%8D%E6%98%93/</url>
      <content type="html"><![CDATA[<p>早在高中时期, 读过 &lt;三言&gt; 中的 &lt;警世通言&gt;, 第一章写的是 <code>俞伯牙摔琴谢知音</code>, 讲的是钟子期和俞伯牙的故事.</p>
<p>读完之后, 整个人都觉得难受, 心理有说不出的滋味, 眼泪竟夺眶而出.</p>
<p>流传的这首诗, 可以感受下.</p>
<blockquote>
<p>摔碎瑶琴凤尾寒，子期不在对谁弹！<br>春风满面皆朋友，欲觅知音难上难。<br>势利交怀势利心，斯文谁复念知音！<br>伯牙不作钟期逝，千古令人说破琴。</p>
</blockquote>
<p>自己工作之后, 对 <code>欲觅知音难上难</code> 这句话尤为赞同.</p>
<p>年少轻狂的你, 藏着要改变世界的心, 残酷的现实会抹去你凸起的棱角, 岁月和环境会让你变得越发不安.</p>
<p>不安的世界, 让你茫然.</p>
<p>于是, 点上一支烟, 回顾折腾的人生, 笑叹: 别人笑我太疯癫, 我笑他人看不穿.</p>
<p>可惜, 我们不是唐寅, 没有这份洒脱和奔放, 毕竟时代也大相径庭.</p>
<p>~ 好了, 回到现实中来.</p>
<p>刚毕业, 你会把主要精力放在如何把工作做好, 维持自己的生计上面, 如果能跟身边的大牛学到一些专业知识, 再苦再累, 你都是开心的.</p>
<p>渐渐地, 你发现知识(专业的和非专业的知识)真是要活到老学到老, 永无止境, 无法像武侠片里面演得那样移花接木, 斗转星移. 呜呼, 脚踏实地的做好本职工作, 顺便能拓展一下自己的交际圈, 扩大自己的知识面, 还是很有必要的.</p>
<p>各行各业都有非常突出的人才, 很多时候, 我们只能望洋兴叹.</p>
<p>如果你能遇到一个肯与你分享和交流, 或者是愿意将自己的实践分享给你的人, 那你算是上辈子积了大德了. 阿弥陀佛!</p>
<p>我把这样的人称之为 <code>恩人</code>, 也算是 <code>知音</code>.</p>
<p>以前, 很多朋友会问如果将来自己开公司, 是否愿意接受现在的自己, 我的回答是一定接受. 如果还有人问这个问题, 我会另外再追加一个问题:</p>
<blockquote>
<p>如果你开公司, 你是否愿意接受和你现在一起工作的同事?或者说你是否愿意让他成为你的合伙人?</p>
</blockquote>
<p>这些问题, 看似玩笑, 实则很现实很残酷, 一旦你决定要去做成某件事情, 立志要实现自己的抱负和理想的时候, 你的立场会和其他人千差外别.首先要考虑的是要和谁一起共谋事, 才能真正的帮到自己, 并且也能帮到别人.因为选择是双向的, 能找到和你一拍即合的人, 也确实不易.但愿任何一个渴望成功并付出行动的人, 能找到自己的合伙人, 找到自己的知音.</p>
<p>真正的成功者, 不是沉浸在多少人让你成功的喜悦中, 而是你让多少人和你一起分享了成功的喜悦的人.</p>
<p>说到这里, 本人只是想说明白一个道理, 送给即将或者已经在职场奋斗的人:</p>
<blockquote>
<p>踏踏实实的做事并没有错, 但是找到值得 “托付终身” 的人确实不易, 你现在能做的只有用知识来武装自己, 让自己变强.</p>
</blockquote>
<p>在职场中, 你会遇到很多让你不爽的人或者事. 记住, 要做到 <code>对事不对人</code>, 不要太委屈自己, 大丈夫能屈能伸, 该出手时就出手, 没有什么大不了.</p>
<p>如果真的觉得有些人或者有些事不值得你浪费时间, 就离它们远点. 惹不起但可以躲得起, 你说呢?</p>
<p>酌一壶小酒, 老夫聊发少年狂!</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 思考 生活 合伙人 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[让自己变强]]></title>
      <url>/2017/03/10/%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%8F%98%E5%BC%BA/</url>
      <content type="html"><![CDATA[<p>当你读到这篇文章的时候, 我其实还不知道『怎么让自己变强』.<br>具体说, 就是没有一套让你或者让他变强的武林秘籍.</p>
<p>只能结合自己经历的事, 分享给大家, 希望能感同身受!</p>
<p>这几天加班加地有点猛, 浑然不知周末轮回了.<br>心理总是在念叨, 好久没有在公众号涂鸦了, 手痒痒了.<br>趁今晚回来早(22:30回到家), 就动笔了.</p>
<p>『让自己变强』, 这句话说着很简单, 但不是任何人都能意识到这几个字带来的力量.</p>
<p>在「明朝那些事儿」中有这么一段:</p>
<blockquote>
<p>我们经常会产生一个疑问，那就是怎样才能获得其他国家及其人民的尊重，在世界上风光自豪一把，其实答案很简单——国家强大。</p>
</blockquote>
<p>看到这里, 感触颇深.</p>
<h2 id="在团队中成长"><a href="#在团队中成长" class="headerlink" title="在团队中成长"></a>在团队中成长</h2><p>团队成长的主观条件是团队的成员要成长, 不然团队哪里来的成长.</p>
<p>如果你是作为一个团队或者小组的负责人, 会面临各种各样的问题, 比如需要跟团队以外的部门谈合作, 需要跟老板汇报工作, 还要处理内部的问题等等诸如此类!</p>
<p>我觉得安邦需安内, 也就是说要先搞定团队内部的各种事物, 人是比较复杂的感情动物, 你不好也不能控制别人的情绪. 所以, 需要对事不对人!你不能说, 你看他长得不好看, 就知道工作做不好类似的话.</p>
<p>这样一说, 基本两个人就结下了梁子.迟早会爆发.</p>
<p>首先, 要给团队成员希望, 让大家都认识到有统一的目标.</p>
<p>其次, 让每个人给出工作和实行计划, 制定自己的考核目标.对做出突出贡献的成员奖励, 每个人都需要得到尊重, 而奖励是最大的尊重.</p>
<p>最后, 加强与团队成员之间的沟通, 互相帮助, 让大家能够相互信任和鼓励, 良好有效的沟通, 事半功倍.</p>
<p>作为团队负责人, 肯定希望手下的人各个骁勇善战, 百战百胜, 但是现实中很难做到, 其实也没有必要.<br>西游记告诉我们, 唐僧带领的团队才是最好的团队.</p>
<h2 id="少埋怨多给予帮助"><a href="#少埋怨多给予帮助" class="headerlink" title="少埋怨多给予帮助"></a>少埋怨多给予帮助</h2><p>每个人生活和工作的环境不一样, 在不同的地点不同的时间面对不同的事情, 都会有不同的看法.</p>
<p>世界上任何一种选择, 都是命中注定的, 没有人能强迫你去做出任何错误的选择, 除了你自己.</p>
<p>在自己所处的环境中, 要么你能改变环境使其来适应自己, 要么就离开这个自己不适应的环境, 不要去抱怨.</p>
<p>唉声叹气, 不仅仅影响自己的工作效率和生活质量, 还会影响到别人.<br>成天在抱怨, 觉得谁谁都不行, 自己才是最牛逼的, 日行见久, 你就是那个充满负能量的人, 当别人觉悟到的时候, 就会离你而去, 岂不咎由自取?!我想这也是微信朋友圈只有点赞没有非点赞的原因吧!</p>
<p>如果觉得自己的同事或者朋友有所欠缺, 就想办法去帮助他, 鼓励他, 把你认为一些好的方式和方法传授给他. 说不定哪天因为你的一句话或者一个方法, 他就走上人生巅峰了, 哈哈!</p>
<p>从现在开始, 忘记埋怨, 给予别人更多的帮助和鼓励.</p>
<h2 id="培养自己的专注力"><a href="#培养自己的专注力" class="headerlink" title="培养自己的专注力"></a>培养自己的专注力</h2><p>专注力, 是一个很神奇的东西.</p>
<p>如果一个人没有专注力, 很难再有所突破, 据说牛顿是在做梦的时候, 发明了很多折磨广大青少年的牛顿定律的.</p>
<p>每个人在自己的行业上, 多少都有短板. 有短板是情有可原的, 但是首先你得认识到自己的短板, 然后再指定计划去突破他.</p>
<blockquote>
<p>要想进步, 必须面对自己的不足.</p>
</blockquote>
<p>比如, 工作上需要你学会某种技术, 如果在某个时间点, 你没有学会, 可能就会丢掉饭碗, 你就会不顾一切的去学习, 直到学会会用为止. 这个过程, 你就是在专注这件事情, 回头想想咬咬牙, 还是可以办到的, 没有什么大不了的.</p>
<p>每天给自己一点时间, 专注去做一件事情, 坚持下来, 你会发现, 学习和进步就是 feel feel 倍儿爽.</p>
<h2 id="最后分享给大家一句话"><a href="#最后分享给大家一句话" class="headerlink" title="最后分享给大家一句话:"></a>最后分享给大家一句话:</h2><blockquote>
<p>不能改变别人的时候, 试着改变一下自己或许就能把事情变通了.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 生活 反思 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat8 配置 HTTPS]]></title>
      <url>/2017/02/15/Tomcat8-%E9%85%8D%E7%BD%AE-HTTPS/</url>
      <content type="html"><![CDATA[<p>博客 [Tomcat8 域名配置] 介绍了如何在本地配置 Tomcat8 的域名以及通过域名来访问对应的资源.</p>
<p>今天继续跟大家分享如何配置 Tomcat8 的 HTTPS (单向认证), 本篇博客的主要内容如下:</p>
<blockquote>
<p>1.配置 Tomcat 的 HTTPS.<br>2.通过 HTTPS + ip 的方式来访问资源.<br>3.通过 HTTPS + 域名 的方式来访问资源.</p>
</blockquote>
<h2 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h2><p>1.安装了 JDK, 并配置了其相关的环境变量.可参考 Mac 配置 JDK1.8.</p>
<p>2.安装了 Tomcat8, 并配置了其相关的环境变量.可参考 Mac 配置 Tomcat8.</p>
<h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><blockquote>
<p>获取证书可以去购买, 这里是在本地机器搭建, 使用 JDK 自带的工具 keytool 生成即可.</p>
</blockquote>
<p>打开 mac 终端, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -v -genkey -alias tomcat -keyalg RSA -keystore ~/Desktop/tomcat.keystore</div></pre></td></tr></table></figure>
<p>紧接着, 会出现一些让你输入信息的交互信息, 第一个是让你输入 密钥库密码(口令), 我输入的是 1234567, 其他信息可以任意输入内容, 在最后一步, 问你生成的 密钥口令 和 密钥库的口令 是否相同, 如果相同就直接回车, 我这里是直接回车的, 即密码相同, 都是 1234567.</p>
<p>这样就生成了所谓的证书.</p>
<h2 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h2><blockquote>
<p>通过修改 server.xml 来配置.</p>
</blockquote>
<p>将 tomcat.keystore 文件复制到 Tomcat 的 conf 目录.</p>
<p>修改 server.xml 文件, 增加一个 Connector, 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;  </div><div class="line">           maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;  </div><div class="line">           clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;conf/tomcat.keystore&quot; keystorePass=&quot;1234567&quot;/&gt;</div></pre></td></tr></table></figure>
<p>注意, keystoreFile 是证书文件, keystorePass 是密码, 这里配置一定要正确.</p>
<h2 id="配置-HTTPS-IP"><a href="#配置-HTTPS-IP" class="headerlink" title="配置 HTTPS + IP"></a>配置 HTTPS + IP</h2><p>配置一个虚拟主机, 修改 server.xml 文件, 增加 Host:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;192.168.1.103&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">	&lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">	&lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
<p>配置 name=”192.168.1.103” 是你本机的 ip 地址.</p>
<p>这个在博客 [iOS: 聊聊 UIWebView 缓存] 中有详细的介绍, 这里不再赘述.</p>
<p>启动 Tomcat, 进行测试.</p>
<p>这里需要到 Tomcat 的 bin 目录下, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo startup.sh</div></pre></td></tr></table></figure>
<p>启动成功后, 打开浏览器, 输入: <a href="https://192.168.1.103:8443/test.html" target="_blank" rel="noopener">https://192.168.1.103:8443/test.html</a>, 这个时候, 会弹出如下的警告(提示不安全):<br><img src="/upload/images/2017/02/15/1.png" alt="1"></p>
<p>直接点击 Advanced 后再点击 Proceed to 192.168.1.103:8443(unsafe) 处理即可看到页面内容.</p>
<h2 id="配置-HTTPS-域名"><a href="#配置-HTTPS-域名" class="headerlink" title="配置 HTTPS + 域名"></a>配置 HTTPS + 域名</h2><p>修改 server.xml, 增加 Connector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;  </div><div class="line">          maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;  </div><div class="line">          clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;conf/tomcat.keystore&quot; keystorePass=&quot;1234567&quot;/&gt;</div></pre></td></tr></table></figure>
<p>修改 server.xml, 增加 Host:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;www.mark.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">	&lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">	&lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
<p>修改 /etc/host 文件, 增加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 www.mark.com</div></pre></td></tr></table></figure>
<p>启动 Tomcat, 在 bin 目录, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shutdown.sh</div><div class="line">sudo startup.sh</div></pre></td></tr></table></figure>
<p>启动成功后, 打开浏览器, 输入 <a href="https://www.mark.com:8443/test.html" target="_blank" rel="noopener">https://www.mark.com:8443/test.html</a>, 如果弹出警告, 可以像如上处理来显示页面内容.</p>
<p>如果你这里配置失败了, 请修改一下端口号, 如将 8443 改为 8433.<br>重启 Tomcat 在试一下.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Apache 官方文档: <a href="https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html" target="_blank" rel="noopener">ssl-howto</a></p>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tomcat Java Apache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat8 域名配置]]></title>
      <url>/2017/02/13/Tomcat8-%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>博客 [Mac 配置 Tomcat8] 介绍了在 Mac 下安装和启动 Tomcat.</p>
<p>接下来介绍, 如何在本地配置 Tomcat8 的域名.</p>
<p>网上有很多关于 Tomcat 如何配置单域名或者多域名的文章, 很多都是翻译或者复制别人的, 根本没有实践过, 害人不浅!</p>
<p>结合自己的实践, 把配置的整个过程分享给大家, 希望能帮到你.</p>
<p>下面进入正题.</p>
<h2 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h2><p>在 Tomcat 的安装(其实是解压的)目录 /conf 下有 server.xml 文件.</p>
<p>将下面内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</div><div class="line">              connectionTimeout=&quot;20000&quot;</div><div class="line">              redirectPort=&quot;8443&quot; /&gt;</div></pre></td></tr></table></figure>
<p>修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;</div><div class="line">              connectionTimeout=&quot;20000&quot;</div><div class="line">              redirectPort=&quot;8443&quot; /&gt;</div></pre></td></tr></table></figure>
<h2 id="添加-web-项目"><a href="#添加-web-项目" class="headerlink" title="添加 web 项目"></a>添加 web 项目</h2><blockquote>
<p>这一步主要是为了后面测试.</p>
</blockquote>
<p>很简单, 在 Tomcat 的安装目录 webapps 下面新建 test 文件夹, 里面创建一个 html 文件即可.<br>这里将其命名为 test.html.</p>
<p>test.html 内容见后面的附录即可.</p>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><blockquote>
<p>增加虚拟主机配置.还需要修改 server.xml 文件.</p>
</blockquote>
<p>在 server.xml 文件中, 在标签 <engine> 和</engine> 之间增加下面的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;www.mark.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">    &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">    &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
<p>其中, www.mark.com 是我自己任意取的一个域名, docBase=”test” 是指向上面新建的 test 目录.</p>
<h2 id="配置域名解析"><a href="#配置域名解析" class="headerlink" title="配置域名解析"></a>配置域名解析</h2><p>由于部署在本地, 需要修改 host.</p>
<p>修改 /etc/host 文件, 需要 sudo 权限:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/host</div></pre></td></tr></table></figure>
<p>增加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 www.mark.com</div></pre></td></tr></table></figure>
<h2 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h2><blockquote>
<p>这一步, 验证配置是否生效.</p>
</blockquote>
<p>启动 Tomcat, 这里的操作比较特殊, 需要 sudo 权限来启动 Tomcat, 否则会报下面的错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">org.apache.coyote.AbstractProtocol.init Failed to initialize end point associated with ProtocolHandler [&quot;http-nio-80&quot;]</div><div class="line"> java.net.SocketException: Permission denied</div></pre></td></tr></table></figure>
<p>因为, 只有 root 用户才可以使用 1024 以下的端口号.</p>
<p>正确姿势:</p>
<p>cd 进入 Tomcat 的 bin 目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/Tomcat/bin</div></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo startup.sh</div></pre></td></tr></table></figure>
<p>成功后, 打开浏览器, 输入 <a href="http://www.mark.com/test.html" target="_blank" rel="noopener">http://www.mark.com/test.html</a>, 即可看到页面内容.</p>
<h2 id="配置另一个域名"><a href="#配置另一个域名" class="headerlink" title="配置另一个域名"></a>配置另一个域名</h2><p>可以配置另外的一个域名, 比如 www.ithome.com, 即多增加一个虚拟主机配置.</p>
<p>在 server.xml 增加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;www.ithome.com&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">    &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">    &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
<p>配置 DNS, 同理修改 etc/host 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 www.ithome.com</div></pre></td></tr></table></figure>
<p>可以看出, 在浏览器输入 <a href="http://www.ithome.com/test.html" target="_blank" rel="noopener">http://www.ithome.com/test.html</a> 和 <a href="http://www.mark.com/test.html" target="_blank" rel="noopener">http://www.mark.com/test.html</a> 效果是一样的.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>test.html 文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;</div><div class="line">&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">Now I input another line, with fancy&lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;</div><div class="line">&lt;/u&gt;.&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">Now I input another line, with fancy &lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;</div><div class="line">&lt;/u&gt;.&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">    mark.zhang is an itman.</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;style&gt;</div><div class="line">.button &#123;</div><div class="line">    background-color: #4CAF50;</div><div class="line">    border: none;</div><div class="line">    color: white;</div><div class="line">    padding: 15px 32px;</div><div class="line">    text-align: center;</div><div class="line">    text-decoration: none;</div><div class="line">    display: inline-block;</div><div class="line">    font-size: 86px;</div><div class="line">    margin: 50px 200px 100px 300px;</div><div class="line">    cursor: pointer;</div><div class="line">    border-radius: 15;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;p&gt;</div><div class="line">   &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot; class=&quot;button&quot;&gt;Try it&lt;/button&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;script&gt;</div><div class="line">   function myFunction() &#123;</div><div class="line">       alert(&quot;Blog: www.veryitman.com&quot;);</div><div class="line">   &#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tomcat Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ATS: HTTPS 认证]]></title>
      <url>/2017/02/08/ATS-HTTPS-%E8%AE%A4%E8%AF%81/</url>
      <content type="html"><![CDATA[<p>在 <a href="http://www.veryitman.com/2017/02/06/ATS-HTTP-HTTPS-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">ATS: HTTP/HTTPS 协议介绍</a> 中介绍了一些关于 HTTP/HTTPS 的概念以及相关的基本知识.</p>
<p>今天来聊聊关于 HTTPS 的认证方式和过程.</p>
<p>说 HTTPS 认证前, 先了解几个概念.</p>
<h2 id="关于加密的几个概念"><a href="#关于加密的几个概念" class="headerlink" title="关于加密的几个概念"></a>关于加密的几个概念</h2><h4 id="1-SSL-协议加密方式"><a href="#1-SSL-协议加密方式" class="headerlink" title="1. SSL 协议加密方式"></a>1. SSL 协议加密方式</h4><blockquote>
<p>SSL 既用了对称加密, 也用了非对称加密(公钥加密).</p>
</blockquote>
<p>在建立传输链路时, SSL 首先对对称加密的密钥使用公钥进行非对称加密, 链路建立好之后，SSL 对传输内容使用对称加密.</p>
<p>下面是两种加密方式的对比:</p>
<p>1.对称加密</p>
<blockquote>
<p>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，这种方法在密码学中叫做 <code>对称加密算法</code>，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，而且对计算机功能要求也没有那么高.<br>IDEA 加密标准由 PGP（Pretty Good Privacy）系统使用.</p>
</blockquote>
<p>该加密方式, 速度快, 可加密内容较大, 用来加密会话过程中的消息.</p>
<p>2.公钥加密(非对称加密)</p>
<blockquote>
<p>1976年，美国学者 Dime 和 Henman 为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”.<br>相对于 <code>对称加密算法</code> 这种方法也叫做 <code>非对称加密算法</code>.<br>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）. 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密.<br>因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
</blockquote>
<p>该加密方式, 速度较慢, 能提供更好的身份认证技术, 用来加密对称加密的密钥.</p>
<h4 id="2-数字证书"><a href="#2-数字证书" class="headerlink" title="2. 数字证书"></a>2. 数字证书</h4><p>一种文件的名称，好比一个机构或人的签名，能够证明这个机构或人的真实性. 其中包含的信息，用于实现上述功能.</p>
<h4 id="3-加密和认证"><a href="#3-加密和认证" class="headerlink" title="3. 加密和认证"></a>3. 加密和认证</h4><p>加密是指通信双方为了防止铭感信息在信道上被第三方窃听而泄漏，将明文通过加密变成密文，如果第三方无法解密的话，就算获得密文也无能为力.</p>
<p>认证是指通信双方为了确认对方是值得信任的消息发送或接受方，而不是使用假身份的非法者，采取的确认身份的方式.</p>
<p>只有同时进行了加密和认证才能保证通信的安全，因此在 SSL 通信协议中这两者(加密和认证)都被使用.</p>
<p>加密一般使用 <code>对称加密算法</code> 和 <code>不对称加密算法</code>，不对称加密最常见的算法就是 RSA.</p>
<h4 id="4-消息摘要"><a href="#4-消息摘要" class="headerlink" title="4. 消息摘要"></a>4. 消息摘要</h4><p>这个技术主要是为了避免消息被篡改.</p>
<p>消息摘要是把一段信息, 通过某种算法, 得出一串字符串.<br>这个字符串就是消息的摘要，如果消息被篡改(发生了变化), 那么摘要也一定会发生变化(如果2个不同的消息生成的摘要是一样的，那么这就叫发生了碰撞).</p>
<p>消息摘要的算法主要有 MD5 和 SHA，在证书领域，一般都是用 SHA(安全哈希算法).</p>
<p>数字证书、加密和认证、消息摘要三个技术结合起来，就是在 HTTPS 中广泛应用的证书(certificate), 证书本身携带了加密/解密的信息，并且可以标识自己的身份，也自带消息摘要.</p>
<h2 id="HTTPS-认证方式"><a href="#HTTPS-认证方式" class="headerlink" title="HTTPS 认证方式"></a>HTTPS 认证方式</h2><p>分为单向和双向认证.</p>
<h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><blockquote>
<p>单向认证较简单, 只需要服务端校验服务端的证书的合法性.</p>
</blockquote>
<p>该认证过程使用下面的流程图来表示:<br><img src="/upload/images/2017/02/08/HTTPS_Single.png" alt="1"></p>
<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>双向认证和单向认证原理基本一致，但是需要双方都校验对方的证书的合法性.</p>
<p>该认证过程使用下面的流程图来表示:<br><img src="/upload/images/2017/02/08/HTTPS_Double.png" alt="1"></p>
<h3 id="随机数的产生"><a href="#随机数的产生" class="headerlink" title="随机数的产生"></a>随机数的产生</h3><p>不管是单向认证, 还是双向认证, 都有随机数的产生和发送.</p>
<p>下图是随机数的产生流程图:<br><img src="/upload/images/2017/02/08/HTTPS_Random.png" alt="1"></p>
<p>生成对话密钥, 一共需要三个随机数.</p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><strong>推荐在线流程图工具</strong>:</p>
<p><a href="http://www.veryitman.com/2017/02/08/www.processon.com" target="_blank" rel="noopener">ProcessOn</a>.</p>
<p><strong>推荐博文</strong>:</p>
<p>1.<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p>
<p>2.<a href="http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html" target="_blank" rel="noopener">HTTPS的七个误解(译文)</a></p>
<p>3.<a href="http://blog.sina.com.cn/s/blog_56d8ea900100bzpr.html" target="_blank" rel="noopener">对称加密和非对称加密介绍和区别</a></p>
<p>本文中参考了上面文章的部分内容, 感谢这些作者.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP HTTPS TLS SSL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ATS: HTTP/HTTPS 协议介绍]]></title>
      <url>/2017/02/06/ATS-HTTP-HTTPS-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>苹果在2017年要求 App 必须支持 HTTPS, 不过, 这个要求, 最后又被苹果自己延期了.</p>
<p>我只能说, 苹果的开发哥哥们真会玩…</p>
<p>该系列博客介绍 iOS 上面的 ATS 以及相关的 HTTPS 知识, 分为三篇来分享.</p>
<p>本篇是第一篇.</p>
<p>第二篇: <a href="http://www.veryitman.com/2017/02/08/ATS-HTTPS-%E8%AE%A4%E8%AF%81/" target="_blank" rel="noopener">ATS: HTTPS 认证</a></p>
<p>今天先简单了解一下 HTTPS 以及相关的知识.</p>
<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><p>先了解一下相关的常用名词.</p>
<h4 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1.HTTP"></a>1.HTTP</h4><p>HyperText Transfer Protocol, 超文本传输协议.</p>
<h4 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2.HTTPS"></a>2.HTTPS</h4><p>Hyper Text Transfer Protocol over Secure Socket Layer, 安全的超文本传输协议.</p>
<h4 id="3-SSL"><a href="#3-SSL" class="headerlink" title="3.SSL"></a>3.SSL</h4><p>Secure Socket Layer, 安全套接字层.</p>
<h4 id="4-TLS"><a href="#4-TLS" class="headerlink" title="4.TLS"></a>4.TLS</h4><p>Transport Layer Security, 传输层安全.其前身就是 SSL.</p>
<h4 id="5-ATS"><a href="#5-ATS" class="headerlink" title="5.ATS"></a>5.ATS</h4><p>App Transport Security, 应用传输安全.</p>
<h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HyperText Transfer Protocol, 超文本传输协议，是互联网上使用最广泛的一种协议，所有 WWW 文件必须遵循的标准.</p>
<p>HTTP 协议传输的数据都是未加密的, 也就是明文的, 因此使用 HTTP 协议传输隐私信息非常不安全.</p>
<p>默认使用 TCP 端口为 80.</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>安全的超文本传输协议, <code>Hyper Text Transfer Protocol over Secure Socket Layer</code>, 网景公式设计了 SSL(Secure Socket Layer) 协议用于对 HTTP 协议传输的数据进行加密，保证会话过程中的安全性.</p>
<p>默认使用 TCP 端口为 443.</p>
<h3 id="拆分-HTTPS"><a href="#拆分-HTTPS" class="headerlink" title="拆分 HTTPS"></a>拆分 HTTPS</h3><h4 id="SSL-协议加密方式"><a href="#SSL-协议加密方式" class="headerlink" title="SSL 协议加密方式"></a>SSL 协议加密方式</h4><p>SSL 协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL 对传输内容使用对称加密.</p>
<blockquote>
<p>1.对称加密<br>速度高，可加密内容较大，用来加密会话过程中的消息.</p>
<p>2.公钥加密<br>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥.</p>
</blockquote>
<h4 id="HTTP-SSL"><a href="#HTTP-SSL" class="headerlink" title="HTTP+SSL"></a>HTTP+SSL</h4><p>HTTPS, 可以看做是 HTTP+SSL, 所以重点在 SSL 上面.</p>
<h4 id="HTTPS-1"><a href="#HTTPS-1" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>在 HTTP (超文本传输协议)基础上提出的一种安全的 HTTP 协议，因此可以称为安全的超文本传输协议。</p>
<p>HTTP 协议直接放置在 TCP 协议之上，而 HTTPS 提出在 HTTP 和 TCP 中间加上一层加密层.</p>
<p>从发送端看，这一层负责把 HTTP 的内容加密后送到下层的 TCP，从接收方看，这一层负责将 TCP 送来的数据解密还原成 HTTP 的内容.</p>
<h4 id="SSL-Secure-Socket-Layer"><a href="#SSL-Secure-Socket-Layer" class="headerlink" title="SSL(Secure Socket Layer)"></a>SSL(Secure Socket Layer)</h4><p>是 Netscape 公司设计的主要用于 WEB 的安全传输协议.<br>它在 HTTPS 协议栈中负责实现上面提到的加密层.</p>
<p>一个 HTTPS 协议栈大致是这样的：<br><img src="/upload/images/2017/02/06/HTTP+SSL.png" alt="1"></p>
<h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>HTTPS，也称作 HTTP over TLS.</p>
<p>TLS(传输层安全, Transport Layer Security) 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3.</p>
<blockquote>
<p>苹果 ATS(App Transport Security), 要求支持 HTTPS 的 TLS 版本最低为 V1.2.</p>
</blockquote>
<p>下图描述了在 TCP/IP 协议栈中 TLS(各子协议）和 HTTP 的关系:<br><img src="/upload/images/2017/02/06/tcp-ip-model.png" alt="1"></p>
<p>其中 Handshake protocol，Change Ciper Spec protocol 和 Alert protocol 组成了 SSL Handshaking Protocols.</p>
<p>SSL 和 TLS 的发展历史:</p>
<blockquote>
<p>1994年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布.</p>
<p>1995年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞.</p>
<p>1996年，SSL 3.0 版问世，得到大规模应用.</p>
<p>1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版.</p>
<p>2006年和2008年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版.最新的变动是2011年 TLS 1.2 的修订版.</p>
<p>TLS 1.3 改动会比较大，目前还在草案阶段.</p>
</blockquote>
<h2 id="HTTP-和-HTTPS-区别"><a href="#HTTP-和-HTTPS-区别" class="headerlink" title="HTTP 和 HTTPS 区别"></a>HTTP 和 HTTPS 区别</h2><p>HTTPS 和 HTTP 的区别主要为以下四点:</p>
<blockquote>
<ol>
<li><p>HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费.</p>
</li>
<li><p>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SLL/TLS 加密传输协议(非对称加密).</p>
</li>
<li><p>HTTP 和 HTTPS 不同的连接方式，用的端口也不一样，前者是 80，后者是 443.</p>
</li>
<li><p>HTTP 的连接很简单，是无状态的；<br>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全.</p>
</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ATS HTTP HTTPS SSL TLS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: Yarn]]></title>
      <url>/2017/02/05/RN-Yarn/</url>
      <content type="html"><![CDATA[<p>React Native 正式版已经更新到 0.41.1 了.</p>
<p>最近使用 <code>react-native-cli</code> 来创建 React Native 工程, 提示如下信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">This will walk you through creating a new React Native project in /Users/mark/workspace/mzProjs/ReactNative/LatestRN</div><div class="line">Installing react-native...</div><div class="line">Consider installing yarn to make this faster: https://yarnpkg.com</div></pre></td></tr></table></figure>
<p>其实 Yarn 也一直在更新, 最新版本 v0.20.0.</p>
<p>官网对应的有中文版本和中文文档, 可以 <a href="http://yarnpkg.top/" target="_blank" rel="noopener">点此进入</a>.</p>
<h2 id="Yarn-简介"><a href="#Yarn-简介" class="headerlink" title="Yarn 简介"></a>Yarn 简介</h2><p>一句话介绍:</p>
<blockquote>
<p>A new package manager for JavaScript</p>
</blockquote>
<p>Yarn 是一个依赖管理工具，它能够管理你的代码，并与全世界的开发者分享你的代码.</p>
<p>Yarn 是高效、安全和可靠.</p>
<blockquote>
<p>1.高效: 使用了缓存, 可以很快的获取已经 download 的包.<br>2.安全: 在代码被执行之前，会使用CheckSum算法验证每一个依赖包的完整性.<br>3.可靠: 在不同平台(windows/mac/linux)只要是同一份配置文件, 执行结果是一样的.</p>
</blockquote>
<p>还有很多特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Offline Mode</div><div class="line">If you&apos;ve installed a package before, you can install it again without any internet connection.</div><div class="line">Deterministic</div><div class="line">The same dependencies will be installed the same exact way across every machine regardless of install order.</div><div class="line">Network Performance</div><div class="line">Yarn efficiently queues up requests and avoids request waterfalls in order to maximize network utilization.</div><div class="line">Same Packages</div><div class="line">Install any package from npm and keep your package workflow the same.</div><div class="line">Network Resilience</div><div class="line">A single request failing won&apos;t cause an install to fail. Requests are retried upon failure.</div><div class="line">Flat Mode</div><div class="line">Resolve mismatching versions of dependencies to a single version to avoid creating duplicates.</div></pre></td></tr></table></figure>
<p>Yarn 能够让你使用其他开发者开发的代码，让你更容易的开发软件.</p>
<p>代码是通过依赖包 (有时也被称为组件). 在每一个依赖中会定义一个 package.json 文件，用来描述这个依赖包中所有要被分享的代码.</p>
<p>Yarn 是开源的, 点击 <a href="http://yarnpkg.top/" target="_blank" rel="noopener">Github</a> 了解更多.</p>
<p>对比 npm 和 yarn, 可以阅读文章:<br><a href="https://www.sitepoint.com/yarn-vs-npm/" target="_blank" rel="noopener">Yarn vs npm: Everything You Need to Know</a></p>
<p>中文版:<br><a href="https://gold.xitu.io/entry/580de578bf22ec0058330692" target="_blank" rel="noopener">译 Yarn vs npm: 你需要知道的一切</a></p>
<h2 id="安装-Yarn"><a href="#安装-Yarn" class="headerlink" title="安装 Yarn"></a>安装 Yarn</h2><p>具体安装的教程, 可以参考官网的 <a href="http://yarnpkg.top/Installation.html" target="_blank" rel="noopener">安装教程</a>.</p>
<p>在 MacOS 上面使用 Homebrew 安装很方便, 两个命令即可完成.</p>
<p>下面具体说说操作步骤.</p>
<p>强烈开发同事购买一个 VPN, 这个年头没有 VPN, 日子不好过.</p>
<p>1.更新 brew</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew update --verbose</div></pre></td></tr></table></figure>
<p>最后加上参数 <code>--verbose</code>, 不然等待的过程很煎熬, 没有任何提示信息.</p>
<p>2.安装 yarn</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install yarn</div></pre></td></tr></table></figure>
<p>在安装过程中, 如果提示如下信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Please note by default only English locale support is provided. If you need</div><div class="line">full locale support you should either rebuild with full icu:</div><div class="line">  `brew reinstall node --with-full-icu`</div><div class="line">or add full icu data at runtime following:</div><div class="line">  https://github.com/nodejs/node/wiki/Intl#using-and-customizing-the-small-icu-build</div></pre></td></tr></table></figure>
<p>可以重新安装已经安装的 node, 执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew reinstall node --with-full-icu</div></pre></td></tr></table></figure>
<p>在执行上面安装命令的时候, 如果卡住不动或者很久, Ctrl+C 终止当前的操作, 重新操作一遍即可.</p>
<p>安装成功后, 可以查看安装的版本信息, 执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn --verbose</div></pre></td></tr></table></figure>
<p>会显示如下信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yarn install v0.20.0</div><div class="line">verbose Performing &quot;GET&quot; request to &quot;https://yarnpkg.com/latest-version&quot;.</div><div class="line">[1/4] 🔍  Resolving packages...</div><div class="line">success Already up-to-date.</div><div class="line">✨  Done in 0.29s.</div></pre></td></tr></table></figure>
<p>使用 brew 安装 Yarn 后, 不需要设置环境变量.</p>
<h2 id="Yarn-与-React-Native"><a href="#Yarn-与-React-Native" class="headerlink" title="Yarn 与 React Native"></a>Yarn 与 React Native</h2><p>在 <code>React Native 0.37</code> 版本中已经加入了对 Yarn 的支持.</p>
<p>可以在 React Native 的官方的这篇 <a href="https://facebook.github.io/react-native/blog/2016/11/08/introducing-button-yarn-and-a-public-roadmap.html" target="_blank" rel="noopener">Blog</a> 找到更多信息.</p>
<p>用 Yarn 创建 React Native 工程</p>
<p>既然 RN 已经支持了 Yarn, 那么就可以使用 Yarn 来管理和创建 RN 工程了.</p>
<p>使用 Yarn, 必须满足几个条件:</p>
<blockquote>
<p>1.react-native-cli 的版本不能小于 1.2.0 版本.<br>2.React Natvie 必须是 0.37 及以上的版本.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init MZLatestRN</div></pre></td></tr></table></figure>
<p>当你安装好 Yarn 后, 执行上面的命令可以出现提示信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">This will walk you through creating a new React Native project in ~/workspace/Projs/ReactNative/MZLatestRN</div><div class="line">Using yarn v0.20.0</div><div class="line">Installing react-native...</div></pre></td></tr></table></figure>
<p>可以看出, RN 会使用 Yarn 来创建工程.</p>
<p>其中, <code>~/workspace/Projs/ReactNative</code> 是我本地的工作目录. <code>MZLatestRN</code> 是要创建的 RN 工程名称.</p>
<p>如果你的网络好的话, 大概1分钟就可以创建成功.</p>
<p>工程目录:<br><img src="/upload/images/2017/02/05/1.png" alt="1"></p>
<p>可以看出多了 <code>yarn.lock</code> 文件.</p>
<p>Yarn 还在茁壮成长, 希望它越来越好, 更多的使用和工作原理可以参考 <a href="https://yarnpkg.com/docs" target="_blank" rel="noopener">官方 Doc</a>, 介绍的很详细.</p>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ReactNative iOS Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装 PHP 遇到的问题]]></title>
      <url>/2017/02/02/%E5%AE%89%E8%A3%85-PHP-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在博客 <a href="http://www.veryitman.com/2017/02/02/PHP-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/" target="_blank" rel="noopener">PHP 开发准备</a> 介绍了安装并部署 PHP 程序到 Nginx.</p>
<p>今天分享在安装中遇到的问题和其他工具的安装, 以及常用的操作, 包括 MySQL, Nginx 等.</p>
<h2 id="pecl-安装"><a href="#pecl-安装" class="headerlink" title="pecl 安装"></a>pecl 安装</h2><blockquote>
<p>PEAR 是 PHP 扩展与应用库(PHP Extension and Application Repository) 的缩写。它是一个 PHP 扩展及应用的一个代码仓库，简单地说，PEAR 就是 PHP 的 CPAN.</p>
<p>PECL (PHP Extension Community Library)，PHP 的扩展库，它提供了一系列已知的扩展库，由 C++ 等其他语言编写而成，以 .so 形式出现，.so 为共享库, 是 shared object, 用于动态连接的, 和 dll 差不多，为比 PEAR 更快，但是与 PEAR 不同的是，PECL 需要在服务器上配置并被注册到主机中.</p>
<p>最直接的表述: PEAR 是 PHP 的上层扩展，PECL 是 PHP 的底层扩展.</p>
</blockquote>
<p>下面说如何安装 pecl 和 pear.</p>
<p>1.下载 pear</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -O http://pear.php.net/go-pear.phar</div></pre></td></tr></table></figure>
<p>2.安装 pear</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php -d detect_unicode=0 go-pear.phar</div></pre></td></tr></table></figure>
<p>3.执行以上命令后会进行安装过程，会有一些配置选项</p>
<p>输入1，回车，配置 pear 路径为：<code>/usr/local/pear</code><br>输入4，回车，配置命令路径为：<code>/usr/local/bin</code></p>
<p>4.回车两次，其他让其默认，安装完成.</p>
<p>5.可以通过命令检查 pear 是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pear version</div></pre></td></tr></table></figure>
<p>或者执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pecl version</div></pre></td></tr></table></figure>
<p>可以看到类似信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PEAR Version: 1.10.1</div><div class="line">PHP Version: 5.6.27</div><div class="line">Zend Engine Version: 2.6.0</div></pre></td></tr></table></figure>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h4 id="MySQL-操作"><a href="#MySQL-操作" class="headerlink" title="MySQL 操作"></a>MySQL 操作</h4><p>基本操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql.server start #启动</div><div class="line">mysql.server stop  #停止</div><div class="line">mysql -u root -p   #用 user 和 pwd 连接</div><div class="line">php-fpm 相关操作</div></pre></td></tr></table></figure>
<p>1.运行 php-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php-fpm -D</div></pre></td></tr></table></figure>
<p>2.关闭 php-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo killall php-fpm</div></pre></td></tr></table></figure>
<p>3.查看 php-fpm 运行状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo lsof -Pni4 | grep LISTEN | grep php</div></pre></td></tr></table></figure>
<p>可以看到 (fpm 默认在 9000 端口)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">php-fpm  84200   root  8u  IPv4 0x91959c43a1ea5abd  0t0  TCP 127.0.0.1:9000 (LISTEN)</div><div class="line">php-fpm  84201   _www  0u  IPv4 0x91959c43a1ea5abd  0t0  TCP 127.0.0.1:9000 (LISTEN)</div><div class="line">php-fpm  84202   _www  0u  IPv4 0x91959c43a1ea5abd  0t0  TCP 127.0.0.1:9000 (LISTEN)</div><div class="line">php-fpm  84203   _www  0u  IPv4 0x91959c43a1ea5abd  0t0  TCP 127.0.0.1:9000 (LISTEN)</div></pre></td></tr></table></figure>
<p>4.php-fpm 开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -sfv /usr/local/opt/php56/*.plist ~/Library/LaunchAgents</div><div class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.php56.plist</div></pre></td></tr></table></figure>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>1.测试配置是否有语法错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -t</div></pre></td></tr></table></figure>
<p>2.启动 nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nginx</div></pre></td></tr></table></figure>
<p>3.重新加载配置|重启|停止|退出 nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -s reload|reopen|stop|quit</div></pre></td></tr></table></figure>
<p>4.开机启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents</div><div class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist</div></pre></td></tr></table></figure>
<p>5.nginx 监听 80 端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo chown root:wheel /usr/local/Cellar/nginx/1.6.0_1/bin/nginx</div><div class="line">sudo chmod u+s /usr/local/Cellar/nginx/1.6.0_1/bin/nginx</div></pre></td></tr></table></figure>
<h2 id="常用目录"><a href="#常用目录" class="headerlink" title="常用目录"></a>常用目录</h2><p>因为使用了 Homebrew 安装的 PHP, 配置文件的目录不是常规的 /etc</p>
<p>这里有几个目录需要知道, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/private/etc</div><div class="line">/usr/local/etc/php/5.6</div><div class="line">/usr/local/var/www</div></pre></td></tr></table></figure>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>1.执行 sudo php-fpm -D 报 php56-intl/intl.so 加载问题</p>
<p>warning 的内容大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NOTICE: PHP message: PHP Warning:  PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found in Unknown on line 0</div><div class="line">&lt;br /&gt;</div><div class="line">&lt;b&gt;Warning&lt;/b&gt;:  PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;</div><div class="line">Unknown(0) : Warning - PHP Startup: Unable to load dynamic library &apos;/usr/local/opt/php56-intl/intl.so&apos; - dlopen(/usr/local/opt/php56-intl/intl.so, 9): image not found</div><div class="line">[31-Dec-2016 22:40:38] NOTICE: PHP message: PHP Warning:  PHP Startup: mcrypt: Unable to initialize module</div><div class="line">Module compiled with build ID=API20131226,NTS</div><div class="line">PHP    compiled with build ID=API20131226,NTS,debug</div><div class="line">These options need to match</div><div class="line"> in Unknown on line 0</div></pre></td></tr></table></figure>
<p>解决方案: 执行下面的命令, 即可解决.方案来源 <a href="https://github.com/Homebrew/homebrew-php/issues/2544" target="_blank" rel="noopener">Github</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew reinstall --build-from-source php56-intl</div></pre></td></tr></table></figure>
<p>2.执行 sudo php-fpm -D 报 PHP Startup: mcrypt: Unable to initialize module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">31-Dec-2016 22:56:51] NOTICE: PHP message: PHP Warning:  PHP Startup: mcrypt: Unable to initialize module</div><div class="line">Module compiled with build ID=API20131226,NTS</div><div class="line">PHP    compiled with build ID=API20131226,NTS,debug</div><div class="line">These options need to match</div><div class="line"> in Unknown on line 0</div><div class="line">&lt;br /&gt;</div><div class="line">&lt;b&gt;Warning&lt;/b&gt;:  PHP Startup: mcrypt: Unable to initialize module</div><div class="line">Module compiled with build ID=API20131226,NTS</div><div class="line">PHP    compiled with build ID=API20131226,NTS,debug</div><div class="line">These options need to match</div><div class="line"> in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;</div><div class="line">Unknown(0) : Warning - PHP Startup: mcrypt: Unable to initialize module</div><div class="line">Module compiled with build ID=API20131226,NTS</div><div class="line">PHP    compiled with build ID=API20131226,NTS,debug</div><div class="line">These options need to match</div></pre></td></tr></table></figure>
<p>解决方案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew reinstall --build-from-source php56-intl</div></pre></td></tr></table></figure>
<p>3.连接 mysql</p>
<p>使用 <code>mysql -u root -p</code> 连接 mysql, 提示 Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock 错误.</p>
<p>解决方案: 启动 mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql.server start</div></pre></td></tr></table></figure>
<p>重新连接即可.</p>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP MySql nginx php-fpm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP 开发准备]]></title>
      <url>/2017/02/02/PHP-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/</url>
      <content type="html"><![CDATA[<p><strong>注意</strong>：这篇文章是基于 Homebrew 安装 php5.6 以及 nginx 和 mysql 的介绍，安装高版本的 php 请绕行。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>亲自实践在 MacOS 上面安装 PHP5.6+MySQL+Nginx.</p>
<p>将自己遇到的问题和对应的解决方案, 分享出来, 希望能帮到你.</p>
<p>MacOS 上面搭建 PHP 开发环境, 使用 Homebrew 来安装对应的开发套件, 就更加简单了.</p>
<p>这篇博客的目的就是安装 PHP 开发环境, 并将第一个 PHP 程序部署在 Nginx 上面.</p>
<p>如果在安装和使用过程中遇到问题, 可以查看这篇博客: <a href="http://www.veryitman.com/2017/02/02/%E5%AE%89%E8%A3%85-PHP-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">Mac PHP 安装遇到的问题</a>.</p>
<p>下面开始介绍具体的安装步骤.</p>
<h2 id="一-安装-Homebrew"><a href="#一-安装-Homebrew" class="headerlink" title="一. 安装 Homebrew"></a>一. 安装 Homebrew</h2><p>这个大家可以自行访问 <a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 了解, 这里不再涉及具体的安装过程和方法.</p>
<h2 id="二-安装-php56"><a href="#二-安装-php56" class="headerlink" title="二. 安装 php56"></a>二. 安装 php56</h2><blockquote>
<p>1.加入官方源</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">brew tap homebrew/dupes</div><div class="line">brew tap homebrew/versions</div><div class="line">brew tap homebrew/php</div></pre></td></tr></table></figure>
<blockquote>
<p>2.安装 PHP</p>
</blockquote>
<p>默认安装会运行在 Apache 下.<br>而我们要使它运行在 PHP-fpm 下，所以要增加参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--with-fpm --without-apache</div></pre></td></tr></table></figure>
<p>查看所有安装参数可以输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew option php56</div></pre></td></tr></table></figure>
<p>进行查看，参考安装指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">brew install php56 \</div><div class="line">--without-snmp \</div><div class="line">--without-apache \</div><div class="line">--with-debug \</div><div class="line">--with-fpm \</div><div class="line">--with-intl \</div><div class="line">--with-homebrew-curl \</div><div class="line">--with-homebrew-libxslt \</div><div class="line">--with-homebrew-openssl \</div><div class="line">--with-imap \</div><div class="line">--with-mysql \</div><div class="line">--with-tidy</div></pre></td></tr></table></figure>
<p>这里使用了下面的选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">with-homebrew-curl</div></pre></td></tr></table></figure>
<p>我试过不带此选项, 安装 PHP56 会失败, 找不到 curl.</p>
<p>安装成功后, 可以查看版本信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">php -v</div><div class="line">php-fpm -v</div></pre></td></tr></table></figure>
<p>此时看到是的系统自带的版本.</p>
<p>下面一步是增加环境变量, 完成后在看版本信息, 即可.</p>
<blockquote>
<p>3.配置 PHP 环境变量</p>
</blockquote>
<p>配置环境变量的目的是要使用 brew 安装的 PHP 和 PHP-fpm, 不使用 MacOS 自带的 PHP 版本.</p>
<p><code>/usr/local/sbin/</code> 下面是我们 brew 安装的 PHP, 其实他是一个软连接指向:<br><code>/usr/local/Cellar/php56/5.6.27_4/sbin</code></p>
<p><code>/usr/local/bin/</code> 下面也是 brew 安装的 PHP, 指向:<br><code>/usr/local/Cellar/php56/5.6.27_4/bin</code></p>
<p>vim ~/.bash_profile 增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=&quot;/usr/local/sbin:$PATH&quot;</div></pre></td></tr></table></figure>
<p>使其立即生效, 执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>或者重启终端.</p>
<p>如果想看系统的 PHP 版本可以这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/php -v</div></pre></td></tr></table></figure>
<blockquote>
<p>4.配置 php-fpm</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /private/etc/php-fpm.conf</div></pre></td></tr></table></figure>
<p>找到 error_log 项，添加下面配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error_log = /usr/local/var/log/php-fpm.log</div><div class="line">pid = /usr/local/var/run/php-fpm.pid</div></pre></td></tr></table></figure>
<p>否则会报:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FPM initialization failed</div></pre></td></tr></table></figure>
<h2 id="三-安装-nginx"><a href="#三-安装-nginx" class="headerlink" title="三. 安装 nginx"></a>三. 安装 nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install nginx</div></pre></td></tr></table></figure>
<p>创建文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir -p /usr/local/var/logs/nginx</div><div class="line">mkdir -p /usr/local/etc/nginx/sites-available</div><div class="line">mkdir -p /usr/local/etc/nginx/sites-enabled</div><div class="line">mkdir -p /usr/local/etc/nginx/conf.d</div><div class="line">mkdir -p /usr/local/etc/nginx/ssl</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /var/www</div><div class="line">sudo chown :staff /var/www</div><div class="line">sudo chmod 775 /var/www</div><div class="line">vi /var/www/info.php</div><div class="line">vi /var/www/index.html</div><div class="line">vi /var/www/403.html</div><div class="line">vi /var/www/404.html</div></pre></td></tr></table></figure>
<p>改变 nginx.conf 配置文件</p>
<p>该配置文件在 <code>/usr/local/etc/nginx/nginx.conf</code> 下面.</p>
<p>我的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">worker_processes  1;</div><div class="line"> </div><div class="line">error_log  /usr/local/etc/nginx/logs/error.log debug;</div><div class="line">pid        /usr/local/var/run/nginx.pid;</div><div class="line"> </div><div class="line">events &#123;</div><div class="line">    worker_connections  256;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">http &#123;</div><div class="line">    include             mime.types;</div><div class="line">    default_type        application/octet-stream;</div><div class="line"> </div><div class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line"> </div><div class="line">    access_log  /usr/local/etc/nginx/logs/access.log  main;</div><div class="line"> </div><div class="line">    sendfile            on;</div><div class="line"> </div><div class="line">    keepalive_timeout   65;</div><div class="line"> </div><div class="line">    index index.html index.php;</div><div class="line"> </div><div class="line">    include /usr/local/etc/nginx/sites-enabled/*; </div><div class="line">    include /usr/local/etc/nginx/conf.d/*;</div><div class="line">     server &#123;</div><div class="line">        listen       8080;</div><div class="line">        server_name  localhost;</div><div class="line">        #charset koi8-r;</div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line">        location / &#123;</div><div class="line">            root   ~/projs/phpdev/nginx/nginx_sites/; #web的根目录</div><div class="line">            index  index.php index.html index.htm; #加index.php</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	root   ~/projs/phpdev/nginx/nginx_sites/; #web的根目录</div><div class="line">	index  index.php index.html index.htm; #加index.php</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置了我的 web 目录和支持的文件.</p>
<h2 id="四-运行-PHP"><a href="#四-运行-PHP" class="headerlink" title="四. 运行 PHP"></a>四. 运行 PHP</h2><p>创建 index.php</p>
<p>启动 PHP-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php-fpm</div></pre></td></tr></table></figure>
<p>或者以守护进程的方式来启动 PHP-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo php-fpm -D</div></pre></td></tr></table></figure>
<p>启动 Nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nginx</div></pre></td></tr></table></figure>
<p>编辑 index.php</p>
<p>在 web 目录(我配置的) <code>/Users/mark/workspace/mzProjs/phpdev/nginx/nginx_sites/</code> 新建文件 <code>index.php</code>.</p>
<p>index.php 里面可以编写代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!-- lang: php --&gt;</div><div class="line">&lt;!-- ~/nginx_sites/index.php --&gt;</div><div class="line">&lt;?php</div><div class="line">    echo &quot;Hello PHP&quot;;</div><div class="line">    echo &quot;&lt;/br&gt;&quot;;</div><div class="line">    </div><div class="line">    echo &quot;学习 php&quot;;</div><div class="line">    echo &quot;&lt;/br&gt;&quot;;</div><div class="line">    echo phpinfo();</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>打开浏览器, 你会看到下面的页面:<br><img src="/upload/images/2017/02/02/php1.png" alt="1"></p>
<p>也可以在该目录下创建其他 php 文件, 如 mark.php 文件.</p>
<p>浏览器中输入:<br><a href="http://localhost:8080/mark.php" target="_blank" rel="noopener">http://localhost:8080/mark.php</a> 可以执行相对应的文件.</p>
<p>这里的 <code>mark.php</code> 是自己新建的 php 文件.</p>
<h2 id="五-安装-MySQL"><a href="#五-安装-MySQL" class="headerlink" title="五. 安装 MySQL"></a>五. 安装 MySQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mysql</div></pre></td></tr></table></figure>
<p>等待安装成功后，直接启动和连接数据库。</p>
<ul>
<li>启动 mysql</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql.server start</div></pre></td></tr></table></figure>
<ul>
<li>连接 mysql</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root -p</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP MySql nginx php-fpm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[过年回家这几天]]></title>
      <url>/2017/01/31/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6%E8%BF%99%E5%87%A0%E5%A4%A9/</url>
      <content type="html"><![CDATA[<p>从放假回家到现在已经一个多星期了, 感触颇多.</p>
<p>主要有以下几个感触:</p>
<blockquote>
<p>1.健康最重要.<br>2.坚持做好一件事情.<br>3.感恩.</p>
</blockquote>
<p><img src="/upload/images/2017/01/31/1.jpeg" alt="1"></p>
<h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><p>前两年回家, 还能见着很多长辈, 互相嘘寒问暖, 家长里短的闲聊, 如今有些已离我远去.</p>
<p>无情的疾病夺走了尚未花甲的他们, 让人不禁感叹生命的脆弱.</p>
<p>我小的时候, 很喜欢和长辈们聊天.</p>
<p>主要是他们讲, 我做一个小小的听众, 觉得他们懂得特别多, 从天文到地里, 从文学到艺术, 讲的有声有色.<br>每逢夏季, 我都会搬着小板凳, 在屋前的老树下, 纠缠他们, 逼着嚷着让他们给我讲故事, 甭提有多高兴.</p>
<p>如今, 老树犹在, 他们已不在人世.睹物思人.</p>
<p>农村大部分人, 不太关注自己的健康, 唯一衡量自己身体状况的标准就是 <code>米饭馒头能吃多少</code>.</p>
<p>很多人, 明明已经感觉到身体不适, 也不愿意去医院做检查, 就这样日积月累成疾.<br>等实在忍受不了才去医院检查, 为时已晚.</p>
<p>平时不注意自己的身体, 身体早晚都会让你注意.</p>
<p>无论平时工作再忙, 也要坚持锻炼, 没有健康的体魄, 其他的都是扯淡.</p>
<h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h2><p>农村这几年鼓励年轻人在家创业, 搞养殖. 有很多人放弃了打工, 回家拿着补贴开始有模有样的创业.</p>
<p>前几年回老家, 看到各种搞养殖的, 有养鸡养鸭养鹅的, 有养羊养猪养牛的, 如雨后春笋, 遍地开花.</p>
<p>但是今年回家, 看到很多荒凉的房子, 无人问津.</p>
<p>我问过几个小伙子(之前在家搞养殖的人, 最后放弃了的).他们跟我说的基本都一样, 太累了, 收益慢!<br>搞养殖, 的确很累, 也很枯燥无味, 每天和这些不会说话的动物们待在一起, 喂它们吃喝, 管他们温饱, 实在乏味.</p>
<p>另外有两个年轻人, 从开始养殖到现在已经坚持五六年了, 搞得风生水起, 家里盖起了楼房, 取了巧媳妇, 生了胖小子, 一家人其乐融融.<br>他们跟我说的基本一样, 只要坚持, 就有收获!</p>
<p>这两个坚持下来的年轻人, 他们相信自己能够把这份事业做好, 他们把别人眼中的脏活累活当做一种快乐, 一种享受!</p>
<p>刚开始, 很艰难, 他们也想过放弃, 但是又舍不得这几年的付出, 于是就坚持下来了, 并且收获了不少意想不到的知识, 不管是物质上还是精神上都得到了满足.</p>
<p>世上, 没有一帆风顺的事业.</p>
<p>只要自己喜欢, 感兴趣的行业, 就值得你去坚持.<br>如果你从内心都不感兴趣, 趁早放弃, 因为你很难坚持下来.</p>
<p>想投机取巧的成就一份事业, 只有神话故事里有吧!</p>
<p>不经一番寒彻骨, 哪得梅花扑鼻香!</p>
<h2 id="感恩"><a href="#感恩" class="headerlink" title="感恩"></a>感恩</h2><p>小的时候, 家里很拮据, 我能够把大学念完, 简直就是天意.</p>
<p>父母永远只会对我说一句话, 只要你想上学, 我们就支持到底.</p>
<p>我知道家里的经济情况, 所以在学习上也是不遗余力, 每次放学除了帮爸爸妈妈干农活, 就是完成家庭作业, 练字背书.</p>
<p>那个时候, 不知道哪来的狠劲, 即使是寒冬腊月, 也要坚持写作业, 即使是手都冻肿了, 也要练字.</p>
<p>当我接到重点高中通知书的那天, 父亲高兴的合不拢嘴, 心理充满了骄傲.</p>
<p>我能感觉到……</p>
<p>然而考上高中, 接下来就是凑钱交学费, 隔壁有个伯伯, 他说学费不够, 算他的.<br>那个时候, 大家家里都不宽裕, 能借钱给你的, 简直就是大恩人.<br>一直到现在, 我都很感激他, 每年过年回家, 我都会给伯伯买点礼物, 给个红包, 陪他聊聊天.他还开玩笑的说, 当年自己的投资, 算是有了回报了.</p>
<p>这辈子, 我们最应该感谢的是我们自己的父母, 养育我们成人, 送我们读书上学. 过年回家, 要多陪陪他们, 珍惜和他们在一起的每一刻.</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 反思 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习杂谈]]></title>
      <url>/2017/01/27/%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%B0%88/</url>
      <content type="html"><![CDATA[<p>今天是中国传统节日, 大年三十, 祝大家新年快乐, 身体健康, 幸福美满.</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近无论是朋友还是同事或者博友, 都问过我关于学习方面的事情.</p>
<p>探讨的问题大概分为如下几种:</p>
<p>怎么有效的学习新知识?<br>怎么快速掌握新知识?<br>是否有必要每天学习?<br>如何坚持学习?<br>谈到关于学习的话题, 我也不是什么专家, 更不是心理咨询师, 只是谈谈个人的一些看法和经历, 希望能给大家带来一点点的帮助.</p>
<p>不要只是嘴上说 <code>我感兴趣</code>, 如果没有驱动和目标, 兴趣永远都只是兴趣.</p>
<h2 id="你为什么学习它"><a href="#你为什么学习它" class="headerlink" title="你为什么学习它"></a>你为什么学习它</h2><p>学习知识之前, 问问自己为什么要学它? 大部分人学习新东西都是为了工作或者为了更好的工作或者为了转行或者其他目的, 也有一部分人是为了兴趣爱好.</p>
<p>这里我只谈为了工作而去学习新知识的内容, 其他方面的我自己也没有什么心得体会, 不能乱说.</p>
<p>既然为了工作或者更好的工作来学习, 那么我们就明确了目标, 如果你已经有了目标, 恭喜你, 你即将成功了.</p>
<p>有一些人说, 我学习它, 这个东西不一定哪天就有用了, 我怕将来失业.<br>这中担心不是在杞人忧天, 特别是在互联网的时代, 如果不学习很容易就落伍啦, 君担心完全在理!</p>
<p>但是, 当下你最应该考虑的是目前掌握的技能是否已经熟练了, 是否是能够独当一面了, 如果深学下去会不会更有前途? 如果是, 请你深入去学习, 不要太杞人忧天了!</p>
<p>在精钻一门学问的情况下, 可以扩大自己的知识面, 而不是 <code>吃着碗里看着锅里</code> 的, 要脚踏实地的大步向前.</p>
<h2 id="坚持学习"><a href="#坚持学习" class="headerlink" title="坚持学习"></a>坚持学习</h2><p>上面的扯淡有点多啊.回正题.</p>
<p>既然搞清楚了为什么学习它, 接下来就是搞定它.</p>
<p>你需要有坚持学习的态度和行动, 不然一切都会成为云烟. 那么当初咬牙切齿的抱负, 结果都是冲动的惩罚.</p>
<p>学习新知识的前期是很累的, 但是只要你意志足够坚定, 一定可以克服种种困难.</p>
<p>记得当初接手一个二手项目, 项目也是足够复杂, 并且有很多引擎之前都没有用过, 上面领导逼得比较紧, 没办法, 只能将其拿下, 每天晚上挑灯夜战, 在 log 的海洋里遨游.</p>
<p>很快自己掌握了新的知识, 结合项目, 不断的去调试和总结, 最终按期完成需求, 回过头想想, 想要坚持做好一件事情, 除了自身的自我约束, 还需要外界环境的 倒逼.</p>
<p>当你坚持不住的时候, 问问自己, 是否已经到了极限, 如果感到累了, 适当的放松一下, 比如出去跑个步, 打个球或者找朋友叙叙旧.</p>
<p>适当的给自己一点压力, 事半功倍.</p>
<h2 id="学习的渠道"><a href="#学习的渠道" class="headerlink" title="学习的渠道"></a>学习的渠道</h2><p>刚开始学习新知识, 大家都渴望有一些大牛能够指导自己, 或者能够从前辈那里获取一些武林秘籍, 这些都是学习的渠道.</p>
<p>有些小伙伴在学习的过程中, 会遇到各种各样的困难, 比如在学习一门知识的时候, 发现竟然还需要学习另一门新知识, 真是日了狗了!<br>到这里, 可能有些人就会情不自禁的选择了放弃, 嘴上说还在学习, 其实心里已经疲倦.</p>
<p>还有一些初学者, 他们没有什么经验, 如果主动性再差点, 动辄遇到问题就问, 根本没有过思考, 哪怕是一点点的思考都没有.其实他们不是不想搞, 就怕搞错了.仅仅是因为怕, 就戛然而止了!<br>这种人, 确实可惜, 所以他们需要更多的指导和教育.这里提醒大家, 学习知识, 不要怕犯错, 大胆的去试错, 在错误中成长, 这样你才能有所收获.</p>
<p>记得以前为了安装 linux, 我把办公室的办公电脑都格式化了, 组长差点要开除我了, 现在想想虽然挨了骂, 但是挺值得.</p>
<p>现在互联网很发达, 想学习的东西基本网上都有, 你可以没有智商, 没有情商, 但是你一定要有 <code>搜商 (搜索能力)</code>.<br>当你自己经过思考, 无法解决问题, 就去搜索相关的知识, 如果搜索也失败了, 再去请教别人, 这样你就可以从中收获意外的惊喜.</p>
<p>所以, 学习渠道的重要来源之一就是在互联网搜索, 培养自己的搜索能力很重要, 我建议大家使用谷歌浏览器, 然后使用 google 的搜索引擎, 搭建一套翻墙的 VPN, 这样你可以在知识的海洋里爽翻.</p>
<p>另外一个比较重要的学习渠道就是你认为的牛人, 向他们学习相关的学习方法, 问他们是怎么学习的, 然后结合自己的实际情况加以运用, 跟他们多交流.</p>
<h2 id="对自己’狠’一些"><a href="#对自己’狠’一些" class="headerlink" title="对自己’狠’一些"></a>对自己’狠’一些</h2><p>我之前有个坏习惯, 喜欢晚上躺在床上看视频, 这些视频可能是优酷或者腾讯视频客户端的, 也有可能是新闻类的 app 来源的视频.<br>视频只要看起来, 时间就不受控制了.第二天早晨起床也很困难.</p>
<p>最后自己把视频类和新闻类 app 全部卸载掉了, 然后把目标转移到 stackoverflow 和 github 上面.<br>那里才是程序员的世界, 只有你想不到的, 没有做不到的.</p>
<p>为了学习新知识, 你需要对自己狠一点, 每天拿点时间出来总结和学习, 一个月一个季度一年下来, 你比别人都进步了很多.</p>
<p>养成一个好习惯, 终生受益.</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 生活 反思 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS: 聊聊 UIWebView 缓存]]></title>
      <url>/2017/01/15/iOS-%E8%81%8A%E8%81%8A-UIWebView-%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发项目过程中, 一些若交互的页面会使用 HTML 展示.</p>
<p>在 iOS 中, 使用 UIWebView 的频率还是比较高的.</p>
<p>今天跟大家聊聊 UIWebView 缓存相关的话题.</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我今天使用 Tomcat 来作为 web 容器, 在本机搭建一个 web 服务器, 然后使用 iPhone 访问该 web 页面, 展示和梳理 UIWebview 关于缓存的问题.</p>
<p>如果你对 Tomcat 还不熟悉, 希望你可以先去大概了解一下, 如何在 Mac os 上面安装和使用 Tomcat, 可以参考我的博文: [Mac 配置 Tomcat8].</p>
<blockquote>
<p>Tomcat 是一个开放源代码、运行 servlet 和 JSP Web 应用软件的基于 Java 的 Web 应用软件容器.<br>Tomcat Server 是根据 servlet 和 JSP 规范执行的，因此可以说 Tomcat Server 实行了 Apache-Jakarta 规范，且比绝大多数商业应用软件服务器要好.<br>但是 Tomcat 对静态文件、高并发的处理比较弱.</p>
</blockquote>
<p>写这篇文章的时候, 我使用的版本分别是 <code>apache-tomcat-8.5.8</code>, <code>jdk1.8</code>.</p>
<h2 id="配置-Tomcat"><a href="#配置-Tomcat" class="headerlink" title="配置 Tomcat"></a>配置 Tomcat</h2><h3 id="修改-server-xml-文件"><a href="#修改-server-xml-文件" class="headerlink" title="修改 server.xml 文件"></a>修改 server.xml 文件</h3><p>文件在 Tomcat 的根目录的 conf 目录下, 如我的文件在这个目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apache-tomcat-8.5.8/conf/server.xml</div></pre></td></tr></table></figure>
<p>增加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;&lt;your local ip&gt;&quot; debug=&quot;0&quot; appBase=&quot;&lt;base dir&gt;&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">	&lt;Context path=&quot;&quot; docBase=&quot;&lt;html file path&gt;&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">	&lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
<p>注意:<br>1.将上述内容放到 <code>&lt;/Host&gt;</code> 和 <code>&lt;/Engine&gt;</code> 节点中间.<br>2.将 <code>name=&quot;&lt;your local ip&gt;&quot;</code> 中的 <your local="" ip=""> 改为你本机的 ip 地址.<br>查看本机的 ip 地址方法很简单:</your></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1</div></pre></td></tr></table></figure>
<p>3.将 appBase=”<base dir="">“ 中的 <base dir=""> 改为你的 web 目录.<br>4.将 docBase=”<html file="" path="">“ 中的 <html file="" path=""> 改为你的 html 目录.</html></html></p>
<p>我的配置如下(部分):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</div><div class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</div><div class="line">        &lt;!-- SingleSignOn valve, share authentication between web applications</div><div class="line">             Documentation at: /docs/config/valve.html --&gt;</div><div class="line">        &lt;!--</div><div class="line">        &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;</div><div class="line">        --&gt;</div><div class="line">        &lt;!-- Access log processes all example.</div><div class="line">             Documentation at: /docs/config/valve.html</div><div class="line">             Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;</div><div class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</div><div class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</div><div class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</div><div class="line">	&lt;/Host&gt;</div><div class="line">        &lt;!--mark 配置静态网页. [BEGIN] --&gt;</div><div class="line">        &lt;Host name=&quot;192.168.1.103&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">            &lt;Context path=&quot;&quot; docBase=&quot;test&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">            &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot; directory=&quot;logs&quot; prefix=&quot;tot_log.&quot; suffix=&quot;.txt&quot; timestamp=&quot;true&quot;/&gt;</div><div class="line">        &lt;/Host&gt;</div><div class="line">        &lt;!--mark 配置静态网页. [END] --&gt;</div><div class="line">    &lt;/Engine&gt;</div><div class="line">  &lt;/Service&gt;</div><div class="line">&lt;/Server&gt;</div></pre></td></tr></table></figure>
<p>搞定上面的配置, 接下来可以配置相关目录了.</p>
<p>在 Tomcat 的根目录有个文件夹 webapps, 在 webapps 目录下新建目录 test 即可.</p>
<h2 id="构建-HTML-页面"><a href="#构建-HTML-页面" class="headerlink" title="构建 HTML 页面"></a>构建 HTML 页面</h2><p>在 test 目录, 新建一个 html 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch test.html</div></pre></td></tr></table></figure>
<p>文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> &lt;p&gt;</div><div class="line">&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">Now I input another line, with fancy&lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;</div><div class="line">&lt;/u&gt;.&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">&lt;em&gt;Sample&lt;/em&gt; text&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">Now I input another line, with fancy &lt;u&gt;&lt;strong&gt;&lt;em&gt;styles&lt;/em&gt;&lt;/strong&gt;</div><div class="line">&lt;/u&gt;.&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">    mark.zhang is itman.</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;style&gt;</div><div class="line">.button &#123;</div><div class="line">    background-color: #4CAF50;</div><div class="line">    border: none;</div><div class="line">    color: white;</div><div class="line">    padding: 15px 32px;</div><div class="line">    text-align: center;</div><div class="line">    text-decoration: none;</div><div class="line">    display: inline-block;</div><div class="line">    font-size: 86px;</div><div class="line">    margin: 50px 200px 100px 300px;</div><div class="line">    cursor: pointer;</div><div class="line">    border-radius: 15;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;p&gt;</div><div class="line">   &lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot; class=&quot;button&quot;&gt;Try it&lt;/button&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;script&gt;</div><div class="line">   function myFunction() &#123;</div><div class="line">       alert(&quot;Blog: www.veryitman.com&quot;);</div><div class="line">   &#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>搭建完成后, 启动 Tomcat 服务器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startup.sh</div></pre></td></tr></table></figure>
<p>在浏览器里面通过 ip:port/test.html 的方式来访问该页面.</p>
<p>看到类似下面的效果即表示搭建成功:</p>
<p><img src="/upload/images/2017/01/15/html.png" alt="1"></p>
<h2 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h2><p>客户端访问该页面, 使用 UIWebview 来请求(HTTP 协议)页面内容.</p>
<p>一般请求会使用下面的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)requestWithURL:(NSURL *)URL;</div></pre></td></tr></table></figure>
<p>该方法的描述如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Creates and returns a URL request for a specified URL with default cache policy and timeout value.</div><div class="line">The default cache policy is NSURLRequestUseProtocolCachePolicy and the default timeout interval is 60 seconds.</div></pre></td></tr></table></figure>
<p>大概意思是使用的缓存策略是根据协议来的, 即 NSURLRequestUseProtocolCachePolicy. 超时时间默认是60s.</p>
<p>也就是说类似如下的请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSURLRequest *urlReq = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60.f];</div></pre></td></tr></table></figure>
<p>如果协议支持缓存的话, UIWebview 请求到的数据就是缓存数据.该缓存是需要 WEB 服务器支持的.</p>
<p>这里我没有配置 Tomcat 的缓存.可以抓包看下:</p>
<p><img src="/upload/images/2017/01/15/rsp1.png" alt="2"></p>
<p>后续博客会分别为大家介绍在 Tomcat 和 Nginx 配置缓存下, 客户端 UIWebview 请求的相关问题.</p>
<p>客户端显示页面效果:<br><img src="/upload/images/2017/01/15/c1.jpeg" alt="2"></p>
<p>ViewController 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">static NSString * const H5Url = @&quot;http://192.168.1.104:8080/test.html&quot;;</div><div class="line"></div><div class="line">@interface ViewController () &lt;UIWebViewDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, strong) UIWebView *webView;</div><div class="line"></div><div class="line">@property (nonatomic, strong) UIButton *refBtn;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    _webView = [[UIWebView alloc] init];</div><div class="line">    CGSize boundsSize = self.view.bounds.size;</div><div class="line">    self.webView.frame = CGRectMake(0, 20, boundsSize.width, boundsSize.height);</div><div class="line">    self.webView.backgroundColor = [UIColor whiteColor];</div><div class="line">    self.webView.scrollView.showsHorizontalScrollIndicator = NO;</div><div class="line">    self.webView.scrollView.showsVerticalScrollIndicator   = NO;</div><div class="line">    self.webView.scalesPageToFit = YES;</div><div class="line">    self.webView.delegate = self;</div><div class="line">    [self.view addSubview:self.webView];</div><div class="line">    </div><div class="line">    UIButton *refreshBtn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">    [self.view addSubview:refreshBtn];</div><div class="line">    [refreshBtn addTarget:self action:@selector(onRefreshWebView) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    refreshBtn.backgroundColor = [UIColor redColor];</div><div class="line">    refreshBtn.layer.masksToBounds = YES;</div><div class="line">    refreshBtn.layer.cornerRadius = 5.f;</div><div class="line">    refreshBtn.frame = CGRectMake(50, 250, 200, 50);</div><div class="line">    [refreshBtn setTitle:@&quot;刷新页面&quot; forState:UIControlStateNormal];</div><div class="line">    _refBtn = refreshBtn;</div><div class="line">    </div><div class="line">    [self loadDataUsingCache];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;didFailLoadWithError: %@&quot;, error);</div><div class="line">    </div><div class="line">    [self hideLoading];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request</div><div class="line"> navigationType:(UIWebViewNavigationType)navigationType</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;shouldStartLoadWithRequest: %@&quot;, request);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)webViewDidStartLoad:(UIWebView *)webView</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;webViewDidStartLoad&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;webViewDidFinishLoad&quot;);</div><div class="line">    </div><div class="line">    [self hideLoading];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//刷新页面.</div><div class="line">- (void)onRefreshWebView</div><div class="line">&#123;</div><div class="line">    // 方式1: 不使用缓存请求数据</div><div class="line">    //[self loadDataNoUsingCache];</div><div class="line">    </div><div class="line">    // 方式2: 清除 NSCache 缓存, 再请求数据</div><div class="line">    [self clearAllCache];</div><div class="line">    [self loadDataUsingCache];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)loadDataUsingCache</div><div class="line">&#123;</div><div class="line">    [self showLoading];</div><div class="line">    </div><div class="line">    NSURL *url = [NSURL URLWithString:H5Url];</div><div class="line">    </div><div class="line">    NSURLRequest *urlReq = [NSURLRequest requestWithURL:url</div><div class="line">                                            cachePolicy:NSURLRequestReturnCacheDataDontLoad</div><div class="line">                                        timeoutInterval:10.f];</div><div class="line">    </div><div class="line">    [self.webView loadRequest:urlReq];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)loadDataWithProtocol</div><div class="line">&#123;</div><div class="line">    [self showLoading];</div><div class="line">    </div><div class="line">    NSURL *url = [NSURL URLWithString:H5Url];</div><div class="line">    </div><div class="line">    [NSURLRequest requestWithURL:url];</div><div class="line">    </div><div class="line">    NSURLRequest *urlReq = [NSURLRequest requestWithURL:url</div><div class="line">                                            cachePolicy:NSURLRequestUseProtocolCachePolicy</div><div class="line">                                        timeoutInterval:60.f];</div><div class="line">    </div><div class="line">    [self.webView loadRequest:urlReq];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)loadDataNoUsingCache</div><div class="line">&#123;</div><div class="line">    [self showLoading];</div><div class="line">    </div><div class="line">    NSURL *url = [NSURL URLWithString:H5Url];</div><div class="line">    NSURLRequest *urlReq = [NSURLRequest requestWithURL:url</div><div class="line">                                            cachePolicy:NSURLRequestReloadIgnoringCacheData</div><div class="line">                                        timeoutInterval:20.0];</div><div class="line">    [self.webView loadRequest:urlReq];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)clearAllCache</div><div class="line">&#123;</div><div class="line">    // remove cache rsp</div><div class="line">    [[NSURLCache sharedURLCache] removeAllCachedResponses];</div><div class="line">    </div><div class="line">    [[NSURLCache sharedURLCache] setDiskCapacity:0];</div><div class="line">    [[NSURLCache sharedURLCache] setMemoryCapacity:0];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)showLoading</div><div class="line">&#123;</div><div class="line">    [self.refBtn setTitle:@&quot;刷新中...&quot; forState:UIControlStateNormal];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)hideLoading</div><div class="line">&#123;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        [self.refBtn setTitle:@&quot;刷新页面&quot; forState:UIControlStateNormal];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里注意下面的 三个方法 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 使用缓存数据, 如果有缓存的话</div><div class="line">// 使用这个方法, 改变 HTML 或者 JS 代码</div><div class="line">// 页面不会拉取最新数据, 还是使用之前请求到的数据.</div><div class="line">// 除非重新刷新</div><div class="line">- (void)loadDataUsingCache;</div><div class="line">// 使用协议缓存, 需要 web 服务器支持.</div><div class="line">- (void)loadDataWithProtocol;</div><div class="line">// 不使用缓存, 加载数据</div><div class="line">- (void)loadDataNoUsingCache;</div></pre></td></tr></table></figure>
<p>另外, 刷新 UIWebview 的方式如下, 有 两种方式 来刷新页面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  刷新页面.</div><div class="line"> */</div><div class="line">- (void)onRefreshWebView</div><div class="line">&#123;</div><div class="line">    // 方式1: 不使用缓存请求数据</div><div class="line">    //[self loadDataNoUsingCache];</div><div class="line">    </div><div class="line">    // 方式2: 清除 NSCache 缓存, 再请求数据</div><div class="line">    [self clearAllCache];</div><div class="line">    [self loadDataUsingCache];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种刷新方式, 会重新加载数据.<br>但是不适合多层级的 HTML 页面, 比如你的 HTML 页面有很多层, 想刷新当前页面, 可以使用下面的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 重新加载当前页面</div><div class="line">[self.webView reload];</div></pre></td></tr></table></figure>
<h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><p>查看本机 IP 的 shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1</div></pre></td></tr></table></figure>
<p>停止 Tomcat 的运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shutdown.sh</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS UIWebView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[f8app]]></title>
      <url>/2017/01/01/f8app/</url>
      <content type="html"><![CDATA[<p>本文主要探讨的是如何编译和运行 f8app.</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>f8app</code> 是 Facebook 开源的, 基于 React Native 开发的一款 App.</p>
<p>代码基本都是 js 的, 很少有原生的代码.</p>
<p><code>f8app</code> 是借鉴和学习 React Native 的上好资料.</p>
<p>原文介绍:</p>
<blockquote>
<p>This is the entire source code of the official F8 app of 2016, available on Google Play and the App Store.</p>
</blockquote>
<p>项目开源地址: <a href="https://github.com/fbsamples/f8app" target="_blank" rel="noopener">Github</a></p>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul>
<li>安装和配置了 React Native 开发环境.</li>
<li>Xcode 7.3 +</li>
<li>CocoaPods (only for iOS) 1.0+</li>
<li>MongoDB (needed to run Parse Server locally)</li>
</ul>
<h3 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a>源码构建</h3><p>下载源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/fbsamples/f8app.git</div></pre></td></tr></table></figure>
<p>下载完成后, 进入下载的 f8app 目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd f8app</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>如果是 iOS 的话, 需要进入 iOS 目录执行 <code>pod install</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ios</div><div class="line">pod install</div></pre></td></tr></table></figure>
<p>在项目 f8app 目录下运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm start</div></pre></td></tr></table></figure>
<p>打开浏览器输入地址 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>, 可以看到 graphql 的界面.</p>
<h3 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h3><p>使用 Homebrew 来安装.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mongodb</div></pre></td></tr></table></figure>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>导入例子数据.</p>
<p>注意:<br>在源码的路径即 <code>~/yourpath/f8app</code> 下面执行, 下面操作没有特殊说明都是在源码根目录下面操作.<br>你可以多开几个终端端口来进行操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run import-data</div></pre></td></tr></table></figure>
<p>导入例子数据, 会报下面的 错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">error: Uncaught internal server error. &#123; [MongoError: connect ECONNREFUSED 127.0.0.1:27017]</div><div class="line">name: &apos;MongoError&apos;,</div><div class="line">message: &apos;connect ECONNREFUSED 127.0.0.1:27017&apos; &#125; Error: connect ECONNREFUSED 127.0.0.1:27017</div><div class="line">at Object.exports._errnoException (util.js:893:11)</div><div class="line">at exports._exceptionWithHostPort (util.js:916:20)</div><div class="line">at TCPConnectWrap.afterConnect as oncomplete</div></pre></td></tr></table></figure>
<p>需要安装 <code>mongodb-runner</code></p>
<p>安装方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g parse-server mongodb-runner</div></pre></td></tr></table></figure>
<p>运行 <code>mongodb-runner</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodb-runner start</div></pre></td></tr></table></figure>
<p>这里执行完毕后, 需要等待一会.</p>
<p>你会看到如下信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Starting a MongoDB deployment to test against...</div></pre></td></tr></table></figure>
<p>上面运行结束后, 你可以查看 MongoDB 是否在运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -iTCP:27017 -sTCP:LISTEN</div></pre></td></tr></table></figure>
<p>会显示当前正在运行的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">COMMAND   PID USER   FD   TYPE             DEVICE    SIZE/OFF  NODE  NAME</div><div class="line">mongod  86824 mark    7u  IPv4    0x91959c43a65644ed      0t0  TCP *:27017 (LISTEN)</div></pre></td></tr></table></figure>
<p>停止 mongodb 运行的方式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodb-runner stop</div></pre></td></tr></table></figure>
<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><p><a href="http://localhost:8080/dashboard" target="_blank" rel="noopener">Parse Dashboard</a></p>
<p><a href="http://localhost:8080/graphql" target="_blank" rel="noopener">GraphiQL</a></p>
<h3 id="启动-react-native"><a href="#启动-react-native" class="headerlink" title="启动 react-native"></a>启动 react-native</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native start</div></pre></td></tr></table></figure>
<h3 id="运行-f8app"><a href="#运行-f8app" class="headerlink" title="运行 f8app"></a>运行 f8app</h3><p>Android:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">react-native run-android</div><div class="line">adb reverse tcp:8081 tcp:8081   # required to ensure the Android app can</div><div class="line">adb reverse tcp:8080 tcp:8080   # access the Packager and GraphQL server</div></pre></td></tr></table></figure>
<p>iOS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native run-ios</div></pre></td></tr></table></figure>
<p>如果出现红色背景的 error 提示, 可以不管, 直接 Dismiss 即可.</p>
<p>然后可以看到如下界面:</p>
<p><img src="/upload/images/2017/01/01/f8app.jpg" alt="1"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.在运行后关闭登录按钮, 报错: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AppEventsLogger.logEvent</div></pre></td></tr></table></figure>
<p>解决方案:</p>
<p>在 <code>/js/store/track.js</code> 文件的第 43 行, 注释掉 log, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">case &apos;SKIPPED_LOGIN&apos;:</div><div class="line">      //AppEventsLogger.logEvent(&apos;Skip login&apos;, 1);</div><div class="line">      break;</div></pre></td></tr></table></figure>
<p>在模拟器上面重新 Reload 即可.</p>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS Android JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[再见 2016]]></title>
      <url>/2016/12/11/%E5%86%8D%E8%A7%81-2016/</url>
      <content type="html"><![CDATA[<p>今天是 2016 年的最后一天, 正好赶上放假, 给自己的这一年做个小结.</p>
<p>2016, 继续做项目, 作为一名软件工程师, 不停地在学习.</p>
<p>2016, 学习到了很多关于产品和运营相关的知识. 知道了 倒逼 的作用.</p>
<p>2016, 读了 20 本非技术类书籍, 养成了读书的习惯, 并把读书的好处讲给身边的人听.</p>
<p>2016, 开始减肥, 注意锻炼身体, 几乎每周都有一次从公司到家的步行, 一次篮球或者跑步运动.</p>
<p>2016, 购买了域名, 建立了自己的 <a href="file:///Users/mark/Desktop/backups/public/2016/12/31/veryitman.com" target="_blank" rel="noopener">博客网站</a>.</p>
<p>2016, 儿子大了一岁, 自己老了一岁, 家庭依旧幸福着.渐渐地理解了做父亲的责任.</p>
<p>2016 对自己影响最大的几句话, 分享给大家:</p>
<blockquote>
<p>1.技术要给产品提供最大的自由度.<br>2.不要轻易的说 NO.<br>3.要不断的让自己值钱, 而不是简单的为了金钱而跳槽.<br>4.不要总是抱怨你的产品设计是狗屎, 学会和产品沟通更优的方案.<br>5.关注细节, 把产品做好.<br>6.多关注别人的优点.<br>7.让对方把话说完.<br>8.多看书, 多思考.</p>
</blockquote>
<p>感谢所有陪伴和支持我的朋友, 同事, 亲人!</p>
<p>祝愿所有人 2017 幸福, 健康, 快乐!</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 配置 Tomcat8]]></title>
      <url>/2016/11/26/Mac-%E9%85%8D%E7%BD%AE-Tomcat8/</url>
      <content type="html"><![CDATA[<h2 id="Tomcat-简介"><a href="#Tomcat-简介" class="headerlink" title="Tomcat 简介"></a>Tomcat 简介</h2><p>Tomcat 是一个 Web 服务器.</p>
<blockquote>
<p>Web 服务器是指为特定组件提供服务的一个标准化的运行时的环境.<br>可为组件提供事务处理, 数据访问, 安全性和持久性等服务.</p>
</blockquote>
<p>Tomcat 是免费且开源的, 他是 Apache 软件基金会 Jakarta 项目中的其中一个子项目.由 Apache, Sun 和其他一些公司及个人共同开发完成.</p>
<p>Tomcat 也是使用最为广泛的 JSP 服务器.</p>
<blockquote>
<p>JSP 是 Java Server Pages 的简称, 是在传统的 HTML 文件中插入 Java 程序段和 JSP 标记的一种动态网页技术.</p>
</blockquote>
<h2 id="下载-Tomcat"><a href="#下载-Tomcat" class="headerlink" title="下载 Tomcat"></a>下载 Tomcat</h2><p>前往 <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">这里</a> 可以下载 Tomcat.</p>
<p>我目前安装的是 8.5.8 版本的.</p>
<p><img src="/upload/images/2016/11/26/tomcat1.png" alt="1"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先安装 JDK, 安装教程可以参考 [Mac 配置 JDK1.8] 这篇文章.</p>
<p>解压下载的 tar.gz 即可.</p>
<p>最好解压到自己的工作目录, 如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/workspace/developr/</div></pre></td></tr></table></figure>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>编辑 <code>/etc/profile</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/profile</div></pre></td></tr></table></figure>
<p>添加如下变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JRE_HOME=$JAVA_HOME</div><div class="line">TOMCAT_HOME=/Users/mark/developer/apache/apache-tomcat-8.5.8</div><div class="line">PATH=$JAVA_HOME/bin:$TOMCAT_HOME/bin:$PATH</div><div class="line">export JRE_HOME</div><div class="line">export PATH</div></pre></td></tr></table></figure>
<p>其中的 JAVA_HOME 是 [Mac 配置 JDK1.8] 这篇文章里面设置的 JDK 的环境变量.</p>
<p>配置环境变量的目的, 可以让我们方便的使用 Tomcat 的命令.</p>
<h2 id="检验安装是否成功"><a href="#检验安装是否成功" class="headerlink" title="检验安装是否成功"></a>检验安装是否成功</h2><p>使 <code>/etc/profile</code> 配置文件立即生效.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure>
<p>如果没有生效, 重启终端即可.</p>
<p>开启 Tomcat 服务, 执行下面的命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startup.sh</div></pre></td></tr></table></figure>
<p>该命令在 Tomcat 的安装目录的 bin 目录下面.</p>
<p>执行后, 可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Using CATALINA_BASE:   /Users/mark/developer/apache/apache-tomcat-8.5.8</div><div class="line">Using CATALINA_HOME:   /Users/mark/developer/apache/apache-tomcat-8.5.8</div><div class="line">Using CATALINA_TMPDIR: /Users/mark/developer/apache/apache-tomcat-8.5.8/temp</div><div class="line">Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home</div><div class="line">Using CLASSPATH:       /Users/mark/developer/apache/apache-tomcat-8.5.8/bin/bootstrap.jar:/Users/mark/developer/apache/apache-tomcat-8.5.8/bin/tomcat-juli.jar</div><div class="line">Tomcat started.</div></pre></td></tr></table></figure>
<p>在浏览器里面打开: <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p>
<p>即可看到一只可爱的 Tom 猫.</p>
<p>执行 <code>shutdown.sh</code> 可以关闭 Tomcat.</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tomcat Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 安装和使用 infer]]></title>
      <url>/2016/11/26/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-infer/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>infer 是 Facebook 开源的一款代码静态检查工具, 源码可以在 <a href="https://github.com/facebook/infer" target="_blank" rel="noopener">Github</a> 上面获取.</p>
<p>支持 Java/C/OC 等语言, 支持 Gradle, Buck, Maven, Xcodebuild, Make 等.</p>
<p>我一般用来分析 iOS 和 Android 工程.</p>
<p>可以在 <a href="http://fbinfer.com/docs/getting-started.html" target="_blank" rel="noopener">这里</a> 查看 Start.</p>
<h2 id="安装-infer"><a href="#安装-infer" class="headerlink" title="安装 infer"></a>安装 infer</h2><p>只要你用 Homebrew, mac 下安装 infer 很简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew update</div><div class="line">brew install infer</div></pre></td></tr></table></figure>
<p>在早期版本, infer 不支持 brew 安装. 安装起来各种问题, 现在 infer 支持了 brew 安装, 很方便.</p>
<p>这里我使用的 infer 版本是 0.9.4.</p>
<p>安装成功后, 可以查看安装版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">infer -version</div></pre></td></tr></table></figure>
<p>可以看到如下信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Infer version v0.9.4</div><div class="line">Copyright 2009 - present Facebook. All Rights Reserved.</div><div class="line">Mac:public mark$ infer --version</div><div class="line">Infer version v0.9.4</div><div class="line">Copyright 2009 - present Facebook. All Rights Reserved.</div></pre></td></tr></table></figure>
<p>这里有个问题, 有时候 brew 无法更新最新的 infer, 我目前的解决方案是先卸载之前安装的 infer, 然后再重新安装.</p>
<p>卸载 infer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew uninstall infer</div></pre></td></tr></table></figure>
<h2 id="安装-xcpretty"><a href="#安装-xcpretty" class="headerlink" title="安装 xcpretty"></a>安装 xcpretty</h2><p><a href="https://github.com/supermarin/xcpretty" target="_blank" rel="noopener">xcpretty</a> 是一款格式化 xcodebuild 输出结果的工具.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">▸ Building X/N [(Release)]</div><div class="line">▸ Check Dependencies</div><div class="line">▸ Copying Info.plist</div><div class="line">▸ Running script &apos;[CP] Check Pods Manifest.lock&apos;</div><div class="line">▸ Running script &apos;Replace PaySdk&apos;</div><div class="line">▸ Compiling User.m</div></pre></td></tr></table></figure>
<p>从0.9.4版本后, infer 默认使用了 xcpretty.</p>
<p>可以使用 gem 安装 xcpretty 工具:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install xcpretty</div></pre></td></tr></table></figure>
<p>如果没有安装成功, 或者提示权限不够, 那就这样折腾:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install xcpretty</div></pre></td></tr></table></figure>
<p>想了解更多关于 xcpretty 的使用可以去 <a href="https://github.com/supermarin/xcpretty" target="_blank" rel="noopener">github</a>.</p>
<h2 id="使用-infer"><a href="#使用-infer" class="headerlink" title="使用 infer"></a>使用 infer</h2><h3 id="iOS-项目使用-infer"><a href="#iOS-项目使用-infer" class="headerlink" title="iOS 项目使用 infer"></a>iOS 项目使用 infer</h3><p>infer 的文档写的也较全面.</p>
<p>可以在 <a href="http://fbinfer.com/docs/infer-workflow.html" target="_blank" rel="noopener">这里</a> 查看使用方法.</p>
<p>1.分析 Cocoapods 项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">infer -- xcodebuild -workspace N.xcworkspace -scheme NSchema</div></pre></td></tr></table></figure>
<p>其中 N.xcworkspace 是你的 workspace 名称, NSchema 是你需要检查的 Schema 名称.</p>
<p>2.分析 .xcodeproj</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">infer -- xcodebuild -target targetName -configuration Debug -sdk iphonesimulator</div></pre></td></tr></table></figure>
<p>其中 targetName 是项目的 target 名称, 必须指定.</p>
<p>分析成功后, infer 会有输出报告.</p>
<p>该报告在你的项目目录下, 名称是 infer-out.</p>
<p>bug.txt 是以文本方式输出的 issue 文档.<br>另外还有 csv 格式的 issue 文档.</p>
<h3 id="Android-Gradle-工程使用-infer"><a href="#Android-Gradle-工程使用-infer" class="headerlink" title="Android Gradle 工程使用 infer"></a>Android Gradle 工程使用 infer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gradle clean</div><div class="line">infer -- gradle build</div></pre></td></tr></table></figure>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>infer 还有很多高级的用法, 比如可以增量检查.</p>
<p>增量检查的功能依赖于你的编译器是否支持.</p>
<p>infer 增量检查的选项是 –reactive.</p>
<blockquote>
<p>之前的版本是 –incremental 选项.<br>自从 v0.8.0 版本后使用了 –reactive 选项.</p>
</blockquote>
<p>可以这样来进行增量检查:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">infer --reactive -- xcodebuild -workspace N.xcworkspace -scheme NSchema</div></pre></td></tr></table></figure>
<p>infer 还有很多高级用法, 可以在 <a href="http://fbinfer.com/docs/advanced-features.html" target="_blank" rel="noopener">Advanced usage</a> 中去查阅和使用.</p>
<p>再使用过程中, 随着 MacOS, Xcode 的升级, infer 会面临更多的挑战, 如果遇到问题, 第一时间去 <a href="https://github.com/facebook/infer" target="_blank" rel="noopener">GitHub</a>  上面提  issue.</p>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MacOS infer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 配置 JDK1.8]]></title>
      <url>/2016/11/26/Mac-%E9%85%8D%E7%BD%AE-JDK1-8/</url>
      <content type="html"><![CDATA[<h2 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h2><p>在 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里下载</a> jdk.</p>
<p>下载版本是 1.8u112, 信息如下:</p>
<p><img src="/upload/images/2016/11/26/jdk1.png" alt="1"></p>
<h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><p>下载完成后, 直接双击安装即可.</p>
<h2 id="配置-Path"><a href="#配置-Path" class="headerlink" title="配置 Path"></a>配置 Path</h2><p>成功安装后, 目录<br><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/</code> 就会存在.</p>
<p>编辑 <code>/etc/profile</code> 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/profile</div></pre></td></tr></table></figure>
<p>添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home</div><div class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line">PATH=$JAVA_HOME/bin:$PATH</div><div class="line">export JAVA_HOME</div><div class="line">export CLASSPATH</div><div class="line">export PATH</div></pre></td></tr></table></figure>
<p>保存文件.</p>
<p>使这个文件立即生效.可以 source 一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure>
<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>执行下面命令来检验 jdk 是否安装成功.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure>
<p>输出如下信息, 标示配置 JDK 成功.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version “1.8.0_112”</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b16)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MacOS java jdk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GameDevelopment: 与 Cocos2d 的再相逢]]></title>
      <url>/2016/11/12/GameDevelopment-%E4%B8%8E-Cocos2d-%E7%9A%84%E5%86%8D%E7%9B%B8%E9%80%A2/</url>
      <content type="html"><![CDATA[<h2 id="认识-Cocos2d"><a href="#认识-Cocos2d" class="headerlink" title="认识 Cocos2d"></a>认识 Cocos2d</h2><p>相信很多人听说过 cocos2d-x 这个引擎, 但听过 <a href="http://cocos2d-objc.org/" target="_blank" rel="noopener">cocos2d-objc</a> 的人应该不多.</p>
<p>cocos2d-objc 是 cocos 系列的 objective-c 版本.<br>开发语言是 OC.在 iOS 上面使用该版本的引擎, 基本是无缝连接(写的没有什么障碍).</p>
<p>欣赏一下 cocos2d-objc 的 logo, 如图:<br><img src="/upload/images/2016/11/12/1.png" alt="1"></p>
<p>如果你对 OC 版感兴趣, 可以通过博文 <a href="http://blog.csdn.net/veryitman/article/details/44993643" target="_blank" rel="noopener">coco2d-iphone: 环境搭建</a> 去了解.</p>
<p>cocos2d-x 目前支持 JavaScript, lua, c++ 等主流语言来开发.<br>cocos 还在迅猛发展中, 不断的完善开发工具, 广大游戏开发者依然热力贡献, 程序猿们在游戏的战场挥洒青春.</p>
<p>现在 cocos 的开发者会得到更多的支持.</p>
<p>下面给张图来展示 cocos 家族及其发展:<br><img src="/upload/images/2016/11/12/2.png" alt="1"></p>
<h2 id="由-libgdx-转向-Cocos2d"><a href="#由-libgdx-转向-Cocos2d" class="headerlink" title="由 libgdx 转向 Cocos2d"></a>由 libgdx 转向 Cocos2d</h2><p>几年前, 那个时候还在开发棋牌游戏, 当时自己也是刚刚接触游戏开发这个「高逼格」的行业, 之前自己是个纯 App 开发者.</p>
<p>内心还是蛮激动的, 心想可能要走上人生巅峰了…</p>
<p>棋牌游戏, 当时使用的是 java 的游戏引擎 <a href="https://libgdx.badlogicgames.com/" target="_blank" rel="noopener">libgdx</a> 0.X.X 的版本, 该引擎和 Android 基本也是无缝连接, Api 设计的很好.</p>
<p>现在 libgdx 也发展到了1.6.x 版本了, 工具也完善了很多.</p>
<p>虽然 libgdx 也可以跨平台, 但是最终我们还是选择了 cocos2d-x 来移植该游戏.其中原因是因为 cocos2d-x 太火了, 人也好找.</p>
<p>改为 cocos2d-x 的版本之后, 我就被安排到了另外一个项目, 也是一个棋牌游戏, 该游戏现在在腾讯的微信游戏里面运营.</p>
<p>这个游戏是 cocos2d-objc 的引擎写的, 自己也不会 objc, 于是硬着头皮学习, 很快的就上手了这个项目.写的也是风生水起.</p>
<p>cocos2d-objc, 现在也支持跨平台, 并且有 xcode 的插件, 可以在 xcode 里面写 Android 的代码, 调试开发等.</p>
<p>因为接触 cocos2d, 后面就直接开搞 iOS 开发了.</p>
<h2 id="再次使用-Cocos2d"><a href="#再次使用-Cocos2d" class="headerlink" title="再次使用 Cocos2d"></a>再次使用 Cocos2d</h2><p>互联网 IT 业的发展, 刺激了各个行业的发展, 也促进和激发了新生的技术, 在这个行业, 每个人都能体会 <code>活到老学到老</code> 这句话的含义.</p>
<p>这两年, HTML5 的发展, 让很多程序员重新认识了 JavaScript 的重要性. 特别是最近 ReactNative 的发展, jsPacth 的开源, 微信小程序的推出, 让 JavaScript 火得不要不要的.</p>
<p>说实话, 是时候开始学习前端相关的技术了, 至少你需要去了解.</p>
<p>cocos2d-js 的发展, 给 HTML 游戏开发带来了很多便利. 最近我们需要开发 H5 的游戏, 直接拿起 coco2d-x(支持 JavaScript) 就撸起.</p>
<p>去 <a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="noopener">GitHub</a> 上面直接 clone 最新版就可以, 按照 README.md 来搭建环境就好了.</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇博客也是有感而发, 没有实质性的内容.</p>
<p>主要目的是想告诉大家, 技术的发展日新月异, 想在这里大展拳脚, 你需要保持一颗年轻的心, 不怕苦, 勇往直前的精神.</p>
<p>我们需要学习的技术有很多, 我认为, 要根据项目本身的发展来适度的学习, 切记盲目的学习, 学习一门新技术之后, 要及时的运用在项目当中, 并分享给你身边的人.</p>
<blockquote>
<p>不拒绝不排斥新技术, 坚持学习和乐于分享, 应该是必备的技能.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Game </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cocos2d Game </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac install Cocoapods]]></title>
      <url>/2016/11/08/Mac-install-Cocoapods/</url>
      <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>这篇博客原本被我发表在 <a href="http://blog.csdn.net/veryitman/article/details/50769069" target="_blank" rel="noopener">CSDN</a> .</p>
<p>那里不再更新, 现在在这里做持续更新.</p>
<h2 id="导引"><a href="#导引" class="headerlink" title="导引"></a>导引</h2><p>如果你的 Mac OSX 升级到 10.11.x+, 并且需要安装 Cocoapods, 可以参考本博客.</p>
<h2 id="安装-ruby"><a href="#安装-ruby" class="headerlink" title="安装 ruby"></a>安装 ruby</h2><p>Mac 系统自带了 ruby, 但是建议大家使用 Homebrew 安装 ruby.</p>
<p>因为 Cocoapods 升级需要对应的 ruby 版本也要升级, 使用 Homebrew 比较方便.</p>
<p>安装 ruby:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ruby</div></pre></td></tr></table></figure>
<p>查看当前安装的 ruby 版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure>
<p>会得到类似下面的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin15]</div></pre></td></tr></table></figure>
<p>gem 是管理 Ruby 库和程序的标准包.<br>安装了 ruby, 自带了 gem 工具.</p>
<p>可以使用 <code>gem -v</code> 查看 gem 版本.</p>
<h2 id="安装-Cocoapods"><a href="#安装-Cocoapods" class="headerlink" title="安装 Cocoapods"></a>安装 Cocoapods</h2><p>1.移除原来的源, 不管以前是否安装过 Cocoapods.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources --remove http://ruby.taobao.org/</div></pre></td></tr></table></figure>
<p>2.重新添加源, 注意是 https.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -a https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<p>之前 <a href="https://ruby.taobao.org/" target="_blank" rel="noopener">taobao 的源</a> 好像已经不行了.</p>
<p><strong>注意：</strong>添加源之前在浏览器打开 <code>https://gems.ruby-china.org/</code> 这个地址看一看是否能访问，如果不能访问就修改一下为 <code>https://gems.ruby-china.com</code> 这个地址。</p>
<p>3.查看是否添加成功, 该步骤可选.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure>
<p>安装, 使用 root 权限安装.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure>
<p>这种安装方式, 会安装最新的 release 版本.</p>
<p>你也可以使用下面两种方式来安装.</p>
<p>指定版本安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods -v 1.0.0</div></pre></td></tr></table></figure>
<p>安装最新的 release beta 版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods --pre</div></pre></td></tr></table></figure>
<h2 id="卸载-Cocoapods"><a href="#卸载-Cocoapods" class="headerlink" title="卸载 Cocoapods"></a>卸载 Cocoapods</h2><p>卸载 Cocoapods 只需执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem uninstall cocoapods</div></pre></td></tr></table></figure>
<p>如果想删除本地的 pod repo, 可以这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -fr ~/.cocoapods/</div></pre></td></tr></table></figure>
<h2 id="建立本地-repo"><a href="#建立本地-repo" class="headerlink" title="建立本地 repo"></a>建立本地 repo</h2><p>安装完 Cocoapods 后, 需要建立本地的 repo.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod setup</div></pre></td></tr></table></figure>
<p>即使你现在不执行 pod setup, 后面进行 pod install 或者 pod update 的时候, 也会自动的进行 pod setup.</p>
<p>执行 pod setup 的目的是将所有第三方的 podspec 索引文件更新到本地的 <code>~/.cocoapods/repos</code> 目录中.</p>
<h2 id="安装使用中遇到的问题"><a href="#安装使用中遇到的问题" class="headerlink" title="安装使用中遇到的问题"></a>安装使用中遇到的问题</h2><p>问题1: 命令行执行 pod 发生: pod command not found, 但是 sudo pod 却可以执行.</p>
<p>解决方案即如下步骤:</p>
<p>[1].卸载原有的 Cocoapods</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem uninstall cocoapods</div></pre></td></tr></table></figure>
<p>[2].重新安装 Cocoapods</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure>
<p>[3].赋予/usr/local/bin给予执行与读取权限:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod -R +rx /usr/local/bin/</div></pre></td></tr></table></figure>
<blockquote>
<p>建议最好使用代(fanq)理(qiang).</p>
</blockquote>
<p>问题2: 更新 gem 过程中, 遇到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Operation not permitted - /usr/bin/update_rubygems</div></pre></td></tr></table></figure>
<p>可以通过通过 brew 安装 ruby 解决.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ruby</div></pre></td></tr></table></figure>
<p>问题3: pod setup 失败</p>
<p>失败提示信息类似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Cloning into &apos;master&apos;...</div><div class="line">error: RPC failed; curl 56 SSLRead() return error -36</div><div class="line">fatal: The remote end hung up unexpectedly</div><div class="line">fatal: early EOF</div><div class="line">fatal: index-pack failed</div></pre></td></tr></table></figure>
<p>解决方案: 更新 gem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div></pre></td></tr></table></figure>
<p>问题4: 添加源, 提示如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source https://gems.ruby-china.org/ already present in the cache</div></pre></td></tr></table></figure>
<p>这个说明你已经添加过该源, 可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure>
<p>来查看已经添加的源.</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>1.更新 gem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div></pre></td></tr></table></figure>
<p>2.pod repo update</p>
<p>更新本地仓库.</p>
<p>3.pod search xxx</p>
<p>搜索 cocoapods 项目.</p>
<p>4.pod list</p>
<p>列出所有可用的库.</p>
<p>5.pod install</p>
<p>根据 podfile 和 podfile.lock来安装库.</p>
<p>默认会执行 pod repo update.</p>
<p>可以加入参数 <code>–no-repo-update</code> 不执行 pod repo update.</p>
<p>6.pod update</p>
<p>更新已安装的库到最新版本, 并且创建新的 Podfile.lock 文件.</p>
<p>该命令也会默认会执行 pod repo update.</p>
<p>可以加入参数 –no-repo-update 不执行 pod repo update.</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2017-01-04 更新</p>
<blockquote>
<p>升级 ruby 到 2.4 版本后, cocoapods 无法使用了.</p>
</blockquote>
<p>升级的 ruby 版本信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-darwin15]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">使用任何 pod 命令都报错:</div><div class="line"></div><div class="line">/usr/local/Cellar/ruby/2.4.0/lib/ruby/2.4.0/rubygems.rb:270:in `find_spec_for_exe&apos;: can&apos;t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)</div><div class="line">from /usr/local/Cellar/ruby/2.4.0/lib/ruby/2.4.0/rubygems.rb:298:in `activate_bin_path&apos;</div><div class="line">from /usr/local/bin/pod:22:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure>
<p>查找各种解决方案, 最终还是没有解决.</p>
<p>你可以在 <a href="https://cocoapods.org/app" target="_blank" rel="noopener">这里</a> 下载 Cocoapods 的 Mac 版本 App 使用.</p>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CocoaPods, iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocoapods 问题集锦]]></title>
      <url>/2016/11/08/Cocoapods-%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
      <content type="html"><![CDATA[<h2 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h2><p>本文会持续更新, 分享在使用 cocoapods 过程中遇到的问题和解决方案.</p>
<p>欢迎大家补充.</p>
<h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p>可以阅读博客 <a href="http://www.veryitman.com/2016/11/08/2016-11-08-Mac-install-Cocoapods/" target="_blank" rel="noopener">Mac 安装 Cocoapods</a>.</p>
<h2 id="pod-search-问题"><a href="#pod-search-问题" class="headerlink" title="pod search 问题"></a>pod search 问题</h2><blockquote>
<p>pod search 无法搜索到指定的项目</p>
</blockquote>
<p>问题描述: 执行 pod search [Name], 出现类似下面的提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[!] Unable to find a pod with name, author, summary, or description matching `[Name]`</div></pre></td></tr></table></figure>
<p>解决方案: 删除 search_index.json 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure>
<p>然后, 重新执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search 项目名称</div></pre></td></tr></table></figure>
<p>如果这样行不通的话, 可以这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm -rf ~/.cocoapods</div><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div><div class="line">pod setup</div></pre></td></tr></table></figure>
<p>如果你的网络不好, 需要漫长的等待…</p>
<p>这个时候, 可以去抽半盒烟了. Orz…</p>
<h2 id="pod-setup-问题"><a href="#pod-setup-问题" class="headerlink" title="pod setup 问题"></a>pod setup 问题</h2><blockquote>
<p>pod setup 卡死</p>
</blockquote>
<p>问题描述:</p>
<p>pod setup 会在本地建立 cocoapods 仓库.</p>
<p>在执行的过程中, 你可以在 <code>~/.cocoapods/repos</code> 使用<br><code>du -sh *</code> 来看 repos 目录的大小变化.</p>
<p>如果观察好久, 大小没有变化, 最终会出现类似下面的错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Cloning into &apos;master&apos;...</div><div class="line">error: RPC failed; curl 56 SSLRead() return error -36</div><div class="line">fatal: The remote end hung up unexpectedly</div><div class="line">fatal: early EOF</div><div class="line">fatal: index-pack failed</div></pre></td></tr></table></figure>
<p>解决方案，如下：</p>
<p>先更新 gem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div></pre></td></tr></table></figure>
<p>再重新执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod setup</div></pre></td></tr></table></figure>
<h2 id="pod-install-问题"><a href="#pod-install-问题" class="headerlink" title="pod install 问题"></a>pod install 问题</h2><p>无法使用，报类似下面的两种错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">can&apos;t find gem cocoapods (&gt;= 0.a) with executable pod (Gem::GemNotFoundException)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">While executing gem ... (TypeError) </div><div class="line">no implicit conversion of nil into String</div></pre></td></tr></table></figure>
<p>解决方案，如下：</p>
<p><strong>1. 重新安装 ruby</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew reinstall ruby</div></pre></td></tr></table></figure>
<p><strong>2. gem 更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm /usr/local/bin/update_rubygems</div><div class="line"></div><div class="line">sudo gem update --system</div></pre></td></tr></table></figure>
<p><strong>3. 重新安装 Cocoapods 并重新添加源</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo gem uninstall cocoapods</div><div class="line"></div><div class="line">sudo gem install -n /usr/local/bin cocoapods</div><div class="line"></div><div class="line">gem sources -a https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> MacOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CocoaPods, iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocoapods 管理开源项目]]></title>
      <url>/2016/11/01/Cocoapods-%E7%AE%A1%E7%90%86%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>创建或者已经有了 github 账号.</p>
</li>
<li><p>了解和熟悉如何在 github 上面创建 Repository.</p>
</li>
<li>安装了 cocoapods.</li>
</ul>
<p>如果你还没有使用 cocoapods, 建议看看 <a href="http://blog.csdn.net/veryitman/article/details/50769069" target="_blank" rel="noopener">Mac OSX 10.11.1+ 安装 Cocoapods</a> 这篇博客.</p>
<p>在博客 iOS 项目: 打造本地 pod 库 里面有介绍如何打造本地的 pod 库.</p>
<p>今天给大家分享如何将代码开源并放到 pod 库中, 供别人使用.<br>这篇博客是基于一个实际例子 <a href="https://github.com/veryitman/MZInsetLabel" target="_blank" rel="noopener">MZInsetLabel</a> 来说明的.</p>
<h2 id="创建-Repository-并完善项目"><a href="#创建-Repository-并完善项目" class="headerlink" title="创建 Repository 并完善项目"></a>创建 Repository 并完善项目</h2><ul>
<li>1.在 github 上面创建 Repository, 取名为 MZInsetLabel.</li>
<li>2.clone 到本地磁盘.</li>
<li>3.写代码, 这里我只写了 MZInsetLabel.h | .m 文件.</li>
<li>4.创建 spec 文件, 使用下面命令:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create MZInsetLabel</div></pre></td></tr></table></figure>
<p>在当前目录会生成 MZInsetLabel.spec 文件.</p>
<p>按照规范和实际情况填写.</p>
<blockquote>
<p>注意: Tag 版本号不要错误.</p>
</blockquote>
<p>最终内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line">  s.name         = &quot;MZInsetLabel&quot;</div><div class="line">  s.version      = &quot;0.2.0&quot;</div><div class="line">  s.summary      = &quot;MZInsetLabel is subClass of UILabel.&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">                        MZInsetLabel is a sub class of UILabel that can be set insets.</div><div class="line">                   DESC</div><div class="line">  s.homepage     = &quot;http://www.veryitman.com&quot;</div><div class="line">  s.license      = &quot;MIT&quot;</div><div class="line">  s.author       = &#123; &quot;veryitman&quot; =&gt; &quot;veryitman@126.com&quot; &#125;</div><div class="line">  s.platform     = :ios, &quot;7.0&quot;</div><div class="line">  s.source = &#123; :git =&gt; &quot;https://github.com/veryitman/MZInsetLabel.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class="line">  s.source_files  = &quot;*.&#123;h,m&#125;&quot;</div><div class="line">  s.framework  = &quot;UIKit&quot;</div><div class="line">  s.requires_arc = true</div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="项目检测"><a href="#项目检测" class="headerlink" title="项目检测"></a>项目检测</h2><ol>
<li>检查该 podspec</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint MZInsetLabel.podspec</div></pre></td></tr></table></figure>
<blockquote>
<p>–verbose 可以输出更加详细的内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint MZInsetLabel.podspec --verbose</div></pre></td></tr></table></figure>
<p>正确的话, 你可以看到</p>
<p><img src="/upload/images/2016/11/1/1.jpg" alt="1"></p>
<h2 id="push-项目到-Repository"><a href="#push-项目到-Repository" class="headerlink" title="push 项目到 Repository"></a>push 项目到 Repository</h2><p>没有错误的话可以执行下面操作.</p>
<ol>
<li>将本地的代码 push 到 github 的 Repository, 就是刚才创建的 MZInsetLabel.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add </div><div class="line">git commit -m &quot;Init&quot;</div><div class="line">git push</div></pre></td></tr></table></figure>
<ol>
<li>创建一个 Release 作为 Tag<br>如图所示:</li>
</ol>
<p><img src="/upload/images/2016/11/1/2.jpg" alt="1"></p>
<h2 id="推送到-cocoapods"><a href="#推送到-cocoapods" class="headerlink" title="推送到 cocoapods"></a>推送到 cocoapods</h2><p>1.注册 trunk</p>
<blockquote>
<p>pod trunk register 你的邮箱 ‘用户名’ –description=’简单描述’</p>
</blockquote>
<p>完整命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk register veryitman@126.com &apos;veryitman&apos; --description=&apos;mark&apos;</div></pre></td></tr></table></figure>
<p>2.打开邮箱, 激活邮件, 点击链接激活即可.</p>
<p>3.检查注册信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk me</div></pre></td></tr></table></figure>
<p>4.添加到 cocoapods</p>
<p>执行下面命令, 即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk push MZInsetLabel.podspec</div></pre></td></tr></table></figure>
<p>成功的效果图:</p>
<p><img src="/upload/images/2016/11/1/3.jpg" alt="1"></p>
<p><img src="/upload/images/2016/11/1/4.png" alt="1"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.检查是否可以搜索到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search MZInsetLabel</div></pre></td></tr></table></figure>
<p>如果搜索不到, 请执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod setup</div></pre></td></tr></table></figure>
<p>2.在项目中可以使用该项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;MZInsetLabel&apos;, &apos;~&gt; 0.1.0&apos;</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可能遇到的麻烦</p>
<p>1.执行 pod trunk push MZInsetLabel.podspec 时, 好久没反应?</p>
<blockquote>
<p>这种情况, 大多数都是因为你的网络不给力造成的, 如果你确定你的网络没问题, 那么请翻墙.</p>
</blockquote>
<p>2.执 行 pod trunk push MZInsetLabel.podspec 时报错?</p>
<p>报错信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR | [iOS] unknown: Encountered an unknown error (Simulator iPhone 4s is not available.) during validation.</div></pre></td></tr></table></figure>
<p>这个错误是因为, 更新了 xcode8 之后不再支持 ios7 的缘故.</p>
<p>解决方案(我的), 升级 cocoapods.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure>
<p>3.pod trunk push 失败</p>
<p>失败提示信息类似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Cloning into &apos;master&apos;...</div><div class="line">error: RPC failed; curl 56 SSLRead() return error -36</div><div class="line">fatal: The remote end hung up unexpectedly</div><div class="line">fatal: early EOF</div><div class="line">fatal: index-pack failed</div></pre></td></tr></table></figure>
<p>解决方案: 更新 gem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>1.删除远程 Tag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --delete origin [TagName]</div></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --delete origin 0.10.0</div></pre></td></tr></table></figure>
<blockquote>
<p>在 github 上面如果你不小心打错了 Release, 然后删除该 Release.<br>你会发现, tag 无法删除.使用上面方式妥妥的解决.</p>
</blockquote>
<p>2.删除本地 Tag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag --delete [TagName]</div></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag --delete 0.10.0</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS cocoapods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS: 谈谈 frame 和 bounds]]></title>
      <url>/2016/10/22/iOS-%E8%B0%88%E8%B0%88-frame-%E5%92%8C-bounds/</url>
      <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大家知道, 我们可以设置 view 的四个角或者其中一个或者几个为圆角.</p>
<p>使用的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect </div><div class="line">			byRoundingCorners:(UIRectCorner)corners </div><div class="line">			cornerRadii:(CGSize)cornerRadii;</div></pre></td></tr></table></figure>
<p>拖好界面元素之后, 在代码中来修改其为圆角, 居然失败了.</p>
<p>想要的效果是这样的:<br><img src="/upload/images/2016/10/23/02.png" alt="1"></p>
<p>但是最终是这样的:<br><img src="/upload/images/2016/10/23/01.png" alt="1"></p>
<p>于是总结了一下, 分享给大家.</p>
<h2 id="设置圆角"><a href="#设置圆角" class="headerlink" title="设置圆角"></a>设置圆角</h2><p>这里分两种情况.</p>
<p><strong>第一种:</strong> 只放置控件, 不设置约束.</p>
<p>1.storyboard 中拖好控件.</p>
<p>注意: 这里我并没有设置任何约束.</p>
<p>2.vc 代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (strong, nonatomic) IBOutlet UILabel *lb;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [self changeLbCorner];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)changeLbCorner</div><div class="line">&#123;</div><div class="line">   UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.frame</div><div class="line">                                                  byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight</div><div class="line">                                                        cornerRadii:CGSizeMake(7, 7)];</div><div class="line">   CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];</div><div class="line">   maskLayer.frame = _lb.bounds;</div><div class="line">   maskLayer.path = maskPath.CGPath;</div><div class="line">   self.lb.layer.mask  = maskLayer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>代码编译运行到模拟器(iphone6), 看不到任何东西.</p>
<p>log 日志显示 lb 的信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ViewController viewDidLoad]:</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div></pre></td></tr></table></figure>
<p>位置信息是正确的, 咨询检查发现是参数传入错误, 修改 changeLbCorner 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)changeLbCorner</div><div class="line">&#123;</div><div class="line">    UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds</div><div class="line">                                                   byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight</div><div class="line">                                                         cornerRadii:CGSizeMake(7, 7)];</div><div class="line">    CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];</div><div class="line">    maskLayer.frame = _lb.bounds;</div><div class="line">    maskLayer.path = maskPath.CGPath;</div><div class="line">    self.lb.layer.mask  = maskLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只是将 <code>self.lb.frame</code> 改成了 <code>self.lb.bounds</code>.</p>
<p>再次运行可以看到效果:<br><img src="/upload/images/2016/10/23/02.png" alt="1"></p>
<p><strong>第二种:</strong> 放置控件并设置约束.</p>
<p>1.设置 lb 距离父 view 左边和上边的约束.<br>2.运行上面的代码, 发现, lb 并没有被设置为圆角.<br>并且 lb 的宽度和高度变小了, 变成了文字的实际的宽高.<br><img src="/upload/images/2016/10/23/04.png" alt="1"></p>
<p>看 log:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ViewController viewDidLoad]:</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div></pre></td></tr></table></figure>
<p>其实这个时候, (从上面图中可以看出) 这里的信息是错误的.</p>
<p>正确的信息应该是这样的(在 viewDidAppear 中)打印信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ViewController viewDidAppear]:</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;58.5, 19.5&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;58.5, 19.5&#125;&#125;</div></pre></td></tr></table></figure>
<p>于是, 将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self changeLbCorner];</div></pre></td></tr></table></figure>
<p>放到 viewDidAppear 中, 圆角就正常了.</p>
<p>接下来, 我们把 lb 的宽高(136*39)约束也加上.</p>
<p>看一下, viewDidLoad 和 viewDidAppear 方法中打印的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ViewController viewDidLoad]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;</div><div class="line">[ViewController viewDidAppear:]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div></pre></td></tr></table></figure>
<p>可以看出, viewDidLoad 中错的一塌糊涂.</p>
<p>这里也说明一个问题:</p>
<blockquote>
<p>xib 或者 storyboard 中设置过约束(现实开发中, 基本都会设置约束)的组件, 在 viewDidLoad 中并没有完全 layout, 只是预加载了这些组件.<br>想获取组件如 frame 何 bounds 信息, 在 viewDidLoad 中是不合适甚至是错误的.</p>
</blockquote>
<p>那么, 问题来了, 哪里合适哪里正确.</p>
<p>上面如果你认真看了, 在 viewDidAppear 中是可以正确获取的, 那么还有没有其他方法可以获取呢?</p>
<h2 id="VC-生命周期函数"><a href="#VC-生命周期函数" class="headerlink" title="VC 生命周期函数"></a>VC 生命周期函数</h2><p>要回答上面的问题, 大家要知道 vc 的生命周期函数.</p>
<p>上面的例子, 可以看出: 当函数 ViewDidLoad 被调用的时候，IBQutlets 已经被连接，但View 还没有被加载出来，无法获取 frame 等信息.<br>可以在 viewDidLoad 中完成在 IB 中不能完成的 view 的自定义。</p>
<p>关于 loadView 和 viewDidLoad 在后面博客跟大家分享.</p>
<p>今天要说的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">viewDidLayoutSubviews</div></pre></td></tr></table></figure>
<p><code>viewDidLayoutSubviews</code> 在 VC 子视图位置或者尺寸 (position|size) 被改变的时候被调用.</p>
<p>直到 AutoLayout 已经完成工作的时候才会被确定，所以在执行完 AutoLayout 之后会调用此方法. 换句话说, view 的 frame 和 bounds 这个时候是正确可以获取的.</p>
<p><code>viewDidLayoutSubviews</code> 这个方法在 <code>viewDidAppear</code> 之前被调用, 有可能会被调用多次.</p>
<p>即依赖 bounds 或者 frame 的操作，都应该放在<code>viewDidLayoutSubviews</code> 中，而不是 <code>viewDidLoad</code> 或 <code>viewWillAppear</code> 中.</p>
<p>改变后的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">#define MZLog(fmt, ...) NSLog((@&quot;%s\n&quot; fmt), __FUNCTION__, ##__VA_ARGS__)</div><div class="line">#define MZLogLbInfo \</div><div class="line">MZLog(@&quot;lb.bounds: %@ \nlb.frame: %@&quot;, NSStringFromCGRect(self.lb.bounds), NSStringFromCGRect(self.lb.frame))</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (strong, nonatomic) IBOutlet UILabel *lb;</div><div class="line">@property (strong, nonatomic) IBOutlet UILabel *displayedText;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillLayoutSubviews</div><div class="line">&#123;</div><div class="line">    [super viewWillLayoutSubviews];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLayoutSubviews</div><div class="line">&#123;</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">    </div><div class="line">    [self changeLbCorner];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark Callback.</div><div class="line"></div><div class="line">- (void)changeLbCorner</div><div class="line">&#123;</div><div class="line">    UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds</div><div class="line">                                                   byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight</div><div class="line">                                                         cornerRadii:CGSizeMake(7, 7)];</div><div class="line">    CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];</div><div class="line">    maskLayer.frame = _lb.bounds;</div><div class="line">    maskLayer.path = maskPath.CGPath;</div><div class="line">    self.lb.layer.mask  = maskLayer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>打印的 log 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[ViewController viewDidLoad]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;</div><div class="line">[ViewController viewWillAppear:]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;</div><div class="line">[ViewController viewWillLayoutSubviews]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;0, 0&#125;, &#123;1000, 1000&#125;&#125;</div><div class="line">[ViewController viewDidLayoutSubviews]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div><div class="line">[ViewController viewWillLayoutSubviews]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div><div class="line">[ViewController viewDidLayoutSubviews]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div><div class="line">[ViewController viewDidAppear:]</div><div class="line">lb.bounds: &#123;&#123;0, 0&#125;, &#123;136, 39&#125;&#125; </div><div class="line">lb.frame: &#123;&#123;39, 89&#125;, &#123;136, 39&#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="frame-和-bounds"><a href="#frame-和-bounds" class="headerlink" title="frame 和 bounds"></a>frame 和 bounds</h2><p>上面的例子, 大家看到由于传入了 frame 而不是 bounds 造成设置圆角失败.</p>
<p>下面说说 frame 和 bounds.</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>从网上”偷”过来的图</p>
<p><img src="/upload/images/2016/10/23/03.jpg" alt="1"></p>
<blockquote>
<p>1.frame</p>
</blockquote>
<p>该 view 在父 view 坐标系统中的位置和大小(参照点是，父坐标系统).</p>
<blockquote>
<p>2.bounds</p>
</blockquote>
<p>该 view 在本地坐标系统中的位置和大小(参照点是，本地坐标系统，就相当于 view 自己的坐标系统，以(0,0)点为起点).<br>其实本地坐标系统的关键就是要知道的它的原点(0,0).</p>
<p>bounds 默认值是(0, 0, width, height).除非手动改变 bounds 的值.</p>
<p>单纯的从概念上面, 很难理解二者的区别.</p>
<p>提供一个例子, 例子大概是这样的:<br>redView 是 yellowView 的父视图, yellowView 是 blueView 的父视图.</p>
<p>通过改变 redView 的 bounds 会影响子视图的位置(不是frame).<br>将 redView 的 bounds 起点设为(-20, -20), 子视图相对于 redView 的本地坐标(0, 0), 也就需要往下增加20, 这样, yellowView 就往下移动了.</p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图:"></a>效果图:</h3><p><img src="/upload/images/2016/10/23/05.png" alt="1"></p>
<p><img src="/upload/images/2016/10/23/06.png" alt="1"></p>
<p><img src="/upload/images/2016/10/23/07.png" alt="1"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">#define MZLog(fmt, ...) NSLog((@&quot;%s\n&quot; fmt), __FUNCTION__, ##__VA_ARGS__)</div><div class="line">#define MZLogLbInfo \</div><div class="line">MZLog(@&quot;lb.bounds: %@ \nlb.frame: %@&quot;, NSStringFromCGRect(self.lb.bounds), NSStringFromCGRect(self.lb.frame))</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (strong, nonatomic) IBOutlet UILabel *lb;</div><div class="line">@property (strong, nonatomic) IBOutlet UILabel *displayedText;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">&#123;</div><div class="line">    UIView *redView;</div><div class="line">    UIView *yellowView;</div><div class="line">    UIView *blueView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">    </div><div class="line">    </div><div class="line">    // 将 redView 添加到 self.view</div><div class="line">    &#123;</div><div class="line">        redView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 120, 120)];</div><div class="line">        redView.backgroundColor = [UIColor redColor];</div><div class="line">        [self.view addSubview:redView];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 将 yellowView 添加到 redView</div><div class="line">    &#123;</div><div class="line">        yellowView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 90, 90)];</div><div class="line">        yellowView.backgroundColor = [UIColor yellowColor];</div><div class="line">        [redView addSubview:yellowView];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 将 blueView 添加到 yellowView</div><div class="line">    &#123;</div><div class="line">        blueView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 60, 60)];</div><div class="line">        blueView.backgroundColor = [UIColor blueColor];</div><div class="line">        [yellowView addSubview:blueView];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [self logViewInfo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillLayoutSubviews</div><div class="line">&#123;</div><div class="line">    [super viewWillLayoutSubviews];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLayoutSubviews</div><div class="line">&#123;</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">    </div><div class="line">    [self changeLbCorner];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    </div><div class="line">    MZLogLbInfo;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark Callback.</div><div class="line"></div><div class="line">- (void)changeLbCorner</div><div class="line">&#123;</div><div class="line">    UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.lb.bounds</div><div class="line">                                                   byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomRight</div><div class="line">                                                         cornerRadii:CGSizeMake(7, 7)];</div><div class="line">    CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];</div><div class="line">    maskLayer.frame = _lb.bounds;</div><div class="line">    maskLayer.path = maskPath.CGPath;</div><div class="line">    self.lb.layer.mask  = maskLayer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)doResetAction:(id)sender</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:1.0f animations:^&#123;</div><div class="line">        [redView setBounds:CGRectMake(0, 0, 120, 120)];</div><div class="line">        [yellowView setBounds:CGRectMake(0, 0, 90, 90)];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self logViewInfo];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)doChangeRedViewBounds:(id)sender</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:1.0f animations:^&#123;</div><div class="line">        [redView setBounds:CGRectMake(-20, -20, 120, 120)];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self logViewInfo];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)doChangeYellowViewBounds:(id)sender</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:1.0f animations:^&#123;</div><div class="line">        [yellowView setBounds:CGRectMake(-20, -20, 90, 90)];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self logViewInfo];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark Display Debug Info.</div><div class="line"></div><div class="line">- (void)logViewInfo</div><div class="line">&#123;</div><div class="line">    NSString *log4rView = [NSString stringWithFormat:@&quot;RedView\nframe:%@ \nbounds:%@&quot;,</div><div class="line">                           NSStringFromCGRect(redView.frame), NSStringFromCGRect(redView.bounds)];</div><div class="line">    NSString *log4yView = [NSString stringWithFormat:@&quot;YellowView\nframe:%@ \nbounds:%@&quot;,</div><div class="line">                           NSStringFromCGRect(yellowView.frame), NSStringFromCGRect(yellowView.bounds)];</div><div class="line">    NSString *log4bView = [NSString stringWithFormat:@&quot;BlueView\nframe:%@ \nbounds:%@&quot;,</div><div class="line">                           NSStringFromCGRect(blueView.frame), NSStringFromCGRect(blueView.bounds)];</div><div class="line">    </div><div class="line">    NSString *log = [NSString stringWithFormat:@&quot;%@\n%@\n%@&quot;, log4rView, log4yView, log4bView];</div><div class="line">    [self display:log];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)display:(NSString *)content</div><div class="line">&#123;</div><div class="line">    self.displayedText.text = content;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>frame, 描述的是当前视图在其父视图中的位置和大小.<br>bounds, 描述的是当前视图在其自身坐标系统中的位置和大小.</li>
</ul>
<p>所以, bounds 默认是 <code>(0, 0, frame.size.width, frame.size.height)</code></p>
<p>另外, 还有一个 <code>center</code> 描述的是当前视图的中心点在其父视图中的位置.</p>
<ul>
<li>bounds 和 frame 是两个不等同的概念, 改变 bounds 会影响子视图的位置(人眼看到其改变了位置), 设置 bounds 可以修改自己坐标系的原点位置. 但是不会改变子视图的 bounds 和 frame.</li>
</ul>
<blockquote>
<p>明白上面的道理很重要, iOS 中滚动视图能让你看到其中的内容, 正是利用了 contentoffset 和 bounds 属性.</p>
<p>这里以 tableView 为例子, 当我们向上滚动 tableView, tableView 的 contentOffset 和 bounds 的坐标都是正数, 相当于其本地坐标(0, 0)改变了即增加了(坐标系往下为增加), 那么其子视图就会向上去.</p>
<p>向下滑动时, 也是同一个道理.<br>可以通过运行 <a href="https://github.com/veryitman/iOSDemo/tree/master/na" target="_blank" rel="noopener">完整 Demo</a> 中[查看 TableView]按钮来打开例子, 看日志.</p>
</blockquote>
<ul>
<li><p>改变子视图所有父视图的 bounds, 子视图的位置是累加改变的.<br>如上面改变 redView 和 yellowView 的 bounds, blueView 的位置相对 redView 往下移动了 40.</p>
</li>
<li><p>当同一个视图的 bounds 大于 frame, 会导致 frame 被撑大，frame 的 x, y, width, height 都会被改变. 反之, bounds 小于 frame, frame 也会变小.</p>
</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol>
<li><p>GitHub 上面可以下载 <a href="https://github.com/veryitman/iOSDemo/tree/master/na" target="_blank" rel="noopener">完整 Demo</a></p>
</li>
<li><p>推荐之前写在 CSDN 上的博文: <a href="http://blog.csdn.net/veryitman/article/details/51622235" target="_blank" rel="noopener">iOS UI 技巧: 视图无法被点击
</a></p>
</li>
</ol>
<p>可关注我的微信公众号:<br><img src="/upload/me/qrcode_wx.jpg" alt="1"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS frame bounds </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: 模拟 Mobx]]></title>
      <url>/2016/10/11/RN-%E6%A8%A1%E6%8B%9F-Mobx/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看过 [React Native 使用 Mobx] 这篇博客的同学, 对 Mobx 应该有了一个简单直观的认识.</p>
<p>其实, 我们完全可以使用 RN 中的 State 来达到同样的效果.</p>
<p>今天的主要内容是使用 State 来模拟 Mobx, 也算是对 Mobx 的进一步认识.</p>
<p>效果</p>
<p>实现效果和 [React Native 使用 Mobx] 中的效果一致, 只是代码没有使用 Mobx 框架.</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="LegacyCounter-js"><a href="#LegacyCounter-js" class="headerlink" title="LegacyCounter.js"></a>LegacyCounter.js</h3><blockquote>
<p>Add 和 Minus 两个按钮分别触发各自的回调, 来更新 state.<br>使用 state 的变化来到达更新 View (计数的 Text 会相应的做出变化)的目的.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 模拟 Mobx 在 ReactNative 上的一个小例子.</div><div class="line"> * </div><div class="line"> * state -&gt; view</div><div class="line"> */</div><div class="line">&apos;use strict&apos;;</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  StyleSheet,</div><div class="line">  View,</div><div class="line">  Text,</div><div class="line">  TouchableHighlight</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">class LegacyCounter extends Component &#123;</div><div class="line">    //构造方法</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">    </div><div class="line">        this.state = &#123;</div><div class="line">            //计数</div><div class="line">            counter: 0</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    render () &#123;</div><div class="line">        return (</div><div class="line">          &lt;View style = &#123;styles.container&#125;&gt;</div><div class="line">            &#123;/*加一*/&#125;</div><div class="line">            &lt;TouchableHighlight</div><div class="line">                onPress = &#123;() =&gt; &#123;this.setState(&#123;</div><div class="line">                    counter: ++this.state.counter</div><div class="line">                &#125;)&#125;&#125;&gt;</div><div class="line">                &lt;Text&gt;Add&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">            &#123;/* 显示处理结果 */&#125;</div><div class="line">            &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt;</div><div class="line">            &#123;this.state.counter&#125;</div><div class="line">            &lt;/Text&gt;</div><div class="line">            &#123;/*减一*/&#125;</div><div class="line">            &lt;TouchableHighlight </div><div class="line">                onPress = &#123;() =&gt; &#123;this.setState(&#123;</div><div class="line">                    counter: --this.state.counter</div><div class="line">                &#125;)&#125;&#125;&gt;</div><div class="line">                &lt;Text&gt;Minus&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export default class LegacyComponent extends Component &#123;</div><div class="line">    render () &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt;</div><div class="line">            </div><div class="line">                &lt;LegacyCounter/&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/* 样式定义 */</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        flexDirection: &apos;row&apos;,</div><div class="line">        justifyContent: &apos;space-around&apos;</div><div class="line">    &#125;,</div><div class="line">    resultTxtStyle: &#123;</div><div class="line">        fontSize: 22, </div><div class="line">        color: &apos;red&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="index-ios-js"><a href="#index-ios-js" class="headerlink" title="index.ios.js"></a>index.ios.js</h3><blockquote>
<p>这个文件很简单, 只是调用 LegacyCounter 中的组件.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">//引入自定义模块</div><div class="line">import LegacyComponent from &apos;./js/Mobx/LegacyCounter&apos;</div><div class="line">import &#123;</div><div class="line">  AppRegistry</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">class RNMobxDemo extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return(</div><div class="line">            &lt;LegacyComponent/&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">AppRegistry.registerComponent(&apos;RNMobxDemo&apos;, () =&gt; MZRNTutorial);</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果你想了解更多关于 RN 中 State 的知识, 请移步官方文档查阅 State 的用法.</p>
<p>后续会给大家带来更多关于 RN 这些方面的东西.</p>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS Android ReactNative </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: 使用 Mobx]]></title>
      <url>/2016/10/06/RN-%E4%BD%BF%E7%94%A8-Mobx/</url>
      <content type="html"><![CDATA[<h2 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h2><p>在 <a href="https://jsfiddle.net/24u7juu0/" target="_blank" rel="noopener">JSFiddler</a> 上面看到 React 结合 Mobx 的一个小例子.</p>
<p>爱不释手, 遂拿来改造一下, 让其能在 RN 上面一展雄风.</p>
<p>之前听过 Mobx, 说是要替代 Redux, 反正我是不知道这些东东, 第一次听说没有什么感觉!<br>如今又再次偶遇 Mobx, 决定认真学习一下它.</p>
<h2 id="Mobx-简介"><a href="#Mobx-简介" class="headerlink" title="Mobx 简介"></a>Mobx 简介</h2><p>Mobx 的 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">github</a> 地址.<br>目前关于他和 React Native 的(中文)资料不多, 大多数是关于 React 的.</p>
<p>看来想学好 React Native, 还是要做好 React 的功课呀!</p>
<p>官网给了一个 Mobx 的图:<br><img src="/upload/images/2016/10/08/rn_mobx_ef4.png" alt="1"></p>
<p>我也是刚接触这个「牛逼闪闪」的 Mobx, 共勉!</p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>今天的例子很简单, 效果图如下<br><img src="/upload/images/2016/10/08/rn_mobx_ef1.png" alt="1"></p>
<p>点击 Add<br><img src="/upload/images/2016/10/08/rn_mobx_ef3.png" alt="1"></p>
<p>点击 Minus<br><img src="/upload/images/2016/10/08/rn_mobx_ef2.png" alt="1"></p>
<p>下面具体说说如何搞定这个 Demo.</p>
<h2 id="准备「材料」"><a href="#准备「材料」" class="headerlink" title="准备「材料」"></a>准备「材料」</h2><p>这里假设你已经具备 React Native 的基本开发环境, 至少成功运行过一次 React Native 的程序.</p>
<h3 id="1-创建-React-Native-项目"><a href="#1-创建-React-Native-项目" class="headerlink" title="1.创建 React Native 项目"></a>1.创建 React Native 项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init RNMobxDemo</div></pre></td></tr></table></figure>
<p>你也可以给你的工程取一个你喜欢的名字.<br>这里姑且称之为 RNMobxDemo</p>
<h3 id="2-安装-mobx-和-mobx-react"><a href="#2-安装-mobx-和-mobx-react" class="headerlink" title="2.安装 mobx 和 mobx-react"></a>2.安装 mobx 和 mobx-react</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i mobx mobx-react --save</div></pre></td></tr></table></figure>
<h3 id="3-Counter-js"><a href="#3-Counter-js" class="headerlink" title="3.Counter.js"></a>3.Counter.js</h3><blockquote>
<p>该文件使用了 mobx 和 mobx-react 的组件.</p>
</blockquote>
<p>具体代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  StyleSheet,</div><div class="line">  View,</div><div class="line">  Text,</div><div class="line">  TouchableHighlight</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">import &#123; observer &#125; from &apos;mobx-react/native&apos;;</div><div class="line">import &#123; observable &#125; from &apos;mobx&apos;;</div><div class="line">// 被观察者, 观察 counter 变量  </div><div class="line">const storer = observable(&#123;</div><div class="line">    counter: 0</div><div class="line">&#125;);</div><div class="line">//---------------------------------</div><div class="line">//  ES6 写法: Arrow Function</div><div class="line">//---------------------------------</div><div class="line">storer.plus =  () =&gt; &#123;</div><div class="line">    storer.counter ++;</div><div class="line">&#125;;</div><div class="line">storer.minus = () =&gt; &#123;</div><div class="line">    storer.counter --;</div><div class="line">&#125;;</div><div class="line">class Counter extends Component &#123;</div><div class="line">    render () &#123;</div><div class="line">        return (</div><div class="line">          &lt;View style = &#123;styles.container&#125;&gt;</div><div class="line">            &#123;/*加一*/&#125;</div><div class="line">            &lt;TouchableHighlight</div><div class="line">                onPress = &#123;() =&gt; &#123;this.props.store.plus()&#125;&#125;&gt;</div><div class="line">                &lt;Text&gt;Add&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">            &#123;/* 显示处理结果 */&#125;</div><div class="line">            &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt;</div><div class="line">            &#123;this.props.store.counter&#125;</div><div class="line">            &lt;/Text&gt;</div><div class="line">            &#123;/*减一*/&#125;</div><div class="line">            &lt;TouchableHighlight </div><div class="line">                onPress = &#123;() =&gt; &#123;storer.minus()&#125;&#125;&gt;</div><div class="line">                &lt;Text&gt;Minus&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 使用 observer 创建</div><div class="line">const CounterComponent = observer(Counter);</div><div class="line">export default class ReactionsComponent extends Component &#123;</div><div class="line">    render () &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt;</div><div class="line">            </div><div class="line">                &lt;CounterComponent store = &#123;storer&#125; /&gt; </div><div class="line">            &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/* 样式定义 */</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        flexDirection: &apos;row&apos;,</div><div class="line">        justifyContent: &apos;space-around&apos;</div><div class="line">    &#125;,</div><div class="line">    resultTxtStyle: &#123;</div><div class="line">        fontSize: 22, </div><div class="line">        color: &apos;red&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="4-index-ios-js"><a href="#4-index-ios-js" class="headerlink" title="4.index.ios.js"></a>4.index.ios.js</h3><blockquote>
<p>该文件使用自定义的组件 ReactionsComponent</p>
</blockquote>
<p>具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">//引入自定义模块</div><div class="line">import ReactionsComponent from &apos;./js/Mobx/Counter&apos;</div><div class="line">import &#123;</div><div class="line">  AppRegistry</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">class RNMobxDemo extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return(</div><div class="line">            &lt;ReactionsComponent/&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">AppRegistry.registerComponent(&apos;RNMobxDemo&apos;, () =&gt; MZRNTutorial);</div></pre></td></tr></table></figure>
<p>Mobx 支持「注解」.</p>
<p>这里的注解就是 ES7 中的 decorators (装饰者模式).</p>
<p>下面代码是使用注解的方式来声明, 但是你需要安装相关的插件(babel plugin)来支持.</p>
<p>安装该插件很简单, 在项目根目录按照下面步骤即可:</p>
<blockquote>
<p>Step 1: 创建 .babelrc 文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch .babelrc</div></pre></td></tr></table></figure>
<blockquote>
<p>Step 2: 编辑 .babelrc 文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> &apos;presets&apos;: [&apos;react-native&apos;],</div><div class="line"> &apos;plugins&apos;: [&apos;transform-decorators-legacy&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Step 3: 安装插件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i babel-plugin-transform-decorators-legacy babel-preset-react-native-stage-0 --save-dev</div></pre></td></tr></table></figure>
<p>修改「Counter.js」, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  StyleSheet,</div><div class="line">  View,</div><div class="line">  Text,</div><div class="line">  TouchableHighlight</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">import &#123; observer &#125; from &apos;mobx-react/native&apos;;</div><div class="line">import &#123; observable &#125; from &apos;mobx&apos;;</div><div class="line">// 被观察者, 观察 counter 变量  </div><div class="line">const storer = observable(&#123;</div><div class="line">    counter: 0</div><div class="line">&#125;);</div><div class="line">//---------------------------------</div><div class="line">//  ES6 写法: Arrow Function</div><div class="line">//---------------------------------</div><div class="line">storer.plus =  () =&gt; &#123;</div><div class="line">    storer.counter ++;</div><div class="line">&#125;;</div><div class="line">storer.minus = () =&gt; &#123;</div><div class="line">    storer.counter --;</div><div class="line">&#125;;</div><div class="line">@observer //使用@方式来前置声明</div><div class="line">class Counter extends Component &#123;</div><div class="line">    render () &#123;</div><div class="line">        return (</div><div class="line">          &lt;View style = &#123;styles.container&#125;&gt;</div><div class="line">            &#123;/*加一*/&#125;</div><div class="line">            &lt;TouchableHighlight</div><div class="line">                onPress = &#123;() =&gt; &#123;this.props.store.plus()&#125;&#125;&gt;</div><div class="line">                &lt;Text&gt;Add&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">            &#123;/* 显示处理结果 */&#125;</div><div class="line">            &lt;Text style = &#123;styles.resultTxtStyle&#125;&gt;</div><div class="line">            &#123;this.props.store.counter&#125;</div><div class="line">            &lt;/Text&gt;</div><div class="line">            &#123;/*减一*/&#125;</div><div class="line">            &lt;TouchableHighlight </div><div class="line">                onPress = &#123;() =&gt; &#123;storer.minus()&#125;&#125;&gt;</div><div class="line">                &lt;Text&gt;Minus&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export default class ReactionsComponent extends Component &#123;</div><div class="line">    render () &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style = &#123;&#123;flex: 1, marginTop: 64&#125;&#125;&gt;</div><div class="line">            </div><div class="line">                &lt;Counter store = &#123;storer&#125; /&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/* 样式定义 */</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        flexDirection: &apos;row&apos;,</div><div class="line">        justifyContent: &apos;space-around&apos;</div><div class="line">    &#125;,</div><div class="line">    resultTxtStyle: &#123;</div><div class="line">        fontSize: 22, </div><div class="line">        color: &apos;red&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从例子可以看出, storer 相当于 state, 当 state 发生改变了, 视图 View 也跟着变化.<br>也就是状态驱动.</p>
<p>Android 开发的同学应该知道 Adapter 和 notifyDatasetChanged 的机制, 当数据源发生变化的时候, 可以通知视图进行刷新操作.</p>
<p>这里的 Mobx 也可以这么简单的理解.</p>
<p>Mobx 的强大之处还有很多, 需要慢慢学习和挖掘.</p>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS Android ReactNative </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: 0.34 运行在 Android 的问题]]></title>
      <url>/2016/09/26/RN-0-34-%E8%BF%90%E8%A1%8C%E5%9C%A8-Android-%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天闲来无事, 想使用 RN 工程在 Android 设备上面跑跑.</p>
<p>想看看运行效果怎么样?!</p>
<h2 id="适合读者"><a href="#适合读者" class="headerlink" title="适合读者"></a>适合读者</h2><ul>
<li>有 Android 开发基础.</li>
<li>会使用 Android Studio.</li>
<li>初级 React Native 的开发者.</li>
</ul>
<h2 id="开发环境和工具"><a href="#开发环境和工具" class="headerlink" title="开发环境和工具"></a>开发环境和工具</h2><ul>
<li>Android Studio 2.2</li>
<li>ReactNative 0.34</li>
<li>Android 模拟器</li>
<li>Mac 操作系统</li>
</ul>
<h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><p>不出所料, 真的不能一帆风顺的 Run.</p>
<p>在我的博客 ReactNative: 不一样的 HelloWorld 中展示了 RN 在 iOS 上面的运行情况.</p>
<p>今天还是这个例子, 部署和运行到 Android 上面.</p>
<p>效果如下:<br><img src="/upload/images/2016/9/26/rn_and_eff_01.png" alt="1"></p>
<p>在这个过程中, 遇到几个问题.</p>
<p>特此记录.</p>
<h2 id="问题描述和解决"><a href="#问题描述和解决" class="headerlink" title="问题描述和解决"></a>问题描述和解决</h2><h3 id="问题1-直接运行-crash"><a href="#问题1-直接运行-crash" class="headerlink" title="问题1: 直接运行 crash"></a>问题1: 直接运行 crash</h3><p>log 描述(部分)</p>
<blockquote>
<p>E/AndroidRuntime: FATAL EXCEPTION: main<br>Process: com.mzrntutorial, PID: 5849<br>java.lang.RuntimeException:<br>Unable to start activity ComponentInfo{com.mzrntutorial/com.mzrntutorial.MainActivity}: java.lang.ClassCastException: android.app.Application cannot be cast to com.facebook.react.ReactApplication<br>at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2416)<br>at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2476)     </p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>Manifest.xml 配置 Application 名称</p>
<p>android:name=”.MainApplication”</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2:"></a>问题2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">could not get batchedbridge make sure your bundle is packaged correctly</div></pre></td></tr></table></figure>
<p>解决问题1后, 再次运行, 会报问题2.<br>该问题是因为没有启动本地的 server.</p>
<p>使用 Xcode 可以自动运行本地 server.<br>可以参考博客 React Native 如何启动 local server</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>手动启动 server.</p>
<p>cd 项目根目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native start</div></pre></td></tr></table></figure>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3:"></a>问题3:</h3><blockquote>
<p>模拟器没有 menu 按键, 无法 Reload</p>
</blockquote>
<p>这个其实不是什么大问题, 但是对于初学者, 也算是一个问题.</p>
<p>新版的 Android SDK 创建的模拟器没有 menu 按键了</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>连续按两次字母 r 即可刷新.</p>
<p>这些问题, FB 后面肯定会解决的.<br>阿门!</p>
<h2 id="附录-代码"><a href="#附录-代码" class="headerlink" title="附录(代码)"></a>附录(代码)</h2><p>index.ios.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;getPlatformString, isIOS&#125; from &apos;./js/Generals/Utils/IDSRNPlatformUtil&apos;;</div><div class="line">import MZButton from &apos;./js/ReactUIKit/MZButton&apos;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Platform,</div><div class="line">  TouchableOpacity,</div><div class="line">  TouchableHighlight</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">// 调用其他模块方法</div><div class="line">var os = getPlatformString();</div><div class="line">var iosPlatform = isIOS();//when run on &apos;ios&apos; true</div><div class="line">class MZRNTutorial extends Component &#123;</div><div class="line">  constructor(props)</div><div class="line">  &#123;</div><div class="line">      super(props);</div><div class="line">      this.state = &#123;status:1&#125;;</div><div class="line">  &#125;</div><div class="line">  customPressHandler = () =&gt; &#123;</div><div class="line">      alert(&apos;当前状态: &apos; + this.state.status);</div><div class="line">      this.state.status = 2;</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    console.log(&apos;render ...&apos;);</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</div><div class="line">          Near use React Native!</div><div class="line">        &lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;</div><div class="line">          To get started, edit index.android.js</div><div class="line">        &lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;</div><div class="line">          Press &apos;R&apos; twice to reload,&#123;&apos;\n&apos;&#125;</div><div class="line">          or shake for dev menu</div><div class="line">        &lt;/Text&gt;</div><div class="line">        &#123;/* 显示当前平台信息*/&#125;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</div><div class="line">            current os: &#123;Platform.OS&#125;</div><div class="line">        &lt;/Text&gt;</div><div class="line">        &#123;/*</div><div class="line">        &lt;TouchableOpacity</div><div class="line">            style=&#123;styles.button&#125;</div><div class="line">            onPress=&#123;this.customPressHandler&#125;</div><div class="line">            &gt;</div><div class="line">            &lt;Text style=&#123;styles.buttonText&#125;&gt;确定&lt;/Text&gt;</div><div class="line">        &lt;/TouchableOpacity&gt;</div><div class="line">        */&#125;</div><div class="line">        &lt;MZButton text=&quot;确定?&quot; bgColor=&quot;green&quot; dianjishijian=&#123;()=&gt;&#123;alert(&apos;居然点击确定?!&apos;)&#125;&#125;&gt;</div><div class="line">        &lt;/MZButton&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  button: &#123;</div><div class="line">    height: 40,</div><div class="line">    width: 150,</div><div class="line">    borderRadius: 20,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;green&apos;,</div><div class="line">    overflow: &apos;hidden&apos;</div><div class="line">  &#125;,</div><div class="line">  buttonText: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;white&apos;</div><div class="line">  &#125;,</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">  instructions: &#123;</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    color: &apos;#333333&apos;,</div><div class="line">    marginBottom: 5,</div><div class="line">  &#125;,</div><div class="line">  flowRight: &#123;</div><div class="line">   flexDirection: &apos;row&apos;,</div><div class="line">   alignItems: &apos;center&apos;,</div><div class="line">   alignSelf: &apos;stretch&apos;</div><div class="line"> &#125;,</div><div class="line">&#125;);</div><div class="line">AppRegistry.registerComponent(&apos;MZRNTutorial&apos;, () =&gt; MZRNTutorial);</div></pre></td></tr></table></figure>
<p>MZButton.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Platform,</div><div class="line">  TouchableOpacity</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">//-----------------------------------------------------</div><div class="line">//外部使用该模块, ES6需要使用关键字 export default</div><div class="line">//-----------------------------------------------------</div><div class="line">export default class MZButton extends Component</div><div class="line">&#123;</div><div class="line">    constructor(props)</div><div class="line">    &#123;</div><div class="line">        super(props);</div><div class="line">        this.state = &#123;status:1&#125;;</div><div class="line">    &#125;</div><div class="line">    costumPressHandler = () =&gt; &#123;</div><div class="line">        alert(&apos;当前状态:&apos; + this.state.status);</div><div class="line">        const &#123;dianjishijian&#125; = this.props;</div><div class="line">        dianjishijian();</div><div class="line">    &#125;;</div><div class="line">    // 使用属性值设置背景颜色</div><div class="line">    // style=&#123;[styles.button], &#123;backgroundColor:this.props.beijingyanse&#125;&#125;</div><div class="line">    render() &#123;</div><div class="line">        //解构</div><div class="line">        const &#123;text, bgColor&#125; = this.props;</div><div class="line">        return (</div><div class="line">            &lt;TouchableOpacity</div><div class="line">                style=&#123;[styles.button], &#123;backgroundColor:bgColor&#125;&#125;</div><div class="line">                onPress = &#123;this.costumPressHandler&#125;</div><div class="line">                &gt;</div><div class="line">                &lt;Text style=&#123;styles.buttonText&#125;&gt;</div><div class="line">                    &#123;/* 使用属性值 */&#125;</div><div class="line">                    &#123;this.props.text&#125;</div><div class="line">                &lt;/Text&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    button: &#123;</div><div class="line">      height: 40,</div><div class="line">      width: 150,</div><div class="line">      borderRadius: 20,</div><div class="line">      justifyContent: &apos;center&apos;,</div><div class="line">      backgroundColor: &apos;green&apos;,</div><div class="line">      overflow: &apos;hidden&apos;</div><div class="line">    &#125;,</div><div class="line">    buttonText: &#123;</div><div class="line">      textAlign: &apos;center&apos;,</div><div class="line">      color: &apos;white&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>IDSRNPlatformUtil.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">    Platform</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">export function getPlatformString()</div><div class="line">&#123;</div><div class="line">    console.log(Platform.OS);</div><div class="line">    </div><div class="line">    return Platform.OS;</div><div class="line">&#125;</div><div class="line">export function isIOS()</div><div class="line">&#123;</div><div class="line">    return Platform.OS === &apos;ios&apos;;</div><div class="line">&#125;</div><div class="line">export function isAndroid()</div><div class="line">&#123;</div><div class="line">    return Platform.OS == &apos;android&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android ReactNative </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 项目: 打造本地 pod 库]]></title>
      <url>/2016/09/25/iOS-%E9%A1%B9%E7%9B%AE-%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0-pod-%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>项目到了一定规模, 代码组织和结构显得尤为重要.</p>
<p>重构项目结构, 可以从分离代码开始.</p>
<p>代码分离, 可以把常用稳定的组件封装抽离出来.</p>
<p>分离代码, 常用的有几种方式</p>
<blockquote>
<p>1.放到不同的文件夹, 管理和组织代码.<br>2.使用 framework 的方式, 提供给项目使用.<br>3.工具管理如 Cocoapods.</p>
</blockquote>
<p>这几种方式, 各有所长, 各有优劣, 无所谓好与坏, 根据自己的项目特点来组织即可.</p>
<p>我的做法是使用 cocoapods 来管理.</p>
<p>下面进入今天的主题:</p>
<blockquote>
<p>使用 cocoapods 管理自己的本地代码.</p>
</blockquote>
<p>在我的博客 <a href="http://blog.csdn.net/veryitman/article/details/50769069" target="_blank" rel="noopener">Mac OSX 10.11.1+ 安装 Cocoapods</a><br>介绍了如何在最新版 MacOS 中安装 Cocoapods 以及注意事项, 并且作者保证持续「更新, 更正」内容.</p>
<p>One by one 吧.</p>
<hr>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>使用 xcode 创建一个工程, 工程名就起为 TestPods.</p>
<blockquote>
<p>工程目录可以防止在桌面或者你喜欢的目录下面都可以.</p>
</blockquote>
<p>在 TestPods 下面创建 LocalLib 目录, 用来放置分离的代码.当然, 你也可以将 LocalLib 这个目录放到其他目录.</p>
<p>在 LocalLib 下面, 我的 pod 库代码名称为 download.</p>
<p>可以新建这个目录.</p>
<p>目录如下:<br><img src="/upload/images/2016/9/25/pod_lib_dir.png" alt="1"></p>
<h2 id="创建-podspec-文件"><a href="#创建-podspec-文件" class="headerlink" title="创建 podspec 文件"></a>创建 podspec 文件</h2><p>在 download 目录下面, 创建 podspec 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create download</div></pre></td></tr></table></figure>
<p>创建完成后, 会生成 download.podspec 文件.</p>
<p>具体内容, 创建后, 大家可以自行查看.</p>
<h2 id="修改-podspec-文件"><a href="#修改-podspec-文件" class="headerlink" title="修改 podspec 文件"></a>修改 podspec 文件</h2><p>修改 download.podspec, 主要修改几个关键地方:</p>
<blockquote>
<p>源码位置<br>源码版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――#</div><div class="line">  #</div><div class="line">  #  Specify the location from where the source should be retrieved.</div><div class="line">  #  Supports git, hg, bzr, svn and HTTP.</div><div class="line">  #</div><div class="line">  s.source       = &#123; :git =&gt; &quot;&quot;, :tag =&gt; &quot;0.0.1&quot; &#125;</div><div class="line">  # ――― Source Code ――――――――――――――――――――――――――――――――――――――――――――#</div><div class="line">  #</div><div class="line">  #  CocoaPods is smart about how it includes source code. For source files</div><div class="line">  #  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</div><div class="line">  #  For header files it will include any header in the folder.</div><div class="line">  #  Not including the public_header_files will make all headers public.</div><div class="line">  #</div><div class="line">  s.source_files  = &quot;Source&quot;, &quot;Source/**/*.&#123;h,m&#125;&quot;</div><div class="line">  s.exclude_files = &quot;Source/Exclude&quot;</div></pre></td></tr></table></figure>
<p>另外, 配置好相关描述信息, 不要包含 ‘Example’ 的字样, 不然, 新版的 Cocoapods 执行 pod install 时候, 会报出警告和错误.</p>
<p>这样, 工程可以使用 pods 库了.</p>
<h2 id="工程使用-pod-库"><a href="#工程使用-pod-库" class="headerlink" title="工程使用 pod 库"></a>工程使用 pod 库</h2><p>将 TestPods 改为 cocoapods 项目.</p>
<p>在 TestPods 目录, 执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod init</div></pre></td></tr></table></figure>
<p>会生成 Podfile 等文件.</p>
<p>修改 Podfile 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Uncomment this line to define a global platform for your project</div><div class="line"># platform :ios, &apos;7.0&apos;</div><div class="line"># Uncomment this line if you&apos;re using Swift</div><div class="line"># use_frameworks!</div><div class="line">target &apos;TestPods&apos; do</div><div class="line">pod &apos;download&apos;, :path =&gt; &apos;./LocalLib/download/&apos;</div><div class="line">#pod &apos;core_lib_spec&apos;, :svn =&gt; &apos;http://svn.ids111.com/o2o/client/ios/trunks/master/Frameworks/CoreLibrary&apos;</div><div class="line">end</div><div class="line">target &apos;TestPodsTests&apos; do</div><div class="line">end</div><div class="line">target &apos;TestPodsUITests&apos; do</div><div class="line">end</div></pre></td></tr></table></figure>
<p>关键是指明 pod 库的位置.<br>路径一定要正确.否则无法找到该库.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;download&apos;, :path =&gt; &apos;./LocalLib/download/&apos;</div></pre></td></tr></table></figure>
<p>在 TestPods 下面, pod install 即可.</p>
<p>如果, pod install 报错, 一般都是你的 pod 库的配置文件(.podspec)里面写的不符合要求.</p>
<p>根据报错信息, 加以修改即可.</p>
<p>xcode 打开工程.<br><img src="/upload/images/2016/9/25/pod_lib_pro.png" alt="1"></p>
<h2 id="示例下载"><a href="#示例下载" class="headerlink" title="示例下载"></a>示例下载</h2><p>工程示例代码, 可以 <a href="http://download.csdn.net/download/androidbluetooth/9520262" target="_blank" rel="noopener">戳这里下载</a> 玩耍!</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>后续博客会给大家分享, 如何将自己的 pod 库提交到 github, 这样别人也可以使用您开发的库了.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS Cocoapods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: 如何启动 local server]]></title>
      <url>/2016/09/22/RN-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8-local-server/</url>
      <content type="html"><![CDATA[<p>使用 <code>react-native init</code> 创建的工程, 在 xcode 中运行会自动启动一个 RN 的本地 Server.</p>
<p>像下面图片展示这样:<br><img src="/upload/images/2016/9/22/rn_1.png" alt="1"></p>
<p>那么, 这里问题来了.</p>
<p>比如, 我想暂时不启动这个本地 Server, 那么如何关闭呢?</p>
<p>下面跟大家一起探讨和追究一下.</p>
<h2 id="找到启动的根源"><a href="#找到启动的根源" class="headerlink" title="找到启动的根源"></a>找到启动的根源</h2><p>启动这个终端的是在一个 React.xcodeproj 工程的 「Build Phases」中脚本里面配置的.</p>
<p>脚本内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if nc -w 5 -z localhost 8081 ; then</div><div class="line">  if ! curl -s &quot;http://localhost:8081/status&quot; | grep -q &quot;packager-status:running&quot; ; then</div><div class="line">    echo &quot;Port 8081 already in use, packager is either not running or not running correctly&quot;</div><div class="line">    exit 2</div><div class="line">  fi</div><div class="line">else</div><div class="line">  open &quot;$SRCROOT/../packager/launchPackager.command&quot; || echo &quot;Can&apos;t start packager automatically&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>真正起作用的是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open &quot;$SRCROOT/../packager/launchPackager.command&quot;</div></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这样我们就可以关闭这个自启动了, 示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if nc -w 5 -z localhost 8081 ; then</div><div class="line">  if ! curl -s &quot;http://localhost:8081/status&quot; | grep -q &quot;packager-status:running&quot; ; then</div><div class="line">    echo &quot;Port 8081 already in use, packager is either not running or not running correctly&quot;</div><div class="line">    exit 2</div><div class="line">  fi</div><div class="line">else</div><div class="line">#open &quot;$SRCROOT/../packager/launchPackager.command&quot; || echo &quot;Can&apos;t start packager automatically&quot;</div><div class="line">    echo &quot;Nothing...&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<h2 id="看看-launchPackager-command"><a href="#看看-launchPackager-command" class="headerlink" title="看看 launchPackager.command"></a>看看 launchPackager.command</h2><p>这个文件在「node_modules/react-native/packager/」下面.</p>
<p>该文件是启动另外一个脚本 packager.sh, 核心代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ./packager.sh</div></pre></td></tr></table></figure>
<p>最终执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node &quot;$THIS_DIR/../local-cli/cli.js&quot; start &quot;$@&quot;</div></pre></td></tr></table></figure>
<p>大家有兴趣可以去看看源码, 一探究竟.</p>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ReactNative iOS Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: 创建iOS工程代码的indent问题]]></title>
      <url>/2016/09/19/RN-%E5%88%9B%E5%BB%BAiOS%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%9A%84indent%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>使用最新版RN(0.33)来创建工程, 大家可以发现, OC 代码的退格变成了两个空格.<br>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSURL *jsCodeLocation;</div><div class="line">  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil];</div><div class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class="line">                                                      moduleName:@&quot;Mark&quot;</div><div class="line">                                               initialProperties:nil</div><div class="line">                                                   launchOptions:launchOptions];</div><div class="line">  rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1];</div><div class="line">  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">  UIViewController *rootViewController = [UIViewController new];</div><div class="line">  rootViewController.view = rootView;</div><div class="line">  self.window.rootViewController = rootViewController;</div><div class="line">  [self.window makeKeyAndVisible];</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论你回车或者 tab 或者格式化(<code>右键/Structure/Re-Indent</code>)代码, 会发现, 都是这种调调.</p>
<p>面对这突如其来的变化, 我开始觉得有点淡淡的忧伤.</p>
<p>对于一直使用 <code>tab width = 4</code> 的我来说, 无法忍受. 必须改过来.</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>打开 Xcode 的 preferences, 看到其『设置』正常的不要不要的.</p>
<p>所以可以断定不是 Xcode 的问题.</p>
<p><img src="/upload/images/2016/9/19/xcode_pref.png" alt="1"></p>
<p>因为升级了 Xcode 到最新版 Xcode8, 还以为是 Xcode8 的 bug, 打开之前的 React Native 工程或者其他 Xcode 工程, 就没有这个「蛋疼」的问题.</p>
<p>最终猜想是工程配置文件引起的…</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然和 Xcode 没有关系, 那么问题就一定出现在配置文件上面.</p>
<p>罪魁祸首 <code>project.pbxproj</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">indentWidth = 2;</div><div class="line">sourceTree = &quot;&lt;group&gt;&quot;;</div><div class="line">tabWidth = 2;</div></pre></td></tr></table></figure>
<p>修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">indentWidth = 4;</div><div class="line">sourceTree = &quot;&lt;group&gt;&quot;;</div><div class="line">tabWidth = 4;</div></pre></td></tr></table></figure>
<p>或者直接删除:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">indentWidth = 2;</div><div class="line">tabWidth = 2;</div></pre></td></tr></table></figure>
<p>关闭工程, 重启 Xcode 就可以了.</p>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ReactNative iOS Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RN: Mac 配置 ES6 简易开发环境]]></title>
      <url>/2016/09/16/RN-Mac-%E9%85%8D%E7%BD%AE-ES6-%E7%AE%80%E6%98%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h2 id="创建文件夹-ES6"><a href="#创建文件夹-ES6" class="headerlink" title="创建文件夹 ES6"></a>创建文件夹 ES6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ES6</div><div class="line">-lib</div><div class="line">-src</div></pre></td></tr></table></figure>
<p>你可以任意取一个你喜欢的目录名称.</p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure>
<p>填写项目信息.</p>
<p>查看一下 package.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat package.json</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;es6tutorials&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;Tutorial&quot;,</div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;keywords&quot;: [</div><div class="line">    &quot;es6&quot;,</div><div class="line">    &quot;.etc&quot;</div><div class="line">  ],</div><div class="line">  &quot;author&quot;: &quot;mark.zhang&quot;,</div><div class="line">  &quot;license&quot;: &quot;MIT&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目录结构如下</p>
<p><img src="/upload/images/2016/9/10/1.jpg" alt="1"></p>
<h3 id="安装-babel-cli"><a href="#安装-babel-cli" class="headerlink" title="安装 babel-cli"></a>安装 babel-cli</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-cli</div></pre></td></tr></table></figure>
<p>也可以全局安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-cli -g</div></pre></td></tr></table></figure>
<p>全局安装上后，会安装如下四个程序到全局环境中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">babel</div><div class="line">babel-node</div><div class="line">babel-doctor</div><div class="line">babel-external-helpers</div></pre></td></tr></table></figure>
<h2 id="安装-babel-core"><a href="#安装-babel-core" class="headerlink" title="安装 babel-core"></a>安装 babel-core</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-core --save</div></pre></td></tr></table></figure>
<h2 id="安装-ES2015-插件"><a href="#安装-ES2015-插件" class="headerlink" title="安装 ES2015 插件"></a>安装 ES2015 插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-es2015</div></pre></td></tr></table></figure>
<p>编写配置文件 .babelrc</p>
<p>注意该文件有个点符号.</p>
<p>在工程目录下新建该文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch .babelrc</div></pre></td></tr></table></figure>
<p>写入如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [</div><div class="line">      &quot;es2015&quot;,</div><div class="line">    ],</div><div class="line">    &quot;plugins&quot;: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写测试代码 tutorials.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function test()</div><div class="line">&#123;</div><div class="line">    console.log(a);</div><div class="line">    var a = 0;</div><div class="line">&#125;</div><div class="line">test();</div><div class="line">var a = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  var c = i;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(c);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 9</div><div class="line">var b = [];</div><div class="line">for (var i=0; i&lt;10; i++) &#123;</div><div class="line">    let c = i; //let 是 es6中的关键字</div><div class="line">    b[i] = function() &#123;</div><div class="line">        console.log(c)</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">b[6]();</div></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel src/tutorials.js</div></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel-node src/tutorials.js</div></pre></td></tr></table></figure>
<p><img src="/upload/images/2016/9/10/2.jpg" alt="1"></p>
<p>这里可以下载 <a href="https://github.com/veryitman/ES6Tutorials" target="_blank" rel="noopener">工程源码</a>.</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="1-将-ES6-语法的文件转换为-ES5-的语法"><a href="#1-将-ES6-语法的文件转换为-ES5-的语法" class="headerlink" title="1.将 ES6 语法的文件转换为 ES5 的语法"></a>1.将 ES6 语法的文件转换为 ES5 的语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel -d lib/ src/</div></pre></td></tr></table></figure>
<p>在 lib 目录下会生成 src 目录中对应的文件.</p>
<h3 id="2-进入交互模式"><a href="#2-进入交互模式" class="headerlink" title="2.进入交互模式"></a>2.进入交互模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel-node</div></pre></td></tr></table></figure>
<p>两次 ctrl+c 退出</p>
<h3 id="3-检查babel状况"><a href="#3-检查babel状况" class="headerlink" title="3.检查babel状况"></a>3.检查babel状况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel-doctor</div></pre></td></tr></table></figure>
<p>检查以下内容</p>
<ul>
<li><p>配置文件.babelrc</p>
</li>
<li><p>是否有重复的babel安装包，比如说安装了5和6</p>
</li>
<li><p>babel安装包是否已经升级到了最新版</p>
</li>
<li><p>npm &gt;= 3.3.0</p>
</li>
</ul>
<p><img src="/upload/images/2016/9/10/3.jpg" alt="1"></p>
<h3 id="4-卸载全局的-babel-cli"><a href="#4-卸载全局的-babel-cli" class="headerlink" title="4.卸载全局的 babel-cli"></a>4.卸载全局的 babel-cli</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm uninstall --global babel-cli</div></pre></td></tr></table></figure>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li><p><a href="https://babeljs.io/docs/usage/cli/" target="_blank" rel="noopener">Babel comes with a built-in CLI which can be used to compile files from the command line.</a></p>
</li>
<li><p>阮一峰老师的 <a href="https://www.gitbook.com/book/wohugb/ecmascript-6/details" target="_blank" rel="noopener">ECMAScript 6入门</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ReactNative </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS: 手机是否设置网络代理]]></title>
      <url>/2016/09/16/iOS-%E6%89%8B%E6%9C%BA%E6%98%AF%E5%90%A6%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>项目开发过程中, 会遇到下面这样一种情景:</p>
<blockquote>
<p>产品或者设计同事需要体验目前产品开发的进度, 然后要求开发人员, 将现在的版本给他们体验.<br>做过程序开发的人都知道, 开发版本会有不少问题.<br>这时, 产品和设计同事就会抱怨, 怎么登录不了, 这里没有数据了!<br>有个小伙伴被折腾的实在受不了, 连网页都打不开了.<br>最后找到原因:<br>他手机被之前的程序猿设置了网络代理, 代理到程序猿哥哥的电脑上来抓包调试问题, 忘记取消设置了.</p>
</blockquote>
<p>假如可以判断当前手机是否设置了网络代理, 就可以很好地解决上面情景中提到的问题了.</p>
<h2 id="找到线索"><a href="#找到线索" class="headerlink" title="找到线索"></a>找到线索</h2><p>在 ASIHttpRequest 中找到如下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (BOOL)configureProxies</div><div class="line">&#123;</div><div class="line">	// Have details of the proxy been set on this request</div><div class="line">	if (![self isPACFileRequest] &amp;&amp; (![self proxyHost] &amp;&amp; ![self proxyPort])) &#123;</div><div class="line">		// If not, we need to figure out what they&apos;ll be</div><div class="line">		NSArray *proxies = nil;</div><div class="line">		// Have we been given a proxy auto config file?</div><div class="line">		if ([self PACurl]) &#123;</div><div class="line">			// If yes, we&apos;ll need to fetch the PAC file asynchronously, so we stop this request to wait until we have the proxy details.</div><div class="line">			[self fetchPACFile];</div><div class="line">			return NO;</div><div class="line">			// Detect proxy settings and apply them</div><div class="line">		&#125; else &#123;</div><div class="line">#if TARGET_OS_IPHONE</div><div class="line">			NSDictionary *proxySettings = [NSMakeCollectable(CFNetworkCopySystemProxySettings()) autorelease];</div><div class="line">#else</div><div class="line">			NSDictionary *proxySettings = [NSMakeCollectable(SCDynamicStoreCopyProxies(NULL)) autorelease];</div><div class="line">#endif</div><div class="line">			proxies = [NSMakeCollectable(CFNetworkCopyProxiesForURL((CFURLRef)[self url], (CFDictionaryRef)proxySettings)) autorelease];</div><div class="line">			// Now check to see if the proxy settings contained a PAC url, we need to run the script to get the real list of proxies if so</div><div class="line">			NSDictionary *settings = [proxies objectAtIndex:0];</div><div class="line">			if ([settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]) &#123;</div><div class="line">				[self setPACurl:[settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]];</div><div class="line">				[self fetchPACFile];</div><div class="line">				return NO;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (!proxies) &#123;</div><div class="line">			[self setReadStream:nil];</div><div class="line">			[self failWithError:[NSError errorWithDomain:NetworkRequestErrorDomain code:ASIInternalErrorWhileBuildingRequestType userInfo:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;Unable to obtain information on proxy servers needed for request&quot;,NSLocalizedDescriptionKey,nil]]];</div><div class="line">			return NO;</div><div class="line">		&#125;</div><div class="line">		// I don&apos;t really understand why the dictionary returned by CFNetworkCopyProxiesForURL uses different key names from CFNetworkCopySystemProxySettings/SCDynamicStoreCopyProxies</div><div class="line">		// and why its key names are documented while those we actually need to use don&apos;t seem to be (passing the kCF* keys doesn&apos;t seem to work)</div><div class="line">		if ([proxies count] &gt; 0) &#123;</div><div class="line">			NSDictionary *settings = [proxies objectAtIndex:0];</div><div class="line">			[self setProxyHost:[settings objectForKey:(NSString *)kCFProxyHostNameKey]];</div><div class="line">			[self setProxyPort:[[settings objectForKey:(NSString *)kCFProxyPortNumberKey] intValue]];</div><div class="line">			[self setProxyType:[settings objectForKey:(NSString *)kCFProxyTypeKey]];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>踏破铁鞋无觅处…</p>
<p>判断 iphone 是否设置网络代理的示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)hasSetProxy</div><div class="line">&#123;</div><div class="line">    BOOL proxy = NO;</div><div class="line">    </div><div class="line">    NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings());</div><div class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];</div><div class="line">    NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef)(url),</div><div class="line">                                                                       (__bridge CFDictionaryRef)(proxySettings)));</div><div class="line">    MZLOG(@&quot;proxies:%@&quot;, proxies);</div><div class="line">    NSDictionary *settings = proxies[0];</div><div class="line">    MZLOG(@&quot;kCFProxyHostNameKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyHostNameKey]);</div><div class="line">    MZLOG(@&quot;kCFProxyPortNumberKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyPortNumberKey]);</div><div class="line">    MZLOG(@&quot;kCFProxyTypeKey: %@&quot;, [settings objectForKey:(NSString *)kCFProxyTypeKey]);</div><div class="line">    if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@&quot;kCFProxyTypeNone&quot;]) &#123;</div><div class="line">        proxy = NO;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        proxy = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return proxy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2><p>判断如果设置了代理, 提示用户, 帮他直接跳到 wifi 设置界面.</p>
<p>下面说说如何跳到系统的 wifi 设置界面.</p>
<p>1.配置 URL TYPES</p>
<p><img src="/upload/images/2016/9/16/1.jpeg" alt="1"></p>
<p>注意这里的配置是 <code>prefs</code>.</p>
<p>2.openURL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSString * urlString = @&quot;prefs:root=WIFI&quot;;</div><div class="line">NSURL *url = [NSURL URLWithString:urlString];</div><div class="line">UIApplication *app = [UIApplication sharedApplication];</div><div class="line">if ([app canOpenURL:[NSURL URLWithString:urlString]]) &#123;</div><div class="line"> </div><div class="line">    if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 10.0) &#123;</div><div class="line">    </div><div class="line">    	[app openURL:url options:@&#123;&#125; completionHandler:nil];</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">    </div><div class="line">    	[app openURL:url];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外, 跳转到系统其他界面的 URL 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">1.系统设置</div><div class="line">prefs:root=INTERNET_TETHERING</div><div class="line">2.WIFI设置</div><div class="line">prefs:root=WIFI</div><div class="line">3.蓝牙设置</div><div class="line">prefs:root=Bluetooth</div><div class="line">4.系统通知</div><div class="line">prefs:root=NOTIFICATIONS_ID</div><div class="line">5.通用设置</div><div class="line">prefs:root=General</div><div class="line">6.显示设置</div><div class="line">prefs:root=DISPLAY&amp;BRIGHTNESS</div><div class="line">7.壁纸设置</div><div class="line">prefs:root=Wallpaper</div><div class="line">8.声音设置</div><div class="line">prefs:root=Sounds</div><div class="line">9.隐私设置</div><div class="line">prefs:root=privacy</div><div class="line">10.打开 APP Store</div><div class="line">prefs:root=STORE</div><div class="line">11.打开 Notes</div><div class="line">prefs:root=NOTES</div><div class="line">12.打开 Safari</div><div class="line">prefs:root=Safari</div><div class="line">13.打开 Music</div><div class="line">prefs:root=MUSIC</div><div class="line">14.打开 photo</div><div class="line">prefs:root=Photos</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS proxy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[与 CSDN 的诀别]]></title>
      <url>/2016/09/10/%E4%B8%8E-CSDN-%E7%9A%84%E8%AF%80%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>写这个话题, 内心还是蛮沉重的.</p>
<p>几年前与 CSDN 不期而遇, 在里面各种折腾, 翻阅大牛们的博客, 写评论, 甚至打印出来. 在技术论坛不停地”灌水”, 订阅 CSDN 杂志, 准备练就一身武艺.</p>
<p>互联网的蓬勃发展, 让我原来不安的心有了更加狂躁的冲动.</p>
<p>在某个夜深人静的夜晚, 开启了奋笔疾书的历程, 踏上了 CSDN 的博客之旅.<br>这么多年以来, CSDN 就像我的一个朋友, 不管是家长里短, 还是技术讨论, 各种心酸, 我都会记录在那里.</p>
<p>一坚持就是几年…</p>
<p>如今, 要离开 CSDN 的博客了, 不准备在那里继续’耕耘’了.<br>总结起来有如下几个原因:</p>
<blockquote>
<ol>
<li>文章被任意的转载, 没经过本人的允许.我在论坛也问过该事, 没有任何回应, 很失望!</li>
<li>广告越来越多.</li>
<li>相比以前, 很难找到让人满意的有质量的文章.</li>
</ol>
</blockquote>
<p>再见, CSDN! 请原谅我的不辞而别!</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 写作 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
